<!DOCTYPE html>
<html lang="zh-CN,en,zh-HK,zh-TW,default">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>面试题总结-基础篇 - Hexo</title>
  
    <meta name="keywords" content="java,面试,总结">
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Alloceee
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post search' style="display: none;">
          
            <div id='cover-backstretch'></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Twilight Rush</p>
    
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-home fa-fw'></i><p>首页</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-history fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about"
              
              
              id="about">
              <i class='fas fa-heart fa-spin fa-fw'></i><p>关于</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/alloceee"
              
              
              id="https:githubcomalloceee">
              <i class='fas fa-paper-plane fa-fw'></i><p>github</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        面试题总结-基础篇
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>请设置文章作者</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年6月11日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="面试题总结-基础篇" data-path="/2020/06/11/%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  
  <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="JVM、JRE、JDK有什么联系与区别？"><a href="#JVM、JRE、JDK有什么联系与区别？" class="headerlink" title="JVM、JRE、JDK有什么联系与区别？"></a>JVM、JRE、JDK有什么联系与区别？</h3><p><strong>JVM是java虚拟机</strong>，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。<br><strong>JRE是java运行时环境</strong>，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。<br><strong>JDK是java开发工具包</strong>，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。<br>所以总得来说，<strong>JDK&gt;JRE&gt;JVM</strong>。</p>
<h3 id="面向对象的特征有哪些？"><a href="#面向对象的特征有哪些？" class="headerlink" title="面向对象的特征有哪些？"></a>面向对象的特征有哪些？</h3><p>有三大特征，继承，封装，多态。</p>
<h3 id="为什么java可以实现跨平台？"><a href="#为什么java可以实现跨平台？" class="headerlink" title="为什么java可以实现跨平台？"></a>为什么java可以实现跨平台？</h3><p>因为java是编译成.class文件运行在JVM上的。<strong>针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用</strong>，从而实现代码的跨平台运行。</p>
<h3 id="类的加载顺序？"><a href="#类的加载顺序？" class="headerlink" title="类的加载顺序？"></a>类的加载顺序？</h3><p>静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。</p>
<h3 id="接口和抽象类有什么共同点和不同点？"><a href="#接口和抽象类有什么共同点和不同点？" class="headerlink" title="接口和抽象类有什么共同点和不同点？"></a>接口和抽象类有什么共同点和不同点？</h3><p>共同点：<br>1.都可以定义抽象方法，子类都要实现定义的抽象方法。<br>2.都不能被实例化，但是可以定义抽象类和接口类型的引用。<br>不同点：<br>1.接口没有构造器，抽象类可以定义构造器。<br>2.接口定义具体方法只能定义<strong>default</strong>修饰，抽象类可以直接定义具体方法。<br>3.接口的子类是实现接口，关键字是<strong>implements</strong>，抽象类的子类是继承，关键字是<strong>extends</strong>。<br>4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。</p>
<h3 id="static关键字有哪些用法？"><a href="#static关键字有哪些用法？" class="headerlink" title="static关键字有哪些用法？"></a>static关键字有哪些用法？</h3><p>①<strong>修饰成员变量，用static修饰的成员变量就成为静态变量</strong>，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。<br>②<strong>static修饰方法，该方法就被定义为静态方法</strong>，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。<br>③<strong>用static修饰代码块，该代码块就被定义为静态代码块</strong>，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。</p>
<h3 id="Switch能用什么数据类型作为参数？"><a href="#Switch能用什么数据类型作为参数？" class="headerlink" title="Switch能用什么数据类型作为参数？"></a>Switch能用什么数据类型作为参数？</h3><p>JDK1.5前：<strong>byte、short、char、int</strong><br>JDK1.5：枚举<br>JDK1.7：String</p>
<h3 id="枚举有哪些特点？在项目中如何使用？"><a href="#枚举有哪些特点？在项目中如何使用？" class="headerlink" title="枚举有哪些特点？在项目中如何使用？"></a>枚举有哪些特点？在项目中如何使用？</h3><p>特点：<br>1.枚举的构造器是私有的。<br>2.枚举不能被继承。<br>3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。<br>使用场景：<br>当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。</p>
<h3 id="什么是方法重载？什么是方法重写？"><a href="#什么是方法重载？什么是方法重写？" class="headerlink" title="什么是方法重载？什么是方法重写？"></a>什么是方法重载？什么是方法重写？</h3><p><strong>方法重载</strong>，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”<strong>一同两不同</strong>“。<br><strong>方法重写</strong>一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。<strong>声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。</strong></p>
<h3 id="静态变量和实例变量有什么不同？分别位于内存的什么区域？"><a href="#静态变量和实例变量有什么不同？分别位于内存的什么区域？" class="headerlink" title="静态变量和实例变量有什么不同？分别位于内存的什么区域？"></a>静态变量和实例变量有什么不同？分别位于内存的什么区域？</h3><p>1.静态变量使用static修饰，实例变量不需要。<br>2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。<br>3.静态变量是存在于<strong>静态区(全局区)<strong>的，实例变量位于</strong>堆内存</strong>中。</p>
<h3 id="java的内部类的分类有哪些？"><a href="#java的内部类的分类有哪些？" class="headerlink" title="java的内部类的分类有哪些？"></a>java的内部类的分类有哪些？</h3><p>实例内部类、静态内部类、局部内部类、匿名内部类。</p>
<h3 id="break、continue、return-的作用是什么？"><a href="#break、continue、return-的作用是什么？" class="headerlink" title="break、continue、return 的作用是什么？"></a>break、continue、return 的作用是什么？</h3><ul>
<li>break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。</li>
<li>continue：跳过本次循环，开始下一次循环。</li>
<li>return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。<h3 id="Object类有哪些常用的方法？"><a href="#Object类有哪些常用的方法？" class="headerlink" title="Object类有哪些常用的方法？"></a>Object类有哪些常用的方法？</h3></li>
</ul>
<p><strong>toString()、equals()、hashCode()。</strong></p>
<ul>
<li><code>toString()</code>默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。</li>
<li><code>equals()</code>方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。</li>
<li><code>hashCode()</code>方法用来返回其所在对象的物理地址（哈希码值），常会和<code>equals()</code>方法同时重写，确保相等的两个对象拥有相等的<strong>hashCode</strong>。<h3 id="与equals-的区别？"><a href="#与equals-的区别？" class="headerlink" title="==与equals()的区别？"></a>==与equals()的区别？</h3><code>equals()</code>方法属于<code>Object</code>对象的，所以比较基础数据类型是不能使用<code>equals()</code>。必须使用<code>==</code>。</li>
</ul>
<p><strong>在默认情况下</strong>，<code>equals()</code>与<code>==</code>是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写<code>equals()</code>方法。</p>
<h3 id="equals-与hashCode-有什么联系？"><a href="#equals-与hashCode-有什么联系？" class="headerlink" title="equals()与hashCode()有什么联系？"></a>equals()与hashCode()有什么联系？</h3><p>1.<code>equals()</code>相等的两个对象他们的<code>hashCode()</code>肯定相等，也就是用<code>equals()</code>对比是绝对可靠的。<br>2.<code>hashCode()</code>相等的两个对象他们的<code>equals()</code>不一定相等，也就是<code>hashCode()</code>不是绝对可靠的。<br>在使用<code>HashSet</code>或者<code>HashMap</code>集合中，比较两个对象是否相等时，会先调用<code>hashCode()</code>比较，如果<code>hashCode()</code>相等，则会继续调用<code>equals()</code>比较，<code>equals()</code>也相等才会认为是同一个对象。如果<code>hashCode()</code>返回不相等，则认为是不相等的对象。<br>所以一般我们会同时重写<code>hashCode()</code>和<code>equals()</code>方法。</p>
<h3 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp; 和 &amp;&amp;有什么区别？"></a>&amp; 和 &amp;&amp;有什么区别？</h3><p><code>&amp;&amp;</code>具有短路的功能，也就是如果<code>&amp;&amp;</code>左边的条件为<code>fasle</code>就不再执行后面的条件判断。<br><code>&amp;</code>则会执行完左右两边的条件判断。</p>
<h3 id="final、finalize-、finally-分别有什么作用？"><a href="#final、finalize-、finally-分别有什么作用？" class="headerlink" title="final、finalize()、finally{}分别有什么作用？"></a>final、finalize()、finally{}分别有什么作用？</h3><p><code>final</code>修饰类，表明这个类不可被其他类继承。<br><code>final</code>修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。<br><code>final</code>修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。<br><code>finalize()</code>是<code>Object</code>里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的<code>finalize()</code>方法只会被调用一次。<br><code>finally</code>作为异常处理的一部分，它只能用在<code>try/catch</code>语句中，并且附带一个语句块。</p>
<h3 id="Cloneable接口有什么作用？"><a href="#Cloneable接口有什么作用？" class="headerlink" title="Cloneable接口有什么作用？"></a>Cloneable接口有什么作用？</h3><p><code>Cloneable</code>接口是一个标记接口，实现了此接口，表示可以使用<code>clone()</code>方法，没有实现此接口使用<code>clone()</code>会抛出<code>CloneNotSupportedException</code>异常。</p>
<h3 id="什么是浅克隆，什么是深克隆？"><a href="#什么是浅克隆，什么是深克隆？" class="headerlink" title="什么是浅克隆，什么是深克隆？"></a>什么是浅克隆，什么是深克隆？</h3><p><strong>浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量）</strong>，而不拷贝对象包含的引用指向的对象。</p>
<p><strong>深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</strong></p>
<h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><p>序列化：把<strong>对象</strong>转换为<strong>字节序列</strong>的过程称为对象的序列化。<br>反序列化：把<strong>字节序列</strong>恢复为<strong>对象</strong>的过程称为对象的反序列化。</p>
<h3 id="Serializable接口有什么作用？"><a href="#Serializable接口有什么作用？" class="headerlink" title="Serializable接口有什么作用？"></a>Serializable接口有什么作用？</h3><p><code>Serializable</code>接口是一个标记接口，一个类只有实现了<code>Serializable</code>接口，它的对象才是可序列化的。否则序列化时会报<code>NotSerializableException</code>异常。如果不显性声明<code>serialVersionUID</code>，则会默认生成一个。为了<code>serialVersionUID</code>的确定性，最好是显性声明。</p>
<h3 id="String、StringBuffer、StringBuilder有什么区别"><a href="#String、StringBuffer、StringBuilder有什么区别" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别?"></a>String、StringBuffer、StringBuilder有什么区别?</h3><ul>
<li><code>String</code>被声明为<code>final class</code>，是由定义<code>final</code>的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</li>
<li><code>StringBuffer</code>是由定义了临时数据<code>transient</code>的字符数组实现的，提供<code>append()</code>和<code>add()</code>方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上<code>synchronized</code>。性能相对<code>StringBuilder</code>会差一点。</li>
<li> <code>StringBuilder</code>和<code>StringBuffer</code>本质上没什么区别，区别是去掉了保证线程安全的<code>synchronized</code>，减少了开销，性能有所提高。<h3 id="什么是泛型-什么是泛型的上界和下界"><a href="#什么是泛型-什么是泛型的上界和下界" class="headerlink" title="什么是泛型?什么是泛型的上界和下界?"></a>什么是泛型?什么是泛型的上界和下界?</h3>Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>上界用<code>extends</code>关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。<br>下界用<code>super</code>进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3></li>
</ul>
<p><strong>Java反射机制</strong>是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在<strong>运行时动态的获取信息以及动态调用对象的方法的功能</strong>称为Java的反射机制。</p>
<h3 id="获取Class对象的方式有哪些？"><a href="#获取Class对象的方式有哪些？" class="headerlink" title="获取Class对象的方式有哪些？"></a>获取Class对象的方式有哪些？</h3><ul>
<li>通过<code>Object</code>类中的<code>getClass()</code>方法，想要用这种方法必须要明确具体的类并且创建该类的对象。</li>
<li>所有数据类型都具备一个静态的属性<code>.class</code>来获取对应的<code>Class</code>对象。但是还是要明确到类，然后才能调用类中的静态成员。</li>
<li>通过<code>Class.forName()</code>方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是<code>Class.forName()</code>方法如果写错类的路径会报<code>ClassNotFoundException</code>的异常。<h3 id="java中的异常有哪几种异常？"><a href="#java中的异常有哪几种异常？" class="headerlink" title="java中的异常有哪几种异常？"></a>java中的异常有哪几种异常？</h3><code>Throwable</code>类是<code>Java</code>异常类型的顶层父类，<code>Throwable</code>包含了<code>Error</code>和<code>Excetion</code>。<code>Excetion</code>分为两种，一种是**非运行时异常(又称为检查异常)<strong>，另一种是</strong>运行时异常(RuntimeException)**。<h3 id="java是如何处理异常的？"><a href="#java是如何处理异常的？" class="headerlink" title="java是如何处理异常的？"></a>java是如何处理异常的？</h3></li>
<li><code>Error</code>是程序无法处理的, 比如<code>OutOfMemoryError</code>、<code>OutOfMemoryError</code>等等, 这些异常发生时, <code>JVM</code>一般会终止线程。</li>
<li>运行时异常(<code>RuntimeException</code>)，如 <code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，<strong>程序应该从逻辑角度去尽量避免</strong>。</li>
<li>非运行时异常是<code>RuntimeException</code>以外的异常，是<code>Exception</code>及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如<code>IOException</code>、<code>SQLException</code>等。<h1 id="java集合、IO流、日期处理等"><a href="#java集合、IO流、日期处理等" class="headerlink" title="java集合、IO流、日期处理等"></a>java集合、IO流、日期处理等</h1><h3 id="常用的集合有哪些？"><a href="#常用的集合有哪些？" class="headerlink" title="常用的集合有哪些？"></a>常用的集合有哪些？</h3>常用集合有<strong>Map、List、Set</strong>。<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3>不是线程安全的。<h3 id="如何使HashMap线程安全？"><a href="#如何使HashMap线程安全？" class="headerlink" title="如何使HashMap线程安全？"></a>如何使HashMap线程安全？</h3>使用<code>Collections</code>类的<code>synchronizedMap()</code>方法包装。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure>
使用<code>java.util.concurrent</code>包下的<code>ConcurrentHashMap</code>类也可以获得线程安全的Map。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap concurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap();</span><br></pre></td></tr></table></figure>
使用<code>Hashtable</code>类，也可以获得线程安全的Map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="HashMap和Hashtable的区别是什么？"><a href="#HashMap和Hashtable的区别是什么？" class="headerlink" title="HashMap和Hashtable的区别是什么？"></a>HashMap和Hashtable的区别是什么？</h3></li>
<li><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了Map接口。</li>
<li><code>Hashtable</code>是线程安全的，<code>HashMap</code>是线程不安全的。</li>
<li> <code>Hashtable</code>中，key和value都不允许出现null值。</li>
<li> <code>HashTable</code>在不指定容量的情况下的<strong>默认容量为11，而HashMap为16</strong>，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<h3 id="HashMap是如何解决哈希冲突的？"><a href="#HashMap是如何解决哈希冲突的？" class="headerlink" title="HashMap是如何解决哈希冲突的？"></a>HashMap是如何解决哈希冲突的？</h3></li>
<li>在JDK1.8前，<code>HashMap</code>是采用<strong>链表法</strong>解决哈希冲突的。当<code>put()</code>一个值到<code>Map</code>时，会通过<code>Key</code>拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该<code>hash</code>值。若不存在，则直接以<code>Entry&lt;V,V&gt;</code>的方式存放在数组中。若存在，则再调用<code>equals()</code>方法对比<code>key</code>是否相同，若<code>hashcode()</code>值和<code>key</code>都相同，则替换<code>value</code>，若<code>hashcode()</code>值相同，<code>key</code>不相同，则形成一个单链表，将<code>hashcode()</code>值相同，<code>key</code>不同的元素以<code>Entry&lt;V,V&gt;</code>的方式存放在链表中，这样就解决了哈希冲突。</li>
<li>JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成<strong>红黑树</strong>，提高性能。<h3 id="HashMap初始大小是多少？负载因子是多少？"><a href="#HashMap初始大小是多少？负载因子是多少？" class="headerlink" title="HashMap初始大小是多少？负载因子是多少？"></a>HashMap初始大小是多少？负载因子是多少？</h3>默认的数组初始大小是16。负载因子是0.75。</li>
</ul>
<p><strong>（为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了）</strong></p>
<h3 id="简述一下HashMap的扩容机制？"><a href="#简述一下HashMap的扩容机制？" class="headerlink" title="简述一下HashMap的扩容机制？"></a>简述一下HashMap的扩容机制？</h3><p><code>HashMap</code>是懒加载的，当调用<code>put()</code>方法时，会先初始化<code>Map</code>的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当<code>HashMap</code>元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。</p>
<h3 id="List有哪些常用的子类？"><a href="#List有哪些常用的子类？" class="headerlink" title="List有哪些常用的子类？"></a>List有哪些常用的子类？</h3><p><code>ArrayList</code>和<code>LinkedList</code>。</p>
<h3 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h3><ul>
<li>底层<strong>数据结构不同</strong>。<code>ArrayList</code>基于数组+动态扩容实现的，<code>LinkedList</code>基于双向链表实现。从储存结构上分析，<code>LinkedList</code>更加占内存，因为每个节点除了存储数据外还要<strong>存储指向前节点的引用和指向后节点的引用。</strong></li>
<li><strong>效率不同</strong>。当随机访问时，<code>ArrayList</code>是基于数组下标访问，<strong>查询效率较高</strong>，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，<strong>增删效率偏低</strong>。<code>LinkedList</code>在查询时，需要从前到后依次遍历，所以<strong>查询效率不高</strong>，但是在增删时只需要更改节点的引用，开销较少，所以<strong>增删效率较高</strong>。<h3 id="List集合排序的方式有哪些？"><a href="#List集合排序的方式有哪些？" class="headerlink" title="List集合排序的方式有哪些？"></a>List集合排序的方式有哪些？</h3>使用List接口定义的sort()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparingInt(User::getAge));</span><br></pre></td></tr></table></figure>
使用<code>Collections</code>的<code>sort()</code>方法，排序的对象需要实现<code>Comparable</code>接口，重写<code>compareTo()</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//重写compareTo方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.getAge(), user.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用<code>Collections</code>的<code>sort()</code>方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line"><span class="comment">//如果不想实现Comparable接口，也可以使用这个方法</span></span><br><span class="line">Collections.sort(list,Comparator.comparingInt(User::getAge));</span><br></pre></td></tr></table></figure>
使用Stream流操作的<code>sort()</code>方法，传入一个<code>Comparator</code>接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列的特点分别是什么？在java中有哪些实现的类？"><a href="#栈和队列的特点分别是什么？在java中有哪些实现的类？" class="headerlink" title="栈和队列的特点分别是什么？在java中有哪些实现的类？"></a>栈和队列的特点分别是什么？在java中有哪些实现的类？</h3>栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>。<br><code>Stack</code>类是栈在java中的实现，继承<code>Vector</code>类，底层是基于数组存储数据。<br><code>Queue</code>接口是队列在java中的代表，<code>Queue</code>接口有几个常用的子类<code>ArrayDeque</code>、<code>LinkedList</code>。<h3 id="IO、NIO有什么区别？"><a href="#IO、NIO有什么区别？" class="headerlink" title="IO、NIO有什么区别？"></a>IO、NIO有什么区别？</h3>IO包括：<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>，<code>Reader</code>。<br>NIO三大核心：<code>selector</code>（选择器），<code>channel</code>（通道），<code>buffer</code>（缓冲区）<br>NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。<h3 id="如何进行日期的转换？"><a href="#如何进行日期的转换？" class="headerlink" title="如何进行日期的转换？"></a>如何进行日期的转换？</h3>使用<code>SimpleDateFormat</code>类进行<code>String</code>和<code>Date</code>之间的转换。<h3 id="如何获取上一年的今天的日期？"><a href="#如何获取上一年的今天的日期？" class="headerlink" title="如何获取上一年的今天的日期？"></a>如何获取上一年的今天的日期？</h3>使用<code>Calendar</code>对象。如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Calendar对象</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//设置年份，当前年份减去一年</span></span><br><span class="line">calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//以下是打印结果</span></span><br><span class="line">Date time = calendar.getTime();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(time));<span class="comment">//2019-06-08 23:43:14 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="BigDecimal类型一定不会失真吗？"><a href="#BigDecimal类型一定不会失真吗？" class="headerlink" title="BigDecimal类型一定不会失真吗？"></a>BigDecimal类型一定不会失真吗？</h3>不一定。<br>参数类型为<code>double</code>的构造方法的结果有一定的不可预知性，是有可能产生失真的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="number">0.99</span>);</span><br><span class="line">System.out.println(bigDecimal);<span class="comment">//结果如下</span></span><br><span class="line"><span class="comment">//0.9899999999999999911182158029987476766109466552734375</span></span><br></pre></td></tr></table></figure>
使用参数类型<code>String</code>构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型<code>String</code>构造方法。<h1 id="java并发编程"><a href="#java并发编程" class="headerlink" title="java并发编程"></a>java并发编程</h1><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3></li>
<li>避免主线程阻塞，可以使用多线程做成异步调用。</li>
<li>提升性能，充分利用CPU资源。<h3 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h3></li>
<li>通过继承<code>Thread</code>类创建线程类。</li>
<li>通过实现<code>Runnable</code>接口创建线程类。</li>
<li>通过实现<code>Callable</code>接口创建线程类。<h3 id="如何获取多线程的返回值？"><a href="#如何获取多线程的返回值？" class="headerlink" title="如何获取多线程的返回值？"></a>如何获取多线程的返回值？</h3>使用<code>Callable</code>和<code>FutureTask </code>接口，获取返回值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       	<span class="comment">//使用匿名内部类创建Callable</span></span><br><span class="line">           Callable callable = () -&gt; <span class="string">&quot;hello call&quot;</span>;</span><br><span class="line">           FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">           <span class="comment">//执行线程</span></span><br><span class="line">           <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">           <span class="keyword">if</span> (!futureTask.isDone()) &#123;</span><br><span class="line">           	<span class="comment">//获取返回值</span></span><br><span class="line">               System.out.println(futureTask.get());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程的生命周期？"><a href="#多线程的生命周期？" class="headerlink" title="多线程的生命周期？"></a>多线程的生命周期？</h3>新建状态、就绪状态、运行状态、阻塞状态、死亡状态<h3 id="如何进行线程之间的通信？"><a href="#如何进行线程之间的通信？" class="headerlink" title="如何进行线程之间的通信？"></a>如何进行线程之间的通信？</h3></li>
<li>使用<code>synchronized、wait()、notify()</code></li>
<li>使用JUC工具类<code>CountDownLatch</code></li>
<li>使用<code>ReentrantLock </code>结合<code>Condition</code></li>
<li>基本<code>LockSupport</code>实现线程间的阻塞和唤醒</li>
</ul>
<p>以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。</p>
<h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3><p>相同点：</p>
<ul>
<li><code>sleep()</code>方法和<code>wait()</code>方法都用来改变线程的状态，能够让线程从<strong>运行状态</strong>，转变为<strong>休眠状态</strong>。</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>sleep()</code>方法是<code>Thread</code>类中的静态方法，而<code>wait()</code>方法是<code>Object</code>类中的方法。</li>
<li><code>sleep()</code>方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用<code>synchronized</code>关键字修饰的)。</li>
<li>这两个方法都在同步代码块或同步方法中使用时，<code>sleep()</code>方法不会释放对象锁。而<code>wait()</code>方法则会释放对象锁。<h3 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h3></li>
<li>使用退出标志，使线程正常退出，也就是当<code>run()</code>方法完成后线程终止。</li>
<li>使用<code>stop()</code>方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。</li>
<li>使用<code>interrupt()</code>方法中断线程。<h3 id="什么是线程的死锁？如何避免线程死锁？"><a href="#什么是线程的死锁？如何避免线程死锁？" class="headerlink" title="什么是线程的死锁？如何避免线程死锁？"></a>什么是线程的死锁？如何避免线程死锁？</h3>多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。</li>
</ul>
<p>避免死锁的三种方式：</p>
<ul>
<li>加锁顺序（线程按照一定的顺序加锁）</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）<h3 id="线程池的作用？"><a href="#线程池的作用？" class="headerlink" title="线程池的作用？"></a>线程池的作用？</h3></li>
<li>利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。</li>
<li>实现任务线程队列缓存策略和拒绝机制。</li>
<li>可以对线程进行统一的分配，监控和调优。</li>
<li>提供定时执行、最大线程数、并发数控制等功能。<h3 id="创建线程池的重要参数分别代表什么意思？"><a href="#创建线程池的重要参数