<!DOCTYPE html>
<html lang="zh-CN,en,zh-HK,zh-TW,default">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>Netty进阶之粘包和拆包 - Hexo</title>
  
    <meta name="keywords" content="java,Netty">
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Alloceee
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post search' style="display: none;">
          
            <div id='cover-backstretch'></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Twilight Rush</p>
    
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-home fa-fw'></i><p>首页</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-history fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about"
              
              
              id="about">
              <i class='fas fa-heart fa-spin fa-fw'></i><p>关于</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/alloceee"
              
              
              id="https:githubcomalloceee">
              <i class='fas fa-paper-plane fa-fw'></i><p>github</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Netty进阶之粘包和拆包
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' target="_blank" href="https://gameofthrones.fandom.com/wiki/Jon_Snow" rel="nofollow noopener">
    <img no-lazy src="https://joe-1253912574.cos.ap-shenzhen-fsi.myqcloud.com/images/IMG_1292(20200629-005627).jpg">
    <p>Alloceee</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a><span class="sep"></span><a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/">Netty</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年7月8日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Netty进阶之粘包和拆包" data-path="/2020/07/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  
  <p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329e0e4be94869?w=895&h=340&f=png&s=33550" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/17329e0e4be94869?w=895&h=340&f=png&s=33550" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<span id="more"></span>

<h1 id="一、什么是粘包和拆包"><a href="#一、什么是粘包和拆包" class="headerlink" title="一、什么是粘包和拆包"></a>一、什么是粘包和拆包</h1><p>TCP是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。(来自百度百科)</p>
<p>发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用<strong>Nagle算法</strong>。Nagle算法会<strong>将多次时间间隔较小且数据量小的数据合并成一个大的数据块</strong>进行发送。虽然这样的确提高了效率，但是<strong>因为面向流通信，数据是无消息保护边界的</strong>，就会<strong>导致接收端难以分辨出完整的数据包</strong>了。</p>
<p>所谓的粘包和拆包问题，就是因为TCP消息无保护边界导致的。</p>
<!-- more -->

<h2 id="1-1-图解粘包和拆包"><a href="#1-1-图解粘包和拆包" class="headerlink" title="1.1 图解粘包和拆包"></a>1.1 图解粘包和拆包</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e5cfafa34ed7?w=774&h=456&f=png&s=36343" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/5/1731e5cfafa34ed7?w=774&h=456&f=png&s=36343" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>正常发送消息是三次发送三个数据包，这种情况没有问题。</p>
<p>粘包，则是其中有多个数据包合并成一个数据包进行发送，也就是上图的第二种情况。</p>
<p>拆包，则是其中一个数据包被拆成了多段，发送的数据包只包含了一个完整数据包的一部分。也就是上图的第三种情况。</p>
<h2 id="1-2-程序演示"><a href="#1-2-程序演示" class="headerlink" title="1.2 程序演示"></a>1.2 程序演示</h2><p>首先准备客户端负责发送消息，连续发送5次消息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;msg No&quot;</span> + i + <span class="string">&quot; &quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    ctx.writeAndFlush(byteBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后服务端作为接收方，接收并且打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count变量，用于计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">    <span class="comment">//把ByteBuf的数据读到bytes数组中</span></span><br><span class="line">    msg.readBytes(bytes);</span><br><span class="line">    String message = <span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器接收到数据：&quot;</span> + message);</span><br><span class="line">    <span class="comment">//打印接收的次数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;接收到的数据量是：&quot;</span> + (++<span class="keyword">this</span>.count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务端，再启动两个客户端发送消息,服务端的控制台可以看到这样：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f27303054a8f?w=719&h=199&f=png&s=28205" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/5/1731f27303054a8f?w=719&h=199&f=png&s=28205" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>粘包的问题其实是随机的，所以每次结果都不太一样。</p>
<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>总体思路可以分为三种：</p>
<ul>
<li>在数据的末尾添加特殊的符号标识数据包的边界。通常会加\n\r、\t或者其他的符号。</li>
<li>在数据的头部声明数据的长度，按长度获取数据。</li>
<li>规定报文的长度，不足则补空位。读取时按规定好的长度来读取。</li>
</ul>
<h2 id="2-1-使用LineBasedFrameDecoder"><a href="#2-1-使用LineBasedFrameDecoder" class="headerlink" title="2.1 使用LineBasedFrameDecoder"></a>2.1 使用LineBasedFrameDecoder</h2><p>这是Netty内置的一个解码器，对应的编码器是LineEncoder。</p>
<p>原理是上面讲的第一种思路，在数据末尾加上特殊符号以标识边界。默认是使用换行符\n。</p>
<p>用法很简单，发送方加上编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//添加编码器，使用默认的符号\n，字符集是UTF-8</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> LineEncoder(LineSeparator.DEFAULT, CharsetUtil.UTF_8));</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> TcpClientHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收方加上解码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//解码器需要设置数据的最大长度，我这里设置成1024</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">//给pipeline管道设置业务处理器</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> TcpServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在发送方，发送消息时在末尾加上标识符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//在末尾加上默认的标识符\n</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;msg No&quot;</span> + i + StringUtil.LINE_FEED, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我们再次启动服务端和客户端，在服务端的控制台可以看到：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f4a496a5469d?w=505&h=231&f=png&s=42918" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/5/1731f4a496a5469d?w=505&h=231&f=png&s=42918" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>粘包、拆包的问题就轻松得到解决。</p>
<p>注意点：<strong>数据末尾一定是分隔符，分隔符后面不要再加上数据</strong>，否则会当做下一条数据的开始部分。下面是错误演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//在分隔符后面加上一段字符串</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;msg No&quot;</span> + i + StringUtil.LINE_FEED + <span class="string">&quot;[我是分隔符后面的字符串]&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端的控制台就会看到这样的打印信息：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731f7fca99184e9?w=446&h=208&f=png&s=24270" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/5/1731f7fca99184e9?w=446&h=208&f=png&s=24270" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="2-2-使用自定义长度帧解码器"><a href="#2-2-使用自定义长度帧解码器" class="headerlink" title="2.2 使用自定义长度帧解码器"></a>2.2 使用自定义长度帧解码器</h2><p>使用这个解码器解决粘包问题的原理是上面讲的第二种，在数据的头部声明数据的长度，按长度获取数据。这个解码器构造器需要定义5个参数，相对较为复杂一点，先看参数的解释：</p>
<ul>
<li>maxFrameLength  发送数据包的最大长度</li>
<li>lengthFieldOffset  长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。</li>
<li>lengthFieldLength  长度域的字节数长度。长度域的字节数长度。</li>
<li>lengthAdjustment  长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。</li>
<li>initialBytesToStrip  丢弃的起始字节数。丢弃处于此索引值前面的字节。</li>
</ul>
<p>前面三个参数比较简单，可以用下面这张图进行演示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/6/173249f1dcce734e?w=557&h=342&f=png&s=28445" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/6/173249f1dcce734e?w=557&h=342&f=png&s=28445" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>矫正偏移量是什么意思呢？意思是假设你的长度域设置的值除了包括有效数据的长度还有其他域的长度包含在里面，那么就要设置这个值进行矫正，否则解码器拿不到有效数据。矫正值的公式就是上面写着了。</p>
<p>丢弃的起始字节数。这个比较简单，就是在这个索引值前面的数据都丢弃，只要后面的数据。一般都是丢弃长度域的数据。当然如果你希望得到全部数据，那就设置为0。</p>
<p>下面就在消息接收端使用自定义长度帧解码器，解决粘包的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//数据包最大长度是1024</span></span><br><span class="line">    <span class="comment">//长度域的起始索引是0</span></span><br><span class="line">    <span class="comment">//长度域的数据长度是4</span></span><br><span class="line">    <span class="comment">//矫正值为0，因为长度域只有 有效数据的长度的值</span></span><br><span class="line">    <span class="comment">//丢弃数据起始值是4，因为长度域长度为4，我要把长度域丢弃，才能得到有效数据</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> TcpClientHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着编写发送端代码，根据解码器的设置，进行发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        String str = <span class="string">&quot;msg No&quot;</span> + i;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.buffer(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">//设置长度域的值，为有效数据的长度</span></span><br><span class="line">        byteBuf.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">//设置有效数据</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动服务端，客户端，我们可以看到控制台打印结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17324aa254af3f3f?w=343&h=199&f=png&s=15892" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/6/17324aa254af3f3f?w=343&h=199&f=png&s=15892" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>可以看到，利用自定义长度帧解码器解决了粘包问题。</p>
<h2 id="2-3-使用Google-Protobuf编解码器"><a href="#2-3-使用Google-Protobuf编解码器" class="headerlink" title="2.3 使用Google Protobuf编解码器"></a>2.3 使用Google Protobuf编解码器</h2><p>Netty<a target="_blank" rel="noopener" href="https://netty.io/">官网</a>上是明显写着支持Google Protobuf的，如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/6/17322cc3e98146fe?w=599&h=343&f=png&s=56992" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/6/17322cc3e98146fe?w=599&h=343&f=png&s=56992" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="2-3-1-Google-Protobuf是什么"><a href="#2-3-1-Google-Protobuf是什么" class="headerlink" title="2.3.1 Google Protobuf是什么"></a>2.3.1 Google Protobuf是什么</h3><blockquote>
<p>摘自官网的原话：<br>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</blockquote>
<p>翻译一下：Protocol buffers是Google公司的<strong>与语言无关、平台无关、可扩展的序列化数据的机制</strong>，类似XML，但是<strong>更小、更快、更简单</strong>。您只需<strong>定义一次数据的结构化方式</strong>，然后就可以使用<strong>特殊生成的源代码</strong>，轻松地<strong>将结构化数据写入和读取到各种数据流中，并支持多种语言</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/">Google Protobuf官网</a></p>
<h3 id="2-3-2-使用Google-Protobuf"><a href="#2-3-2-使用Google-Protobuf" class="headerlink" title="2.3.2 使用Google Protobuf"></a>2.3.2 使用Google Protobuf</h3><p>首先先下载编译器，我使用的是win系统，所以下载的是win版本。<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.6.1">下载编译器链接，版本是v3.6.1</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17324e5a84010099?w=1041&h=240&f=png&s=31916" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/17324e5a84010099?w=1041&h=240&f=png&s=31916" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>如果官网下载慢的话，我已经下载了一个，并且上传到百度网盘，<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/11yckiP4uWXR9I0bKyRBzOQ">网盘链接</a>，提取码：8b1r。公众号什么的随缘关注吧，哈哈~</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/17329eb724fd70a4?w=741&h=364&f=png&s=19605" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/17329eb724fd70a4?w=741&h=364&f=png&s=19605" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>以下步骤参考Google Protobuf的github项目的<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/tree/master/java">指南</a>。</p>
<h4 id="第一步：添加maven依赖"><a href="#第一步：添加maven依赖" class="headerlink" title="第一步：添加maven依赖"></a>第一步：添加maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="第二步：编写proto文件Message-proto"><a href="#第二步：编写proto文件Message-proto" class="headerlink" title="第二步：编写proto文件Message.proto"></a>第二步：编写proto文件Message.proto</h4><p>如何编写.proto文件的相关文档说明，可以去<a target="_blank" rel="noopener" href="https://developers.google.cn/protocol-buffers/docs/proto3#scalar">官网查看</a></p>
<p>下面我写一个例子，请看示范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; //版本</span><br><span class="line">option java_outer_classname = &quot;MessagePojo&quot;;//生成的外部类名，同时也是文件名</span><br><span class="line"></span><br><span class="line">message Message &#123;</span><br><span class="line">    int32 id = 1;//Message类的一个属性，属性名称是id，序号为1</span><br><span class="line">    string content = 2;//Message类的一个属性，属性名称是content，序号为2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第三步：使用编译器，通过-proto文件生成代码"><a href="#第三步：使用编译器，通过-proto文件生成代码" class="headerlink" title="第三步：使用编译器，通过.proto文件生成代码"></a>第三步：使用编译器，通过.proto文件生成代码</h4><p>解压前面下载下来的压缩包protoc-3.6.1-win32.zip,然后打开\protoc-3.6.1-win32\bin目录下，可以看到有一个protoc.exe程序。如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/1732508b9c9007ee?w=635&h=108&f=png&s=6967" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/1732508b9c9007ee?w=635&h=108&f=png&s=6967" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>然后复制前面写好的Message.proto文件到此目录下，如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250997e5b223c?w=638&h=136&f=png&s=10706" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/173250997e5b223c?w=638&h=136&f=png&s=10706" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>接着在此目录下打开命令行cmd，输入命令：protoc.exe –java_out=. Message.proto</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250bea472e4c7?w=521&h=107&f=png&s=3797" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/173250bea472e4c7?w=521&h=107&f=png&s=3797" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>然后就可以看到生成的MessagePojo.java文件。最后把文件复制到IDEA项目中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/7/173250d5605c8188?w=242&h=179&f=png&s=7294" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/173250d5605c8188?w=242&h=179&f=png&s=7294" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h4 id="第四步：在发送端添加编码器，在接收端添加解码器"><a href="#第四步：在发送端添加编码器，在接收端添加解码器" class="headerlink" title="第四步：在发送端添加编码器，在接收端添加解码器"></a>第四步：在发送端添加编码器，在接收端添加解码器</h4><p>客户端添加编码器，对消息进行编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//在发送端添加Protobuf编码器</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> TcpClientHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端添加解码器，对消息进行解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//添加Protobuf解码器，构造器需要指定解码具体的对象实例</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> ProtobufDecoder(MessagePojo.Message.getDefaultInstance()));</span><br><span class="line">    <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> TcpServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步：发送消息"><a href="#第五步：发送消息" class="headerlink" title="第五步：发送消息"></a>第五步：发送消息</h4><p>客户端发送消息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用的是构建者模式进行创建对象</span></span><br><span class="line">    MessagePojo.Message message = MessagePojo</span><br><span class="line">            .Message</span><br><span class="line">            .newBuilder()</span><br><span class="line">            .setId(<span class="number">1</span>)</span><br><span class="line">            .setContent(<span class="string">&quot;芜湖大司马，起飞~&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    ctx.writeAndFlush(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端接收到数据，并且打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessagePojo.Message messagePojo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span> + messagePojo.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;content:&quot;</span> + messagePojo.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果正确：<br><img src="https://user-gold-cdn.xitu.io/2020/7/7/17325145051d6e3a?w=364&h=68&f=png&s=2580" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/7/7/17325145051d6e3a?w=364&h=68&f=png&s=2580" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="2-3-3-分析Protocol的粘包、拆包"><a href="#2-3-3-分析Protocol的粘包、拆包" class="headerlink" title="2.3.3 分析Protocol的粘包、拆包"></a>2.3.3 分析Protocol的粘包、拆包</h3><p>实际上直接使用Protocol编解码器还是存在粘包问题的。</p>
<p>证明一下，发送端循环一百次发送100条”大司马，起飞”的消息，请看发送端代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        MessagePojo.Message message = MessagePojo</span><br><span class="line">                .Message</span><br><span class="line">                .newBuilder()</span><br><span class="line">                .setId(i)</span><br><span class="line">                .setContent(i + <span class="string">&quot;号大司马，起飞~&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，启动服务端，客户端后，你会在控制台看到如下错误：</p>
<blockquote>
<p>com.google.protobuf.InvalidProtocolBufferException: While parsing a protocol message, the input ended unexpectedly in the middle of a field.  This could mean either that the input has been truncated or that an embedded message misreported its own length.</p>
</blockquote>
<p>意思是：分析protocol消息时，输入意外地在字段中间结束。这可能