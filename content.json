{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Alloceee","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-07-21T07:09:57.761Z","updated":"2021-07-21T07:09:52.056Z","comments":true,"path":"contact.html","permalink":"http://example.com/contact.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:36:59.438Z","updated":"2021-07-28T03:36:59.438Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"首页","date":"2021-07-21T07:07:37.111Z","updated":"2021-07-21T07:07:37.111Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-28T03:33:13.532Z","updated":"2021-07-28T03:33:13.532Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:32:03.331Z","updated":"2021-07-28T03:32:03.331Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"my-friends","date":"2021-07-28T03:35:55.301Z","updated":"2021-07-28T03:35:55.301Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:34:26.738Z","updated":"2021-07-28T03:34:26.738Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-28T03:33:40.751Z","updated":"2021-07-28T03:33:40.751Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"为什么MySQL使用B+树","slug":"数据库/MySQL/other/为什么MySQL使用B+树","date":"2021-07-27T09:10:38.662Z","updated":"2021-07-29T07:42:24.598Z","comments":true,"path":"2021/07/27/数据库/MySQL/other/为什么MySQL使用B+树/","link":"","permalink":"http://example.com/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BD%BF%E7%94%A8B+%E6%A0%91/","excerpt":"在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，我们就以这两种数据结构为例，分析比较 B+ 树的优点。","text":"在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，我们就以这两种数据结构为例，分析比较 B+ 树的优点。 概述首先需要澄清的一点是，MySQL跟B+树没有直接的关系，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取，除了InnoDB之外，MySQL中也支持MyISAM作为表的底层存储引擎。 我们在使用 SQL 语句创建表时就可以为当前表指定使用的存储引擎，你能在 MySQL 的文档 Alternative Storage Engines 中找到它支持的全部存储引擎，例如：MyISAM、CSV、MEMORY 等，然而默认情况下，使用如下所示的 SQL 语句来创建表就会得到 InnoDB 存储引擎支撑的表： 1234CREATE TABLE t1 ( a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB; 想要详细了解 MySQL 默认存储引擎的读者，可以通过之前的文章 『浅入浅出』MySQL 和 InnoDB 了解包括 InnoDB 存储方式、索引和锁等内容，我们在这里主要不会介绍 InnoDB 相关的过多内容。 我们今天最终将要分析的问题其实还是，为什么 MySQL 默认的存储引擎 InnoDB 会使用 MySQL 来存储数据，相信对MySQL稍微有些了解的人都知道，无论是表中的数据（主键索引）还是辅助索引最终都会使用B+树来存储数据，其中前者在表中会以&lt;id,row&gt;的方式存储，而后者会以&lt;index,id&gt;的方式进行存储，这其实也比较好理解： 在主键索引中，id是主键，我们能够通过id找到该行的全部列； 在辅助索引中，索引中的几个列构成了键，我们能够通过索引中的列找到id，如果有需要的话，可以再通过id找到当前数据行的全部内容； 对于InnoDB来说，所有的数据都是以键值对的方式存储的，主键索引和辅助索引在存储数据时都会将id和index作为键，将所有列和id作为键对应的值。 在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，相信这也是很多人会在面试中真实遇到的问题，我们就以这两种数据结构为例，分析比较 B+ 树的优点。 设计为什么MySQL的InnoDB存储引擎会选择B+树作为底层数据结构，而不选择B树或者哈希？在这一节中，我们将通过以下的两个方面介绍InnoDB这样选择的原因。 InnoDB需要支持的场景和功能需要在特定查询上拥有较强的性能； CPU将磁盘上的数据加载到内存中需要花费大量的时间，这使得B+树成为了非常好的选择。 数据的持久化以及持久化数据的查询其实是一种常见的需求，而数据的持久化就需要我们与磁盘、内存和CPU打交道；MySQL作为OLTP的数据库不仅需要具备事务的处理能力，而且要保证数据的持久化而且能够有一定的实时数据查询能力，这些需求共同决定了B+树的选择，接下来我们会详细分析上述两个原因背后的逻辑。 读写性能OLTP代表Online Transaction Processing，与OLTP相比的还有OLAP：Online Analytical Processing，从这两个名字中我们就可以看出，前者指的是传统的关系型数据库，主要用于处理基本的、日常的事务处理，而后者主要在数据仓库中使用，用于支持一些复杂的分析和决策。 作为支撑CLTP数据的存储引擎，我们经常会使用InnoDB完成以下的一些工作： 通过 INSERT、UPDATE 和 DELETE 语句对表中的数据进行增加、修改和删除； 通过 UPDATE 和 DELETE 语句对符合条件的数据进行批量的删除； 通过 SELECT 语句和主键查询某条记录的全部列； 通过 SELECT 语句在表中查询符合某些条件的记录并根据某些字段排序； 通过 SELECT 语句查询表中数据的行数； 通过唯一索引保证表中某个字段或者某几个字段的唯一性；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":"Alloceee"},{"title":"SQL如何使用Concat连接两列数据","slug":"数据库/MySQL/other/concat组合多个字段","date":"2021-07-26T16:00:00.000Z","updated":"2021-07-27T01:37:30.626Z","comments":true,"path":"2021/07/27/数据库/MySQL/other/concat组合多个字段/","link":"","permalink":"http://example.com/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/concat%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5/","excerpt":"","text":"SQL如何使用Concat连接两列数据方法/步骤concat直接组合多个字段1select concat(name,uid) as name from user concat不仅可以使用字段名，也可以使用字符串1select concat(name,&#x27;~&#x27;,uid) as name from user concat嵌套使用1select concat(name,concat(uid,sex)) as name from user","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"第5章 系统性能评价","slug":"SystemArchitect/第5章：系统性能评价","date":"2021-07-25T16:00:00.000Z","updated":"2021-07-28T08:26:44.106Z","comments":true,"path":"2021/07/26/SystemArchitect/第5章：系统性能评价/","link":"","permalink":"http://example.com/2021/07/26/SystemArchitect/%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/","excerpt":"性能设计主要包含两方面的内容：一是作为未来计算机发展的参考和规划；另一个则是对现有系统进行性能上的调整已达到最优化。","text":"性能设计主要包含两方面的内容：一是作为未来计算机发展的参考和规划；另一个则是对现有系统进行性能上的调整已达到最优化。 5.1 性能指标描述当前流行系统主要涉及的性能指标 5.1.1 对计算机评价的主要性能指标1.时钟频率（主频）主频是计算机的主要性能指标之一，在很大程度上决定了计算机的运算速度。CPU的工作节拍是由主时钟来控制的，主时钟不断产生固定频率的时钟脉冲，这个主时钟的评率即是CPU的主频。主频越高，意味着CPU的工作节拍就越快，运算速度也就越快。现在已经发展为多核心CPU，除了看时钟频率还得看单个CPU中的内核数。 2.高速缓存高速缓存可以提高CPU的运行效率。目前一般采用两级高速缓存技术，有些使用三层。高速缓冲存储器均由静态RAM（Random Access Memory，随机存取存储器）组成，结构较复杂，在 CPU 管芯面积不能太大的情况下，L1 级高速缓存的容量不可能做得太大。采用回写（WriteBack）结构的高速缓存。它对读和写操作均有可提供缓存。而采用写通（Write-through）结构的高速缓存，仅对读操作有效。L2 及 L3 高速缓存容量也会影响 CPU的性能，原则是越大越好。 性能计算描述当前使用到的主要性能指标的计算方法 性能设计描述如何对现有系统进行性能上的调整优化，并介绍几个已经成熟的设计规则和解决方案 性能评估描述如何对当前取得的性能指标进行评价和改进","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第10章：设计模式","slug":"SystemArchitect/第10章：设计模式","date":"2021-07-21T06:33:00.000Z","updated":"2021-07-27T06:48:02.887Z","comments":true,"path":"2021/07/21/SystemArchitect/第10章：设计模式/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1.设计模式概述1.1设计模式的概念GoF设计模式：对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述。通俗地说，可以把设计模式理解为对某一类问题的通用解决方案。 1.2设计模式的组成一般的，在描述一个设计模式时，至少需要包含四个方面： 模式名称（Pattern name） 问题（Problem） 解决方案（Solution） 效果（Consequence） 这四个方面就是设计模式的四要素。 1.3GoF设计模式（模式介绍）创建型1.Factory Method模式（工厂方法）Factory Method 模式提供了一种延迟创建类的方法，使用这个方法可以在运行期由子类决定创建哪一个类的实例。 2.Abstract Factory模式（抽象工厂）Abstract Factory又称为抽象工厂模式，该模式主要为解决复杂系统中对象创建的问题。抽象工厂模式提供了一个一致的对象创建接口来创建一系列具有相似基类或相似接口的对象。 3.Buider模式（建造器）Builder模式与Abstract Factory模式非常类似，但Builder模式是逐步地构造出一个复杂对象，并在最后返回对象的实例。Builder模式可以把复杂对象的创建与表示分离，使得同样的创建过程可以创建不同的表示。 4.Prototype模式（原型）Prototype模式可以根据原型实例制定创建的对象的种类，并通过深复制这个原型来创建新的对象。Prototype模式有着同Abstract Factory模式和Builder模式相同的效果，不过当需要实例化的类是在运行期才被指定的而且要避免创建一个与产品曾是平行的工厂类层次时，可以使用Prototype模式。使用Prototype模式可以在运行时增加或减少原型，比Abstract Factory和Builder模式更加灵活。 5.Singleton模式（单例）使用Singleton模式可以保证一个类仅有一个实例，从而可以提供一个单一的全局访问点。 结构型6.Adapter模式（适配器）Adapter模式可以解决系统间接口不相容的问题。通过Adapter可以把类的接口转化为客户程序所希望的接口，从而提高复用性。 7.Bridge模式（桥接）Bridge模式基于类的最小设计的原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（Implementation）分离开来，从而可以保证各部分的独立性以及应对他们的功能拓展。 8.Composite模式（组合）Composite模式提供了一种以树形结构组合对象的方法，使用Composite可以使单个对象和组合后的对象具有一致性以提高软件的复用性。 9.Decorator模式（装饰者）Decorator模式可以动态地为对象的某一个方法增加更多的功能。在更多时候，使用Decorator模式可以不必继承出新的子类从而维护简介的类继承结构。 10.Facade模式（门面）Facade模式为一组类提供了一致的访问接口。使用Facade可以封装内部具有不同接口的类，使其对外提供统一的访问方法。Facade模式在J2EE系统开发中发展为Session Facade模式。 11.Flyweight模式（享元）Flyweight模式可以共享大量的细粒度对象，从而节省创建对象所需要分配的空间，不过在时间上的开销会变大。 12.Proxy模式（代理）顾名思义，Proxy模式为对象提供了一种访问代理，通过对象Proxy可以控制客户程序的访问。例如：访问权限的控制、访问地址的控制、访问方式的控制等，甚至可以通过Proxy将开销较大的访问化整为零，提高访问效率。 行为型13.Interpreter模式（解释器）定义了一个解释器，来解释遵循给定语言和文法的句子。 14.Template Method模式（模板）定义一个操作的模板，其中的一些步骤会在子类中实现，以适应不同的情况。 15.Chain of Responsibility模式（责任链）Chain of Responsibility模式把可以响应请求的对象组织成一条链，并在这条对象链上传递对象，从而保证多个对象都有机会处理请求而且可以避免请求方和响应方的耦合。 16.Command模式（命令）将请求封装为对象，从而增强请求的能力，如参数化、排队、记录日志等。 17.Iterator模式（迭代器）Iterator模式提供了顺序访问一个对象集合的各元素的方法，使用Iterator可以避免暴露集合中对象的耦合关系。 18.Mediator模式（中介者）Mediator模式可以减少系统中对象间的耦合性。Mediator模式使用中介对象封装其他对象，从而使这些被封装的对象间的关系就成了松散耦合。 19.Memento模式（备忘录）Memento模式提供了一种捕获对象状态的方法，且不会破坏对象的封装，并且可以在对象外部保存对象的状态，并在需要的时候恢复对象状态。 20.Observer模式（观察者）Observer模式提供了将对象的状态广播到一组观察者的方式，从而可以让每个观察者随时都可以得到对象更新的通知。 21.State模式（状态）State模式允许一个对象在其内部状态改变的时候改变他的行为。 22.Strategy（策略）使用Strategy模式可以让对象中算法的变化独立于客户。 23.Visitor模式（访问者）表示对某对象结构中各元素的操作，使用Visitor模式可以在不改变各元素类的前提下定义作用于这些元素的新操作。 1.5设计模式与软件架构1.6设计模式分类 创建型 结构型 行为型 应用范围 应用于类 Factory Method Adapter Interpreter Template Method 应用于对象 Abstract Factory Builder Prototype Singleton Adapter Bridege Composite Decorator Facade Flyweight Proxy Chain of Responsiblity Command Interator Mediator Memento Observer State Strategy Visitor 1.7设计模式的六大原则开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热拔插的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级，想要达到这样的效果，我们需要使用接口和抽象类。 1.8模式具体分析5.Signleton模式7.Bridge模式桥接模式的角色和职责： 1.Client调用端 这是Bridge模式的调用者。 2.抽象类（Abstraction） 抽象类接口（接口这货抽象类）维护对行为实现（implementation）的引用，他的角色就是桥接类。 3.Refined Abstraction 这是Abstraction的子类。 4.Implementor 行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作） 5.ConcreteImplmentor Implementor的子类。 桥接模式的UML图如下： 总结： 1.桥接模式的优点 （1）实现了抽象和实现部分的分离 桥接模式分离了抽象部分和实现部分，从而极大地提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 （2）更好的可扩展性 由于桥接模式把抽象部分和实现部分分离了，从而分别定义接口，这就使得抽象部分和实现部分可以分别独立扩展，而不会相互影响，大大的提供了系统的可扩展性。 （3）可动态的切换实现 由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。 （4）实现细节对客户端透明，可以对用户隐藏实现细节。 2.桥接模式的缺点 （1）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 （2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。 3.桥接模式的使用场景 （1）如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使他们在抽象层建立一个关联关系。 （2）抽象化角色和实现化角色可以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。","categories":[],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第9章：软件架构设计","slug":"SystemArchitect/第9章：软件架构设计","date":"2021-07-21T06:32:00.000Z","updated":"2021-07-28T09:26:39.630Z","comments":true,"path":"2021/07/21/SystemArchitect/第9章：软件架构设计/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC9%E7%AB%A0%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。","text":"软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。 3.软件架构风格软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。 软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（idiomatic paradigm），定义了用于描述系统的术语表和一组指导构建系统的规则。 3.1软件架构风格分类（1）设计词汇表是什么？ （2）构建和连接件的类型是什么？ （3）可容许的结构模式是什么？ （4）基本的计算模型是什么？ （5）风格的基本不变性是什么？ （6）其使用的常见例子是什么？ （7）使用此风格的优缺点是什么？ （8）其常见的特例是什么？ 3.2数据流风格数据流风格的软件架构是一种最常见，结构最为简单的软件架构。这样的架构下，所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构，就像工厂中的汽车流水线一样，数据就像汽车零部件一样的流水线的各个节点上被加工，最终输出所需要的结果（一步完整的汽车）。在流动过程中，数据经过序列间的数据处理组件进行加工，然后将处理结果向后传送，最后进行输出。 批处理序列批处理风格的每一步处理都是独立的，并且每一步是顺序执行的。只有当前一步处理完，后一步处理才能开始。数据传送在步与步之间作为一个整体。（组件为一系列固定顺序的计算单元，组件间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在前一步结束后才能开始，数据必须是完整的，以整体的方式传递）。 批处理的典型应用： （1）经典数据处理； （2）程序开发； （3）Windows 下的 BAT 程序就是这种应用的典型实例 管道-过滤器在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。 此风格特别重要的过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。一个管道/过滤器网络输出的正确性并不依赖于过滤器进行增量计算过程的顺序。 典型应用： （1）以UNIX Shell编写的程序。UNIX 既提供一种符号，以连接各组成部分（UNIX 的进程），又提供某种进程运行时机制以实现管道。 （2）传统的编译器。传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。 特点3.3调用/返回风格调用返回风格顾名思义，就是指在系统中采用了调用与返回机制。利用调用-返回实际上是一种分而治之的策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。程序从其执行起点开始执行该构建的代码，程序执行结束，将控制返回给程序调用构件。 主程序/子程序主程序/子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。调用关系具有层次性，其语义逻辑表现为子程序的正确性，取决于它调用的子程序的正确性。 面向对象风格抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。 特点：（1）对象负责维护其表示的完整性； 层次结构5.面向服务的架构SOA是一种在计算环境中设计、开发、部署和管理离散逻辑单元（服务）模型的方法。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第1章：计算机组成与体系结构","slug":"SystemArchitect/第1章：计算机组成与体系结构","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-28T03:39:22.787Z","comments":true,"path":"2021/07/21/SystemArchitect/第1章：计算机组成与体系结构/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.计算机系统1.3 复杂指令集系统与精简指令集系统 指令系统类型 指令 寻址方式 实现方式 其他 CISC（复杂） 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术 研制周期长 RISC（精简） 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编译，有效支持高级语言 2.存储器系统2.3 Cache存储器Cache的性能是计算机系统性能的重要方面。命中率是cache的一个重要指标，但不是最重要的指标。cache设计的主要目标是在成本允许的情况下达到较高的命中率，使存储系统具有最短的平均访问时间。cache的命中率和cache容量的关系是：cache容量越大，则命中率越高，随着容量的增加，其失效率接近0%（命中率接近100%）。但是，增加cache容量意味着增加cache的成本和增加cache的命中时间。 3.流水线流水线技术把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构复杂执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构，这个就可以实现多个任务的重叠执行，以提高工作效率。 3.1 流水线周期流水线应用过程中，会将需要处理的工作分为 N 个阶段，最耗时的那一段所消耗的时间为流水线周期。 3.2 计算流水线执行时间以流水线的执行时间可通俗的表达为： 流水线执行时间=第 1 条指令的执行时间+（n-1）*流水线周期 n 代表需要处理的任务数量。 而实际上，真正做流水线处理时，考虑到处理的复杂性，会将指令的每个执行阶段的时 间都统一为流水线周期，即 1 条指令的执行时间为：4ms+4ms+4ms=12ms。 所以：实际流水线执行时间=4ms+4ms+4ms+(100-1)*4=408ms。 考试时 80%以上的概率采用理论公式计算，所以考试时需要以理论公式计算，若计算的结果无正确选项才考虑采用实际公式计算。 3.3 流水线的吞吐率流水线的吞吐率（Though Put rate，TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。有些文献也称为平均吞吐率、实际吞吐率。计算流水线吞吐率的最基本的公式如下：$$TP = \\frac{n}{T_k}$$其中n为任务数，$T_k$是处理完成n个任务所用的时间。 流水线的最大吞吐率为：$$TP_{max} = \\lim_{n\\to\\infty}\\frac{n}{(k+n-1)\\Delta{t}} = \\frac{1}{\\Delta{t}}$$ 3.4 流水线的加速比加速比：不使用流水线的执行时间/使用流水线的执行时间 如果不使用流水线，即顺序执行所用的时间为 $T_0$ ，使用流水线的执行时间为$T_k$，则计算流水线加速比的基本公式如下：$$S = \\frac{T_0}{T_k}$$如果流水线各个流水段的执行时间都相等（设为Dt），则一条k段流水线完成n个连续任务所需要的时间为(k+n-1)Dt。如果不使用流水线，即顺序执行这 n 个任务，则所需要的时间为 nkDt。因此，各个流水段执行时间均相等的一条 k 段流水线完成 n 个连续任务 时的实际加速比为：$$S = \\frac{nk\\Delta{t}}{(k+n-1)\\Delta{t}} = \\frac{nk}{k+n-1}$$这种情况下的最大加速比为：$$S_{max} = \\lim_{n\\to\\infty}\\frac{nk}{k+n-1} = k$$效率：即流水线设备的利用率，指流水线中的设备实际使用时间与整个运行时间的比值","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第2章：操作系统","slug":"SystemArchitect/第2章：操作系统","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-21T06:52:15.987Z","comments":true,"path":"2021/07/21/SystemArchitect/第2章：操作系统/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第3章：数据库系统","slug":"SystemArchitect/第3章：数据库系统","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-21T06:31:35.103Z","comments":true,"path":"2021/07/21/SystemArchitect/第3章：数据库系统/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"3.2 数据库模式与范式3.2.4 数据的规范化综合1NF、2NF和3NF、BCNF的内涵可概括如下： （1）非主属性完全函数依赖于码（2NF的要求） （2）非主属性不传递依赖于任何一个候选码（3NF的要求） （3）主属性对不含它的码完全函数依赖（BCNF的要求） （4）没有属性完全函数依赖于一组非主属性（BCNF的要求） 3.3 数据库设计3.3.1 逻辑结构设计1.基本E-R模型向关系模型转换2.数据模型优化（1）改善数据库的性能。 减少连接运算 减少关系大小和数据量（分表） 分表常用有水平分割与垂直分割。水平分割为分系建立关系，垂直分割为将常用数据与非常用数据分开。 （2）节约存储空间 缩小每个属性占用的空间 通常可以有两种方法：即用编码和用缩写符号表示属性，但这两种方法的缺点是失去了属性值含义的直观性。 采用假属性 主要任务逻辑结构设计阶段的主要任务是确定数据模型、将ER图转换成指定数据模型、确定完整性约束、确定用户视图。 超类实体：由多个实体中共有的属性组成 派生属性：由其他属性计算获得，用于存储计算结果值。","categories":[],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第6章：开发方法","slug":"SystemArchitect/第6章：开发方法","date":"2021-07-20T16:00:00.000Z","updated":"2021-07-21T06:29:31.768Z","comments":true,"path":"2021/07/21/SystemArchitect/第6章：开发方法/","link":"","permalink":"http://example.com/2021/07/21/SystemArchitect/%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/","excerpt":"","text":"3.统一过程（Unified Process,UP）RUP软件开发生命周期是一个二维的软件开发模型，其中有9个核心工作流，分别为： 业务建模、需求 分析设计 实施 测试 部署 配置与变更管理 项目管理 环境 RUP把软件生命生存周期划分为多个循环，每个循环产生产品的一个新的版本，每个循环依次由4个连续的阶段组成，每个阶段完成确定的任务。这四个阶段分别为： 初始阶段：定义最终产品视图与业务模型，并确定系统范围。 细化阶段：设计及确定系统的体系结构，制定工作计划及资源要求。 构造阶段：构造产品并继续演进需求、体系构造、计划直至产品提交。 移交阶段：把产品提交给用户使用。 每个阶段都有一个或多人连续的迭代组成。迭代并不是重复得做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程，它需要项目经理根据当前迭代所处的阶段以及上次迭代的结果，适当地对工作流中的行为进行裁剪。在每个阶段结束前都有一个里程碑评估该阶段的工作。如果未能通过该里程碑的评估，则决策者应该做出决定，是取消该项目还是继续该阶段的工作。 与其他软件开发过程相比，RUP具有自己的特点，即RUP是用例驱动的、以体系结构为中心的、迭代和增量的软件开发过程。","categories":[],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"","slug":"数据库/Redis/Redis计数器解决并发问题","date":"2021-07-20T05:09:35.036Z","updated":"2020-08-06T03:11:18.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis计数器解决并发问题/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Redis解决并发问题用setnx替代set命令初始化计数器，这确保了一旦A初始化计数器成功，B就不会再去初始化计数器。 12345678910111213141516171819202122/** * 获取用户当前的排序 * @return int */ protected function getCurrentOrder() &#123; $redis = new R(&quot;game&quot;); $order = $redis-&gt;get(self::$hd_ename); $number = point_model::getPointLogByTips(self::$hd_ename, &#x27;luckNumber&#x27;); if(!$order)&#123; if($number)&#123; $number = $number[count($number) - 1][&#x27;point&#x27;]; &#125;else&#123; $number = 0; &#125; $redis-&gt;setex(self::$hd_ename,120,$number); &#125;else&#123; $number = $redis-&gt;incr(self::$hd_ename); &#125; return $number; &#125; 我们都或多或少遇到过并发问题。家人因为看电视抢遥控器，这就是一种并发；两个孩子争着玩同一个玩具，这也是并发。在每一次“双11”购物节狂欢的背后，都有一群程序员在严阵以待，这不是一位数的并发，而是成千上万级别的并发。 说了什么是并发，接下来将向大家演示如何用Redis处理一个典型的并发问题。我们选择最常见的商品抢购场景，假定我们有100件商品，参与抢购的用户有成千上万，如何确保我们的商品不被多抢了？ 聪明的你应该想到了，可以用计数器来控制，每卖出一件商品，计数器加1，当计数器到达100时，我们的商品就卖完了。程序的工作流程如下图。 看起来很完美，但需要通过高并发场景的检验。我们假定有A、B两个进程同时在运行这段程序。 问题1初始化set计数器：A、B都发现计数器尚未初始化，在A执行“计数器加1”后，B去set计数器，此时计数器的值比正确值少1。（为什么时间差那么大？这在高并发场景中是完全可能存在的） 问题2计数器加1：A、B都读到计数器的值为99，不满足&gt;=100，两者都抢到了商品，但最终卖掉了101件，显然超卖了。 上面的流程存在两个问题，我们需要对程序流程做一点改进，新的流程如下图。 改进1用setnx替代set命令初始化计数器，这确保了一旦A初始化计数器成功，B就不会再去初始化计数器。 改进2先对计数器加1，再判断计数器是否&gt;100，如果是，说明超卖了。这确保了即使A、B同时读到计数器的值为99，都去对计数器加1，两者至少有一个得到的结果&gt;100，不会超卖。 从以上的内容我们学习到，如何用Redis处理一个常见的并发场景，这背后还有更多的技术细节值得我们深入了解，期待在下一篇文章中与大家共同学习。","categories":[],"tags":[]},{"title":"Redis的skiplist","slug":"数据库/Redis/Redis-skiplist","date":"2021-07-20T05:09:35.033Z","updated":"2021-07-27T01:42:38.389Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis-skiplist/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-skiplist/","excerpt":"","text":"跳表的实现从排行榜切入懂行的老哥一看这个小标题，就知道我要以排行榜作为切入点，去讲 Redis 的 zset 了。 是的，经典面试题，请实现一个排行榜，大部分情况下就是在考验你知不知道 Redis 的 zset 结构，和其对应的操作。 当然了，排行榜我们也可以基于其他的解决方案。比如 mysql。 我曾经就基于 mysql 做过排行榜，一条 sql 就能搞定。但是仅限于数据量比较少，性能要求不高的场景（我当时只有 11 支队伍做排行榜，一分钟刷新一次排行榜）。 对于这种经典的面试八股文，网上一找一大把，所以本文就不去做相关解析了。 说好的只是一个切入点。 如果你不知道具体怎么实现，或者根本就不知道这题在问啥，那一定记得看完本文后要去看看相关的文章。最好自己实操一下。 相信我，八股文，得背，这题会考。 zset的内部编码众所周知，Redis 对外提供了五种基本数据类型。但是每一种基本类型的内部编码却是另外一番风景： 其中 list 数据结构，在 Redis 3.2 版本中还提供了 quicklist 的内部编码。不是本文重点，我提一嘴就行，有兴趣的朋友自己去了解一下。 本文主要探讨的是上图中的 zset 数据结构。 zset 的内部编码有两种：ziplist 和 skiplist。 其实你也别觉得这个东西有多神奇。因为对于这种对外一套，对内又是一套的“双标党”其实你已经很熟悉了。 它就是 JDK 的一个集合类，来朋友们，大胆的喊出它的名字：HashMap。 HashMap 除了基础的数组结构之外，还有另外两个数据结构：一个链表，一个红黑树。 这样一联想是不是就觉得也不过如此，心里至少有个底了。 当链表长度大于 8 且数组长度大于 64 的时候， HashMap 中的链表会转红黑数。 对于 zset 也是一样的，一定会有条件触发其内部编码 ziplist 和 skiplist 之间的变化？ 这个问题的答案就藏在 redis.conf 文件中，其中有两个配置： 上图中配置的含义是，当有序集合的元素个数小于 zset-max-ziplist-entries 配置的值，且每个元素的值的长度都小于 zset-max-ziplist-value 配置的值时，zset 的内部编码是 ziplist。 反之则用 skiplist。 理论铺垫上了，接下我给大家演示一波。 首先，我们给 memberscore 这个有序集合的 key 设置两个值，然后看看其内部编码： 此时有序集合的元素个数是 2，可以看到，内部编码采用的是 ziplist 的结构。 为了大家方便理解这个储存，我给大家画个图： 然后我们需要触发内部编码从 ziplist 到 skiplist 的变化。 先验证 zset-max-ziplist-value 配置，往 memberscore 元素中塞入一个长度大于 64字节（zset-max-ziplist-value默认配置）的值： 这个时候 key 为 memberscore 的有序集合中有 3 个元素了，其中有一个元素的值特别长，超过了 64 字节。 此时的内部编码采用的是 skiplist。 接下来，我们往 zset 中多塞点值，验证一下元素个数大于 zset-max-ziplist-entries 的情况。 我们搞个新的 key，取值为 whytestkey。 首先，往 whytestkey 中塞两个元素，这是其内部编码还是 ziplist： 那么问题来了，从配置来看 zset-max-ziplist-entries 128。 这个 128 是等于呢还是大于呢？ 没关系，我也不知道，试一下就行了。 现在已经有两个元素了，再追加 126 个元素，看看： 通过实验我们发现，当 whytestkey 中的元素个数是 128 的时候，其内部编码还是 ziplist。 那么触发其从 ziplist 转变为 skiplist 的条件是 元素个数大于 128，我们再加入一个试一试： 果然，内部编码从 ziplist 转变为了 skiplist。 理论验证完毕，zset 确实是有两幅面孔。 本文主要探讨 skiplist 这个内部编码。 它就是标题说的：基于运气的数据结构。 什么是 skiplist？这个结构是一个叫做 William Pugh 的哥们在 1990 年发布的一篇叫做《Skip Lists: A Probabilistic Alternative to Balanced Trees》的论文中提出的。 1论文地址：ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf 摘要里面说：跳表是一种可以用来代替平衡树的数据结构，跳表使用概率平衡而不是严格的平衡，因此，与平衡树相比，跳表中插入和删除的算法要简单得多，并且速度要快得多。 论文里面，在对跳表算法进行详细描述的地方他是这样说的： 首先火男大佬说，对于一个有序的链表来说，如果我们需要查找某个元素，必须对链表进行遍历。比如他给的示意图的 a 部分。 我单独截取一下： 这个时候，大家还能跟上，对吧。链表查找，逐个遍历是基本操作。 那么，如果这个链表是有序的，我们可以搞一个指针，这个指针指向的是该节点的下下个节点。 意思就是往上抽离一部分节点。 怎么抽离呢，每隔一个节点，就抽一个出来，和上面的 a 示意图比起来，变化就是这样的： 抽离出来有什么好处呢？ 假设我们要查询的节点是 25 。 当就是普通有序链表的时候，我们从头节点开始遍历，需要遍历的路径是： head -&gt; 3 -&gt; 6 -&gt; 7 -&gt; 9 -&gt; 12 -&gt; 17 -&gt; 19 -&gt; 21 -&gt; 25 需要 9 次查询才能找到 25 。 但是当结构稍微一变，变成了 b 示意图的样子之后，查询路径就是： 第二层的 head -&gt; 6 -&gt; 9 -&gt; 17 -&gt; 21 -&gt; 25。 5 次查询就找到了 25 。 这个情况下我们找到指定的元素，不会超过 (n/2)+1 个节点： 那么这个时候有个小问题就来了：怎么从 21 直接到 25 的呢？ 看论文中的图片，稍微有一点不容易明白。 所以，我给大家重新画个示意图： 看到了吗？“多了”一个向下的指针。其实也不是多了，只是论文里面没有明示而已。 所以，查询 25 的路径是这样的，空心箭头指示的方向： 在 21 到 26 节点之间，往下了一层，逻辑也很简单。 21 节点有一个右指针指向 26，先判断右指针的值大于查询的值了。 于是下指针就起到作用了，往下一层，再继续进行右指针的判断。 其实每个节点的判断逻辑都是这样，只是前面的判断结果是进行走右指针。 按照这个往上抽节点的思想，假设我们抽到第四层，也就是论文中的这个示意图： 我们查询 25 的时候，只需要经过 2 次。 第一步就直接跳过了 21 之前的所有元素。 怎么样，爽不爽？ 但是，它是有缺陷的。 火男的论文里面是这样说的： This data structure could be used for fast searching, but insertion and deletion would be impractical. 查询确实飞快。但是对于插入和删除 would be impractical。 impractical 是什么意思？ 你看，又学一个四级单词。 对于插入和删除几乎是难以实现的。 你想啊，上面那个最底层的有序链表，我一开始就拿出来给你了。 然后我就说基于这个有序链表每隔一个节点抽离到上一层去，再构建一个链表。那么这样上下层节点比例应该是 2:1。巴拉巴拉的….. 但是实际情况应该是我们最开始的时候连这个有序链表都没有，需要自己去创建的。 就假设要在现有的这个跳表结构中插入一个节点，毋庸置疑，肯定是要插入到最底层的有序链表中的。 但是你破坏了上下层 2:1 的比例了呀？ 怎么办，一层层的调整呗。 可以，但是请你考虑一下编码实现起来的难度和对应的时间复杂度？ 要这样搞，直接就是一波劝退。 这就受不了了？ 我还没说删除的事呢。 那怎么办？ 看看论文里面怎么说到： 首先我们关注一下第一段划红线的地方。 火男写到：50% 的节点在第一层，25% 的节点在第二层， 12.5% 的节点在第三层。 你以为他在给你说什么？ 他要表达的意思除了每一层节点的个数之外，还说明了层级： 没有第 0 层，至少论文里面没有说有第 0 层。 如果你非要说最下面那个有全部节点的有序链表叫做第 0 层，我觉得也可以。但是，我觉得叫它基础链表更加合适一点。 然后我再看第二段划线的地方。 火男提到了一个关键词：randomly，意思是随机。 说出来你可能不信，但是跳表是用随机的方式解决上面提出的插入（删除）之后调整结构的问题。 怎么随机呢？抛硬币。 是的，没有骗你，真的是“抛硬币”。 跳表中的“硬币”当跳表中插入一个元素的时候，火男表示我们上下层之间可以不严格遵循 1:2 的节点关系。 如果插入的这个元素需要建立索引，那么把索引建立在第几层，都是由抛硬币决定的。 或者说：由抛硬币的概率决定的。 我问你，一个硬币抛出去之后，是正面的概率有多大？ 是不是 50%？ 如果我们把这个概率记为 p，那么 50%，即 p=1/2。 上面我们提到的概率，到底是怎么用的呢？ 火男的论文中有一小节是这样的写的： 随机选择一个层级。他说我们假设概率 p=1/2，然后叫我们看图 5。 图 5 是这样的： 非常关键的一张图啊。 短短几行代码，描述的是如何选择层级的随机算法。 首先定义初始层级为 1（lvl := 1）。 然后有一行注释：random() that returns a random value in [0…1) random() 返回一个 [0…1) 之间的随机值。 接下来一个 while…do 循环。 循环条件两个。 第一个：random() &lt; p。由于 p = 1/2，那么该条件成立的概率也是 1/2。 如果每随机一次，满足 random() &lt; p，那么层级加一。 那假设你运气爆棚，接连一百次随机出来的数都是小于 p 的怎么办？岂不是层级也到 100 层了？ 第二个条件 lvl &lt; MaxLevel，就是防止这种情况的。可以保证算出来的层级不会超过指定的 MaxLevel。 这样看来，虽然每次都是基于概率决定在那个层级，但是总体趋势是趋近于 1/2 的。 带来的好处是，每次插入都是独立的，只需要调整插入前后节点的指针即可。 一次插入就是一次查询加更新的操作，比如下面的这个示意图： 对于这个概率，其实火男在论文专门写了一个小标题，还给出了一个图表： 最终得出的结论是，火男建议 p 值取 1/4。如果你主要关心的是执行时间的变化，那么 p 就取值 1/2。 说一下我的理解。首先跳表这个是一个典型的空间换时间的例子。 一个有序的二维数组，查找指定元素，理论上是二分查找最快。而跳表就是在基础的链表上不断的抽节点（或者叫索引），形成新的链表。 所以，当 p=1/2 的时候，就近似于二分查找，查询速度快，但是层数比较高，占的空间就大。 当 p=1/4 的时候，元素升级层数的概率就低，总体层高就低，虽然查询速度慢一点，但是占的空间就小一点。 根据《Redis深度历险》一书里面的描述，在 Redis 中 p 的取值就是 1/4，MaxLevel 的取值是 64（视版本而定，有的Redis版本是32）。 论文里面还花了大量的篇幅去推理时间复杂度，有兴趣的可以去看着论文一起推理一下： 跳表在Java中的应用跳表，虽然是一个接触比较少的数据结构。 其实在 java 中也有对应的实现。 先问个问题：Map 家族中大多都是无序的，那么请问你知道有什么 Map 是有序的呢？ TreeMap，LinkedHashMap 是有序的，对吧。 但是他们不是线程安全的。 那么既是线程安全的，又是有序的 Map 是什么？ 那就是它，一个存在感也是低的不行的 ConcurrentSkipListMap。 你看它这个名字多吊，又有 list 又有 Map。 看一个测试用例： 12345678910111213141516public class MainTest &#123; public static void main(String[] args) &#123; ConcurrentSkipListMap&lt;Integer, String&gt; skipListMap = new ConcurrentSkipListMap&lt;&gt;(); skipListMap.put(3,&quot;3&quot;); skipListMap.put(6,&quot;6&quot;); skipListMap.put(7,&quot;7&quot;); skipListMap.put(9,&quot;9&quot;); skipListMap.put(12,&quot;12&quot;); skipListMap.put(17,&quot;17&quot;); skipListMap.put(19,&quot;19&quot;); skipListMap.put(21,&quot;21&quot;); skipListMap.put(25,&quot;25&quot;); skipListMap.put(26,&quot;26&quot;); System.out.println(&quot;skipListMap = &quot; + skipListMap); &#125;&#125; 输出结果是这样的，确实是有序的： 稍微的剖析一下。首先看看它的三个关键结构。 第一个是 index： index 里面包含了一个节点 node、一个右指针（right）、一个下指针（down）。 第二个是 HeadIndex: 它是继承自 index 的，只是多了一个 level 属性，记录是位于第几层的索引。 第三个是 node： 这个 node 没啥说的，一看就是个链表。 这三者之间的关系就是示意图这样的： 我们就用前面的示例代码，先 debug 一下，把上面的示意图，用真实的值填充上。 debug 跑起来之后，可以看到当前是有两层索引的，需要注意的是这里的两层是不包含最底层的基础的有序链表的： 我们先看看第二层的链表是怎样的，也就是看第二层头节点的 right 属性： 所以第二层的链表是这样的： 第二层的 HeadIndex 节点除了我们刚刚分析的 right 属性外，还有一个 down，指向的是下一层，也就是第一层的 HeadIndex： 可以看到第一层的 HeadIndex 的 down 属性是 null。但是它的 right 属性是有值的，但 right 属性里面的 down 属性也是 null： 可以画出第一层的链表结构是这样的： 同时我们可以看到其 node 属性里面其实是整个有序链表（其实每一层的 HeadIndex 里面都有，right 节点里面也有）： 所以，整个跳表结构是这样的，需要注意的是最底层的有序链表和第一层之间是虚线连接的，它们之间是不存在 down 属性的： 但是当你拿着同样的程序，自己去调试的时候，你会发现，你的跳表不长这样啊？ 当然不一样了，一样了才是撞了鬼了。 别忘了，索引的层级是随机产生的。 ConcurrentSkipListMap 是怎样随机的呢？ 带大家看看 put 部分的源码。 标号为 ① 的地方代码很多，但是核心思想是把指定元素维护进最底层的有序链表中。就不进行解读了，所以我把这块代码折叠起来了。 标号为 ② 的地方是 (rnd &amp; 0x80000001) == 0。 这个 rnd 是上一行代码随机出来的值。 而 0x80000001 对应的二进制是这样的： 一头一尾都是1，其他位都是 0。 那么只有 rnd 的一头一尾都是 0 的时候，才会满足 if 条件，(rnd &amp; 0x80000001) == 0。 二进制的一头一尾都是 0，说明是一个正偶数。 随机出来一个正偶数的时候，表明需要对其进行索引的维护。 负偶数，负奇数，正偶数，正奇数。而这里只要正偶数，说明这里的概率其实是 1/4。 标号为 ③ 的地方是判断当前元素要维护到第几层索引中。默认是第 1 层。 ((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0 ，已知 rnd 是一个正偶数，那么从其二进制的低位的第二位（第一位肯定是0嘛）开始，有几个连续的 1，就维护到第几层。 不明白？没关系，我举个例子。 假设随机出来的正偶数是 110，其二进制是 01101110。因为有 3 个连续的 1，那么 level 就是从 1 连续自增 3 次，最终的 level 就是 4。 那么问题就来了，如果我们当前最多只有 2 层索引呢？直接就把索引干到第 4 层吗？ 这个时候标号为 ④ 的代码的作用就出来了。 如果新增的层数大于现有的层数，那么只是在现有的层数上进行加一。 这个时候我们再回过头去看看火男论文里面的随机算法： 意思是一个意思，但是实现起来其实是两个不同的方案。但是核心实现都是随机。 所以，你现在知道了，由于有随机数的出现，所以即使是相同的参数，每次都可以构建出不一样的跳表结构。 比如还是前面演示的代码，我 debug 截图的时候有两层索引。 但是，其实有的时候我也会碰到 3 层索引的情况。 别问为什么，用心去感受，你心里应该有数。 另外，开篇用 redis 作为了切入点，其实 redis 的跳表整体思想是大同的，但是也是有小异的。 比如 Redis 在 skiplist 的 forward 指针（相当于 index）上，每个 forward 指针都增加了 span 属性。 在《Redis深度历险》一书里面对该属性进行了描述： 好了，那么这次的文章就到这里啦。","categories":[],"tags":[]},{"title":"","slug":"数据库/Redis/Redis应用-位图","date":"2021-07-20T05:09:35.031Z","updated":"2020-07-09T09:41:08.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis应用-位图/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8-%E4%BD%8D%E5%9B%BE/","excerpt":"","text":"Redis应用-位图我们都知道8bit = 1b = 2^-10kb， bitmap就是通过最小的单位 bit来进行0或者1的设置，表示某个元素对应的值或者状态。 一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。 位图并不是一种特殊的数据结构，其实本质上是二进制字符串，也可以看做是 byte 数组。可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。 位图的优势: 基于最小的单位bit进行存储，所以非常省空间。 设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的 二进制数据的存储，进行相关计算的时候非常快 方便扩容 一般可以在如下场景使用： 用户签到 用户在线状态 统计活跃用户 各种状态值 常用命令SETBIT对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。SETBIT key offset valueoffset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。 GETBIT对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 1GETBIT key offset BITCOUNT计算给定字符串中，被设置为 1 的比特位的数量。 1BITCOUNT key BITPOS返回位图中第一个值为 bit 的二进制位的位置。 1BITPOS key bit[start][end] BITOP对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITOP operation destkey key[key…]operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种 BITOP AND destkey key[key...]，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITFIELDbitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。 适用于各类统计应用记录用户的签到，每日在线情况等，可以将当天或者当天的偏移量对应的bit位设置为1即可，使用 BITCOUNT可以轻松统计签到次数。 还有一种使用比较多的情况，就是设置各类状态值，例如商城的设置：是否可以评价订单，是否展示售罄商品，是否正常营业等状态值可以使用bitmap来存储 在性能方面，如前面提到的签到，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT key [start] [end] 的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。 当然如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法： 将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。 使用 BITCOUNT key [start] [end] 的 start 和 end 参数，每次只对所需的部分位进行计算，然后在进行累加。","categories":[],"tags":[]},{"title":"Redis常见问题","slug":"数据库/Redis/Redis常见问题","date":"2021-07-20T05:09:35.030Z","updated":"2021-07-27T08:38:12.716Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis常见问题/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、Redis雪崩、穿透、并发等5大难题解决方案缓存雪崩数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。 雪崩的简单过程： redis集群大面积故障 缓存失效，但依然大量请求访问缓存服务redis redis大量失效后，大量请求转向到mysql数据库 mysql的调用量暴增，很快就扛不住了，甚至直接宕机 由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。 如何预防缓存雪崩： 缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.缓存降级 可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。 当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。 降级的最终目的是保证核心服务可用，即使是有损的。 比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。 在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 3.Redis备份和快速预热 (1)Redis数据备份和恢复 (2)快速缓存预热 4.提前演练 最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。 缓存穿透缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决思路： 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。 可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。 缓存并发这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。 缓存预热缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路： 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 目的就是在系统上线前，将数据加载到缓存中。 二、Redis为什么是单线程，高并发快的3大原因详解Redis的高并发和快速原因 redis是基于内存的，内存的读写速度非常快； redis是单线程的，省去了很多上下文切换线程的时间； redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。 下面重点介绍单线程设计和IO多路复用核心设计快的原因。 为什么Redis是单线程的？1.官方答案 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。 2.性能指标 关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 3.详细原因 1.不需要各种锁的性能消耗 Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 2.单线程多进程集群方案 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。 所以单线程、多进程的集群不失为一个时髦的解决方案。 3.CPU消耗 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？ 可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。 Redis单线程的优劣势单进程单线程优势 代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善； IO多路复用技术 redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。 多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。 Redis高并发快总结 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。 三、Redis缓存和MySQL数据一致性方案详解 需求起因 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。 这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。 读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子： 如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。 如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。 缓存和数据库一致性解决方案1.第一种方案：采用延时双删策略 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。 伪代码如下： 123456public void write(String key,Object data)&#123; redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key);&#125; 具体的步骤就是： 先删除缓存；再写数据库；休眠500毫秒；再次删除缓存。 那么，这个500毫秒怎么确定的，具体该休眠多久呢？ 需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。 设置缓存过期时间 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 该方案的弊端 结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。 2、第二种方案：异步更新缓存(基于订阅binlog的同步机制) 技术整体思路： MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 读Redis：热数据基本都在Redis 写MySQL:增删改都是操作MySQL 更新Redis数据：MySQL的数据操作binlog，来更新到Redis Redis更新 1）数据操作主要分为两大块： 一个是全量(将全部数据一次写入到redis)一个是增量（实时更新） 这里说的是增量,指的是mysql的update、insert、delate变更数据。 2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。 当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"","slug":"数据库/Redis/Redis","date":"2021-07-20T05:09:35.027Z","updated":"2020-05-11T07:01:38.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis/","excerpt":"","text":"Redis面试题大全含答案 1.什么是Redis？答：Remote Dictionary Server(Redis)是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 2.Redis的特点什么是？\\1. 支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash表)、set(集合)、zset(排序set)、hyperloglog(基数估算)\\2. 支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。\\3. 支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。 3.Redis数据类型有哪些？答：String(字符串)Hash(hash表)List(链表)Set(集合)SortedSet(有序集合zset) 4.Redis中的常用命令哪些？incr 让当前键值以1的数量递增，并返回递增后的值incrby 可以指定参数一次增加的数值，并返回递增后的值incrby 可以指定参数一次增加的数值，并返回递增后的值decrby 可以指定参数一次递减的数值，并返回递减后的值incrbyfloat 可以递增一个双精度浮点数append 作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value。返回值是追加后字符串的总长度。mget/mset 作用与get/set相似，不过mget/mset可以同时获得/设置多个键的键值del 根据key来删除valueflushdb 清除当前库的所有数据hset 存储一个哈希键值对的集合hget获取一个哈希键的值hmset 存储一个或多个哈希是键值对的集合hmget 获取多个指定的键的值hexists 判断哈希表中的字段名是否存在 如果存在返回1 否则返回0hdel 删除一个或多个字段hgetall 获取一个哈希是键值对的集合hvals 只返回字段值hkeys 只返回字段名hlen 返回key的hash的元素个数lpush key value向链表左侧添加rpush key value向链表右侧添加lpop key 从左边移出一个元素rpop key 从右边移出一个元素llen key 返回链表中元素的个数 相当于关系型数据库中 select count()lrange key start end lrange命令将返回索引从start到stop之间的所有元素。Redis的列表起始索引为0。lrange也支持负索引 lrange nn -2 -1 如 -1表示最右边第一个元素 -2表示最右边第二个元素，依次类推。lindex key indexnumber 如果要将列表类型当做数组来用，lindex命令是必不可少的。lindex命令用来返回指定索引的元素，索引从0开始如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。Lset key indexnumber value 是另一个通过索引操作列表的命令，它会将索引为index的元素赋值为value。sadd key value 添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0scard key 返回set的元素个数，如果set是空或者key不存在返回0smembers key 返回key对应set的所有元素，结果是无序的sismember key value 判断value 是否在set中，存在返回1，0表示不存在或者key不存在srem key value 从key对应set中移除给定元素，成功返回1，如果value 在集合中不存在或者key不存在返回0zadd key score value 将一个或多个value及其socre加入到set中zrange key start end 0和-1表示从索引为0的元素到最后一个元素（同LRANGE命令相似）zrange key 0 -1 withscores 也可以连同score一块输出，使用WITHSCORES参数zremrangebyscore key start end 可用于范围删除操作ping 测试redis是否链接 如果已链接返回 PONGecho value测试redis是否链接 如果已链接返回 echo命令后给定的值keys * 返回所有的key 可以加通配exists key判断string类型一个key是否存在 如果存在返回1 否则返回0expire key time(s) 设置一个key的过期时间 单位秒。时间到达后会删除key及valuettl key 查询已设置过期时间的key的剩余时间 如果返回-2表示该键值对已经被删除persist 移除给定key的过期时间select dbindex 选择数据库(0-15)move key dbIndex 将当前数据库中的key转移到其他数据库中dbsize 返回当前数据库中的key的数目info 获取服务器的信息和统计flushdb 删除当前选择的数据库中的keyflushall 删除所有数据库中的所有keyquit 退出连接 5.Redis的配置以及持久化方案有几种？以下两种RDB方式AOF方式 什么是RDB方式？是RDB是对内存中数据库状态进行快照RDB方式：将Redis在内存中的数据库状态保存到磁盘里面，RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态（默认下，持久化到dump.rdb文件，并且在redis重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB的快照文件，同步到内存中的 时间是20-30秒）RDB的生成方式：1、执行命令手动生成有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求，创建RDB文件结束之前，客户端发送的BGSAVE和SAVE命令会被服务器拒绝 2、通过配置自动生成可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令例如：save 900 1save 300 10save 60 10000那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行服务器在900秒之内，对数据库进行了至少1次修改服务器在300秒之内，对数据库进行了至少10次修改服务器在60秒之内，对数据库进行了至少10000次修改 什么是AOF方式？AOF持久化方式在redis中默认是关闭的，需要修改配置文件开启该方式。AOF：把每条命令都写入文件，类似mysql的binlog日志AOF方式：是通过保存Redis服务器所执行的写命令来记录数据库状态的文件。AOF文件刷新的方式，有三种：appendfsync always - 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全appendfsync everysec - 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据appendfsync no - 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾AOF数据恢复方式服务器在启动时，通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程：载入AOF文件创建模拟客户端从AOF文件中读取一条命令使用模拟客户端执行命令循环读取并执行命令，直到全部完成如果同时启用了RDB和AOF方式，AOF优先，启动时只加载AOF文件恢复数据","categories":[],"tags":[]},{"title":"","slug":"数据库/Redis/Redis-面试题","date":"2021-07-20T05:09:35.026Z","updated":"2020-08-06T03:10:42.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis-面试题/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.Redis是什么Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用做数据库、缓存、消息中间件等 它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。 Redis作为一个内存数据库： 性能优秀，数据在内存中，读写速度非常快，支持并发10w QPS 单进程单线程，是线程安全的，采用IO多路复合机制 丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等 支持数据持久化，可以将内存中数据保存在磁盘中，重启时加载 主从复制，哨兵，高可用 可以用作分布式锁 可以作为消息中间件使用，支持发布订阅 Redis为何这么快，还是单线程Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。 既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。 为什么单线程这么快： Redis是完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O（1）。 数据结构简单，对数据操作也简单 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。 使用多路复用IO模型，非阻塞IO Redis和Memcached的区别 存储方式上：Memcached会把数据全部存储在内存之中，断电之后会挂掉，数据不能超过内存大小。Redis有部分数据存在硬盘上，这样能保证数据的持久性。 数据支持类型上：Memcached对数据类型的支持简单，只支持简单的key-value，而Redis支持五种数据类型。 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 Value的大小：Redis可以达到1GB，而Memached只有1MB。 淘汰策略Redis有六种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的KV集合中有限对最近最好使用（less recently used）的数据淘汰 volatile-ttl 从已设置过期时间的KV集合中优先对剩余时间短（time to live）的数据淘汰 volatile-random 从已设置过期时间的KV集合中随机选择数据淘汰 allkeys-lru 从所有KV集合中优先对最近最少使用（less recently used）的数据淘汰 allkeys-random 从所有KV集合中随机选择数据淘汰 noeviction 不淘汰策略，若超过最大内存，返回错误信息 Redis 4.0加入了LFU（least frequently use）淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰 持久化机制Redis为了保证效率，数据缓存在内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。 Redis的持久化策略有两种： RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存策略 AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令集合。 Redis默认是快照RDB的持久化方式。 当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整，你甚至可以关闭持久化功能，让数据只在服务器运行时存。 主从复制","categories":[],"tags":[]},{"title":"","slug":"数据库/Redis/Redis-集群的原理与搭建","date":"2021-07-20T05:09:35.022Z","updated":"2020-07-15T03:05:34.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis-集群的原理与搭建/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%90%AD%E5%BB%BA/","excerpt":"","text":"前言 Redis 是我们目前大规模使用的缓存中间件，由于它强大高效而又便捷的功能，得到了广泛的使用。单节点的Redis已经就达到了很高的性能，为了提高可用性我们可以使用Redis集群。本文参考了Rdis的官方文档和使用Redis官方提供的Redis Cluster工具搭建Rdis集群。 注意 ：Redis的版本要在3.0以上,截止今天，Redis的版本是3.2.9，本教程也使用3.2.9作为教程 Redis集群的概念 介绍 Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的错误。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 Redis 集群提供了以下两个好处： 将数据自动切分（split）到多个节点的能力。 当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。 数据分片 Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中： 节点 A 负责处理 0 号至 5500 号哈希槽。 节点 B 负责处理 5501 号至 11000 号哈希槽。 节点 C 负责处理 11001 号至 16384 号哈希槽。 这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说： 我现在想设置一个key，叫my_name: 1set my_name zhangguoji 按照Redis Cluster的哈希槽算法，CRC16(‘my_name’)%16384 = 2412 那么这个key就被分配到了节点A上 。 同样的，当我连接(A,B,C)的任意一个节点想获取my_name这个key,都会转到节点A上 ，再比如 ，如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。 增加一个D节点的结果可能如下： 节点A覆盖1365-5460 节点B覆盖6827-10922 节点C覆盖12288-16383 节点D覆盖0-1364,5461-6826,10923-1228 与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。 因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。 所以,Redis Cluster的模型大概是这样的形状 主从复制模型 为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。 在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。 另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。 不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。 Redis一致性保证 Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作： 第一个原因是因为集群是用了异步复制. 写操作过程: 客户端向主节点B写入一条命令. 主节点B向客户端回复命令状态. 主节点将写操作复制给他得从节点 B1, B2 和 B3 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 ** 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。 举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 . Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了. 注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项 搭建Redis集群 要让集群正常工作至少需要3个主节点，在这里我们要创建6个redis节点，其中三个为主节点，三个为从节点，对应的redis节点的ip和端口对应关系如下（为了简单演示都在同一台机器上面） 123456127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002127.0.0.1:7003127.0.0.1:7004127.0.0.1:7005 安装和启动Redis 下载安装包 1wget http://download.redis.io/releases/redis-3.2.9.tar.gz 解压安装 123tar zxvf redis-3.2.9.tar.gzcd redis-3.2.9make &amp;&amp; make PREFIX=/usr/local/redis install 这里如果失败的自行yum安装gcc和tcl 12yum install gcc yum install tcl 创建目录 1234cd /usr/local/redismkdir clustercd clustermkdir 7000 7001 7002 7003 7004 7005 复制和修改配置文件 将redis目录下的配置文件复制到对应端口文件夹下,6个文件夹都要复制一份 1cp redis-3.2.9/redis.conf /usr/local/redis/cluster/7000 修改配置文件redis.conf，将下面的选项修改 123456789101112131415161718# 端口号port 7000# 后台启动daemonize yes# 开启集群cluster-enabled yes#集群节点配置文件cluster-config-file nodes-7000.conf# 集群连接超时时间cluster-node-timeout 5000# 进程pid的文件位置pidfile /var/run/redis-7000.pid# 开启aofappendonly yes# aof文件路径appendfilename &quot;appendonly-7005.aof&quot;# rdb文件路径dbfilename dump-7000.rdb 6个配置文件安装对应的端口分别修改配置文件 创建启动脚本 在/usr/local/redis目录下创建一个start.sh 1234567#!/bin/bashbin/redis-server cluster/7000/redis.confbin/redis-server cluster/7001/redis.confbin/redis-server cluster/7002/redis.confbin/redis-server cluster/7003/redis.confbin/redis-server cluster/7004/redis.confbin/redis-server cluster/7005/redis.conf 这个时候我们查看一下进程看启动情况 1ps -ef | grep redis 进程状态如下： 123456root 1731 1 1 18:21 ? 00:00:49 bin/redis-server *:7000 [cluster] root 1733 1 0 18:21 ? 00:00:29 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:08 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:26 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:13 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:08 bin/redis-server *:7005 [cluster] 有6个redis进程在开启，说明我们的redis就启动成功了 开启集群 这里我们只是开启了6个redis进程而已，它们都还只是独立的状态，还么有组成集群 这里我们使用官方提供的工具redis-trib，不过这个工具是用ruby写的，要先安装ruby的环境 1yum install ruby rubygems -y 执行，报错 12345[root@centos]# redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005/usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require&#x27;: no such file to load -- redis (LoadError) from /usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require&#x27; from /usr/local/bin/redis-trib.rb:25[root@centos]# 原来是ruby和redis的连接没安装好 安装gem-redis 1gem install redis 安装到这里的时候突然卡住很久不动，网上搜了下，这里需要翻墙或者换镜像 1gem source -a https://gems.ruby-china.org 这里可以将镜像换成ruby-china的镜像，不过我好像更换失败，最终还是翻墙下载了 12345[root@centos]# gem install redisSuccessfully installed redis-3.2.11 gem installedInstalling ri documentation for redis-3.2.1...Installing RDoc documentation for redis-3.2.1... 等下载好后我们就可以使用了 12345[root@centos]# gem install redisSuccessfully installed redis-3.2.11 gem installedInstalling ri documentation for redis-3.2.1...Installing RDoc documentation for redis-3.2.1... 将redis-3.2.9的src目录下的trib复制到相应文件夹 1cp redis-3.2.9/src/redis-trib.rb /usr/local/redis/bin/redis-trib 创建集群： 1redis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 命令的意义如下： 给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。 选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。 简单来说，以上的命令的意思就是让redis-trib程序帮我们创建三个主节点和三个从节点的集群， 接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中： 12345678910111213141516171819202122&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002Adding replica 127.0.0.1:7003 to 127.0.0.1:7000Adding replica 127.0.0.1:7004 to 127.0.0.1:7001Adding replica 127.0.0.1:7005 to 127.0.0.1:7002M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) masterM: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) masterM: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) masterS: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6Can I set the above configuration? (type &#x27;yes&#x27; to accept): 按下yes，集群就会将配置应用到各个节点，并连接起（join)各个节点，也即是，让各个节点开始通讯 123456789101112131415161718192021222324252627&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. Redis集群的使用 连接集群 这里我们使用reids-cli连接集群，使用时加上-c参数，就可以连接到集群 连接7000端口的节点 123456[root@centos1 redis]# ./redis-cli -c -p 7000127.0.0.1:7000&gt; set name zgj-&gt; Redirected to slot [5798] located at 127.0.0.1:7001OK127.0.0.1:7001&gt; get name&quot;zgj&quot; 前面的理论知识我们知道了，分配key的时候，它会使用CRC16算法，这里将keyname分配到了7001节点上 1Redirected to slot [5798] located at 127.0.0.1:7001 redis cluster 采用的方式很直接，它直接跳转到7001 节点了，而不是还在自身的7000节点。 好，现在我们连接7003这个从节点进入 1234[root@centos1 redis]# ./redis-cli -c -p 7003127.0.0.1:7003&gt; get name-&gt; Redirected to slot [5798] located at 127.0.0.1:7001&quot;zgj&quot; 这里获取name的值，也同样跳转到了7001上 我们再测试一下其他数据 123456789127.0.0.1:7001&gt; set age 20-&gt; Redirected to slot [741] located at 127.0.0.1:7000OK127.0.0.1:7000&gt; set message helloworld-&gt; Redirected to slot [11537] located at 127.0.0.1:7002OK127.0.0.1:7002&gt; set height 175-&gt; Redirected to slot [8223] located at 127.0.0.1:7001OK 我们发现数据会在7000-7002这3个节点之间来回跳转 测试集群中的节点挂掉 上面我们建立了一个集群，3个主节点和3个从节点，7000-7002负责存取数据，7003-7005负责把7000-7005的数据同步到自己的节点上来。 我们现在来模拟一下一台matser服务器宕机的情况 12345678910111213141516171819202122232425262728293031[root@centos1 redis]# ps -ef | grep redisroot 1731 1 0 18:21 ? 00:01:02 bin/redis-server *:7000 [cluster] root 1733 1 0 18:21 ? 00:00:43 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:22 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:40 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:27 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:22 bin/redis-server *:7005 [cluster] root 23988 1 0 18:30 ? 00:00:42 ./redis-server *:6379 root 24491 1635 0 21:55 pts/1 00:00:00 grep redis[root@centos1 redis]# kill 1731[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots:0-5460 (5461 slots) master 0 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里看得出来，现在已经有了3个节点了，7003被选取成了替代7000成为主节点了。 我们再来模拟 7000节点重新启动了的情况，那么它还会自动加入到集群中吗？那么，7000这个节点上充当什么角色呢？ 我们试一下： 12345678910111213141516171819202122232425[root@centos1 redis]# bin/redis-server cluster/7000/redis.conf[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7000&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)S: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots: (0 slots) slave replicates d403713ab9db48aeac5b5393b69e1201026ef479S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots:0-5460 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里我们可以看到7000节点变成了7003节点的从节点 我们试着将7000和7003两个节点都关掉 123456789101112131415161718192021222324252627282930[root@centos1 redis]# ps -ef | grep redisroot 1733 1 0 18:21 ? 00:00:45 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:24 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:42 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:29 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:24 bin/redis-server *:7005 [cluster] root 23988 1 0 18:30 ? 00:00:43 ./redis-server *:6379 root 24527 1 0 22:04 ? 00:00:00 bin/redis-server *:7000 [cluster] root 24541 1635 0 22:07 pts/1 00:00:00 grep redis[root@centos1 redis] kill 1743[root@centos1 redis] kill 24527[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[ERR] Not all 16384 slots are covered by nodes. 这里我们的集群就不能工作了，因为两个节点主节点和从节点都挂掉了，原来7001分配的slot现在无节点接管，需要人工介入重新分配slots。 集群中加入新的主节点 这里在cluster目录下再新建一个7006并修改对应的配置文件，然后启动这个这个redis进程 然后再使用redis-trib的add node指令加入节点 1bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000 这里前面的节点表示要加入的节点，第二个节点表示要加入的集群中的任意一个节点，用来标识这个集群 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@centos1 redis]# bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000&gt;&gt;&gt; Adding node 127.0.0.1:7006 to cluster 127.0.0.1:7000&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7006 to make it join the cluster.[OK] New node added correctly.[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7006&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots: (0 slots) master 0 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里我们可以看到7006节点已经变成了一个主节点，然鹅，等等，好像发现了有什么地方不对 12M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots: (0 slots) master 里面0 slots,也就是说节点6没有分配哈希槽，即不能进行数据的存取，拿我加上去干嘛。 原来redis cluster 不是在新加节点的时候帮我们做好了迁移工作，需要我们手动对集群进行重新分片迁移，也是这个命令： 1/bin/redis-trib reshard 127.0.0.1:7000 这个命令是用来迁移slot节点的，后面的127.0.0.1:7000是表示哪个集群的，7000-7006都是可以的 1234567891011121314151617181920212223242526272829303132333435[root@centos1]# redis-trib.rb reshard 127.0.0.1:7000Connecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7002: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7003: OK&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7006)M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 slots: (0 slots) master 0 additional replica(s)M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slots: (0 slots) slave replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6cS: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slots: (0 slots) slave replicates d2237fdcfbba672de766b913d1186cebcb6e1761M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slots: (0 slots) slave replicates dfa0754c7854a874a6ebd2613b86140ad97701fcM: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 slots:0-5460 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.How many slots do you want to move (from 1 to 16384)? 它提示我们需要迁移多少slot到7006上，我们可以算一下：16384/4 = 4096，也就是说，为了平衡分配起见，我们需要移动4096个槽点到7006上。 好，那输入4096: 它又提示我们，接受的node ID是多少，7006的id 我们通过上面就可以看到是efc3131fbdc6cf929720e0e0f7136cae85657481: 12345What is the receiving node ID? efc3131fbdc6cf929720e0e0f7136cae85657481Please enter all the source node IDs. Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots. Type &#x27;done&#x27; once you entered all the source nodes IDs.Source node #1: 接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 4096 个哈希槽， 并将这些槽移动到7006节点上面。 如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 4096 个， 然后移动到7006节点上： 1Source node #1:all 接下来就开始迁移了，并且会询问你是否确认： 1234567Moving slot 1359 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1360 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1361 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1362 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1363 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1364 from d2237fdcfbba672de766b913d1186cebcb6e1761Do you want to proceed with the proposed reshard plan (yes/no)? 输入yes并回车后，redis-trib就会正式执行重新分片操作，将制定的哈希槽从源节点一个个移动到7006节点上 。 迁移结束之后，我们来检查一下 12345678910111213141516171819202122232425M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:1365-5460 (4096 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots:0-1364,5461-6826,10923-12287 (4096 slots) master 0 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:6827-10922 (4096 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:12288-16383 (4096 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 我们可以看到 slots:0-1364,5461-6826,10923-12287 (4096 slots) 这些原来在其他节点上的哈希槽都迁移到了7006上 增加一个从节点 新建一个 7007从节点，作为7006的从节点 我们再新建一个节点7007，步骤类似，就先省略了。建好后，启动起来，我们看如何把它加入到集群中的从节点中： 1[root@centos1]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000 add-node的时候加上–slave表示是加入到从节点中，但是这样加，是随机的。这里的命令行完全像我们在添加一个新主服务器时使用的一样，所以我们没有指定要给哪个主服 务器添加副本。这种情况下，redis-trib会将7007作为一个具有较少副本的随机的主服务器的副本。 那么，你猜，它会作为谁的从节点，应该是7006，因为7006还没有从节点。我们运行下。 12345678910[root@web3 7007]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000......[OK] All 16384 slots covered.Automatically selected master 127.0.0.1:7006Connecting to node 127.0.0.1:7007: OK&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7007 to make it join the cluster.Waiting for the cluster to join.&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.[OK] New node added correctly. 上面提示说，自动选择了7006作为master节点。并且成功了。我们检查下： 1234567891011121314151617181920212223242526272829303132333435363738[root@centos1]# redis-trib.rb check 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7002: OK&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)S: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slots: (0 slots) slave replicates d2237fdcfbba672de766b913d1186cebcb6e1761M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 slots:0-1364,5461-6826,10923-12287 (4096 slots) master 1 additional replica(s)S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slots: (0 slots) slave replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6cS: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slots: (0 slots) slave replicates dfa0754c7854a874a6ebd2613b86140ad97701fcM: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 slots:1365-5460 (4096 slots) master 1 additional replica(s)M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 slots:6827-10922 (4096 slots) master 1 additional replica(s)S: 86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 slots: (0 slots) slave replicates efc3131fbdc6cf929720e0e0f7136cae85657481M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 slots:12288-16383 (4096 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 果然，7007加入到了7006的从节点当中。 你说，我如果想指定一个主节点行不行？当然可以。我们再建一个7008节点。 1bin/redis-trib.rb add-node --slave --master-id efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7008 127.0.0.1:7000 –master-id 表示指定的主节点node id。这里指定的是 7006 这个主节点。 123Waiting for the cluster to join.&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.[OK] New node added correctly. 提示我们已经作为7006的从节点了，也就是加入到7006的从节点来了，照这么说，7006就有2个从节点了，我们看一下： 1234bin/redis-cli -c -p 7008 cluster nodes |grep efc3131fbdc6cf929720e0e0f7136cae8565748186d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 1445089507786 8 connectedefc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master - 0 1445089508289 8 connected 0-1364 5461-6826 10923-1228744321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 myself,slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 0 0 connected 我们过滤了下看结果，果真，7007和7008是7006的从节点了。 刚好，我们再做一个实验，我把7006的进程杀掉，看7007和7008谁会变成主节点： 123456789101112131415161718192021222324252627[root@centos1]# ps -ef|grep redisroot 11384 1 0 09:56 ? 00:00:16 redis-server *:7001 [cluster]root 11388 1 0 09:56 ? 00:00:16 redis-server *:7002 [cluster]root 11392 1 0 09:56 ? 00:00:16 redis-server *:7003 [cluster]root 11396 1 0 09:56 ? 00:00:15 redis-server *:7004 [cluster]root 11400 1 0 09:56 ? 00:00:15 redis-server *:7005 [cluster]root 12100 1 0 11:01 ? 00:00:11 redis-server *:7000 [cluster]root 12132 1 0 11:28 ? 00:00:11 redis-server *:7006 [cluster]root 12202 1 0 13:14 ? 00:00:02 redis-server *:7007 [cluster]root 12219 1 0 13:39 ? 00:00:00 redis-server *:7008 [cluster]root 12239 8259 0 13:49 pts/0 00:00:00 grep redis[root@centos1]# kill 12132[root@centos1]# redis-cli -c -p 7008127.0.0.1:7008&gt; get ss5rtr-&gt; Redirected to slot [1188] located at 127.0.0.1:7007&quot;66&quot;127.0.0.1:7007&gt; cluster nodesefc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master,fail - 1445089780668 1445089779963 8 disconnectedd2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 master - 0 1445089812195 7 connected 1365-546030858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slave dfa0754c7854a874a6ebd2613b86140ad97701fc 0 1445089813710 3 connected86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 myself,master - 0 0 10 connected 0-1364 5461-6826 10923-12287cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 master - 0 1445089814214 2 connected 6827-109224b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slave cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 0 1445089812701 2 connected44321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 slave 86d05e7c2b197dc182b5e71069e791d033cf899e 0 1445089814214 10 connected3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slave d2237fdcfbba672de766b913d1186cebcb6e1761 0 1445089813204 7 connecteddfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 master - 0 1445089813204 3 connected 12288-16383127.0.0.1:7007&gt; 这里7007获得了成为主节点的机会，7008就变成了7007的从节点。 那么这个时候，重启7006节点，那么他就会变成了一个7007的从节点了。 移除一个节点 上面是增加一个节点，接下来就是移除一个节点了，移除节点的命令是 1bin/redis-trib del-node 127.0.0.1:7000 `&lt;node-id&gt;` 没我们尝试下输入以下命令 123456789101112[root@centos]# bin/redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7002: OK[ERR] Node 127.0.0.1:7007 is not empty! Reshard data away and try again. 这里报错了，提示我们7007节点里面有数据，让我们把7007节点里的数据移除出去，也就是说需要重新分片，这个和上面增加节点的方式一样，我们再来一遍 1bin/redis-trib.rb reshard 127.0.0.1:7000 省去中间内容，原来7007节点上已经有了4096个哈希槽，这里我们也移动4096个哈希槽 然后将这些哈希槽移动到7001节点上 123Source node #1:86d05e7c2b197dc182b5e71069e791d033cf899eSource node #2:doneDo you want to proceed with the proposed reshard plan (yes/no)? yes 然后我们再继续执行移除命令，结果如下 123456789101112131415[root@centos1]# redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7002: OK&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; 127.0.0.1:7006 as replica of 127.0.0.1:7001&gt;&gt;&gt; 127.0.0.1:7008 as replica of 127.0.0.1:7001&gt;&gt;&gt; SHUTDOWN the node. 删除成功，而且还很人性化的将7006和7008这2个原来7007的附属节点送给了7001。考虑的真周到~ 移除一个从节点 移除一个从节点就比较简单了，因为从节点没有哈希槽，也不需要考虑数据迁移，直接移除就行 1234567891011121314[root@centos1]# redis-trib.rb del-node 127.0.0.1:7005 44321e7d619410dc4e0a8745366610a0d06d2395&gt;&gt;&gt; Removing node 44321e7d619410dc4e0a8745366610a0d06d2395 from cluster 127.0.0.1:7005Connecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7002: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7003: OK&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node.[root@centos1]# redis-trib.rb check 127.0.0.1:7008Connecting to node 127.0.0.1:7008: [ERR] Sorry, can&#x27;t connect to node 127.0.0.1:7008 表示移除成功 Redis性能测试 Redis自带了性能测试工具redis-benchmark 使用说明如下： 1234567891011121314151617181920212223Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;]-h &lt;hostname&gt; Server hostname (default 127.0.0.1)-p &lt;port&gt; Server port (default 6379)-s &lt;socket&gt; Server socket (overrides host and port)-c &lt;clients&gt; Number of parallel connections (default 50)-n &lt;requests&gt; Total number of requests (default 10000)-d &lt;size&gt; Data size of SET/GET value in bytes (default 2)-k &lt;boolean&gt; 1=keep alive 0=reconnect (default 1)-r &lt;keyspacelen&gt; Use random keys for SET/GET/INCR, random values for SADD Using this option the benchmark will get/set keys in the form mykey_rand:000000012456 instead of constant keys, the &lt;keyspacelen&gt; argument determines the max number of values for the random number. For instance if set to 10 only rand:000000000000 - rand:000000000009 range will be allowed.-P &lt;numreq&gt; Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).-q Quiet. Just show query/sec values--csv Output in CSV format-l Loop. Run the tests forever-t &lt;tests&gt; Only run the comma-separated list of tests. The test names are the same as the ones produced as output.-I Idle mode. Just open N idle connections and wait. 基准测试 基准的测试命令： redis-benchmark -q -n 100000 结果入下： 1234567891011121314151617181920root@centos1 bin]# redis-benchmark -q -n 100000-bash: redis-benchmark: command not found[root@centos1 bin]# ./redis-benchmark -q -n 100000PING_INLINE: 61576.36 requests per secondPING_BULK: 60277.28 requests per secondSET: 61349.69 requests per secondGET: 60459.49 requests per secondINCR: 58858.15 requests per secondLPUSH: 59066.75 requests per secondRPUSH: 57339.45 requests per secondLPOP: 55586.44 requests per secondRPOP: 56465.27 requests per secondSADD: 57045.07 requests per secondSPOP: 53734.55 requests per secondLPUSH (needed to benchmark LRANGE): 57012.54 requests per secondLRANGE_100 (first 100 elements): 55803.57 requests per secondLRANGE_300 (first 300 elements): 54914.88 requests per secondLRANGE_500 (first 450 elements): 53333.33 requests per secondLRANGE_600 (first 600 elements): 56529.11 requests per secondMSET (10 keys): 59276.82 requests per second 这里可以看出，单机版的redis每秒可以处理6万个请求，这已经是一个非常厉害的数据了，不得不佩服 我们再来看下集群情况下是是什么情况 123456789101112131415161718[root@centos1 bin]# ./redis-benchmark -q -n 100000 -p 7000PING_INLINE: 64599.48 requests per secondPING_BULK: 64184.85 requests per secondSET: 66800.27 requests per secondGET: 65616.80 requests per secondINCR: 66269.05 requests per secondLPUSH: 40273.86 requests per secondRPUSH: 40355.12 requests per secondLPOP: 43421.62 requests per secondRPOP: 45187.53 requests per secondSADD: 62539.09 requests per secondSPOP: 61538.46 requests per secondLPUSH (needed to benchmark LRANGE): 38182.51 requests per secondLRANGE_100 (first 100 elements): 25555.84 requests per secondLRANGE_300 (first 300 elements): 9571.21 requests per secondLRANGE_500 (first 450 elements): 7214.49 requests per secondLRANGE_600 (first 600 elements): 5478.85 requests per secondMSET (10 keys): 41893.59 requests per second 这里看出大部分和单机版的性能查不多，主要是lrange命令的差别是很大的 流水线测试 使用流水线 默认情况下，每个客户端都是在一个请求完成之后才发送下一个请求（基准会模拟50个客户端除非使用-c指定特别的数量），这意味着服务器几乎是按顺序读取每个客户端的命令。RTT也加入了其中。 真实世界会更复杂，Redis支持/topics/pipelining，使得可以一次性执行多条命令成为可能。Redis流水线可以提高服务器的TPS redis-benchmark -n 1000000 -t set,get -P 16 -q 加入-P选项使用管道技术，一次执行多条命令 123./redis-benchmark -n 1000000 -t set,get -P 16 -qSET: 515198.34 requests per secondGET: 613873.56 requests per second 每秒处理get/sret请求达到了60/50W,真的厉害！ 遇到的问题 安装redis集群的时候遇到了挺多问题，踩了很多坑，单单是修改配置文件就出了不少问题，那些配置文件的内容都要一一修改，有些配置不修改就会出现无法创建进程的错误 注意配置集群的时候不要加密码，否则会出现无法连接的情况 gem install的时候需要修改镜像或者翻墙 昨天启动成功，今天启动的时候报错 1[ERR] Node 172.168.63.202:7001 is not empty. Either the nodealready knows other nodes (check with CLUSTER NODES) or contains some key in database 0 解决方法： 将需要新增的节点下aof、rdb等本地备份文件删除； 同时将新Node的集群配置文件删除,即：删除你redis.conf里面cluster-config-file所在的文件； 再次添加新节点如果还是报错，则登录新Node,执行bin/redis-cli–h x –p对数据库进行清除： 1127.0.0.1:7001&gt; flushdb #清空当前数据库 总结 之间对了Redis的了解并不是说非常多，只是简单的会用，因为现在企业里也很多都在用，刚好老大说接下来的项目可能会用到Redis集群，让我先去了解下，所以最近就在回头看，一边看文档，博客，一边实践，踩了很多的坑，出问题的时候的确是让人感到很痛苦很郁闷的，可是当运行成功的那一刻心情却是无比激动和开心的，可能这就是编程的魅力吧。","categories":[],"tags":[]},{"title":"为什么禁止使用外键","slug":"数据库/MySQL/other/为什么禁止使用外键","date":"2021-07-20T05:09:35.017Z","updated":"2021-07-27T01:33:05.354Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/为什么禁止使用外键/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE/","excerpt":"","text":"外键的优点一、数据一致性由数据库自身保证数据一致性、完整性会更可靠，程序很难100％保证数据的一致性、完整性 二、ER图可靠性有主外键的数据库设计可以增加ER图的可读性 外键的缺点一、级联问题阿里巴巴的开发手册中，就曾指出强制要求不允许使用外键，一切外键概念必须在应用层解决。 因为每次级联delete或update的时候，都要级联操作相关的外键表，不论有没有这个必要，由其在高并发的场景下，这会导致性能瓶颈 二、增加数据库压力外键等于把数据的一致性事务实现，全部交给数据库服务器完成，并且有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源 三、死锁问题若是高并发大流量事务场景，使用外键还可能容易造成死锁 四、开发不方便有外键时，无论开发还是维护，需要手工维护数据时，都不太方便，要考虑级联因素 总结一、如是单机且低并发，也不需要性能调优，再或者不能用程序保证数据的一致性，完整性，可以使用外键二、如果为了高并发，分布式，使系统性能更优，以及更好维护，则一定不能使用外键 引言其实这个话题是老生常谈，很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条 **【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 ** 但是呢，询问他们原因，大多是这么回答的 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便。 坦白说，这么说也是对的。但是呢，不够全面，所以开一文来详细说明。 正文首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。比如使用外键，可以 保证数据的完整性和一致性 级联操作方便 将数据完整性判断托付给了数据库完成，减少了程序的代码量 然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下 性能问题假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。 并发问题在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。 扩展性问题这里主要是分为两点 做平台迁移方便，比如你从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。 技术问题使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"外键","slug":"外键","permalink":"http://example.com/tags/%E5%A4%96%E9%94%AE/"}]},{"title":"","slug":"数据库/MySQL/other/mysql count() 函数 字段按条件统计数量并排除某个字段重复值","date":"2021-07-20T05:09:35.015Z","updated":"2021-05-31T09:48:08.904Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/mysql count() 函数 字段按条件统计数量并排除某个字段重复值/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/mysql%20count()%20%E5%87%BD%E6%95%B0%20%E5%AD%97%E6%AE%B5%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%BB%9F%E8%AE%A1%E6%95%B0%E9%87%8F%E5%B9%B6%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%87%8D%E5%A4%8D%E5%80%BC/","excerpt":"","text":"mysql count() 函数 字段按条件统计数量并排除某个字段重复值 12345678910111213141516SELECT *, count(c.recruit_info_id) AS apply_number, count( IF (c.approval_status= 5, 1, NULL) ) AS s_numberFROM `sh_further_position_posting` `a`LEFT JOIN `sh_student_keshi` `b` ON `a`.`student_keshi_id` = `b`.`student_keshi_id`LEFT JOIN `sh_further_recruit_info` `c` ON `c`.`post_id` = `a`.`post_id`WHERE 1 = 1GROUP BY `a`.`post_id`ORDER BY `a`.`create_time` DESCLIMIT 10","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/other/left join、right join和join的区别","date":"2021-07-20T05:09:35.013Z","updated":"2021-03-17T01:24:58.396Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/left join、right join和join的区别/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/left%20join%E3%80%81right%20join%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"真的是一张图道清所有join的区别啊，可惜我还是看不懂，可能人比较懒，然后基本一个left join给我就是够用的了，所以就没怎么去仔细研究了，但是现实还是逼我去搞清楚，索性自己动手，总算理解图中的含义了，下面就听我一一道来。 首先，我们先来建两张表，第一张表命名为kemu，第二张表命名为score： 一、left join顾名思义，就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。如下： 12345select *from kemuleft join score on kemu.id = score.id 结果集： 二、right join “右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据，如下： 12345select *from kemuright join score on kemu.id = score.id 结果集： 三、joinjoin，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的，如下 12345select *from kemujoin score on kemu.id = score.id 结果集：","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/other/Find_in_set","date":"2021-07-20T05:09:35.011Z","updated":"2021-07-28T03:49:38.885Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/Find_in_set/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/Find_in_set/","excerpt":"","text":"Returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings. A string list is a string composed of substrings separated by , characters. If the first argument is a constant string and the second is a column of type SET, the FIND_IN_SET() function is optimized to use bit arithmetic. Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL. This function does not work properly if the first argument contains a comma (,) character. 12mysql&gt; SELECT FIND_IN_SET(&#x27;b&#x27;,&#x27;a,b,c,d&#x27;); -&gt; 2 mysql中FIND_IN_SET函数用来比较是不是包含，不管‘list’字段是变量或给定的字符串常量都能很好的工作。MySQL中原型为：FIND_IN_SET(str,strlist)。 假如字符串str 在由N 子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被‘,’符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则 FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。 str也可以是变量，比如表中的一个字段。 虽然这样很好用，但问题是如果数据量大的情况下怎么办，性能会是问题么，手册上有说对find_in_set 做的优化，但在没有索引的情况下他的性能应该是个问题。","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/面试","date":"2021-07-20T05:09:35.002Z","updated":"2021-07-19T02:37:46.649Z","comments":true,"path":"2021/07/20/数据库/MySQL/面试/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%9D%A2%E8%AF%95/","excerpt":"","text":"为什么在写SQL语句时遵守最左前缀原则才能用到索引？不遵守就用不到索引？其底层工作机制是怎样的？ MySQL中写缓冲区为什么能优化写入的速度？如何做到的？ MySQL在执行一个SQL语句时会经过哪些步骤？这每个步骤可以如何优化？ 写了一个很长的SQL，这个SQL最终的执行顺序是怎样的？如何优化复杂SQL？ 到底多大数据的表才是大表？500万条？2000万条？5000万条？ 如果一个表中数据量很大，这个时候如何建立索引，如何优化索引？ 高并发场景下，使用MySQL事务时应该要注意哪些方面，如何进行优化？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/开篇","date":"2021-07-20T05:09:34.998Z","updated":"2021-01-26T03:57:14.000Z","comments":true,"path":"2021/07/20/数据库/MySQL/开篇/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%BC%80%E7%AF%87/","excerpt":"","text":"基础篇1.基础架构：一条SQL查询语句是如何执行的？ Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数字和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 连接器 连接器负责跟客户端建立链接、获取权限、维持和管理链接。 如果长时间没有动静，连接器默认8小时会自动断开，再次发送请求需要进行重连。 数据库中长连接指的是连接成功后，如果客户端持续有请求，则一直使用同一个连接，短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 全部使用长连接，会非常占用内存，导致内存占用太大，被系统强行杀掉（OOM），导致MySQL异常重启。 解决方案： 1.定期断开连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 2.MySQL5.7及以上版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接回复到刚刚创建完的状态。 查询缓存 不建议使用查询缓存： 因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要对一个表的更新，这个表上所有的查询花奴才能都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低，除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 MySQL8.0已经移除该功能。 分析器 分析器会先做”词法分析”。你输入的是由多个字符喜欢和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 然后是“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的额这个NySQL语句是否满足MySQL语法。 优化器 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 执行器 开始执行的时候，会先判断你对这个表T哟没有执行查询的权限，如果没有，就会返回没有权限的错误（在工程上实现，如果命中查询缓存，就会在查询缓存返回结果的时候，做权限验证，查询也会在优化器之前调用precheck权限验证）。 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 2.日志系统：一条SQL更新语句是如何执行的？MySQL的逻辑架构图和查询一直，执行语句前要先连接数据库，这是连接器的工作。 一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空，这也就是我们一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引，然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块:redo log(重做日志)和bin log(归档日志)。 redo log(重做日志)在MySQL有一个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高，为了解决这个问题，MySQL的设计者采用WAL技术，全称 Write-Ahead Logging。它的关键点就是先写日志，再写磁盘。 具体俩说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 于此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以自己录4GB操作。从头开始写，写到末尾就又回到开头循环写，如图所示。 write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的操作，得停下来先擦掉一些记录，把checkpoint推进一下。 有了redo log，InnoDB就可以保存即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 binlog(归档日志)MySQL整体来看，分为两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块就是引擎层，负责存储相关的具体事宜。redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)。 为什么会有两个日志 因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档，而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统-也就是redo log来实现crash-safe能力。 两种日志的区别 1.redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎都可以使用。 2.redo log是物理日志，记录的是“在某个数据页上做了什么修改”;binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2 这一行的c字段加 1”。 3.redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 执行器和InnoDB引擎在执行这个简单Update语句时的内部流程 1.执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在是的数据项本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 2.执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 3.引擎将这行新数据更新到内存中，同时将这个更新数据操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务。 4.执行器生成这个操作的binlog，并把binlog写入磁盘。 5.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起： 怎样让数据库恢复到半个月内任意一秒的状态？ 前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 3.事务隔离：为什么你改了我还看不见？简单来说，事务就是保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。MyISAM就不支持事务，InnoDB支持。 隔离性与隔离级别提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（readuncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释： 1.读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 2.读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 3.可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 4.串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。 配置的方式是，将启动参数tranaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。 总结来说，哪个隔离级别都有它自己的使用场景，要根据业务情况来定。 事务隔离的实现在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，建议不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在MySQL5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里，即使长事务最终提交，回滚段被清理，文件也不会变小。有数据只有20GB，而回滚段有200GB的库，最终只好为了清理回滚段，重建整个库。 除了对回滚段的印象，长事务还占用锁资源，也可能拖垮整个库。 事务的启动方式如前面所述，长事务有这些潜在风险，建议尽量避免，其实很多时候业务开发不是有意使用长事务，而是由于误用所致。 MySQL的事务启动方式有一下几种： 1.显示启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback。 2.set autocommit=0，这命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会主动提交，这个事务持续存到知道你主动执行commit或rollback语句，或者断开连接。 有些客户端连接框架会默认连接成功后先执行一个set autocommit=0命令，这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。 因此，建议总是使用set autocommit=1，通过显式语句的方式来启动事务。 在autocommit=1的情况下，用begin显式启动的事务。 但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。 如果你也有这个顾虑，我建议你使用 commit work and chain 语法。 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。 如何避免长事务对业务的影响？首先，从应用开发端来看： 1.确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志 来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它 改成 1。 2.确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框 起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。 这种只读事务可以去掉。 3.业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命 令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。 其次，从数据库端来看： 1.监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill； 2.Percona 的 pt-kill 这个工具不错，推荐使用； 3.在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题； 4.如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方 便。 4.深入浅出索引（上）索引的出现其实是为了提高数据查询的效率，就像书的目录一样。 索引的常见模型索引的出现是为了提高查询效率，但是实现索引的方式却又很多种，所以这里也就引入了索引模型的概念，可以用于提高读写效率的数据结构很多，比较常见、简单的数据结构分别是哈希表、有序数组和索引树。 从使用的角度，简单分析这三种模型的区别。 哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示： 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链 表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询 的速度是很慢的。 你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用 户，就必须全部扫描一遍了。 所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证 号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示： 这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候 如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。 同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区 间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证 号，退出循环。 如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就 麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。 所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有 人口信息，这类不会再修改的数据。 二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我 们用二叉搜索树来实现的话，示意图如下所示： 二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你 要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。 当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个 保证，更新的时间复杂度也是 O(log(N))。 树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从 左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉 树。其原因是，索引不止存在内存中，还要写到磁盘上。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就 不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块 的大小。 N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引 擎中了。 在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引 擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实 现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就 以 InnoDB 为例，和你分析一下其中的索引模型。 InnoDB 的索引模型在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组 织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。 每一个索引在 InnoDB 里面对应一棵 B+ 树。 假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树 的示例示意图如下。 从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 （clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引 （secondary index）。 基于主键索引和普通索引的查询有什么 区别？ 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量 使用主键查询。 索引维护B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例， 如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请 一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合 并。合并的过程，可以认为是分裂过程的逆过程。 基于上面的索引维护过程说明，我们来讨论一个案例： 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自 增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而 哪些场景下不应该。 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。 也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插 入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字 段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？ 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级 索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整 型（bigint）则是 8 个字节。 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。 有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求 是这样的： 只有一个索引； 该索引必须是唯一索引。 你一定看出来了，这就是典型的 KV 场景。 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置 为主键，可以避免每次查询需要搜索两棵树。 总结InnoDB采用B+树结构，因为B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问数。 由于InnoDB是索引组织表，一般情况下建议创建一个自增组件，这样非主键索引占用的空间最小，但是事无绝对，根据业务场景也可以使用业务逻辑字段做主键。 5.深入浅出索引（下）6.全局锁和表锁：给表加个字段怎么有这么多阻碍？数据库锁设计的初衷是处理并发问题，作为多用户共享的资源，当出现并发访问的时候，数据需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。 根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。 全局锁顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock(FTWRL)。当你需要整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。 以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做 备份。注意，在备份过程中整个库完全处于只读状态。 但是让整库都只读，听上去就很危险： 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从 延迟。 不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑 不一致的。其实是有一个方法能够拿到一 致性视图的，就是在可重复读隔离级别下开启一个事务。 官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持， 这个过程中数据是可以正常更新的。 你一定在疑惑，有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎 要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有 更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。 所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了 不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员 使用 InnoDB 替代 MyISAM 的原因之一。 你也许会问，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确 实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要 有两个原因： 1.在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库 还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。 2.在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个 库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状 态，这样会导致整个库长时间处于不可写状态，风险较高。 业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作 （DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操 作，都是会被锁住的。 但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们 要介绍的表级锁。 表级锁MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock， MDL)。 **表锁的语法是lock tables…read/write.**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放，需要注意，lock tables语法除了会限制别的线程的读写外，也限制了本线程接下来的操作对象。 举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。 在还没出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。 另一类表级的锁MDL（metadata lock）。DML不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性，你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果更表结构对不上，肯定是不行的。 因此，在MySQL5.5版本中引入了MDL，当对一个表做增删查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变成表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。 你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响，而实际上，即使是小表，操作不慎也会出问题。 我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需 要的也是 MDL 读锁，因此可以正常执行。 之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。 如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读 锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。 如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。 你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会 马上释放，而会等到整个事务提交后再释放。 基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？ 首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。 但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请 求很频繁，而你不得不加个字段，你该怎么做呢？ 这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不 到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这 个过程。 MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。 12ALTER TABLE tbl_name NOWAIT add column ...ALTER TABLE tbl_name WAIT N add column ... 小结全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，我建议你选择使用– single-transaction 参数，对应用会更友好。 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 lock tables 这样的语句，你需要追查一下，比较可能的情况是： 要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎； 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。 MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。 最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一 列。这时候，从备库上会看到什么现象呢？ online ddl Online DDL的过程是这样的： 拿MDL写锁 降级成MDL读锁 真正做DDL 升级成MDL写锁 释放MDL锁 1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表 可以正常读写数据，是因此称为“online ” 我们文中的例子，是在第一步就堵住了 7.行锁功过：怎么减少行锁对性能的影响？8.事务到底是隔离还是不隔离的？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇3","date":"2021-07-20T05:09:34.997Z","updated":"2021-05-21T07:12:28.976Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇3/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%873/","excerpt":"","text":"33.我查这么多数据，会不会把数据内存打爆？34.到底可不可以使用join?在实际生产中，关于 join 语句使用的问题，一般会集中在以下两类： 我们 DBA 不让使用 join，使用 join 有什么问题呢？ 如果有两个大小不同的表做 join，应该用哪个表做驱动表呢？ Index Nested-Loop Join这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称 NLJ。 35.join语句怎么优化？36.为什么临时表可以重名？37.什么时候会使用内部临时表？38.都说InnoDB好，那还要不要使用Memory引擎？39.自增主键为什么不是连续的？40.insert语句的锁为什么这么多？41.怎么最快地复制一张表？42.grant之后要跟着flush privileges吗？43.要不要使用分区表？44.45.递增id用完了怎么办？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇2","date":"2021-07-20T05:09:34.995Z","updated":"2021-05-20T08:17:29.913Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇2/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%872/","excerpt":"","text":"21.为什么我只查一行的语句，锁这么多？22.MySQL有哪些“饮鸩止渴”提高性能的方法？23.MySQL是怎么保证数据不丢的？只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。 binlog的写入机制其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。 一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。 系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空binlog cache。状态如图 1 所示。 24.MySQL是怎么保证主备一致的？25.MySQL是怎么保证高可用的？26.备库为什么会延迟好几个小时？27.主库出问题了，从库怎么办？28.读写分离有哪些坑？29.如何判断一个数据库是不是出问题了?30.答疑文章（二）：用动态的观点看加锁31.误删数据后除了跑路，还能怎么办？32.为什么还有kill不掉的语句？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇1","date":"2021-07-20T05:09:34.993Z","updated":"2021-04-08T01:16:29.938Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇1/","link":"","permalink":"http://example.com/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%871/","excerpt":"","text":"实践篇9.普通索引和唯一索引，应该怎么选择？10.MySQL为什么有时候会选错索引？11.怎么给字符串字段加索引？12.为什么我的MySQL会“抖”一下？13.为什么表数据删除一半，表文件大小不变？14.count(*)这么慢，我改怎么办？count(*)的实现方式你首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。 15.日志和索引相关问题16.“order by”是怎么工作的？17.如何正确地显示随机消息？18.为什么这些SQL语句逻辑相同，性能却差异巨大？19.为什么我只查一行的语句，也执行这么慢？20.幻读是什么，幻读有什么问题？","categories":[],"tags":[]},{"title":"Redis常见问题","slug":"数据库/Redis/Redis-雪崩、穿透、并发等5大难题解决方案","date":"2020-12-19T14:04:23.000Z","updated":"2020-12-19T07:14:40.000Z","comments":true,"path":"2020/12/19/数据库/Redis/Redis-雪崩、穿透、并发等5大难题解决方案/","link":"","permalink":"http://example.com/2020/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%B9%B6%E5%8F%91%E7%AD%895%E5%A4%A7%E9%9A%BE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"一、Redis雪崩、穿透、并发等5大难题解决方案缓存雪崩数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。 雪崩的简单过程： redis集群大面积故障 缓存失效，但依然大量请求访问缓存服务redis redis大量失效后，大量请求转向到mysql数据库 mysql的调用量暴增，很快就扛不住了，甚至直接宕机 由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。 如何预防缓存雪崩： 缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.缓存降级 可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。 当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。 降级的最终目的是保证核心服务可用，即使是有损的。 比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。 在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 3.Redis备份和快速预热 (1)Redis数据备份和恢复 (2)快速缓存预热 4.提前演练 最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。 缓存穿透缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决思路： 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。 可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。 缓存并发这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。 缓存预热缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路： 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 目的就是在系统上线前，将数据加载到缓存中。 二、Redis为什么是单线程，高并发快的3大原因详解Redis的高并发和快速原因 redis是基于内存的，内存的读写速度非常快； redis是单线程的，省去了很多上下文切换线程的时间； redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。 下面重点介绍单线程设计和IO多路复用核心设计快的原因。 为什么Redis是单线程的？1.官方答案 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。 2.性能指标 关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 3.详细原因 1.不需要各种锁的性能消耗 Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 2.单线程多进程集群方案 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。 所以单线程、多进程的集群不失为一个时髦的解决方案。 3.CPU消耗 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？ 可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。 Redis单线程的优劣势单进程单线程优势 代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善； IO多路复用技术 redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。 多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。 Redis高并发快总结 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。 三、Redis缓存和MySQL数据一致性方案详解 需求起因 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。 这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。 读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子： 如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。 如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。 缓存和数据库一致性解决方案1.第一种方案：采用延时双删策略 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。 伪代码如下： 123456public void write(String key,Object data)&#123; redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key);&#125; 具体的步骤就是： 先删除缓存；再写数据库；休眠500毫秒；再次删除缓存。 那么，这个500毫秒怎么确定的，具体该休眠多久呢？ 需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。 设置缓存过期时间 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 该方案的弊端 结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。 2、第二种方案：异步更新缓存(基于订阅binlog的同步机制) 技术整体思路： MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 读Redis：热数据基本都在Redis 写MySQL:增删改都是操作MySQL 更新Redis数据：MySQL的数据操作binlog，来更新到Redis Redis更新 1）数据操作主要分为两大块： 一个是全量(将全部数据一次写入到redis)一个是增量（实时更新） 这里说的是增量,指的是mysql的update、insert、delate变更数据。 2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。 当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"数据库索引模块","slug":"数据库/MySQL/数据库索引模块","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:46:42.000Z","comments":true,"path":"2020/07/15/数据库/MySQL/数据库索引模块/","link":"","permalink":"http://example.com/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9D%97/","excerpt":"","text":"如何设计一个关系型数据库程序实例： 存储管理 减少对数据的访问，提供缓存机制（全页缓存） SQL解析 日志管理：缓存不易过大，提供淘汰策略，在数据库修改之后及时修改缓存，进行主从同步和灾难恢复 权限划分 容灾机制 索引管理 锁管理 影响数据的运行瓶颈就是IO 存储（文件系统）索引模块为什么使用索引原始数据的查询方法就是将全表放入内存中，全表扫描轮询找到需要查找的数据，少量数据可以，大量数据严重影响性能。 什么样的信息能成为索引主键：唯一键以及普通键 索引的数据结构生成索引，建立二叉查找树进行二分查找（二叉树–平衡二叉树–红黑树）因为是二分查找，时间复杂度为O(logn) 生成索引，建立B-Tree结构进行查找因为添加结点导致二叉树的深度增加，虽然进行旋转可以使其继续维持平衡，但是增加了IO，降低了性能，因此提供了B-Tree结构（平衡多路查找树）。 每个结点最多有m个孩子，这个结点就是M阶B树 每个存储块包括关键字和指向结点的指针，最多有几个孩子取决于存储块的容量和数据库的相关配置 生成索引，建立B+-Tree结构进行查找 生成索引，建立Hash结构进行查找 密集索引和稀疏索引的区别密集索引密集索引文件中每一个搜索码值都对应一个索引值，就是叶子节点保存的不只是键值，还保存了位于同一行记录里的其他列信息，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引。 稀疏索引稀疏索引文件只为索引码的某些值建立索引项，比如InnoDB的其他索引只存了键位信息和主键，MyISAM的所有索引都是稀疏索引。 MyISAM–》 主键索引，唯一键索引，还是普通索引 —都是 稀疏索引 额外知识InnoDB 若一个主键被定义，该主键则作为密集索引 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引 若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引） 非主键索引存储相关键位和其对应的主键值，包含两次查找 InnoDB聚簇表分布myisam在磁盘存储上有三个文件，每个文件名以表名开头，扩展名指出文件类型。.frm 用于存储表的定义.MYD 用于存放数据.MYI 用于存放表索引 可以看到—–》 Innodb索引与数据放在一起 慢查询/索引101.数据库索引的实现(B+树介绍、和B树、R树区别) 参考文章：数据库索引的实现原理 - 辉仔 の专栏 - 博客频道 - CSDN.NET由浅入深理解数据库中索引的底层实现 | 学步园 102.SQL性能优化 参考文章：高手详解SQL性能优化十条经验 - 51CTO.COMOracle SQL性能优化 - 一江水 - 博客园 103.数据库索引的优缺点以及什么时候数据库索引失效 参考文章：数据库索引的作用和优点缺点以及索引的11中用法 - 技术与人生 - 博客园正确高效使用数据库不可不知的索引失效问题 - simplefrog - 博客园SQL优化避免索引失效 - OPEN 开发经验库Colin Lau Oracle哪些情况下索引会失效？ - 曾是土木人 - 博客园","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"索引的使用和含义","slug":"数据库/MySQL/高级SQL","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:41:58.000Z","comments":true,"path":"2020/07/15/数据库/MySQL/高级SQL/","link":"","permalink":"http://example.com/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%AB%98%E7%BA%A7SQL/","excerpt":"","text":"索引索引（Index）是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。MySQL索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特殊指明，一般都是B树结构组织的索引（B+Tree索引） 索引是什么?索引是帮助MySQL高效获取数据的数据结构。 索引能干什么?提高数据查询的效率。 索引：排好序的快速查找数据结构！索引会影响where后面的查找，和order by 后面的排序。公众号：Java后端 发布过几十篇 MySQL 文章，其中包括索引的文章，可以关注后后台回复 666 获取。 一、索引的分类 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。 从应用层次来分：普通索引，唯一索引，复合索引。 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。 1 中所描述的是索引存储时保存的形式，2 是索引使用过程中进行的分类，两者是不同层次上的划分。不过平时讲的索引类型一般是指在应用层次的划分。 就像手机分类，安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引唯一索引：索引列的值必须唯一，但允许有空值复合索引：即一个索引包含多个列聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。非聚簇索引：不是聚簇索引，就是非聚簇索引（认真脸）。二、索引的底层实现 mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。不谈存储引擎，只讨论实现(抽象)Hash索引 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。 B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。 是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。 案例：假设有一张学生表，id为主键 在MyISAM引擎中的实现（二级索引也是这样实现的） 在InnoDB中的实现 三、问题 问：为什么索引结构默认使用B-Tree，而不是hash，二叉树，红黑树？hash：虽然可以快速定位，但是没有顺序，IO复杂度高。二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。红黑树：树的高度随着数据量增加而增加，IO代价高。问：为什么官方建议使用自增长主键作为索引。结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。插入连续的数据： 插入非连续的数据 视图触发器count(1)、count(*)和count(字段)区别https://zhuanlan.zhihu.com/p/28397595","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"缓存雪崩、缓存击穿和缓存穿透","slug":"数据库/Redis/缓存雪崩、缓存穿透和缓存击穿","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:42:10.000Z","comments":true,"path":"2020/07/15/数据库/Redis/缓存雪崩、缓存穿透和缓存击穿/","link":"","permalink":"http://example.com/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/","excerpt":"","text":"缓存雪崩、缓存穿透和缓存击穿的区别是什么，各自有什么解决方案缓存穿透一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的Key，请求量很大，就会对后端系统造成很大的压力，这就叫做缓存穿透。 如何避免 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据Insert了之后清理缓存。 对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的bitmap中，查询时通过该bitmap过滤。 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。 如何避免 在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 做二级缓存，A1为原始数据，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 缓存击穿对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。 如何避免 使用互斥锁，当缓存失效时，不立即去load DB，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时在进行Load DB的操作并回设缓存，否则重试get缓存的方法 永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新） 使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤。 缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。解决方案：为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的话更新缓存时间。这样每次取session,都会延长30分钟，相对来说，就减少了缓存过期的几率 缓存一致性要求数据更新的同时缓存数据也能够实时更新。 解决方案：在数据更新的同时立即去更新缓存，首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。","categories":[],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://example.com/tags/%E7%BC%93%E5%AD%98/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"系统架构师","slug":"系统架构师","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"外键","slug":"外键","permalink":"http://example.com/tags/%E5%A4%96%E9%94%AE/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"http://example.com/tags/%E7%BC%93%E5%AD%98/"}]}