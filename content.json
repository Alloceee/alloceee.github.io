{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Alloceee","url":"https://alloceee.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-21T07:09:57.761Z","updated":"2021-07-21T07:09:52.056Z","comments":true,"path":"contact.html","permalink":"https://alloceee.github.io/contact.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:36:59.438Z","updated":"2021-07-28T03:36:59.438Z","comments":true,"path":"404.html","permalink":"https://alloceee.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"首页","date":"2021-07-21T07:07:37.111Z","updated":"2021-07-21T07:07:37.111Z","comments":true,"path":"archives/index.html","permalink":"https://alloceee.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-28T03:33:13.532Z","updated":"2021-07-28T03:33:13.532Z","comments":true,"path":"categories/index.html","permalink":"https://alloceee.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-12T07:03:01.127Z","updated":"2021-08-12T07:03:01.127Z","comments":true,"path":"about/other.html","permalink":"https://alloceee.github.io/about/other.html","excerpt":"","text":"1.了解游戏服务器架构及性能优化方法 2.熟悉MySQL、Redis等数据库操作 3.有数据库运维/优化的经验； 4.具备良好的分析解决问题能力，能独立承担后台逻辑系统开发工具。 1.根据策划需求设计，实现服务器功能和维护； 2.负责游戏数据库结构的设计和优化； 3.配合游戏前端进行各个功能模板的联调； 4.负责游戏后端性能优化； 5.游戏上线运维，后台相关脚本和工具研发。 熟悉MVC、TP6、Layui 了解PHP的性能最优化和安全最大化 熟练使用MySQL，精通MySQL分析及优化，善于找出MySQL语句的毛病及如何优化 有实际分表、分库、存储引擎优化经验 熟练使用内存缓存、文件缓存，有EPR开发和处理消息队列经验者优化 熟悉Laravel框架 熟悉LNMP架构 熟悉redis常用数据结构 熟悉Linux常用命令 广告投放系统开发经验 2年经验 MVC框架原理 PHP环境相关服务配置 熟练操作git源码管理 熟练掌握HTML5、CSS3、JavaScript等 熟练使用JQuery、Vue等主流JS框架 熟练使用MySQL，了解MySQL底层原理，掌握MySQL常用优化方法，能编写高性能MySQL语句 有高负载、大并发、大数据量、复杂业务逻辑的项目经验 拥有电商软件开发经验 Docker容器化相关技术栈 熟练LAMP架构 数据库性能调优 ERP、电商系统 熟悉面向对象（OOP）和常用设计模式 熟悉Nginx、Apache等web容器 独立带团队能力 web前端、redis、TP框架 2年以上经验 精通PHP 熟悉phalcon，swoole或者workman等框架 熟悉另外一门后端语言，包括但不限于Go、C、C++、NodeJS 5年以上开发经验 3年以上系统设计经验 有社交娱乐，大型互联网产品的系统设计经验优先 熟悉Nginx、Redis、MySQL、Sphinx等的管理和调优 熟练运用缓存、消息队列等技术 项目管理能力 20-40 电商ERP、WMS、CMS、CRM等系统开发经验者优先； 熟练使用Laravel，有完整的非练手项目经验； 熟练使用MySQL，并且能对复杂SQL进行调优； 熟练使用Git管理工具，熟悉Git工作流； 熟悉前端jQuery的基本使用方法； 熟悉HTTP协议，了解RESTful API设计风格，了解XML技术； 熟悉Vue全家桶的基本使用，了解Elctron框架优先； 工作态度，沟通与团队协作，有责任心"},{"title":"","date":"2021-08-12T06:57:05.325Z","updated":"2021-08-12T06:57:05.325Z","comments":true,"path":"about/index.html","permalink":"https://alloceee.github.io/about/index.html","excerpt":"","text":"PHP开发工程师 1998-07-02 华东交通大学理工学院 2016-2020 本科-软件工程 链接 博客 简历 github 简介 前端：熟悉HTML/JavaScript/CSS，熟悉CSS3与ES6，vue快速搭建与使用 后端：以PHP为主，同时熟悉Java 数据库：MySQL、Redis使用 测试 git：熟悉git流程，使用commitizen规范commit提交；svn 工作经历上海黑桃互动网络科技股份有限公司武汉分公司 2019-10 ~ 2021-03 PHP开发工程师 上海凌立健康管理股份有限公司 2021-03 ~ 至今 PHP开发工程师 项目经历协和教学一体化项目（2021-03 ~ 至今） 负责其中教学评价综合管理系统、轮转排班管理系统、学员招录系统以及综合门户系统开发 前端使用layui开发后台管理，html,css3与jquery开发综合门户，独立封装课程日历等js组件 后端使用CI框架 游戏管理后台服务（2019-12 ~ 2021-03） 游戏后台，游戏数据统计，分析与服务器开服关服相关操作 greylog 日志统计与分析 cronsun定时脚本 greylog Redis mysql 官网服务（2019-10 ~ 2021-03） 官网维护，游戏活动业务 前后端分离开发 redis缓存各种数据 技术亮点 对接联运游戏 荣誉证书 江西省大学生计算机职业技能竞赛专业组 一等奖 软考 软件设计师 Java工程师 计算机二级、英语四级 其他 Nginx基础配置"},{"title":"my-friends","date":"2021-07-28T03:35:55.301Z","updated":"2021-07-28T03:35:55.301Z","comments":true,"path":"friends/index.html","permalink":"https://alloceee.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:34:26.738Z","updated":"2021-07-28T03:34:26.738Z","comments":true,"path":"mylist/index.html","permalink":"https://alloceee.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-28T03:33:40.751Z","updated":"2021-07-28T03:33:40.751Z","comments":true,"path":"tags/index.html","permalink":"https://alloceee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第21章：虚拟化、云计算与物联网","slug":"SystemArchitect/第21章：虚拟化、云计算与物联网","date":"2021-08-20T16:00:00.000Z","updated":"2021-08-12T06:53:19.202Z","comments":true,"path":"2021/08/21/SystemArchitect/第21章：虚拟化、云计算与物联网/","link":"","permalink":"https://alloceee.github.io/2021/08/21/SystemArchitect/%E7%AC%AC21%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%81%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/","excerpt":"","text":"","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"","slug":"大前端/01-浏览器/Untitled","date":"2021-08-14T06:17:55.458Z","updated":"2021-08-14T06:17:55.458Z","comments":true,"path":"2021/08/14/大前端/01-浏览器/Untitled/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-%E6%B5%8F%E8%A7%88%E5%99%A8/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"大前端/01-浏览器/03","date":"2021-08-14T06:15:45.552Z","updated":"2021-08-14T06:15:51.665Z","comments":true,"path":"2021/08/14/大前端/01-浏览器/03/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-%E6%B5%8F%E8%A7%88%E5%99%A8/03/","excerpt":"","text":"#3 Chrome 打开一个页面需要启动多少进程？分别有哪些进程？打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 #4 渲染机制1. 浏览器如何渲染网页 概述：浏览器渲染一共有五步 处理 HTML 并构建 DOM 树。 处理 CSS构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染 具体如下图过程如下图所示 渲染 网页生成的时候，至少会渲染一次 在用户访问的过程中，还会不断重新渲染 重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制) 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且CSS也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 2. 浏览器渲染五个阶段 2.1 第一步：解析HTML标签，构建DOM树 在这个阶段，引擎开始解析html，解析出来的结果会成为一棵dom树 dom的目的至少有2个 作为下个阶段渲染树状图的输入 成为网页和脚本的交互界面。(最常用的就是getElementById等等) 当解析器到达script标签的时候，发生下面四件事情 html解析器停止解析, 如果是外部脚本，就从外部网络获取脚本代码 将控制权交给js引擎，执行js代码 恢复html解析器的控制权 由此可以得到第一个结论1 由于&lt;script&gt;标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。 defer和async属性也能有助于加载外部脚本。 defer使得脚本会在dom完整构建之后执行； async标签使得脚本只有在完全available才执行，并且是以非阻塞的方式进行的 2.2 第二步：解析CSS标签，构建CSSOM树 我们已经看到html解析器碰到脚本后会做的事情，接下来我们看下html解析器碰到样式表会发生的情况 js会阻塞解析，因为它会修改文档(document)。css不会修改文档的结构，如果这样的话，似乎看起来css样式不会阻塞浏览器html解析。但是事实上 css样式表是阻塞的。阻塞是指当cssom树建立好之后才会进行下一步的解析渲染 通过以下手段可以减轻cssom带来的影响 将script脚本放在页面底部 尽可能快的加载css样式表 将样式表按照media type和media query区分，这样有助于我们将css资源标记成非阻塞渲染的资源。 非阻塞的资源还是会被浏览器下载，只是优先级较低 2.3 第三步：把DOM和CSSOM组合成渲染树（render tree） 2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构 布局(layout)：定位坐标和大小，是否换行，各种position, overflow, z-index属性 2.5 调用 GPU 绘制，合成图层，显示在屏幕上 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting 3. 渲染优化相关 3.1 Load 和 DOMContentLoaded 区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 3.2 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。 通过以下几个常用属性可以生成新图层 3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 3.3 重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流 以下几个动作可能会导致性能问题 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关 当 Event loop 执行完Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 常见的引起重绘的属性 color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 3.4 常见引起回流属性和方法 任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 回流影响的范围 由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 全局范围回流 1234567891011&lt;body&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h4&gt;hello&lt;/h4&gt; &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt; &lt;h5&gt;male&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;coding&lt;/li&gt; &lt;li&gt;loving&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt; 当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响 局部范围回流 用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界 3.5 减少重绘和回流 使用 translate 替代 top 12345678910111213141516&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;style&gt; .test &#123; position: absolute; top: 10px; width: 100px; height: 100px; background: red; &#125;&lt;/style&gt;&lt;script&gt; setTimeout(() =&gt; &#123; // 引起回流 document.querySelector(&#x27;.test&#x27;).style.top = &#x27;100px&#x27; &#125;, 1000)&lt;/script&gt; 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 1234for(let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS选择符从右往左匹配查找，避免 DOM深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层。 #5 缓存机制1. 首先得明确 http 缓存的好处 减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型 私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存 本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是 第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。 3.1 Cache-Control Cache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 must-revalidate，当缓存过期时，需要去服务端校验缓存的有效性。 1234# 例如：Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 注意，虽然你可能在其他资料中看到可以使用 meta 标签来设置缓存，比如像下面的形式： 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2021 22:33:00 GMT&quot; 但在 HTML5 规范中，并不支持这种方式，所以尽量不要使用 meta 标签来设置缓存。 3.2 Expires Expires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用 12Cache-Control: publicExpires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商 当第一次请求时服务器返回的响应头中存在以下情况时 没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。 Last-Modified 与 If-Modified-Since 具体工作流程如下： 浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 服务端再次收到请求，根据请求头 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，并且不返回资源内容，浏览器使用资源缓存值；否则正常返回资源内容，且更新Last-Modified 响应头内容。 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回 这种方式虽然能判断缓存是否失效，但也存在两个问题： 精度问题，Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断可能会失效； 准度问题，考虑这样一种情况，如果一个文件被修改，然后又被还原，内容并没有发生变化，在这种情况下，浏览器的缓存还可以继续使用，但因为修改时间发生变化，也会重新返回重复的内容。 123456# 第一次请求返回的响应头Cache-Control:max-age=3600Expires: Fri, Jan 12 2018 00:27:04 GMTLast-Modified: Wed, Jan 10 2018 00:27:04 GMT# 第二次请求的请求头信息If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match ETag与If-None-Match 为了解决精度问题和准度问题，HTTP 提供了另一种不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。 ETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断 浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。 具体工作流程如下： 浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值 当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值； 服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中 这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面。 计算成本。生成哈希值相对于读取文件修改时间而言是一个开销比较大的操作，尤其是对于大文件而言。如果要精确计算则需读取完整的文件内容，如果从性能方面考虑，只读取文件部分内容，又容易判断出错。 计算误差。HTTP 并没有规定哈希值的计算方法，所以不同服务端可能会采用不同的哈希值计算方式。这样带来的问题是，同一个资源，在两台服务端产生的 Etag 可能是不相同的，所以对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。 需要注意的是，强制缓存的优先级高于协商缓存，在协商缓存中，Etag 优先级比 Last-Modified 高 1234567# 第一次请求返回的响应头：Cache-Control: public, max-age=31536000ETag: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot;# 第二次请求的请求头信息：If-None-Match: &quot;15f0fff99ed5aae4edffdd6496d7131f&quot; 缓存位置 浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇 Service Worker Memory Cache Disk Cache Push Cache Service Worker 这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是Service Worker Cache。 Memory Cache 指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。 Disk Cache 存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。 Disk Cache VS Memory Cache 两者对比，主要的策略👇 内容使用率高的话，文件优先进入磁盘 比较大的JS，CSS文件会直接放入磁盘，反之放入内存。 Push Cache 推送缓存，这算是浏览器中最后一道防线吧，它是HTTP/2的内容 浏览器缓存总结 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下 先根据这个资源的一些 http header 判断它是否命中强缓存，先检查Cache-Control，如果命中，则直接从本地获取缓存资源，不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是返回304告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；（服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新） 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间） Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）协商缓 Last-Modified（值为资源最后更新时间，随服务器response返回，即使文件改回去，日期也会变化） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存） ETag（表示资源内容的唯一标识，随服务器response返回，仅根据文件内容是否变化判断） If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） #6 浏览器存储 我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用 持久性存储，可以分为 浏览器端 与 服务器端 浏览器: ```cookie12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 : 通常用于存储用户身份，登录状态等 - `http` 中自动携带， 体积上限为 `4K`， 可自行设置过期时间 - `localStorage / sessionStorage`: 长久储存/窗口关闭删除， 体积限制为 `4~5M` - `indexDB` - 服务器: - 分布式缓存 `redis` - 数据库**cookie和localSrorage、session、indexDB 的区别**| 特性 | cookie | localStorage | sessionStorage | indexDB || ------------ | ------------------------------------------ | ------------------------ | -------------- | ------------------------ || 数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 || 数据存储大小 | `4K` | `5M` | `5M` | 无限 || 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 |&gt; 从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage`和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。**对于 `cookie`，我们还需要注意安全性**| 属性 | 作用 || ----------- | ------------------------------------------------------------ || `value` | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 || `http-only` | 不能通过 `JS`访问 `Cookie`，减少 `XSS`攻击 || `secure` | 只能在协议为 `HTTPS` 的请求中携带 || `same-site` | 规定浏览器不能在跨域请求中携带 `Cookie`，减少 `CSRF` 攻击 |![img](http://img-repo.poetries.top/images/20210421172522.png)- `Name`，即该 `Cookie` 的名称。`Cookie` 一旦创建，名称便不可更改。- `Value`，即该 `Cookie` 的值。如果值为 `Unicode` 字符，需要为字符编码。如果值为二进制数据，则需要使用 `BASE64` 编码。- `Max Age`，即该 `Cookie` 失效的时间，单位秒，也常和 `Expires` 一起使用，通过它可以计算出其有效时间。`Max Age`如果为正数，则该 `Cookie` 在 `Max Age` 秒之后失效。如果为负数，则关闭浏览器时 `Cookie` 即失效，浏览器也不会以任何形式保存该 `Cookie`。- `Path`，即该 `Cookie` 的使用路径。如果设置为 `/path/`，则只有路径为 `/path/` 的页面可以访问该 `Cookie`。如果设置为 `/`，则本域名下的所有页面都可以访问该 `Cookie`。- `Domain`，即可以访问该 `Cookie` 的域名。例如如果设置为 `.zhihu.com`，则所有以 `zhihu.com`，结尾的域名都可以访问该 `Cookie`。 `Size` 字段，即此 `Cookie` 的大小。- `Http` 字段，即 `Cookie` 的 `httponly` 属性。若此属性为 `true`，则只有在 `HTTP Headers` 中会带有此 Cookie 的信息，而不能通过 `document.cookie` 来访问此 Cookie。- `Secure`，即该 `Cookie` 是否仅被使用安全协议传输。安全协议。安全协议有 `HTTPS、SSL` 等，在网络上传输数据之前先将数据加密。默认为 `false`。### [#](https://blog.poetries.top/FE-Interview-Questions/docs/simply.html#_7-跨域方案)7 跨域方案&gt; 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 `jsonp`、`iframe`、`cors`、`img`、`HTML5 postMessage`等等。其中用到 `html` 标签进行跨域的原理就是 `html` 不受同源策略影响。但只是接受 `Get` 的请求方式，这个得清楚。&gt; **延伸1：img iframe script 来发送跨域请求有什么优缺点？****1. `iframe`**- 优点：跨域完毕之后`DOM`操作和互相之间的`JavaScript`调用都是没有问题的- 缺点：1.若结果要以`URL`参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是`iframe`本身带来的，母页面和`iframe`本身的交互本身就有安全性限制。**2. script**- 优点：可以直接返回`json`格式的数据，方便处理- 缺点：只接受`GET`请求方式**3. 图片ping**- 优点：可以访问任何`url`，一般用来进行点击追踪，做页面分析常用的方法- 缺点：不能访问响应文本，只能监听是否响应&gt; **延伸2：配合 webpack 进行反向代理？**`webpack` 在 `devServer` 选项里面提供了一个 `proxy` 的参数供开发人员进行反向代理```js&#x27;/api&#x27;: &#123; target: &#x27;http://www.example.com&#x27;, // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; // rewrite path &#125;&#125;, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理 123456789const express = require(&#x27;express&#x27;);const proxy = require(&#x27;http-proxy-middleware&#x27;);// proxy api requestsconst exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项// mount `exampleProxy` in web serverconst app = express();app.use(&#x27;/api&#x27;, exampleProxy);app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可 说到 nginx ，可以再谈谈 CORS 配置，大致如下 123456789101112location / &#123; if ($request_method = &#x27;OPTIONS&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type&#x27;; add_header &#x27;Access-Control-Max-Age&#x27; 86400; add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;; add_header &#x27;Content-Length&#x27; 0; return 200; &#125;&#125; #8 XSS 和 CSRF 1. XSS 涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。 XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, &#x27;&amp;amp;&#x27;) str = str.replace(/&lt;/g, &#x27;&amp;lt;&#x27;) str = str.replace(/&gt;/g, &#x27;&amp;gt;&#x27;) str = str.replace(/&quot;/g, &#x27;&amp;quto;&#x27;) str = str.replace(/&#x27;/g, &#x27;&amp;#39;&#x27;) str = str.replace(/`/g, &#x27;&amp;#96;&#x27;) str = str.replace(/\\//g, &#x27;&amp;#x2F;&#x27;) return str&#125; 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 12// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;escape(&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;) 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式 1234const xss = require(&#x27;xss&#x27;)let html = xss(&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;)// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;console.log(html) 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script标签 CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 这里以设置 HTTP Header 来举例 只允许加载本站资源 1Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src &#x27;none&#x27; 当然可以设置的属性远不止这些，你可以通过查阅 文档 (opens new window)的方式来学习，这里就不过多赘述其他的属性了。 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 2 CSRF 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法 CSRF 就是利用用户的登录态发起恶意请求 如何攻击 假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src=&quot;http://www.domain.com/xxx?comment=&#x27;attack&#x27;&quot;/&gt; 1res.setHeader(&#x27;Set-Cookie&#x27;, `username=poetry2;sameSite = strict;path=/;httpOnly;expires=$&#123;getCookirExpires()&#125;`) 在B网站，危险网站向A网站发起请求 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;!-- 利用img自动发送请求 --&gt; &lt;img src=&quot;http://localhost:8000/api/user/login&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 会带上A网站的cookie 123456789101112// 在A网站下发cookie的时候，加上sameSite=strict，这样B网站在发送A网站请求，不会自动带上A网站的cookie，保证了安全// NAME=VALUE 赋予Cookie的名称及对应值// expires=DATE Cookie 的有效期// path=PATH 赋予Cookie的名称及对应值// domain=域名 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） (一般不指定)// Secure 仅在 HTTPS 安全通信时才会发送 Cookie// HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问// SameSite Lax|Strict|None 它允许您声明该Cookie是否仅限于第一方或者同一站点上下文res.setHeader(&#x27;Set-Cookie&#x27;, `username=poetry;sameSite=strict;path=/;httpOnly;expires=$&#123;getCookirExpires()&#125;`) 如何防御 Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token SameSite Cookies: 只能当前域名的网站发出的http请求，携带这个Cookie。当然，由于这是新的cookie属性，在兼容性上肯定会有问题 CSRF攻击，仅仅是利用了http携带cookie的特性进行攻击的，但是攻击站点还是无法得到被攻击站点的cookie。这个和XSS不同，XSS是直接通过拿到Cookie等信息进行攻击的 在CSRF攻击中，就Cookie相关的特性： http请求，会自动携带Cookie。 携带的cookie，还是http请求所在域名的cookie。 3 密码安全 加盐 对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系 通常需要对密码加盐，然后进行几次不同加密算法的加密 12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误 前端加密 虽然前端加密对于安全防护来说意义不大，但是在遇到中间人攻击的情况下，可以避免明文密码被第三方获取 4. 总结 XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义 CSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与 XSS 相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 防范：用户操作验证（验证码），额外验证机制（token使用）等 #9 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API 浏览器对 ServiceWorker 做了很多限制 在 ServiceWorker 中无法直接访问 DOM，但可以通过 postMessage 接口发送的消息来与其控制的页面进行通信 ServiceWorker 只能在本地环境下或 HTTPS 网站中使用 ServiceWorker 有作用域的限制，一个 ServiceWorker 脚本只能作用于当前路径及其子路径； 目前该技术通常用来做缓存文件，提高首屏速度 123456789101112131415161718192021222324252627282930313233// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker .register(&quot;sw.js&quot;) .then(function(registration) &#123; console.log(&quot;service worker 注册成功&quot;); &#125;) .catch(function(err) &#123; console.log(&quot;servcie worker 注册失败&quot;); &#125;);&#125;// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(&quot;install&quot;, e =&gt; &#123; e.waitUntil( caches.open(&quot;my-cache&quot;).then(function(cache) &#123; return cache.addAll([&quot;./index.html&quot;, &quot;./index.js&quot;]); &#125;) );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(&quot;fetch&quot;, e =&gt; &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response) &#123; return response; &#125; console.log(&quot;fetch source&quot;); &#125;) );&#125;); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的","categories":[],"tags":[]},{"title":"","slug":"大前端/01-浏览器/01-浏览器架构","date":"2021-08-14T05:14:29.737Z","updated":"2021-08-14T05:14:47.455Z","comments":true,"path":"2021/08/14/大前端/01-浏览器/01-浏览器架构/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-%E6%B5%8F%E8%A7%88%E5%99%A8/01-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/","excerpt":"","text":"1 浏览器架构单进程浏览器时代 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的 缺点 不稳定：一个插件的意外崩溃会引起整个浏览器的崩溃 不流畅：所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行 不安全：可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题 以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全 多进程浏览器时代 由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题 JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的 Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。 最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响","categories":[],"tags":[]},{"title":"JavaScript单线程模型","slug":"大前端/01-浏览器/02-JavaScript单线程模型","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-14T05:17:30.129Z","comments":true,"path":"2021/08/14/大前端/01-浏览器/02-JavaScript单线程模型/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-%E6%B5%8F%E8%A7%88%E5%99%A8/02-JavaScript%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"JavaScript语言的一大特点就是单线程，也就是说，同一时间只能做一件事，前面的任务没做完，后面的任务只能等着。 1. 为什么JavaScript是单线程的呢? 这主要与JavaScript用途有关。它的主要用途是与用户互动，以及操作DOM。如果JavaScript是多线程的，会带来很多复杂的问题，假如 JavaScript有A和B两个线程，A线程在DOM节点上添加了内容，B线程删除了这个节点，应该是哪个为准呢? 所以，为了避免复杂性，所以设计成了单线程。 虽然 HTML5 提出了Web Worker标准。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。但是子线程完全受主线程控制，且不得操作DOM。所以这个并没有改变JavaScript单线程的本质。一般使用 Web Worker 的场景是代码中有很多计算密集型或高延迟的任务，可以考虑分配给 Worker 线程。 但是使用的时候一定要注意，worker 线程是为了让你的程序跑的更快，但是如果 worker 线程和主线程之间通信的时间大于了你不使用worker线程的时间，结果就得不偿失了。 2. 浏览器内核中线程之间的关系 GUI渲染线程和JS引擎线程互斥 js是可以操作DOM的，如果在修改这些元素的同时渲染页面（js线程和ui线程同时运行），那么渲染线程前后获得的元素数据可能就不一致了。 JS阻塞页面加载 js如果执行时间过长就会阻塞页面 3. 浏览器是多进程的优点 默认新开 一个 tab 页面 新建 一个进程,所以单个 tab 页面崩溃不会影响到整个浏览器。 第三方插件崩溃也不会影响到整个浏览器。 多进程可以充分利用现代 CPU 多核的优势。 方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性。 4. 进程和线程又是什么呢 进程（process）和线程（thread）是操作系统的基本概念。 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）。 线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）。 由于每个进程至少要做一件事,所以一个进程至少有一个线程。系统会给每个进程分配独立的内存,因此进程有它独立的资源。同一进程内的各个线程之间共享该进程的内存空间（包括代码段,数据集,堆等）。 进程可以理解为一个工厂不不同车间，相互独立。线程是车间里的工人，可以自己做自己的事情,也可以相互配合做同一件事情。 5. 任务队列 单线程就意味着，所有任务都要排队执行，前一个任务结束，才会执行后一个任务。 如果一个任务需要执行，但此时JavaScript引擎正在执行其他任务，那么这个任务就需要放到一个队列中进行等待。等到线程空闲时，就可以从这个队列中取出最早加入的任务进行执行（类似于我们去银行排队办理业务，单线程相当于说这家银行只有一个服务窗口，一次只能为一个人服务，后面到的就需要排队，而任务队列就是排队区，先到的就优先服务） 注意： 如果当前线程空闲，并且队列为空，那每次加入队列的函数将立即执行。 为什么会有任务队列？ 由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以我们将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。","categories":[{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"JavaScript","slug":"web/JavaScript","permalink":"https://alloceee.github.io/categories/web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://alloceee.github.io/tags/JavaScript/"}],"author":"Alloceee"},{"title":"从输入URL到页面展示过程","slug":"大前端/01-浏览器/12-从输入URL到页面展示过程","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-14T06:18:39.742Z","comments":true,"path":"2021/08/14/大前端/01-浏览器/12-从输入URL到页面展示过程/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-%E6%B5%8F%E8%A7%88%E5%99%A8/12-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B/","excerpt":"","text":"1. DNS域名解析 根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址 顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址 权威 DNS 服务器 ：返回相应主机的 IP 地址 DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询； 在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。 如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图： 结合起来的过程，可以用一个图表示： 在查找过程中，有以下优化点： DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。 2. 建立TCP连接 首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据 进行三次握手，建立TCP连接。 第一次握手：建立连接。客户端发送连接请求报文段 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认 第三次握手：客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段 SSL握手过程 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息 第四阶段 变更密码构件和结束握手协议 完成了之后，客户端和服务器端就可以开始传送数据 发送HTTP请求，服务器处理请求，返回响应结果 TCP连接建立后，浏览器就可以利用 HTTP／HTTPS 协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200 这里有发生的一个过程是HTTP缓存，是一个常考的考点，大致过程如图： 3. 关闭TCP连接 4. 浏览器渲染 按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图： 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。 构建 DOM 树 转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串 Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则 构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同） 构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系 样式计算 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 CSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。 页面布局 布局过程，即排除 script、meta 等功能化、非视觉节点，排除 display: none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图： 其中，这个过程需要注意的是回流和重绘 生成分层树 页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree） 栅格化 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。 显示 最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。","categories":[],"tags":[],"author":"Alloceee"},{"title":"Vue响应式原理","slug":"大前端/12-Vue进阶/01-响应式原理","date":"2021-08-13T16:00:00.000Z","updated":"2021-08-14T04:48:40.033Z","comments":true,"path":"2021/08/14/大前端/12-Vue进阶/01-响应式原理/","link":"","permalink":"https://alloceee.github.io/2021/08/14/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E8%BF%9B%E9%98%B6/01-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上。","text":"Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上。 虚拟DOM (Virtaul DOM): 用 js 对象模拟的，保存当前视图内所有 DOM 节点对象基本描述属性和节点间关系的树结构。用 js 对象，描述每个节点，及其父子关系，形成虚拟 DOM 对象树结构。 因为只要在 data 中声明的基本数据类型的数据，基本不存在数据不响应问题，所以重点介绍数组和对象在vue中的数据响应问题，vue可以检测对象属性的修改，但无法监听数组的所有变动及对象的新增和删除，只能使用数组变异方法及$set方法。 可以看到，arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知，这就很好地解释了用 vm.items.splice(newLength) 方法可以检测到变化 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Observer 遍历数据对象，给所有属性加上 setter 和 getter，监听数据的变化 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情 在自身实例化时往属性订阅器 (dep) 里面添加自己 待属性变动 dep.notice() 通知时，调用自身的 update() 方法，并触发 Compile 中绑定的回调 **Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，**Object.defineProperty()**是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue3.x响应式数据原理 Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？ 我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger 1234567891011121314151617181920212223242526// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;, count: 0 &#125;// 模拟 Vue 实例let vm = new Proxy(data, &#123; // 当访问 vm 的成员会执行 get (target, key) &#123; console.log(&#x27;get, key: &#x27;, key, target[key]) return target[key] &#125;, // 当设置 vm 的成员会执行 set (target, key, newValue) &#123; console.log(&#x27;set, key: &#x27;, key, newValue) if (target[key] === newValue) &#123; return &#125; target[key] = newValue document.querySelector(&#x27;#app&#x27;).textContent = target[key] &#125;&#125;)// 测试vm.msg = &#x27;Hello World&#x27;console.log(vm.msg) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听 Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 12345678910111213141516171819202122232425262728let p = new Proxy(target, handler);// `target` 代表需要添加代理的对象// `handler` 用来自定义对象中的操作// 可以很方便的使用 Proxy 来实现一个数据绑定和监听let onWatch = (obj, setBind, getLogger) =&gt; &#123; let handler = &#123; get(target, property, receiver) &#123; getLogger(target, property) return Reflect.get(target, property, receiver); &#125;, set(target, property, value, receiver) &#123; setBind(value); return Reflect.set(target, property, value); &#125; &#125;; return new Proxy(obj, handler);&#125;;let obj = &#123; a: 1 &#125;let valuelet p = onWatch(obj, (v) =&gt; &#123; value = v&#125;, (target, property) =&gt; &#123; console.log(`Get &#x27;$&#123;property&#125;&#x27; = $&#123;target[property]&#125;`);&#125;)p.a = 2 // bind `value` to `2`p.a // -&gt; Get &#x27;a&#x27; = 2 总结 Vue 记录传入的选项，设置 $data/$el 把 data 的成员注入到 Vue 实例 负责调用 Observer 实现数据响应式处理(数据劫持) 负责调用 Compiler 编译指令/插值表达式等 ```Observer 12345678910 - 数据劫持 - 负责把 `data` 中的成员转换成 `getter/setter` - 负责把多层属性转换成 `getter/setter` - 如果给属性赋值为新对象，把新对象的成员设置为 `getter/setter` - 添加 `Dep` 和 `Watcher` 的依赖关系 - 数据变化发送通知- ``` Compiler 负责编译模板，解析指令/插值表达式 负责页面的首次渲染过程 当数据变化后重新渲染 ```Dep 123456 - 收集依赖，添加订阅者(`watcher`) - 通知所有订阅者- ``` Watcher 自身实例化的时候往dep对象中添加自己 当数据变化dep通知所有的 Watcher 实例更新视图","categories":[{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"Vue","slug":"web/Vue","permalink":"https://alloceee.github.io/categories/web/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://alloceee.github.io/tags/Vue/"}],"author":"Alloceee"},{"title":"","slug":"大前端/04-JavaScript进阶/23-Proxy代理","date":"2021-08-13T15:21:07.699Z","updated":"2021-08-13T15:21:13.275Z","comments":true,"path":"2021/08/13/大前端/04-JavaScript进阶/23-Proxy代理/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/23-Proxy%E4%BB%A3%E7%90%86/","excerpt":"","text":"23 Proxy代理 proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截 1var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为 12345678910111213141516171819var target = &#123; name: &#x27;poetries&#x27; &#125;; var logHandler = &#123; get: function(target, key) &#123; console.log(`$&#123;key&#125; 被读取`); return target[key]; &#125;, set: function(target, key, value) &#123; console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`); target[key] = value; &#125; &#125; var targetWithLog = new Proxy(target, logHandler); targetWithLog.name; // 控制台输出：name 被读取 targetWithLog.name = &#x27;others&#x27;; // 控制台输出：name 被设置为 others console.log(target.name); // 控制台输出: others targetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。 在 targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值 12345678910// 由于拦截函数总是返回35，所以访问任何属性都得到35var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 Proxy 实例也可以作为其他对象的原型对象 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截 Proxy的作用 对于代理模式 Proxy 的作用主要体现在三个方面 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 Proxy所能代理的范围–handler 实际上 handler 本身就是ES6所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.getPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.setPrototypeOf() // 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.isExtensible() // 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.preventExtensions()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。handler.getOwnPropertyDescriptor() // 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。andler.defineProperty() // 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。handler.has()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.get() // 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.set()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.deleteProperty()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.ownKeys()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.apply() // 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。handler.construct() 为何Proxy不能被Polyfill 如class可以用function模拟；promise可以用callback模拟 但是proxy不能用Object.defineProperty模拟 目前谷歌的polyfill只能实现部分的功能，如get、set https://github.com/GoogleChrome/proxy-polyfill 123456789// commonJS requireconst proxyPolyfill = require(&#x27;proxy-polyfill/src/proxy&#x27;)();// Your environment may also support transparent rewriting of commonJS to ES6:import ProxyPolyfillBuilder from &#x27;proxy-polyfill/src/proxy&#x27;;const proxyPolyfill = ProxyPolyfillBuilder();// Then use...const myProxy = new proxyPolyfill(...);","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/13-模块化","date":"2021-08-13T15:19:41.495Z","updated":"2021-08-13T15:19:52.154Z","comments":true,"path":"2021/08/13/大前端/04-JavaScript进阶/13-模块化/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/13-%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"13 模块化 js 中现在比较成熟的有四种模块加载方案： 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块 在有 Babel 的情况下，我们可以直接使用 ES6的模块化 12345678// file a.jsexport function a() &#123;&#125;export function b() &#123;&#125;// file b.jsexport default function() &#123;&#125;import &#123;a, b&#125; from &#x27;./a.js&#x27;import XXX from &#x27;./b.js&#x27; CommonJS CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify解析了。 12345678910// a.jsmodule.exports = &#123; a: 1&#125;// orexports.a = 1// b.jsvar module = require(&#x27;./a.js&#x27;)module.a // -&gt; log 1 在上述代码中，module.exports 和 exports 很容易混淆，让我们来看看大致内部实现 12345678910111213141516171819var module = require(&#x27;./a.js&#x27;)module.a// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，// 重要的是 module 这里，module 是 Node 独有的一个变量module.exports = &#123; a: 1&#125;// 基本实现var module = &#123; exports: &#123;&#125; // exports 就是个空对象&#125;// 这个是为什么 exports 和 module.exports 用法相似的原因var exports = module.exportsvar load = function (module) &#123; // 导出的东西 var a = 1 module.exports = a return module.exports&#125;; 再来说说 module.exports 和exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。 对于 CommonJS 和 ES6 中的模块化的两者区别是： 前者支持动态导入，也就是 require($&#123;path&#125;/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。 但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 AMD AMD 是由 RequireJS 提出的 AMD 和 CMD 规范的区别？ 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。 123456789101112131415161718// CMDdefine(function(require, exports, module) &#123; var a = require(&quot;./a&quot;); a.doSomething(); // 此处略去 100 行 var b = require(&quot;./b&quot;); // 依赖可以就近书写 b.doSomething(); // ...&#125;);// AMD 默认推荐define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething(); // 此处略去 100 行 b.doSomething(); // ...&#125;) AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 谈谈对模块化开发的理解 我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。 由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。 后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。 现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/12-事件机制","date":"2021-08-13T15:17:37.213Z","updated":"2021-08-13T15:17:54.435Z","comments":true,"path":"2021/08/13/大前端/04-JavaScript进阶/12-事件机制/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/12-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"12 事件机制 涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？ 1. 简介 事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方法 事件流有三个阶段 事件捕获阶段 处于目标阶段 事件冒泡阶段 事件捕获 事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件 事件冒泡 事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点 无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播 2. 捕获和冒泡 1234567891011121314151617&lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; let div1 = document.getElementById(&#x27;div1&#x27;); let div2 = document.getElementById(&#x27;div2&#x27;); div1.onClick = function()&#123; alert(&#x27;1&#x27;) &#125; div2.onClick = function()&#123; alert(&#x27;2&#x27;); &#125;&lt;/script&gt; 当点击 div2时，会弹出两个弹出框。在 ie8/9/10、chrome浏览器，会先弹出”2”再弹出“1”，这就是事件冒泡：事件从最底层的节点向上冒泡传播。事件捕获则跟事件冒泡相反 W3C的标准是先捕获再冒泡， addEventListener的第三个参数决定把事件注册在捕获（true）还是冒泡(false) 3. 事件对象 4. 事件流阻止 在一些情况下需要阻止事件流的传播，阻止默认动作的发生 event.preventDefault()：取消事件对象的默认动作以及继续传播。 event.stopPropagation()/ event.cancelBubble = true：阻止事件冒泡。 事件的阻止在不同浏览器有不同处理 在IE下使用 event.returnValue= false， 在非IE下则使用 event.preventDefault()进行阻止 preventDefault与stopPropagation的区别 preventDefault告诉浏览器不用执行与事件相关联的默认动作（如表单提交） stopPropagation是停止事件继续冒泡，但是对IE9以下的浏览器无效 5. 事件注册 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false。useCapture 决定了注册的事件是捕获事件还是冒泡事件 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件 1node.addEventListener(&#x27;click&#x27;,(event) =&gt;&#123; event.stopImmediatePropagation() console.log(&#x27;冒泡&#x27;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&#x27;click&#x27;,(event) =&gt; &#123; console.log(&#x27;捕获 &#x27;)&#125;,true) 6. 事件委托 在js中性能优化的其中一个主要思想是减少dom操作。 节省内存 不需要给子节点注销事件 假设有100个li，每个li有相同的点击事件。如果为每个Li都添加事件，则会造成dom访问次数过多，引起浏览器重绘与重排的次数过多，性能则会降低。 使用事件委托则可以解决这样的问题 原理 实现事件委托是利用了事件的冒泡原理实现的。当我们为最外层的节点添加点击事件，那么里面的ul、li、a的点击事件都会冒泡到最外层节点上，委托它代为执行事件 123456789101112131415161718&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123; var ulEle = document.getElementById(&#x27;ul&#x27;); ul.onclick = function(ev)&#123; //兼容IE ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123; alert( target.innerHTML); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/07-闭包","date":"2021-08-13T15:15:36.470Z","updated":"2021-08-13T15:15:48.554Z","comments":true,"path":"2021/08/13/大前端/04-JavaScript进阶/07-闭包/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/07-%E9%97%AD%E5%8C%85/","excerpt":"","text":"#7 闭包 闭包其实就是一个可以访问其他函数内部变量的函数。创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。 因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。下面我们通过代码先来看一个简单的例子 1function fun1() &#123; var a = 1; return function()&#123; console.log(a); &#125;;&#125;fun1();var result = fun1();result(); // 1// 结合闭包的概念，我们把这段代码放到控制台执行一下，就可以发现最后输出的结果是 1（即 a 变量的值）。那么可以很清楚地发现，a 变量作为一个 fun1 函数的内部变量，正常情况下作为函数内的局部变量，是无法被外部访问到的。但是通过闭包，我们最后还是可以拿到 a 变量的值 闭包有两个常用的用途 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。 123456789101112131415let a = 1// fn 是闭包function fn() &#123; console.log(a);&#125;function fn1() &#123; let a = 1 // 这里也是闭包 return () =&gt; &#123; console.log(a); &#125;&#125;const fn2 = fn1()fn2() 大家都知道闭包其中一个作用是访问私有变量，就比如上述代码中的 fn2 访问到了 fn1 函数中的变量 a。但是此时 fn1 早已销毁，我们是如何访问到变量 a 的呢？不是都说原始类型是存放在栈上的么，为什么此时却没有被销毁掉？ 接下来笔者会根据浏览器的表现来重新理解关于原始类型存放位置的说法。 先来说下数据存放的正确规则是：局部、占用空间确定的数据，一般会存放在栈中，否则就在堆中（也有例外）。 那么接下来我们可以通过 Chrome 来帮助我们验证这个说法说法。 上图中画红框的位置我们能看到一个内部的对象 [[Scopes]]，其中存放着变量 a，该对象是被存放在堆上的，其中包含了闭包、全局对象等等内容，因此我们能通过闭包访问到本该销毁的变量。 另外最开始我们对于闭包的定位是：假如一个函数能访问外部的变量，那么这个函数它就是一个闭包，因此接下来我们看看在全局下的表现是怎么样的。 123456let a = 1var b = 2// fn 是闭包function fn() &#123; console.log(a, b);&#125; 从上图我们能发现全局下声明的变量，如果是 var 的话就直接被挂到 globe 上，如果是其他关键字声明的话就被挂到 Script 上。虽然这些内容同样还是存在 [[Scopes]]，但是全局变量应该是存放在静态区域的，因为全局变量无需进行垃圾回收，等需要回收的时候整个应用都没了。 只有在下图的场景中，原始类型才可能是被存储在栈上。 这里为什么要说可能，是因为 JS 是门动态类型语言，一个变量声明时可以是原始类型，马上又可以赋值为对象类型，然后又回到原始类型。这样频繁的在堆栈上切换存储位置，内部引擎是不是也会有什么优化手段，或者干脆全部都丢堆上？只有 const 声明的原始类型才一定存在栈上？当然这只是笔者的一个推测，暂时没有深究，读者可以忽略这段瞎想 因此笔者对于原始类型存储位置的理解为：局部变量才是被存储在栈上，全局变量存在静态区域上，其它都存储在堆上。 当然这个理解是建立的 Chrome 的表现之上的，在不同的浏览器上因为引擎的不同，可能存储的方式还是有所变化的。 闭包产生的原因 我们在前面介绍了作用域的概念，那么你还需要明白作用域链的基本概念。其实很简单，当访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，这样的链路就是作用域链 需要注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。那么我们还是通过下面的代码来详细说明一下作用域链 12345678var a = 1;function fun1() &#123; var a = 2 function fun2() &#123; var a = 3; console.log(a);//3 &#125;&#125; 从中可以看出，fun1 函数的作用域指向全局作用域（window）和它自己本身；fun2 函数的作用域指向全局作用域 （window）、fun1 和它本身；而作用域是从最底层向上找，直到找到全局作用域 window 为止，如果全局还没有的话就会报错。 那么这就很形象地说明了什么是作用域链，即当前函数一般都会存在上层函数的作用域的引用，那么他们就形成了一条作用域链。 由此可见，闭包产生的本质就是：当前环境中存在指向父级作用域的引用。那么还是拿上的代码举例。 123456789function fun1() &#123; var a = 2 function fun2() &#123; console.log(a); //2 &#125; return fun2;&#125;var result = fun1();result(); 从上面这段代码可以看出，这里 result 会拿到父级作用域中的变量，输出 2。因为在当前环境中，含有对 fun2 函数的引用，fun2 函数恰恰引用了 window、fun1 和 fun2 的作用域。因此 fun2 函数是可以访问到 fun1 函数的作用域的变量。 那是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此还可以这么改代码，如下所示 1var fun3;function fun1() &#123; var a = 2 fun3 = function() &#123; console.log(a); &#125;&#125;fun1();fun3(); 可以看出，其中实现的结果和前一段代码的效果其实是一样的，就是在给 fun3 函数赋值后，fun3 函数就拥有了 window、fun1 和 fun3 本身这几个作用域的访问权限；然后还是从下往上查找，直到找到 fun1 的作用域中存在 a 这个变量；因此输出的结果还是 2，最后产生了闭包，形式变了，本质没有改变。 因此最后返回的不管是不是函数，也都不能说明没有产生闭包 闭包的表现形式 返回一个函数 在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。请看下面这段代码，这些都是平常开发中用到的形式 12345678// 定时器setTimeout(function handler()&#123; console.log(&#x27;1&#x27;);&#125;，1000);// 事件监听$(&#x27;#app&#x27;).click(function()&#123; console.log(&#x27;Event Listener&#x27;);&#125;); 作为函数参数传递的形式，比如下面的例子。 12345678910111213var a = 1;function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; // 这就是闭包 fn();&#125;foo(); // 输出2，而不是1 IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量，如下所示 1234var a = 2;(function IIFE()&#123; console.log(a); // 输出2&#125;)(); IIFE 这个函数会稍微有些特殊，算是一种自执行匿名函数，这个匿名函数拥有独立的作用域。这不仅可以避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域，我们经常能在高级的 JavaScript 编程中看见此类函数。 如何解决循环输出问题？ 在互联网大厂的面试中，解决循环输出问题是比较高频的面试题，一般都会给一段这样的代码让你来解释 12345for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0)&#125; 上面这段代码执行之后，从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么一般面试官都会先问为什么都是 6？我想让你实现输出 1、2、3、4、5 的话怎么办呢？ 因此结合本讲所学的知识我们来思考一下，应该怎么给面试官一个满意的解释。你可以围绕这两点来回答。 setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行 因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。 那么我们再来看看如何按顺序依次输出 1、2、3、4、5 呢？ 利用 IIFE 可以利用 IIFE（立即执行函数），当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。 1234567for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i)&#125; 使用 ES6 中的 let ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行。通过改造后的代码，可以实现上面想要的结果。 12345for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0)&#125; 定时器传入第三个参数 setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。 1for(var i=1;i&lt;=5;i++)&#123; setTimeout(function(j) &#123; console.log(j) &#125;, 0, i)&#125; 从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径 常见考点 闭包能考的很多，概念和笔试题都会考。 概念题就是考考闭包是什么了。 笔试题的话基本都会结合上异步，比如最常见的： 1for (var i = 0; i &lt; 6; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;)&#125; 这道题会问输出什么，有哪几种方式可以得到想要的答案？","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/19-垃圾回收","date":"2021-08-13T15:12:42.299Z","updated":"2021-08-13T15:16:26.305Z","comments":true,"path":"2021/08/13/大前端/04-JavaScript进阶/19-垃圾回收/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/19-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"19 垃圾回收 对于在JavaScript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当JavaScript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。 内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。 JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。 针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数 标记清除 v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。 新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。 这个算法分为三步： 首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。 如果对象不存活，则释放对象的空间。 最后将 From 空间和 To 空间角色进行交换。 新生代对象晋升到老生代有两个条件： 第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老��代中；若没有经历，则复制到 To 空间。 第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行 #20 内存泄露 意外的全局变量: 无法被回收 定时器: 未被正确关闭，导致所引用的外部变量无法被释放 事件监听: 没有正确销毁 (低版本浏览器可能出现) 闭包 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。 dom 引用: dom 元素被删除时，内存中的引用未被正确清空 控制台console.log打印的东西 可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。 内存泄露排查方法(opens new window)","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/02-JS基础","date":"2021-08-13T15:08:54.528Z","updated":"2021-08-13T15:08:54.528Z","comments":true,"path":"2021/08/13/大前端/14-前端面试/02-JS基础/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/02-JS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/02进阶","date":"2021-08-13T15:08:33.543Z","updated":"2021-08-14T06:17:37.983Z","comments":true,"path":"2021/08/13/大前端/14-前端面试/02进阶/","link":"","permalink":"https://alloceee.github.io/2021/08/13/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/02%E8%BF%9B%E9%98%B6/","excerpt":"","text":"一、JS基础#1 类型及检测方式1. JS内置类型 JavaScript 的数据类型有下图所示 其中，前 7 种类型为基础类型，最后 1 种（Object）为引用类型，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型 JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）； 1种引用数据类型—— 1Object （Object本质上是由一组无序的名值对组成的）。里面包含 1function、Array、Date 等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。 引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function） 在这里，我想先请你重点了解下面两点，因为各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储： 原始数据类型：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用数据类型：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript 中的数据是如何存储在内存中的？ 在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。 在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个“closure(fn)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在“堆空间”中的。 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。 题目一：初出茅庐 123456789let a = &#123; name: &#x27;lee&#x27;, age: 18&#125;let b = a;console.log(a.name); //第一个consoleb.name = &#x27;son&#x27;;console.log(a.name); //第二个consoleconsole.log(b.name); //第三个console 这道题比较简单，我们可以看到第一个 console 打出来 name 是 ‘lee’，这应该没什么疑问；但是在执行了 b.name=’son’ 之后，结果你会发现 a 和 b 的属性 name 都是 ‘son’，第二个和第三个打印结果是一样的，这里就体现了引用类型的“共享”的特性，即这两个值都存在同一块内存中共享，一个发生了改变，另外一个也随之跟着变化。 你可以直接在 Chrome 控制台敲一遍，深入理解一下这部分概念。下面我们再看一段代码，它是比题目一稍复杂一些的对象属性变化问题。 题目二：渐入佳境 123456789101112131415let a = &#123; name: &#x27;Julia&#x27;, age: 20&#125;function change(o) &#123; o.age = 24; o = &#123; name: &#x27;Kath&#x27;, age: 30 &#125; return o;&#125;let b = change(a); // 注意这里没有new，后面new相关会有专门文章讲解console.log(b.age); // 第一个consoleconsole.log(a.age); // 第二个console 这道题涉及了 function，你通过上述代码可以看到第一个 console 的结果是 30，b 最后打印结果是 &#123;name: &quot;Kath&quot;, age: 30&#125;；第二个 console 的返回结果是 24，而 a 最后的打印结果是 &#123;name: &quot;Julia&quot;, age: 24&#125;。 是不是和你预想的有些区别？你要注意的是，这里的 function 和 return 带来了不一样的东西。 原因在于：函数传参进来的 o，传递的是对象在堆中的内存地址值，通过调用 o.age = 24（第 7 行代码）确实改变了 a 对象的 age 属性；但是第 12 行代码的 return 却又把 o 变成了另一个内存地址，将 &#123;name: &quot;Kath&quot;, age: 30&#125; 存入其中，最后返回 b 的值就变成了 &#123;name: &quot;Kath&quot;, age: 30&#125;。而如果把第 12 行去掉，那么 b 就会返回 undefined 2. 数据类型检测 （1）typeof typeof 对于原始类型来说，除了 null 都可以显示正确的类型 12345678console.log(typeof 2); // numberconsole.log(typeof true); // booleanconsole.log(typeof &#x27;str&#x27;); // stringconsole.log(typeof []); // object []数组的数据类型在 typeof 中被解释为 objectconsole.log(typeof function()&#123;&#125;); // functionconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof undefined); // undefinedconsole.log(typeof null); // object null 的数据类型被 typeof 解释为 object 1typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 `instanceof （2）instanceof 1instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype 12345678console.log(2 instanceof Number); // falseconsole.log(true instanceof Boolean); // false console.log(&#x27;str&#x27; instanceof String); // false console.log([] instanceof Array); // trueconsole.log(function()&#123;&#125; instanceof Function); // trueconsole.log(&#123;&#125; instanceof Object); // true // console.log(undefined instanceof Undefined);// console.log(null instanceof Null); instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型； 而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断 123456789101112131415// 我们也可以试着实现一下 instanceoffunction instanceof(left, right) &#123; // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) &#123; if (left === null) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; （3）constructor 123456console.log((2).constructor === Number); // trueconsole.log((true).constructor === Boolean); // trueconsole.log((&#x27;str&#x27;).constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() &#123;&#125;).constructor === Function); // trueconsole.log((&#123;&#125;).constructor === Object); // true 这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了 12345678function Fn()&#123;&#125;; Fn.prototype=new Array(); var f=new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true （4）Object.prototype.toString.call() toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。 123456789101112131415Object.prototype.toString(&#123;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也okObject.prototype.toString.call(1) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;1&#x27;) // &quot;[object String]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(function()&#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) //&quot;[object Null]&quot;Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;Object.prototype.toString.call(/123/g) //&quot;[object RegExp]&quot;Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;Object.prototype.toString.call([]) //&quot;[object Array]&quot;Object.prototype.toString.call(document) //&quot;[object HTMLDocument]&quot;Object.prototype.toString.call(window) //&quot;[object Window]&quot;// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。 实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下 1234567891011121314151617function getType(obj)&#123; let type = typeof obj; if (type !== &quot;object&quot;) &#123; // 先进行typeof判断，如果是基础数据类型，直接返回 return type; &#125; // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, &#x27;$1&#x27;); // 注意正则中间有个空格&#125;/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */getType([]) // &quot;Array&quot; typeof []是object，因此toString返回getType(&#x27;123&#x27;) // &quot;string&quot; typeof 直接返回getType(window) // &quot;Window&quot; toString返回getType(null) // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断getType(undefined) // &quot;undefined&quot; typeof 直接返回getType() // &quot;undefined&quot; typeof 直接返回getType(function()&#123;&#125;) // &quot;function&quot; typeof能判断，因此首字母小写getType(/123/g) //&quot;RegExp&quot; toString返回 小结 ```typeof 12345678 - 直接在计算机底层基于数据类型的值（二进制）进行检测 - `typeof null`为`object` 原因是对象存在在计算机中，都是以`000`开始的二进制存储，所以检测出来的结果是对象 - `typeof` 普通对象/数组对象/正则对象/日期对象 都是`object` - `typeof NaN === &#x27;number&#x27;`- ``` instanceof 检测当前实例是否属于这个类的 底层机制：只要当前类出现在实例的原型上，结果都是true 不能检测基本数据类型 ```constructor 123456 - 支持基本类型 - constructor可以随便改，也不准- ``` Object.prototype.toString.call([val]) 返回当前实例所属类信息 判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待: 基本类型(null): 使用 String(null) 基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断 3. 数据类型转换 我们先看一段代码，了解下大致的情况。 1234567891011121314151617181920212223&#x27;123&#x27; == 123 // false or true?&#x27;&#x27; == null // false or true?&#x27;&#x27; == 0 // false or true?[] == 0 // false or true?[] == &#x27;&#x27; // false or true?[] == ![] // false or true?null == undefined // false or true?Number(null) // 返回什么？Number(&#x27;&#x27;) // 返回什么？parseInt(&#x27;&#x27;); // 返回什么？&#123;&#125;+10 // 返回什么？let obj = &#123; [Symbol.toPrimitive]() &#123; return 200; &#125;, valueOf() &#123; return 300; &#125;, toString() &#123; return &#x27;Hello&#x27;; &#125;&#125;console.log(obj + 200); // 这里打印出来是多少？ 首先我们要知道，在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串 转Boolean 在条件判断时，除了 undefined，null， false， NaN， &#39;&#39;， 0， -0，其他所有值都转为 true，包括所有对象 1234567Boolean(0) //falseBoolean(null) //falseBoolean(undefined) //falseBoolean(NaN) //falseBoolean(1) //trueBoolean(13) //trueBoolean(&#x27;12&#x27;) //true 对象转原始类型 对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下 如果已经是原始类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回原始类型，就会报错 当然你也可以重写 Symbol.toPrimitive，该方法在转原始类型时调用优先级最高。 123456789101112let a = &#123; valueOf() &#123; return 0 &#125;, toString() &#123; return &#x27;1&#x27; &#125;, [Symbol.toPrimitive]() &#123; return 2 &#125;&#125;1 + a // =&gt; 3 四则运算符 它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 1231 + &#x27;1&#x27; // &#x27;11&#x27;true + true // 24 + [1,2,3] // &quot;41,2,3&quot; 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 &#39;11&#39; 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString转为字符串 1,2,3，得到结果 41,2,3 另外对于加法还需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; 1&#x27;a&#x27; + + &#x27;b&#x27; // -&gt; &quot;aNaN&quot; 因为 + &#39;b&#39; 等于 NaN，所以结果为 &quot;aNaN&quot;，你可能也会在一些代码中看到过 + &#39;1&#39;的形式来快速获取 number 类型。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 1234 * &#x27;3&#x27; // 124 * [] // 04 * [1, 2] // NaN 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0 &#125;, toString() &#123; return &#x27;1&#x27; &#125;&#125;a &gt; -1 // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。 强制类型转换 强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()，这几种方法都比较类似 Number() 方法的强制转换规则 如果是布尔值，true 和 false 分别被转换为 1 和 0； 如果是数字，返回自身； 如果是 null，返回 0； 如果是 undefined，返回 NaN； 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN； 如果是 Symbol，抛出错误； 如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值。 1Number(true); // 1Number(false); // 0Number(&#x27;0111&#x27;); //111Number(null); //0Number(&#x27;&#x27;); //0Number(&#x27;1a&#x27;); //NaNNumber(-0X11); //-17Number(&#x27;0X11&#x27;) //17 Object 的转换规则 对象转换的规则，会先调用内置的 [ToPrimitive] 函数，其规则逻辑如下： 如果部署了 Symbol.toPrimitive 方法，优先调用再返回； 调用 valueOf()，如果转换为基础类型，则返回； 调用 toString()，如果转换为基础类型，则返回； 如果都没有返回基础类型，会报错。 1var obj = &#123; value: 1, valueOf() &#123; return 2; &#125;, toString() &#123; return &#x27;3&#x27; &#125;, [Symbol.toPrimitive]() &#123; return 4 &#125;&#125;console.log(obj + 1); // 输出5// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回&#x27;31&#x27;(字符串拼接)// 再看两个特殊的case：10 + &#123;&#125;// &quot;10[object Object]&quot;，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果&quot;[object Object]&quot;，于是和10进行&#x27;+&#x27;运算，按照字符串拼接规则来，参考&#x27;+&#x27;的规则C[1,2,undefined,4,5] + 10// &quot;1,2,,4,510&quot;，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回&quot;1,2,,4,5&quot;，然后再和10进行运算，还是按照字符串拼接规则，参考&#x27;+&#x27;的第3条规则 ‘==’ 的隐式类型转换规则 如果类型相同，无须进行类型转换； 如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false； 如果其中一个是 Symbol 类型，那么返回 false； 两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number； 如果一个操作值是 boolean，那么转换成 number； 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。 1234567891011121314151617null == undefined // true 规则2null == 0 // false 规则2&#x27;&#x27; == null // false 规则2&#x27;&#x27; == 0 // true 规则4 字符串转隐式转换成Number之后再对比&#x27;123&#x27; == 123 // true 规则4 字符串转隐式转换成Number之后再对比0 == false // true e规则 布尔型隐式转换成Number之后再对比1 == true // true e规则 布尔型隐式转换成Number之后再对比var a = &#123; value: 0, valueOf: function() &#123; this.value++; return this.value; &#125;&#125;;// 注意这里a又可以等于1、2、3console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3); //true f规则 Object隐式转换// 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下 ‘+’ 的隐式类型转换规则 ‘+’ 号操作符，不仅可以用作数字相加，还可以用作字符串拼接。仅当 ‘+’ 号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。 如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。 如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。 如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接 1234567891011121 + 2 // 3 常规情况&#x27;1&#x27; + &#x27;2&#x27; // &#x27;12&#x27; 常规情况// 下面看一下特殊情况&#x27;1&#x27; + undefined // &quot;1undefined&quot; 规则1，undefined转换字符串&#x27;1&#x27; + null // &quot;1null&quot; 规则1，null转换字符串&#x27;1&#x27; + true // &quot;1true&quot; 规则1，true转换字符串&#x27;1&#x27; + 1n // &#x27;11&#x27; 比较特殊字符串和BigInt相加，BigInt转换为字符串1 + undefined // NaN 规则2，undefined转换数字相加NaN1 + null // 1 规则2，null转换为01 + true // 2 规则2，true转换为1，二者相加为21 + 1n // 错误 不能把BigInt和Number类型直接混合相加&#x27;1&#x27; + 3 // &#x27;13&#x27; 规则3，字符串拼接 整体来看，如果数据中有字符串，JavaScript 类型转换还是更倾向于转换成字符串，因为第三条规则中可以看到，在字符串和数字相加的过程中最后返回的还是字符串，这里需要关注一下 null 和 undefined 的区别？ 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 undefined 代表的含义是未定义， null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。 其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。 当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。 #2 This 不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数 我们先来看几个函数调用的场景 1function foo() &#123; console.log(this.a)&#125;var a = 1foo()const obj = &#123; a: 2, foo: foo&#125;obj.foo()const c = new foo() 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this 1function a() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind这类函数是无效的。 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。 那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？ 1let a = &#123;&#125;let fn = function () &#123; console.log(this) &#125;fn.bind().bind(a)() // =&gt; ? 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式 1// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window 1let a = &#123; name: &#x27;poetries&#x27; &#125;function foo() &#123; console.log(this.name)&#125;foo.bind(a)() // =&gt; &#x27;poetries&#x27; 以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 函数执行改变this 由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。 因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如 obj.fn()，便是 obj 调用了函数，既函数中的 this === obj fn()，这里可以看成 window.fn()，因此 this === window 但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向: call: fn.call(target, 1, 2) apply: fn.apply(target, [1, 2]) bind: fn.bind(target)(1,2) #3 apply/call/bind 原理 call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。 123func.call(thisArg, param1, param2, ...)func.apply(thisArg, [param1,param2,...])func.bind(thisArg, param1, param2, ...) 在浏览器里，在全局范围内this 指向window对象； 在函数中，this永远指向最后调用他的那个对象； 构造函数中，this指向new出来的那个新的对象； call、apply、bind中的this被强绑定在指定的那个对象上； 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来； apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。 12345678910let a = &#123; value: 1&#125;function getValue(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a, &#x27;poe&#x27;, &#x27;24&#x27;)getValue.apply(a, [&#x27;poe&#x27;, &#x27;24&#x27;]) bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化 方法的应用场景 下面几种应用场景，你多加体会就可以发现它们的理念都是“借用”方法的思路。我们来看看都有哪些。 判断数据类型 用 Object.prototype.toString 来判断类型是最合适的，借用它我们几乎可以判断所有类型的数据 1234567function getType(obj)&#123; let type = typeof obj; if (type !== &quot;object&quot;) &#123; return type; &#125; return Object.prototype.toString.call(obj).replace(/^$/, &#x27;$1&#x27;);&#125; 类数组借用方法 类数组因为不是真正的数组，所有没有数组类型上自带的种种方法，所以我们就可以利用一些方法去借用数组的方法，比如借用数组的 push 方法，看下面的一段代码。 123456789var arrayLike = &#123; 0: &#x27;java&#x27;, 1: &#x27;script&#x27;, length: 2&#125; Array.prototype.push.call(arrayLike, &#x27;jack&#x27;, &#x27;lily&#x27;); console.log(typeof arrayLike); // &#x27;object&#x27;console.log(arrayLike);// &#123;0: &quot;java&quot;, 1: &quot;script&quot;, 2: &quot;jack&quot;, 3: &quot;lily&quot;, length: 4&#125; 用 call 的方法来借用 Array 原型链上的 push 方法，可以实现一个类数组的 push 方法，给 arrayLike 添加新的元素 获取数组的最大 / 最小值 我们可以用 apply 来实现数组中判断最大 / 最小值，apply 直接传递数组作为调用方法的参数，也可以减少一步展开数组，可以直接使用 Math.max、Math.min 来获取数组的最大值 / 最小值，请看下面这段代码。 123456let arr = [13, 6, 10, 11, 16];const max = Math.max.apply(Math, arr); const min = Math.min.apply(Math, arr); console.log(max); // 16console.log(min); // 6 实现一个 bind 函数 对于实现以下几个函数，可以从几个方面思考 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ 123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== &#x27;function&#x27;) &#123; throw new TypeError(&#x27;Error&#x27;) &#125; var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 实现一个 call 函数 12345678910111213Function.prototype.myCall = function (context) &#123; var context = context || window // 给 context 添加一个属性 // getValue.call(a, &#x27;pp&#x27;, &#x27;24&#x27;) =&gt; a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, &#x27;pp&#x27;, &#x27;24&#x27;) =&gt; a.fn(&#x27;pp&#x27;, &#x27;24&#x27;) var result = context.fn(...args) // 删除 fn delete context.fn return result&#125; 实现一个 apply 函数 123456789101112131415161718192021Function.prototype.myApply = function(context = window, ...args) &#123; // this--&gt;func context--&gt; obj args--&gt; 传递过来的参数 // 在context上加一个唯一值不影响context上的属性 let key = Symbol(&#x27;key&#x27;) context[key] = this; // context为调用的上下文,this此处为函数，将这个函数作为context的方法 // let args = [...arguments].slice(1) //第一个参数为obj所以删除,伪数组转为数组 let result = context[key](args); // 这里和call传参不一样 delete context[key]; // 不删除会导致context属性越来越多 return result;&#125;// 使用function f(a,b)&#123; console.log(a,b) console.log(this.name)&#125;let obj=&#123; name:&#x27;张三&#x27;&#125;f.myApply(obj,[1,2]) //arguments[1] #4 变量提升 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。 12345678b() // call bconsole.log(a) // undefinedvar a = &#x27;Hello world&#x27;function b() &#123; console.log(&#x27;call b&#x27;)&#125; 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 123456789b() // call b secondfunction b() &#123; console.log(&#x27;call b fist&#x27;)&#125;function b() &#123; console.log(&#x27;call b second&#x27;)&#125;var b = &#x27;Hello world&#x27; var 会产生很多错误，所以在 ES6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用 #5 执行上下文 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了） this 12345var a = 10function foo(i) &#123; var b = 20&#125;foo() 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。 1234stack = [ globalContext, fooContext] 对于全局上下文来说，VO大概是这样的 1globalContext.VO === globeglobalContext.VO = &#123; a: undefined, foo: &lt;Function&gt;,&#125; 对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO） 1fooContext.VO === foo.AOfooContext.AO &#123; i: undefined, b: undefined, arguments: &lt;&gt;&#125;// arguments 是函数独有的对象(箭头函数没有)// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素// 该对象中的 `callee` 属性代表函数本身// `caller` 属性代表函数的调用者 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]]属性查找上级变量 1fooContext.[[Scope]] = [ globalContext.VO]fooContext.Scope = fooContext.[[Scope]] + fooContext.VOfooContext.Scope = [ fooContext.VO, globalContext.VO] 接下来让我们看一个老生常谈的例子，var 1b() // call bconsole.log(a) // undefinedvar a = &#x27;Hello world&#x27;function b() &#123; console.log(&#x27;call b&#x27;)&#125; 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 1b() // call b secondfunction b() &#123; console.log(&#x27;call b fist&#x27;)&#125;function b() &#123; console.log(&#x27;call b second&#x27;)&#125;var b = &#x27;Hello world&#x27; var会产生很多错误，所以在 ES6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。 对于非匿名的立即执行函数需要注意以下一点 12345var foo = 1(function foo() &#123; foo = 10 console.log(foo)&#125;()) // -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125; 因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。 123456789specialObject = &#123;&#125;;Scope = specialObject + Scope;foo = new FunctionExpression;foo.[[Scope]] = Scope;specialObject.foo = foo; // &#123;DontDelete&#125;, &#123;ReadOnly&#125;delete Scope[0]; // remove specialObject from the front of scope chain 总结 执行上下文可以简单理解为一个对象: 它包含三个部分: 变量对象(VO) 作用域链(词法作用域) this指向 它的类型: 全局执行上下文 函数执行上下文 eval执行上下文 代码执行过程: 创建 全局上下文 (global EC) 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行 #6 作用域 作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找 作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。 当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找 作用域链的创建过程跟执行上下文的建立有关…. 作用域可以理解为变量的可访问性，总共分为三种类型，分别为： 全局作用域 函数作用域 块级作用域，ES6 中的 let、const 就可以产生该作用域 其实看完前面的闭包、this 这部分内部的话，应该基本能了解作用域的一些应用。 一旦我们将这些作用域嵌套起来，就变成了另外一个重要的知识点「作用域链」，也就是 JS 到底是如何访问需要的变量或者函数的。 首先作用域链是在定义时就被确定下来的，和箭头函数里的 this 一样，后续不会改变，JS 会一层层往上寻找需要的内容。 其实作用域链这个东西我们在闭包小结中已经看到过它的实体了：[[Scopes]] 图中的 [[Scopes]] 是个数组，作用域的一层层往上寻找就等同于遍历 [[Scopes]]。 1. 全局作用域 全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量 1234567891011121314var globalName = &#x27;global&#x27;;function getName() &#123; console.log(globalName) // global var name = &#x27;inner&#x27; console.log(name) // inner&#125; getName();console.log(name); // console.log(globalName); //globalfunction setName()&#123; vName = &#x27;setName&#x27;;&#125;setName();console.log(vName); // setName 从这段代码中我们可以看到，globalName 这个变量无论在什么地方都是可以被访问到的，所以它就是全局变量。而在 getName 函数中作为局部变量的 name 变量是不具备这种能力的 当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。 2. 函数作用域 函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域 123456function getName () &#123; var name = &#x27;inner&#x27;; console.log(name); //inner&#125;getName();console.log(name); 除了这个函数内部，其他地方都是不能访问到它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 getName 函数外面的 name 是访问不到的 3. 块级作用域 ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。 在 JS 编码过程中 if 语句及 for 语句后面 &#123;...&#125; 这里面所包括的，就是块级作用域 1console.log(a) //a is not definedif(true)&#123; let a = &#x27;123&#x27;； console.log(a)； // 123&#125;console.log(a) //a is not defined 从这段代码可以看出，变量 a 是在 if 语句&#123;...&#125; 中由 let 关键词进行定义的变量，所以它的作用域是 if 语句括号中的那部分，而在外面进行访问 a 变量是会报错的，因为这里不是它的作用域。所以在 if 代码块的前后输出 a 这个变量的结果，控制台会显示 a 并没有定义 #8 New的原理常见考点 new 做了那些事？ new 返回不同的类型时会有什么表现？ 手写 new 的实现过程 new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递。下面我们通过一段代码来看一个简单的 new 的例子 1function Person()&#123; this.name = &#x27;Jack&#x27;;&#125;var p = new Person(); console.log(p.name) // Jack 这段代码比较容易理解，从输出结果可以看出，p 是一个通过 person 这个构造函数生成的一个实例对象，这个应该很容易理解。 new 操作符可以帮助我们构建出一个实例，并且绑定上 this，内部执行步骤可大概分为以下几步： 创建一个新对象 对象连接到构造函数原型上，并绑定 this（this 指向新对象） 执行构造函数代码（为这个新对象添加属性） 返回新对象 在第四步返回新对象这边有一个情况会例外： 那么问题来了，如果不用 new 这个关键词，结合上面的代码改造一下，去掉 new，会发生什么样的变化呢？我们再来看下面这段代码 1234567function Person()&#123; this.name = &#x27;Jack&#x27;;&#125;var p = Person();console.log(p) // undefinedconsole.log(name) // Jackconsole.log(p.name) // &#x27;name&#x27; of undefined 从上面的代码中可以看到，我们没有使用 new 这个关键词，返回的结果就是 undefined。其中由于 JavaScript 代码在默认情况下 this 的指向是 window，那么 name 的输出结果就为 Jack，这是一种不存在 new 关键词的情况。 那么当构造函数中有 return 一个对象的操作，结果又会是什么样子呢？我们再来看一段在上面的基础上改造过的代码。 12345678function Person()&#123; this.name = &#x27;Jack&#x27;; return &#123;age: 18&#125;&#125;var p = new Person(); console.log(p) // &#123;age: 18&#125;console.log(p.name) // undefinedconsole.log(p.age) // 18 通过这段代码又可以看出，当构造函数最后 return 出来的是一个和 this 无关的对象时，new 命令会直接返回这个新对象，而不是通过 new 执行步骤生成的 this 对象 但是这里要求构造函数必须是返回一个对象，如果返回的不是对象，那么还是会按照 new 的实现步骤，返回新生成的对象。接下来还是在上面这段代码的基础之上稍微改动一下 1234567function Person()&#123; this.name = &#x27;Jack&#x27;; return &#x27;tom&#x27;;&#125;var p = new Person(); console.log(p) // &#123;name: &#x27;Jack&#x27;&#125;console.log(p.name) // Jack 可以看出，当构造函数中 return 的不是一个对象时，那么它还是会根据 new 关键词的执行逻辑，生成一个新的对象（绑定了最新 this），最后返回出来 因此我们总结一下：new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象 手工实现New的过程 12345678910111213141516171819function create(fn, ...args) &#123; if(typeof fn !== &#x27;function&#x27;) &#123; throw &#x27;fn must be a function&#x27;; &#125; // 1、用new Object() 的方式新建了一个对象obj // var obj = new Object() // 2、给该对象的__proto__赋值为fn.prototype，即设置原型链 // obj.__proto__ = fn.prototype // 1、2步骤合并 // 创建一个空对象，且这个空对象继承构造函数的 prototype 属性 // 即实现 obj.__proto__ === constructor.prototype var obj = Object.create(fn.prototype); // 3、执行fn，并将obj作为内部this。使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 var res = fn.apply(obj, args); // 4、如果fn有返回值，则将其作为new操作返回内容，否则返回obj return res instanceof Object ? res : obj;&#125;; 使用 Object.create 将 obj 的proto指向为构造函数的原型； 使用 apply 方法，将构造函数内的 this 指向为 obj； 在 create 返回时，使用三目运算符决定返回结果。 我们知道，构造函数如果有显式返回值，且返回值为对象类型，那么构造函数返回结果不再是目标实例 如下代码： 1234567function Person(name) &#123; this.name = name return &#123;1: 1&#125;&#125;const person = new Person(Person, &#x27;lucas&#x27;)console.log(person)// &#123;1: 1&#125; 测试 1234567//使用create代替newfunction Person() &#123;...&#125;// 使用内置函数newvar person = new Person(1,2)// 使用手写的new，即createvar person = create(Person, 1,2) new 被调用后大致做了哪几件事情 让实例可以访问到私有属性； 让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性； 构造函数返回的最后结果是引用数据类型。 #9 原型/原型链__proto__和prototype关系：__proto__和constructor是对象独有的。2️⃣prototype属性是函数独有的 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。 特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。 构造函数: 可以通过new来 新建一个对象 的函数。 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。 以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。 12// 实例const instance = new Object() 则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为: 12// 原型const prototype = Object.prototype 这里我们可以来看出三者的关系: 实例.__proto__ === 原型 原型.constructor === 构造函数 构造函数.prototype === 原型 1234567// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线// 例如: // const o = new Object()// o.constructor === Object --&gt; true// o.__proto__ = null;// o.constructor === Object --&gt; false实例.constructor === 构造函数 原型链 原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined； 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。 js 获取原型的方法 p.proto p.constructor.prototype Object.getPrototypeOf(p) 总结 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]]是内部属性，我们并不能访问到，所以使用 _proto_来访问。 对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。 #10 继承 涉及面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ 首先先来讲下 class，其实在 JS中并不存在类，class 只是语法糖，本质还是函数 12class Person &#123;&#125;Person instanceof Function // true 组合继承 组合继承是最常用的继承方式 123456789101112131415function Parent(value) &#123; this.val = value&#125;Parent.prototype.getValue = function() &#123; console.log(this.val)&#125;function Child(value) &#123; Parent.call(this, value)&#125;Child.prototype = new Parent()const child = new Child(1)child.getValue() // 1child instanceof Parent // true 以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费 寄生组合继承 这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了 1234567891011121314151617181920212223function Parent(value) &#123; this.val = value&#125;Parent.prototype.getValue = function() &#123; console.log(this.val)&#125;function Child(value) &#123; Parent.call(this, value)&#125;Child.prototype = Object.create(Parent.prototype, &#123; constructor: &#123; value: Child, enumerable: false, writable: true, configurable: true &#125;&#125;)const child = new Child(1)child.getValue() // 1child instanceof Parent // true 以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。 Class 继承 以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单 1234567891011121314151617class Parent &#123; constructor(value) &#123; this.val = value &#125; getValue() &#123; console.log(this.val) &#125;&#125;class Child extends Parent &#123; constructor(value) &#123; super(value) this.val = value &#125;&#125;let child = new Child(1)child.getValue() // 1child instanceof Parent // true class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 ES5 和 ES6 继承的区别： ES6 继承的子类需要调用 super() 才能拿到子类，ES5 的话是通过 apply 这种绑定的方式 类声明不会提升，和 let 这些一致 12345678910111213141516function Super() &#123;&#125;Super.prototype.getNumber = function() &#123; return 1&#125;function Sub() &#123;&#125;Sub.prototype = Object.create(Super.prototype, &#123; constructor: &#123; value: Sub, enumerable: false, writable: true, configurable: true &#125;&#125;)let s = new Sub()s.getNumber() 以下详细讲解几种常见的继承方式 1. 方式1: 借助call 12345678function Parent1()&#123; this.name = &#x27;parent1&#x27;; &#125; function Child1()&#123; Parent1.call(this); this.type = &#x27;child1&#x27; &#125; console.log(new Child1); 这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。 2. 方式2: 借助原型链 12345678910function Parent2() &#123; this.name = &#x27;parent2&#x27;; this.play = [1, 2, 3] &#125; function Child2() &#123; this.type = &#x27;child2&#x27;; &#125; Child2.prototype = new Parent2(); console.log(new Child2()); 看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子： 1234var s1 = new Child2();var s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play); 可以看到控制台： 明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。 那么还有更好的方式么？ 3. 方式3：将前两种组合 12345678910111213function Parent3 () &#123; this.name = &#x27;parent3&#x27;; this.play = [1, 2, 3];&#125;function Child3() &#123; Parent3.call(this); this.type = &#x27;child3&#x27;;&#125;Child3.prototype = new Parent3();var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play); 可以看到控制台： 之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？ 4. 方式4: 组合继承的优化1 123456789function Parent4 () &#123; this.name = &#x27;parent4&#x27;; this.play = [1, 2, 3];&#125;function Child4() &#123; Parent4.call(this); this.type = &#x27;child4&#x27;;&#125;Child4.prototype = Parent4.prototype; 这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下： 123var s3 = new Child4();var s4 = new Child4();console.log(s3) 子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。 5. 方式5(最推荐使用): 组合继承的优化2 12345678910function Parent5 () &#123; this.name = &#x27;parent5&#x27;; this.play = [1, 2, 3]; &#125; function Child5() &#123; Parent5.call(this); this.type = &#x27;child5&#x27;; &#125; Child5.prototype = Object.create(Parent5.prototype); Child5.prototype.constructor = Child5; 这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。 6. ES6的extends被编译后的JavaScript代码 ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。 那最后编译成了什么样子呢？ 123456789101112131415161718192021222324252627282930313233343536function _possibleConstructorReturn(self, call) &#123; // ... return call &amp;&amp; (typeof call === &#x27;object&#x27; || typeof call === &#x27;function&#x27;) ? call : self;&#125;function _inherits(subClass, superClass) &#123; // ... //看到没有 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;var Parent = function Parent() &#123; // 验证是否是 Parent 构造出来的 this _classCallCheck(this, Parent);&#125;;var Child = (function (_Parent) &#123; _inherits(Child, _Parent); function Child() &#123; _classCallCheck(this, Child); return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments)); &#125; return Child;&#125;(Parent)); 核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？ 答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。 追问: 面向对象的设计一定是好的设计吗？ 不一定。从继承的角度说，这一设计是存在巨大隐患的。 #11 面向对象编程思想 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计 优点 易维护 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的 易扩展 开发工作的重用性、继承性高，降低重复工作量。 缩短了开发周期 一般面向对象包含：继承，封装，多态，抽象 1. 对象形式的继承 浅拷贝 1var Person = &#123; name: &#x27;allin&#x27;, age: 18, address: &#123; home: &#x27;home&#x27;, office: &#x27;office&#x27;, &#125; sclools: [&#x27;x&#x27;,&#x27;z&#x27;],&#125;;var programer = &#123; language: &#x27;js&#x27;,&#125;;function extend(p, c)&#123; var c = c || &#123;&#125;; for( var prop in p)&#123; c[prop] = p[prop]; &#125;&#125;extend(Person, programer);programer.name; // allinprogramer.address.home; // homeprogramer.address.home = &#x27;house&#x27;; //housePerson.address.home; // house 从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本 深拷贝 1function extendDeeply(p, c)&#123; var c = c || &#123;&#125;; for (var prop in p)&#123; if(typeof p[prop] === &quot;object&quot;)&#123; c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;; extendDeeply(p[prop], c[prop]); &#125;else&#123; c[prop] = p[prop]; &#125; &#125;&#125; 利用递归进行深拷贝，这样子对象的修改就不会影响到父对象 1extendDeeply(Person, programer);programer.address.home = &#x27;allin&#x27;;Person.address.home; // home 利用call和apply继承 12345678function Parent()&#123; this.name = &quot;abc&quot;; this.address = &#123;home: &quot;home&quot;&#125;;&#125;function Child()&#123; Parent.call(this); this.language = &quot;js&quot;; &#125; ES5中的Object.create() 123var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = Object.create(o);obj.name; // allin Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法： 12345678910//模拟Object.create()方法function myCreate(o)&#123; function F()&#123;&#125;; F.prototype = o; o = new F(); return o;&#125;var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = myCreate(o);obj.name; // allin 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署 1234567 if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 2. 类的继承 1Object.create() 123456789function Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer; // 修改constructor的指向 调用父类方法 12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123; Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = &quot;js&quot;;Programmer.prototype.work = function()&#123; console.log(&#x27;i am working code in &#x27;+ this.language); Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125; 3. 封装 命名空间 js是没有命名空间的，因此可以用对象模拟 12345678910var app = &#123;&#125;; // 命名空间app//模块1app.module1 = &#123; name: &#x27;allin&#x27;, f: function()&#123; console.log(&#x27;hi robot&#x27;); &#125;&#125;;app.module1.name; // &quot;allin&quot;app.module1.f(); // hi robot 对象的属性外界是可读可写 如何来达到封装的额目的？答：可通过闭包+局部变量来完成 在构造函数内部声明局部变量 和普通方法 因为作用域的关系 只有构造函数内的方法 才能访问局部变量 而方法对于外界是开放的 因此可以通过方法来访问 原本外界访问不到的局部变量 达到函数封装的目的 123456789101112131415161718192021222324252627282930313233function Girl(name,age)&#123; var love = &#x27;小明&#x27;;//love 是局部变量 准确说不属于对象 属于这个函数的额激活对象 函数调用时必将产生一个激活对象 love在激活对象身上 激活对象有作用域的关系 有办法访问 加一个函数提供外界访问 this.name = name; this.age = age; this.say = function () &#123; return love; &#125;; this.movelove = function ()&#123; love = &#x27;小轩&#x27;; //35 &#125;&#125; var g = new Girl(&#x27;yinghong&#x27;,22);console.log(g);console.log(g.say());//小明console.log(g.movelove());//undefined 因为35行没有返回console.log(g.say());//小轩function fn()&#123; function t()&#123; //var age = 22;//声明age变量 在t的激活对象上 age = 22;//赋值操作 t的激活对象上找age属性 ，找不到 找fn的激活对象....再找到 最终找到window.age = 22; //不加var就是操作window全局属性 &#125; t();&#125;console.log(fn());//undefined 4. 静态成员 面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性 123456789function Person(name)&#123; var age = 100; this.name = name;&#125;//静态成员Person.walk = function()&#123; console.log(&#x27;static&#x27;);&#125;;Person.walk(); // static 5. 私有与公有 1234567891011121314151617function Person(id)&#123; // 私有属性与方法 var name = &#x27;allin&#x27;; var work = function()&#123; console.log(this.id); &#125;; //公有属性与方法 this.id = id; this.say = function()&#123; console.log(&#x27;say hello&#x27;); work.call(this); &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id; // 123p1.say(); // say hello 123 6. 模块化 1234567891011var moduleA;moduleA = function() &#123; var prop = 1; function func() &#123;&#125; return &#123; func: func, prop: prop &#125;;&#125;(); // 立即执行匿名函数 7. 多态 多态:同一个父类继承出来的子类各有各的形态 123456789101112131415161718192021222324252627282930function Cat()&#123; this.eat = &#x27;肉&#x27;;&#125;function Tiger()&#123; this.color = &#x27;黑黄相间&#x27;;&#125;function Cheetah()&#123; this.color = &#x27;报文&#x27;;&#125;function Lion()&#123; this.color = &#x27;土黄色&#x27;;&#125;Tiger.prototype = Cheetah.prototype = Lion.prototype = new Cat();//共享一个祖先 Catvar T = new Tiger();var C = new Cheetah();var L = new Lion();console.log(T.color);console.log(C.color);console.log(L.color);console.log(T.eat);console.log(C.eat);console.log(L.eat); 8. 抽象类 在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用 12345678910111213141516171819202122232425function DetectorBase() &#123; throw new Error(&#x27;Abstract class can not be invoked directly!&#x27;);&#125;DetectorBase.prototype.detect = function() &#123; console.log(&#x27;Detection starting...&#x27;);&#125;;DetectorBase.prototype.stop = function() &#123; console.log(&#x27;Detection stopped.&#x27;);&#125;;DetectorBase.prototype.init = function() &#123; throw new Error(&#x27;Error&#x27;);&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error #14 Iterator迭代器 Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator语法： 123const obj = &#123; [Symbol.iterator]:function()&#123;&#125;&#125; [Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。 迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据 每一次的 1next 都会返回一个对象，该对象有两个属性 value 代表想要获取的数据 done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束 Iterator 的作用有三个： 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 123456let arr = [&#123;num:1&#125;,2,3]let it = arr[Symbol.iterator]() // 获取数组中的迭代器console.log(it.next()) // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;console.log(it.next()) // &#123; value: 2, done: false &#125;console.log(it.next()) // &#123; value: 3, done: false &#125;console.log(it.next()) // &#123; value: undefined, done: true &#125; 对象没有布局Iterator接口，无法使用for of 遍历。下面使得对象具备Iterator接口 一个数据结构只要有Symbol.iterator属性，就可以认为是“可遍历的” 原型部署了Iterator接口的数据结构有三种，具体包含四种，分别是数组，类似数组的对象，Set和Map结构 为什么对象（Object）没有部署Iterator接口呢？ 一是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。然而遍历遍历器是一种线性处理，对于非线性的数据结构，部署遍历器接口，就等于要部署一种线性转换 对对象部署Iterator接口并不是很必要，因为Map弥补了它的缺陷，又正好有Iteraotr接口 12345678910111213141516171819202122232425262728let obj = &#123; id: &#x27;123&#x27;, name: &#x27;张三&#x27;, age: 18, gender: &#x27;男&#x27;, hobbie: &#x27;睡觉&#x27;&#125;obj[Symbol.iterator] = function () &#123; let keyArr = Object.keys(obj) let index = 0 return &#123; next() &#123; return index &lt; keyArr.length ? &#123; value: &#123; key: keyArr[index], val: obj[keyArr[index++]] &#125; &#125; : &#123; done: true &#125; &#125; &#125;&#125;for (let key of obj) &#123; console.log(key)&#125; #15 Promise 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人） Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap 1. Promise 的基本情况 简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息 一般 Promise 在执行过程中，必然会处于以下几种状态之一。 待定（pending）：初始状态，既没有被完成，也没有被拒绝。 已完成（fulfilled）：操作成功完成。 已拒绝（rejected）：操作失败。 待定状态的 Promise 对象执行的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生时，我们用 Promise 的 then 方法排列起来的相关处理程序就会被调用。因为最后 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是一个 Promise， 所以它们可以继续被链式调用 关于 Promise 的状态流转情况，有一点值得注意的是，内部状态改变之后不可逆，你需要在编程过程中加以注意。文字描述比较晦涩，我们直接通过一张图就能很清晰地看出 Promise 内部状态流转的情况 从上图可以看出，我们最开始创建一个新的 Promise 返回给 p1 ，然后开始执行，状态是 pending，当执行 resolve之后状态就切换为 fulfilled，执行 reject 之后就变为 rejected 的状态 2. Promise 的静态方法 ```all 方法 123456789- 语法： `Promise.all（iterable）`- 参数： 一个可迭代对象，如 `Array`。- 描述： 此方法对于汇总多个 promise 1234567 的结果很有用，在 ES6 中可以将多个 Promise.all 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 异步请求并行操作，返回结果一般有下面两种情况。 - 当所有结果成功返回时按照请求顺序返回成功结果。 - 当其中有一个失败方法时，则进入失败方法- 我们来看下业务的场景，对于下面这个业务场景页面的加载，将多个请求合并到一起，用 all 来实现可能效果会更好，请看代码片段```js// 在一个页面中需要加载获取轮播列表、获取店铺列表、获取分类列表这三个操作，页面需要同时发出请求进行页面渲染，这样用 `Promise.all` 来实现，看起来更清晰、一目了然。//1.获取轮播数据列表function getBannerList()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function()&#123; resolve(&#x27;轮播数据&#x27;) &#125;,300) &#125;)&#125;//2.获取店铺列表function getStoreList()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function()&#123; resolve(&#x27;店铺数据&#x27;) &#125;,500) &#125;)&#125;//3.获取分类列表function getCategoryList()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function()&#123; resolve(&#x27;分类数据&#x27;) &#125;,700) &#125;)&#125;function initLoad()&#123; Promise.all([getBannerList(),getStoreList(),getCategoryList()]) .then(res=&gt;&#123; console.log(res) &#125;).catch(err=&gt;&#123; console.log(err) &#125;)&#125; initLoad() ```allSettled 123456789101112131415161718192021 方法 - `Promise.allSettled` 的语法及参数跟 `Promise.all` 类似，其参数接受一个 `Promise` 的数组，返回一个新的 `Promise`。`唯一的不同在于，执行完之后不会失败`，也就是说当 `Promise.allSettled` 全部处理完成后，我们可以拿到每个 `Promise` 的状态，而不管其是否处理成功- 我们来看一下用 `allSettled` 实现的一段代码```jsconst resolved = Promise.resolve(2);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// 返回结果：// [// &#123; status: &#x27;fulfilled&#x27;, value: 2 &#125;,// &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;// ] 从上面代码中可以看到，Promise.allSettled 最后返回的是一个数组，记录传进来的参数中每个 Promise 的返回值，这就是和 all 方法不太一样的地方。 ```any123456789101112131415161718 方法 - 语法： `Promise.any（iterable）` - 参数： `iterable` 可迭代的对象，例如 `Array`。 - 描述： `any` 方法返回一个 `Promise`，只要参数 `Promise` 实例有一个变成 `fulfilled`状态，最后 `any`返回的实例就会变成 `fulfilled` 状态；如果所有参数 `Promise` 实例都变成 `rejected` 状态，包装实例就会变成 `rejected` 状态。```jsconst resolved = Promise.resolve(2);const rejected = Promise.reject(-1);const anyPromise = Promise.any([resolved, rejected]);anyPromise.then(function (results) &#123; console.log(results);&#125;);// 返回结果：// 2 从改造后的代码中可以看出，只要其中一个 Promise 变成 fulfilled状态，那么 any 最后就返回这个p romise。由于上面 resolved 这个 Promise 已经是 resolve 的了，故最后返回结果为 2 ```race1234567891011121314151617181920212223242526272829303132333435363738 方法 - 语法： `Promise.race（iterable）` - 参数： `iterable` 可迭代的对象，例如 `Array`。 - 描述： `race`方法返回一个 `Promise`，只要参数的 `Promise` 之中有一个实例率先改变状态，则 `race` 方法的返回状态就跟着改变。那个率先改变的 `Promise` 实例的返回值，就传递给 `race` 方法的回调函数- 我们来看一下这个业务场景，对于图片的加载，特别适合用 race 方法来解决，将图片请求和超时判断放到一起，用 race 来实现图片的超时判断。请看代码片段。```js//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = &#x27;http://www.baidu.com/img/flexible/logo/pc/result.png&#x27;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject(&#x27;图片请求超时&#x27;); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;);// 从上面的代码中可以看出，采用 Promise 的方式来判断图片是否加载成功，也是针对 Promise.race 方法的一个比较好的业务场景 promise手写实现，面试够用版： 123456789101112131415161718192021222324252627282930313233343536373839function myPromise(constructor)&#123; let self=this; self.status=&quot;pending&quot; //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value)&#123; //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;)&#123; self.value=value; self.status=&quot;resolved&quot;; &#125; &#125; function reject(reason)&#123; //两个===&quot;pending&quot;，保证了状态的改变是不可逆的 if(self.status===&quot;pending&quot;)&#123; self.reason=reason; self.status=&quot;rejected&quot;; &#125; &#125; //捕获构造异常 try&#123; constructor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125;&#125;// 定义链式调用的then方法myPromise.prototype.then=function(onFullfilled,onRejected)&#123; let self=this; switch(self.status)&#123; case &quot;resolved&quot;: onFullfilled(self.value); break; case &quot;rejected&quot;: onRejected(self.reason); break; default: &#125;&#125; #16 Generator Generator 是 ES6中新增的语法，和 Promise 一样，都可以用来异步编程。Generator函数可以说是Iterator接口的具体实现方式。Generator 最大的特点就是可以控制函数的执行。 function* 用来声明一个函数是生成器函数，它比普通的函数声明多了一个*,*的位置比较随意可以挨着 function 关键字，也可以挨着函数名 yield 产出的意思，这个关键字只能出现在生成器函数体内，但是生成器中也可以没有yield 关键字，函数遇到 yield 的时候会暂停，并把 yield 后面的表达式结果抛出去 next作用是将代码的控制权交还给生成器函数 123456789function *foo(x) &#123; let y = 2 * (yield (x + 1)) let z = yield (y / 3) return (x + y + z)&#125;let it = foo(5)console.log(it.next()) // =&gt; &#123;value: 6, done: false&#125;console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125; 上面这个示例就是一个Generator函数，我们来分析其执行过程： 首先 Generator 函数调用时它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 yield实际就是暂缓执行的标示，每执行一次next()，相当于指针移动到下一个yield位置 总结一下，Generator函数是ES6提供的一种异步编程解决方案。通过yield标识位和next()方法调用，实现函数的分段执行 遍历器对象生成函数，最大的特点是可以交出函数的执行权 function 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下 回调函数 事件监听 发布/订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。 123456789101112// 使用 * 表示这是一个 Generator 函数// 内部可以通过 yield 暂停代码// 通过调用 next 恢复执行function* test() &#123; let a = 1 + 2; yield 2; yield 3;&#125;let b = test();console.log(b.next()); // &gt; &#123; value: 2, done: false &#125;console.log(b.next()); // &gt; &#123; value: 3, done: false &#125;console.log(b.next()); // &gt; &#123; value: undefined, done: true &#125; 从以上代码可以发现，加上 *的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// cb 也就是编译过的 test 函数function generator(cb) &#123; return (function() &#123; var object = &#123; next: 0, stop: function() &#123;&#125; &#125;; return &#123; next: function() &#123; var ret = cb(object); if (ret === undefined) return &#123; value: undefined, done: true &#125;; return &#123; value: ret, done: false &#125;; &#125; &#125;; &#125;)();&#125;// 如果你使用 babel 编译后可以发现 test 函数变成了这样function test() &#123; var a; return generator(function(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case &quot;end&quot;: return _context.stop(); &#125; &#125; &#125;);&#125; #17 async/await Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。 await 和 promise 一样，更多的是考笔试题，当然偶尔也会问到和 promise 的一些区别。 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，此时更应该使用 Promise.all。 一个函数如果加上 async ，那么该函数就会返回一个 Promise async =&gt; * await =&gt; yield 123456789101112// 基本用法async function timeout (ms) &#123; await new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncConsole (value, ms) &#123; await timeout(ms) console.log(value)&#125;asyncConsole(&#x27;hello async and await&#x27;, 1000) 下面来看一个使用 await 的代码。 12345678910var a = 0var b = async () =&gt; &#123; a = a + await 10 console.log(&#x27;2&#x27;, a) // -&gt; &#x27;2&#x27; 10 a = (await 10) + a console.log(&#x27;3&#x27;, a) // -&gt; &#x27;3&#x27; 20&#125;b()a++console.log(&#x27;1&#x27;, a) // -&gt; &#x27;1&#x27; 1 首先函数b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来 因为 await 是异步操作，遇到await就会立即返回一个pending状态的Promise对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 console.log(&#39;1&#39;, a) 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 10 然后后面就是常规执行代码了 优缺点： async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 async原理 async/await语法糖就是使用Generator函数+自动执行器来运作的 12345678910111213141516171819202122232425262728293031// 定义了一个promise，用来模拟异步请求，作用是传入参数++function getNum(num)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(num+1) &#125;, 1000) &#125;)&#125;//自动执行器，如果一个Generator函数没有执行完，则递归调用function asyncFun(func)&#123; var gen = func(); function next(data)&#123; var result = gen.next(data); if (result.done) return result.value; result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步var func = function* ()&#123; var f1 = yield getNum(1); var f2 = yield getNum(f1); console.log(f2) ;&#125;;asyncFun(func); 在执行的过程中，判断一个函数的promise是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤 每一个 next() 方法返回值的 value 属性为一个 Promise 对象，所以我们为其添加 then 方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator函数运行完成 #18 事件循环 默认代码从上到下执行，执行环境通过script来执行（宏任务） 在代码执行过程中，调用定时器 promise click事件…不会立即执行，需要等待当前代码全部执行完毕 给异步方法划分队列，分别存放到微任务（立即存放）和宏任务（时间到了或事情发生了才存放）到队列中 script执行完毕后，会清空所有的微任务 微任务执行完毕后，会渲染页面（不是每次都调用） 再去宏任务队列中看有没有到达时间的，拿出来其中一个执行 执行完毕后，按照上述步骤不停的循环 例子 自动执行的情况 会输出 listener1 listener2 task1 task2 如果手动点击click 会一个宏任务取出来一个个执行，先执行click的宏任务，取出微任务去执行。会输出 listener1 task1 listener2 task2 12345678910111213141516171819202122232425262728console.log(1)async function asyncFunc()&#123; console.log(2) // await xx ==&gt; promise.resolve(()=&gt;&#123;console.log(3)&#125;).then() // console.log(3) 放到promise.resolve或立即执行 await console.log(3) // 相当于把console.log(4)放到了then promise.resolve(()=&gt;&#123;console.log(3)&#125;).then(()=&gt;&#123; // console.log(4) // &#125;) // 微任务谁先注册谁先执行 console.log(4)&#125;setTimeout(()=&gt;&#123;console.log(5)&#125;)const promise = new Promise((resolve,reject)=&gt;&#123; console.log(6) resolve(7)&#125;)promise.then(d=&gt;&#123;console.log(d)&#125;)asyncFunc()console.log(8)// 输出 1 6 2 3 8 7 4 5 1. 浏览器事件循环 涉及面试题：异步代码执行顺序？解释一下什么是 Event Loop ？ JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变 js代码执行过程中会有很多任务，这些任务总的分成两类： 同步任务 异步任务 当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明： 我们解释一下这张图： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 那主线程执行栈何时为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数 以上就是js运行的整体流程 面试中该如何回答呢？ 下面是我个人推荐的回答： 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function(resolve, reject) &#123; console.log(2); resolve()&#125;).then(function() &#123; console.log(3)&#125;);process.nextTick(function () &#123; console.log(4)&#125;)console.log(5) 第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。 第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 1234567console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);console.log(&#x27;script end&#x27;); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task 1234567891011121314151617console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);new Promise((resolve) =&gt; &#123; console.log(&#x27;Promise&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;);// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe ```MutationObserver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 - ![img](http://img-repo.poetries.top/images/20210516165328.png)**宏任务**- `script`- `setTimeout`- `setInterval`- `setImmediate`- `I/O` 网络请求完成、文件读写完成事件- `UI rendering`- 用户交互事件（比如鼠标点击、滚动页面、放大缩小等）&gt; 宏任务中包括了 `script` ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务![img](http://img-repo.poetries.top/images/20210414213126.png)**所以正确的一次 Event loop 顺序是这样的**- 执行同步代码，这属于宏任务- 执行栈为空，查询是否有微任务需要执行- 执行所有微任务- 必要的话渲染 UI- 然后开始下一轮 `Event loop`，执行宏任务中的异步代码&gt; 通过上述的 `Event loop` 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 `DOM` 的话，为了更快的响应界面响应，我们可以把操作 `DOM` 放入微任务中- JavaScript 引擎首先从宏任务队列（macrotask queue）中取出第一个任务- 执行完毕后，再将微任务（microtask queue）中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行；- 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。![img](http://img-repo.poetries.top/images/20210414211816.png)&gt; 总结起来就是：`一次 Eventloop 循环会处理一个宏任务和所有这次循环中产生的微任务`。**2. Node 中的 Event loop**&gt; 当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，`process.nextTick()` 方法会开始处理事件循环。下面就是 Node.js 官网提供的 `Eventloop` 事件循环参考流程- `Node` 中的 `Event loop` 和浏览器中的不相同。- `Node` 的 `Event loop` 分为`6`个阶段，它们会按照顺序反复运行![img](http://img-repo.poetries.top/images/20210414211850.png) ![img](http://img-repo.poetries.top/images/20210516214402.png) ![img](http://img-repo.poetries.top/images/20210516221825.png)- 每次执行执行一个宏任务后会清空微任务（执行顺序和浏览器一致，在node11版本以上）- `process.nextTick` node中的微任务，当前执行栈的底部，优先级比`promise`要高&gt; 整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程。我们来分别看下这六个阶段都做了哪些事情。- **Timers 阶段**：这个阶段执行 `setTimeout` 和 `setInterval`的回调函数，简单理解就是由这两个函数启动的回调函数。- **I/O callbacks 阶段**：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。- **idle，prepare 阶段**：仅系统内部使用，你只需要知道有这 2 个阶段就可以。- **poll 阶段**：`poll` 阶段是一个重要且复杂的阶段，几乎所有 `I/O` 相关的回调，都在这个阶段执行（除了`setTimeout`、`setInterval`、`setImmediate` 以及一些因为 `exception` 意外关闭产生的回调）。`检索新的 I/O 事件，执行与 I/O 相关的回调`，其他情况 Node.js 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行。这个阶段的主要流程如下图所示。![img](http://img-repo.poetries.top/images/20210414212124.png)- **check 阶段**：`setImmediate()` 回调函数在这里执行，`setImmediate` 并不是立马执行，而是当事件循环 `poll 中没有新的事件处理时就执行该部分`，如下代码所示。```jsconst fs = require(&#x27;fs&#x27;);setTimeout(() =&gt; &#123; // 新的事件循环的起点 console.log(&#x27;1&#x27;); &#125;, 0);setImmediate( () =&gt; &#123; console.log(&#x27;setImmediate 1&#x27;);&#125;);/// fs.readFile 将会在 poll 阶段执行fs.readFile(&#x27;./test.conf&#x27;, &#123;encoding: &#x27;utf-8&#x27;&#125;, (err, data) =&gt; &#123; if (err) throw err; console.log(&#x27;read file success&#x27;);&#125;);/// 该部分将会在首次事件循环中执行Promise.resolve().then(()=&gt;&#123; console.log(&#x27;poll callback&#x27;);&#125;);// 首次事件循环执行console.log(&#x27;2&#x27;); 在这一代码中有一个非常奇特的地方，就是 setImmediate 会在 setTimeout 之后输出。有以下几点原因： setTimeout 如果不设置时间或者设置时间为 0，则会默认为 1ms 主流程执行完成后，超过 1ms 时，会将 setTimeout 回调函数逻辑插入到待执行回调函数 poll 队列中； 由于当前 poll 队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行check：setImmediate。 因此这也验证了这句话，先执行回调函数，再执行 setImmediate close callbacks 阶段：执行一些关闭的回调函数，如 socket.on(&#39;close&#39;, ...) 除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick() 可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列） 事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢 微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick 和 Promise也存在优先级，process.nextTick 高于 Promise 宏任务：在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列 我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。 同步代码。 将异步任务插入到微任务队列或者宏任务队列中。 执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。 123456789101112131415161718192021const fs = require(&#x27;fs&#x27;);// 首次事件循环执行console.log(&#x27;start&#x27;);/// 将会在新的事件循环中的阶段执行fs.readFile(&#x27;./test.conf&#x27;, &#123;encoding: &#x27;utf-8&#x27;&#125;, (err, data) =&gt; &#123; if (err) throw err; console.log(&#x27;read file success&#x27;);&#125;);setTimeout(() =&gt; &#123; // 新的事件循环的起点 console.log(&#x27;setTimeout&#x27;); &#125;, 0);/// 该部分将会在首次事件循环中执行Promise.resolve().then(()=&gt;&#123; console.log(&#x27;Promise callback&#x27;);&#125;);/// 执行 process.nextTickprocess.nextTick(() =&gt; &#123; console.log(&#x27;nextTick callback&#x27;);&#125;);// 首次事件循环执行console.log(&#x27;end&#x27;); 分析下上面代码的执行过程 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end； 再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：Promise.resolve 和 process.nextTick，宏任务队列包含：fs.readFile 和 setTimeout； 先执行微任务队列，但是根据优先级，先执行 process.nextTick 再执行 Promise.resolve，所以先输出 nextTick callback 再输出 Promise callback； 再执行宏任务队列，根据宏任务插入先后顺序执行 setTimeout 再执行 fs.readFile，这里需要注意，先执行 setTimeout 由于其回调时间较短，因此回调也先执行，并非是 setTimeout 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 1ms，所以虽然 fs.readFile 先于setTimeout 执行，但是 setTimeout 执行更快，所以先输出 setTimeout ，最后输出 read file success。 1234567// 输出结果startendnextTick callbackPromise callbacksetTimeoutread file success 当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示： 12345678910111213141516171819const fs = require(&#x27;fs&#x27;);setTimeout(() =&gt; &#123; // 新的事件循环的起点 console.log(&#x27;1&#x27;); fs.readFile(&#x27;./config/test.conf&#x27;, &#123;encoding: &#x27;utf-8&#x27;&#125;, (err, data) =&gt; &#123; if (err) throw err; console.log(&#x27;read file sync success&#x27;); &#125;);&#125;, 0);/// 回调将会在新的事件循环之前fs.readFile(&#x27;./config/test.conf&#x27;, &#123;encoding: &#x27;utf-8&#x27;&#125;, (err, data) =&gt; &#123; if (err) throw err; console.log(&#x27;read file success&#x27;);&#125;);/// 该部分将会在首次事件循环中执行Promise.resolve().then(()=&gt;&#123; console.log(&#x27;poll callback&#x27;);&#125;);// 首次事件循环执行console.log(&#x27;2&#x27;); 在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 setTimeout 和 fs.readFile，微任务是 Promise.resolve。 整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。 接下来执行微任务，输出 poll callback。 再执行宏任务中的 fs.readFile 和 setTimeout，由于 fs.readFile 优先级高，先执行 fs.readFile。但是处理时间长于 1ms，因此会先执行 setTimeout 的回调函数，输出 1。这个阶段在执行过程中又会产生新的宏任务 fs.readFile，因此又将该 fs.readFile 插入宏任务队列 最后由于只剩下宏任务了 fs.readFile，因此执行该宏任务，并等待处理完成后的回调，输出 read file sync success。 123456// 结果2poll callback1read file successread file sync success Process.nextick() 和 Vue 的 nextick Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。 12345678910setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;);&#125;)// 这里可能会输出 setTimeout，setImmediate// 可能也会相反的输出，这取决于性能// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate// 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行 1234567891011121314151617181920setTimeout(()=&gt;&#123; console.log(&#x27;timer1&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;) &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log(&#x27;timer2&#x27;) Promise.resolve().then(function() &#123; console.log(&#x27;promise2&#x27;) &#125;)&#125;, 0)// 以上代码在浏览器和 node 中打印情况是不同的// 浏览器中一定打印 timer1, promise1, timer2, promise2// node 中可能打印 timer1, timer2, promise1, promise2// 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 12345678910111213141516171819setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(function() &#123; console.log(&quot;promise1&quot;); &#125;);&#125;, 0);// poll阶段执行fs.readFile(&#x27;./test&#x27;,()=&gt;&#123; // 在poll阶段里面 如果有setImmediate优先执行，setTimeout处于事件循环顶端 poll下面就是setImmediate setTimeout(()=&gt;console.log(&#x27;setTimeout&#x27;),0) setImmediate(()=&gt;console.log(&#x27;setImmediate&#x27;),0)&#125;)process.nextTick(() =&gt; &#123; console.log(&quot;nextTick&quot;);&#125;);// nextTick, timer1, promise1,setImmediate,setTimeout 对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask 谁来启动这个循环过程，循环条件是什么？ 当 Node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 API、调度定时器，或者 process.nextTick()，然后再开始处理事件循环。因此可以这样理解，Node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。 总结来说，Node.js 事件循环的发起点有 4 个： Node.js 启动后； setTimeout 回调函数； setInterval 回调函数； 也可能是一次 I/O 后的回调函数。 无限循环有没有终点 当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行 Node.js 是单线程的还是多线程的？ 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等 EventLoop 对渲染的影响 想必你之前在业务开发中也遇到过 requestIdlecallback 和 requestAnimationFrame，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在 Eventloop 的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于 JS 的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。 我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行 渲染原本就不应该出现在 Eventloop 相关的知识体系里，但是因为 Eventloop 显然是在讨论 JS 如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是 requestAnimationFrame的出现却把这两件事情给关联起来 通过调用 1requestAnimationFrame 我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和 Eventloop 有什么关系呢？ 简单来说，就是在每一次 Eventloop 的末尾，判断当前页面是否处于渲染时机，就是重新渲染 有屏幕的硬件限制，比如 60Hz 刷新率，简而言之就是 1 秒刷新了 60 次，16.6ms 刷新一次。这个时候浏览器的渲染间隔时间就没必要小于 16.6ms，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每 16.6ms 会渲染一次，因为还会受到处理器的性能、JavaScript 执行效率等其他因素影响。 回到 requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果 当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理 但是 requestIdlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务，如下图所示： #21 深浅拷贝 1. 浅拷贝的原理和实现 自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象 方法一：object.assign object.assign是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。 1object.assign 的语法为：Object.assign(target, ...sources) object.assign 的示例代码如下： 1234let target = &#123;&#125;;let source = &#123; a: &#123; b: 1 &#125; &#125;;Object.assign(target, source);console.log(target); // &#123; a: &#123; b: 1 &#125; &#125;; 但是使用 object.assign 方法有几点需要注意 它不会拷贝对象的继承属性； 它不会拷贝对象的不可枚举的属性； 可以拷贝 Symbol 类型的属性。 12345678910let obj1 = &#123; a:&#123; b:1 &#125;, sym:Symbol(1)&#125;; Object.defineProperty(obj1, &#x27;innumerable&#x27; ,&#123; value:&#x27;不可枚举属性&#x27;, enumerable:false&#125;);let obj2 = &#123;&#125;;Object.assign(obj2,obj1)obj1.a.b = 2;console.log(&#x27;obj1&#x27;,obj1);console.log(&#x27;obj2&#x27;,obj2); 从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能 方法二：扩展运算符方式 我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。 扩展运算符的语法为：let cloneObj = &#123; ...obj &#125;; 12345678910/* 对象的拷贝 */let obj = &#123;a:1,b:&#123;c:1&#125;&#125;let obj2 = &#123;...obj&#125;obj.a = 2console.log(obj) //&#123;a:2,b:&#123;c:1&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:1&#125;&#125;obj.b.c = 2console.log(obj) //&#123;a:2,b:&#123;c:2&#125;&#125; console.log(obj2); //&#123;a:1,b:&#123;c:2&#125;&#125;/* 数组的拷贝 */let arr = [1, 2, 3];let newArr = [...arr]; //跟arr.slice()是一样的效果 扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用