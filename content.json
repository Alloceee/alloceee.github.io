{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Alloceee","url":"https://alloceee.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-21T07:09:57.761Z","updated":"2021-07-21T07:09:52.056Z","comments":true,"path":"contact.html","permalink":"https://alloceee.github.io/contact.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:36:59.438Z","updated":"2021-07-28T03:36:59.438Z","comments":true,"path":"404.html","permalink":"https://alloceee.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-08-12T06:57:05.325Z","updated":"2021-08-12T06:57:05.325Z","comments":true,"path":"about/index.html","permalink":"https://alloceee.github.io/about/index.html","excerpt":"","text":"PHP开发工程师 1998-07-02 华东交通大学理工学院 2016-2020 本科-软件工程 链接 博客 简历 github 简介 前端：熟悉HTML/JavaScript/CSS，熟悉CSS3与ES6，vue快速搭建与使用 后端：以PHP为主，同时熟悉Java 数据库：MySQL、Redis使用 测试 git：熟悉git流程，使用commitizen规范commit提交；svn 工作经历上海黑桃互动网络科技股份有限公司武汉分公司 2019-10 ~ 2021-03 PHP开发工程师 上海凌立健康管理股份有限公司 2021-03 ~ 至今 PHP开发工程师 项目经历协和教学一体化项目（2021-03 ~ 至今） 负责其中教学评价综合管理系统、轮转排班管理系统、学员招录系统以及综合门户系统开发 前端使用layui开发后台管理，html,css3与jquery开发综合门户，独立封装课程日历等js组件 后端使用CI框架 游戏管理后台服务（2019-12 ~ 2021-03） 游戏后台，游戏数据统计，分析与服务器开服关服相关操作 greylog 日志统计与分析 cronsun定时脚本 greylog Redis mysql 官网服务（2019-10 ~ 2021-03） 官网维护，游戏活动业务 前后端分离开发 redis缓存各种数据 技术亮点 对接联运游戏 荣誉证书 江西省大学生计算机职业技能竞赛专业组 一等奖 软考 软件设计师 Java工程师 计算机二级、英语四级 其他 Nginx基础配置"},{"title":"","date":"2021-08-12T07:03:01.127Z","updated":"2021-08-12T07:03:01.127Z","comments":true,"path":"about/other.html","permalink":"https://alloceee.github.io/about/other.html","excerpt":"","text":"1.了解游戏服务器架构及性能优化方法 2.熟悉MySQL、Redis等数据库操作 3.有数据库运维/优化的经验； 4.具备良好的分析解决问题能力，能独立承担后台逻辑系统开发工具。 1.根据策划需求设计，实现服务器功能和维护； 2.负责游戏数据库结构的设计和优化； 3.配合游戏前端进行各个功能模板的联调； 4.负责游戏后端性能优化； 5.游戏上线运维，后台相关脚本和工具研发。 熟悉MVC、TP6、Layui 了解PHP的性能最优化和安全最大化 熟练使用MySQL，精通MySQL分析及优化，善于找出MySQL语句的毛病及如何优化 有实际分表、分库、存储引擎优化经验 熟练使用内存缓存、文件缓存，有EPR开发和处理消息队列经验者优化 熟悉Laravel框架 熟悉LNMP架构 熟悉redis常用数据结构 熟悉Linux常用命令 广告投放系统开发经验 2年经验 MVC框架原理 PHP环境相关服务配置 熟练操作git源码管理 熟练掌握HTML5、CSS3、JavaScript等 熟练使用JQuery、Vue等主流JS框架 熟练使用MySQL，了解MySQL底层原理，掌握MySQL常用优化方法，能编写高性能MySQL语句 有高负载、大并发、大数据量、复杂业务逻辑的项目经验 拥有电商软件开发经验 Docker容器化相关技术栈 熟练LAMP架构 数据库性能调优 ERP、电商系统 熟悉面向对象（OOP）和常用设计模式 熟悉Nginx、Apache等web容器 独立带团队能力 web前端、redis、TP框架 2年以上经验 精通PHP 熟悉phalcon，swoole或者workman等框架 熟悉另外一门后端语言，包括但不限于Go、C、C++、NodeJS 5年以上开发经验 3年以上系统设计经验 有社交娱乐，大型互联网产品的系统设计经验优先 熟悉Nginx、Redis、MySQL、Sphinx等的管理和调优 熟练运用缓存、消息队列等技术 项目管理能力 20-40 电商ERP、WMS、CMS、CRM等系统开发经验者优先； 熟练使用Laravel，有完整的非练手项目经验； 熟练使用MySQL，并且能对复杂SQL进行调优； 熟练使用Git管理工具，熟悉Git工作流； 熟悉前端jQuery的基本使用方法； 熟悉HTTP协议，了解RESTful API设计风格，了解XML技术； 熟悉Vue全家桶的基本使用，了解Elctron框架优先； 工作态度，沟通与团队协作，有责任心"},{"title":"首页","date":"2021-07-21T07:07:37.111Z","updated":"2021-07-21T07:07:37.111Z","comments":true,"path":"archives/index.html","permalink":"https://alloceee.github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-07-28T03:33:13.532Z","updated":"2021-07-28T03:33:13.532Z","comments":true,"path":"categories/index.html","permalink":"https://alloceee.github.io/categories/index.html","excerpt":"","text":""},{"title":"my-friends","date":"2021-07-28T03:35:55.301Z","updated":"2021-07-28T03:35:55.301Z","comments":true,"path":"friends/index.html","permalink":"https://alloceee.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-28T03:34:26.738Z","updated":"2021-07-28T03:34:26.738Z","comments":true,"path":"mylist/index.html","permalink":"https://alloceee.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-28T03:33:40.751Z","updated":"2021-07-28T03:33:40.751Z","comments":true,"path":"tags/index.html","permalink":"https://alloceee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第21章：虚拟化、云计算与物联网","slug":"SystemArchitect/第21章：虚拟化、云计算与物联网","date":"2021-08-20T16:00:00.000Z","updated":"2021-08-12T06:53:19.202Z","comments":true,"path":"2021/08/21/SystemArchitect/第21章：虚拟化、云计算与物联网/","link":"","permalink":"https://alloceee.github.io/2021/08/21/SystemArchitect/%E7%AC%AC21%E7%AB%A0%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%81%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/","excerpt":"","text":"","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第11章：测试评审方法","slug":"SystemArchitect/第11章：测试评审方法","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-12T09:23:06.210Z","comments":true,"path":"2021/08/12/SystemArchitect/第11章：测试评审方法/","link":"","permalink":"https://alloceee.github.io/2021/08/12/SystemArchitect/%E7%AC%AC11%E7%AB%A0%EF%BC%9A%E6%B5%8B%E8%AF%95%E8%AF%84%E5%AE%A1%E6%96%B9%E6%B3%95/","excerpt":"本章重点要求读者掌握测试方法、评审方法、验证与确认、测试自动化、面向对象的测试等 5 个方面的知识。","text":"本章重点要求读者掌握测试方法、评审方法、验证与确认、测试自动化、面向对象的测试等 5 个方面的知识。 测试方法软件测试阶段从测试阶段上分，软件测试通常可分为单元测试、集成测试和系统测试。 1.单元测试单元测试（unit testing），也称模块测试，通常可放在编程阶段，由程序员对自己编写的模块自行测试，检查模块是否实现了详细设计说明书中规定的功能和算法。单元测试主要发现编程和详细设计中产生的错误，单元测试计划应该在详细设计阶段制定。 单元测试期间着重从以下几个方面对模块进行测试：模块接口、局部数据结构、重要的执行通路、出错处理通路和边界条件等。 测试一个模块时需要为该模块编写一个驱动模块和若干个桩（stub）模块。驱动模块用来调用被测模块，它接收测试者提供的测试数据，并把这些数据传送给被测模块，然后从被测模块接收测试结果，并以某种可以看见的方式（例如显示或打印）将测试结果返回给测试者。桩模块用来模拟被测模块所调用的子模块，它接受被测模块的调用，检验调用参数，并以尽可能简单的操作模拟被调用的子程序模块功能，把结果送回被测模块。顶层模块测试时不需要驱动模块，底层模块测试时不需要桩模块。 模块的内聚程度高可以简化单元测试过程。如果每个模块只完成一种功能，则需要的测试方案数目将明显减少，模块中的错误也更容易预测和发现。 2.集成测试集成测试（integration testing），也称组装测试，它是对由各模块组装而成的程序进行测试，主要目标是发现模块间的接口和通信问题。例如，数据穿过接口可能丢失，一个模块对另一个模块可能由于疏忽而造成有害影响，把子功能组合起来可能不产生预期的主功能，个别看来是可以接受的误差可能积累到不能接受的程度，全程数据结构可能有问题等。集成测试主要发现设计阶段产生的错误，集成测试计划应该在概要设计阶段制订。 集成的方式可分为非渐增式和渐增式。 非渐增式集成是先测试所有的模块，然后一下子把所有这些模块集成到一起，并把庞大的程序作为一个整体来测试。这种测试方法的出发点是可以“一步到位”，但测试者面对众多的错误现象，往往难以分清哪些是“真正的”错误，哪些是由其他错误引起的“假性错误”，诊断定位和改正错误也十分困难。非渐增式集成只适合一些非常小的软件。 渐增式集成是将单元测试和集成测试合并到一起，它根据模块结构图，按某种次序选一个尚未测试的模块，把它同已经测试好的模块组合在一起进行测试，每次增加一个模块，直到所有模块被集成在程序中。这种测试方法比较容易定位和改正错误，目前在进行集成测试时已普遍采用渐增式集成。 渐增式集成又可分为自顶向下集成和自底向上集成。自顶向下集成先测试上层模块，再测试下层模块。由于测试下层模块时它的上层模块已测试过，所以不必另外编写驱动模块。 自底向上集成先测试下层模块，再测试上层模块。同样，由于测试上层模块时它的下层模块已测试过，所以不必另外编写桩模块。这两种集成方法各有利弊，一种方法的优点恰好对应于另一种方法的缺点，实际测试时可根据软件特点及进度安排灵活选用最适当的方法，也可将两种方法混合使用。 3.系统测试系统测试是软件测试中的最后的、最完整的测试，它是在单元测试和集成测试的基础上进行的，它从全局来考察软件系统的功能和性能要求。系统测试计划应该在需求分析阶段制订。 通常，系统测试包括确认测试和验收测试。 确认测试，主要依据软件需求说明书检查软件的功能、性能及其他特征是否与用户的需求一致。 软件配置复查是确认测试的另一项重要内容。复查的目的是保证软件配置的所有成分都已齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必需的细节。 如果一个软件是为某个客户定制的，最后还要由该客户来实施验收测试，以便确认其所有需求是否都已得到满足。由于软件系统的复杂性，在实际工作中，验收测试可能会持续到用户实际使用该软件之后的相当长的一段时间。 如果一个软件是作为产品被许多客户使用的，不可能也没必要由每个客户进行验收测试。 绝大多数软件开发商都使用被称为 (Alpha)测试和 (Beta)测试的过程，来发现那些看起来只有最终用户才能发现的错误。 a 测试由用户在开发者的场所进行，并且在开发者的指导下进行测试。开发者负责记录发现的错误和使用中遇到的问题。也就是说， 测试是在“受控的”环境中进行的。 b 测试是在一个或多个用户的现场由该软件的最终用户实施的，开发者通常不在现场，用户负责记录发现的错误和使用中遇到的问题并把这些问题报告给开发者。也就是说，测试是在“不受控的”环境中进行的。经过系统测试之后的软件通常就可以交付使用了。 白盒测试和黑盒测试缺陷的分类和级别调试软件测试在将软件交付给客户之前所必须完成的重要步骤。软件调试(排错)与成功的测试形影相随。 测试成功的标志是发现了错误，根据错误迹象确定错误的原因和准确位置，并加以改正，主要依靠软件调试技术。 软件调试与软件测试区别主要体现在以下几个方面： ①测试的目的是找出存在的错误，而调试的目的是定位错误并修改程序以修正错误；②调试是测试之后的活动，测试和调试在目标、方法和思路上都有所不同；③测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预计；④测试过程可以实现设计，进度可以实现确定；而调试不能描述过程或持续时间。 静态测试静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。 静态测试包括对文档的静态测试和对代码的静态测试。 对代码的静态测试包括控制流分析、数据流分析、接口分析和表达式分析 1.控制流分析控制流分析是指使用控制流程序图检查被测程序控制结构的过程。例如，可检查被测程序是否存在没有使用的语句或子程序、是否调试并不存在的子程序，以及是否存在无法达到的语句等。 2.数据流分析数据流分析是指使用控制流程图分析数据各种异常情况的过程，包括数据初始化、赋值或引用过程中的异常。例如，引用未定义的变量、对以前未使用的变量再次赋值等程序查错或异常情况。 3.接口分析接口分析主要包括模块之间接口的一致性分析、模块与外部数据库及其他软件配置项之间的一致性分析、子程序和函数之间的接口一致性分析等。例如可以检查函数形参与实现的数量、顺序、类型和使用的一致性。 4.表达式分析表达式分析用于检查程序代码中的表达式错误。例如，括号不配对、数组引用越界、除数为零，以及浮点数变量比较时的误差等错误。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"","slug":"大前端/14-前端面试/01基础","date":"2021-08-11T08:25:38.476Z","updated":"2021-07-06T09:59:34.569Z","comments":true,"path":"2021/08/11/大前端/14-前端面试/01基础/","link":"","permalink":"https://alloceee.github.io/2021/08/11/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、HTML、HTTP、web综合问题1 前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2 &lt;img&gt;的title和alt有什么区别 通常当鼠标滑动到元素上的时候显示 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析 3 HTTP的几种请求方法用途 GET方法 发送一个请求来取得服务器上的某一资源 POST方法 向URL指定的资源提交数据或附加新的数据 PUT方法 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 HEAD方法 只请求页面的首部 DELETE方法 删除服务器上的某资源 OPTIONS方法 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 TRACE方法 TRACE方法被用于激发一个远程的，应用层的请求消息回路 CONNECT方法 把请求连接转换到透明的TCP/IP通道 4 从浏览器地址栏输入url到显示页面的步骤基础版本 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 详细版 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control: HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete，window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 详细简版 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系） 开启网络线程到发出一个完整的HTTP请求（这一部分涉及到dns查询，TCP/IP请求，五层因特网协议栈等知识） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等） 后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等） 单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag，catch-control等） 浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和DOMContentLoaded等） CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念） JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容） 5 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 css方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 你有用过哪些前端性能优化的方法？ 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性) 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载 请求带宽：压缩文件，开启GZIP 前端性能优化最佳实践？ 性能评级工具（PageSpeed 或 YSlow） 合理设置 HTTP 缓存：Expires 与 Cache-control 静态资源打包，开启 Gzip 压缩（节省响应流量） CSS3 模拟图像，图标base64（降低请求数） 模块延迟(defer)加载/异步(async)加载 Cookie 隔离（节省请求流量） localStorage（本地存储） 使用 CDN 加速（访问最近服务器） 启用 HTTP/2（多路复用，并行加载） 前端自动化（gulp/webpack） 6 HTTP状态码及其含义 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX:服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 7 语义化的理解 用正确的标签做正确的事情！ HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 浏览器的内核分别是什么IE：trident内核 Firefox：gecko内核 Safari：webkit内核 9 html5有哪些新特性、移除了那些元素？ HTML5指的是包括HTML，CSS和JavaScript在内的一套技术组合。 HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker、 websocket、 Geolocation 移除的元素： 纯表现的元素：basefont、big、center、font、 s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 10 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/offline.html NETWORK 永远不会被缓存 CACHE缓存 FALLBACK无法建立网络连接 11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 14 WEB标准以及W3C标准是什么? 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 15 xhtml和html有什么区别? 一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import只在IE5以上才能识别，而link是XHTML标签，无兼容问题 link方式的样式的权重 高于@import的权重 &lt;!DOCTYPE&gt;位于文档中的最前面，处于 `` 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现 17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 行内元素有：a b span img input select strong 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4… p 空元素： 行内元素不可以设置宽高，不独占一行 块级元素可以设置宽高，独占一行 18 HTML全局属性(global attribute)有哪些 class:为元素设置类标识 data-*: 为元素增加自定义属性 draggable: 设置元素是否可拖拽 id: 元素id，文档内唯一 lang: 元素内容的的语言 style: 行内css样式 title: 元素相关的建议信息 19 Canvas和SVG有什么区别？ svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布 svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20 HTML5 为什么只需要写 HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 21 如何在页面上实现一个圆形的可点击区域？ svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 22 网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 23 viewport12345678&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; // width 设置viewport宽度，为一个正整数，或字符串‘device-width’ // device-width 设备宽度 // height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 // initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数 // minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 // maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 // user-scalable 是否允许手动缩放 延伸提问 怎样处理 移动端 1px 被 渲染成 2px问题 局部处理 mate标签中的 viewport属性 ，initial-scale 设置为 1 rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可； 全局处理 mate标签中的 viewport属性 ，initial-scale 设置为 0.5 rem 按照设计稿标准走即可 24 渲染优化 禁止使用iframe（阻塞父文档onload事件） iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题 禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） 使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流） 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU 小图标优势在于 减少HTTP请求 避免文件跨域 修改及时生效 页面头部的 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的） 页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程) 网页gzip，CDN托管，data缓存 ，图片服务器 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO 25 meta viewport相关1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt; &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用 IE 最新版本和 Chrome--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; &lt;!--为移动设备添加 viewport--&gt;&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; &lt;!--设置苹果工具栏颜色--&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt; &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt; &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; &lt;!--windows phone 点击无高亮设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt; 26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? IE: trident内核 Firefox：gecko内核 Safari:webkit内核 Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核 Chrome:Blink(基于webkit，Google与Opera Software共同开发) 27 div+css的布局较table布局有什么优点？ 改版的时候更方便 只要改css文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前。 28 a：img的alt与title有何异同？b：strong与em的异同？ alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示) title(tool tip):该属性为设置该属性的元素提供建议性的信息 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点 29 你能描述一下渐进增强和优雅降级之间的不同吗 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 30 为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 31 简述一下src与href的区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 &lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式 32 知道的网页制作会用到的图片格式有哪些？ png-8、png-24、jpeg、gif、svg 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp,Apng。（是否有关注新技术，新鲜事物） Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。 Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准 33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？dns缓存，cdn缓存，浏览器缓存，服务器缓存 34 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 35 常见排序算法的时间复杂度,空间复杂度36 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 37 HTTP request报文结构是怎样的 首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 请求头和消息实体之间有一个CRLF分隔 根据实际请求需要可能包含一个消息实体 一个请求报文例子如下： 1234567891011121314GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1Host: www.w3.orgConnection: keep-aliveCache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36Referer: https://www.google.com.hk/Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: authorstyle=yesIf-None-Match: &quot;2cc8-3e3073913b100&quot;If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMTname=qiu&amp;age=25 38 HTTP response报文结构是怎样的 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部 响应头部和响应实体之间用一个CRLF空行分隔 最后是一个可能的消息实体 响应报文例子如下： 12345678910111213HTTP/1.1 200 OKDate: Tue, 08 Jul 2014 05:28:43 GMTServer: Apache/2Last-Modified: Wed, 01 Sep 2004 13:24:52 GMTETag: &quot;40d7-3e3073913b100&quot;Accept-Ranges: bytesContent-Length: 16599Cache-Control: max-age=21600Expires: Tue, 08 Jul 2014 11:28:43 GMTP3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;Content-Type: text/html; charset=iso-8859-1&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125; 二、CSS部分1 css sprite是什么,有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2 display: none;与visibility: hidden;的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3 link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC(文档样式短暂失效) link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 4 什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。 由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏 解决方法：用link加载css文件，放在head标签里面 5 如何创建块级格式化上下文(block formatting context),BFC有什么用 创建规则： 根元素 浮动元素（float不取值为none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block、table-cell、table-caption、flex、inline-flex之一的元素 overflow不取值为visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 #6 display、float、position的关系 如果display取值为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position取值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display #7 清除浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 父级div也浮动，需要定义宽度 结尾处加br标签clear:both 比较好的是第3种方式，好多网站都这么用 #8 为什么要初始化CSS样式? 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 #9 css3有哪些新特性 新增各种css选择器 圆角 border-radius 多列布局 阴影和反射 文字特效text-shadow 线性渐变 旋转transform CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 `` 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 `` 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容。 :enabled 已启用的表单元素。 :disabled 已禁用的表单元素。 :checked 单选框或复选框被选中。 #10 display有哪些值？说明他们的作用 block 转换成块状元素。 inline 转换成行内元素。 none 设置元素不可见。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 #11 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE盒子模型、W3C盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; #12 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag; !important 比 内联优先级高 #13 对BFC规范的理解？ 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用 #14 谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 #15 position的值， relative和absolute定位原点是 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位 relative：生成相对定位的元素，相对于其正常位置进行定位 static 默认值。没有定位，元素出现在正常的流中 inherit 规定从父元素继承 position 属性的值 #16 display:inline-block 什么时候不会显示间隙？(携程) 移除空格 使用margin负值 使用font-size:0 letter-spacing word-spacing #17 PNG\\GIF\\JPG的区别及如何选 GIF 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 #18 行内元素float:left后是否变为块级元素？ 行内元素设置成浮动之后变得更加像是inline-block（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是100%），这时候给行内元素设置padding-top和padding-bottom或者width、height都是有效果的 #19 在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系 #20 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 用于区分伪类和伪元素 #21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms ＝ 16.7ms #22 CSS合并方法 避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 #23 CSS不同选择器的权重(CSS层叠的规则) ！important规则最重要，大于其它规则 行内样式规则，加1000 对于选择器中给定的各个ID属性值，加100 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10 对于选择其中给定的各个元素标签选择器，加1 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 24 列出你所知道可以改变页面布局的属性 position、display、float、width、height、margin、padding、top、left、right、` #25 CSS在性能优化方面的实践 css压缩与合并、Gzip压缩 css文件放在head里、不要用@import 尽量用缩写、避免用滤镜、合理使用选择器 #26 CSS3动画（简单动画的实现，如旋转等） 依靠CSS3中提出的三个属性：transition、transform、animation transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。 transform：定义元素的变化结果，包含rotate、scale、skew、translate。 animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction #27 base64的原理及优缺点 优点可以加密，减少了HTTTP请求 缺点是需要消耗CPU进行编解码 #28 几种常见的CSS布局#流体布局1234567891011121314151617181920212223 .left &#123; float: left; width: 100px; height: 200px; background: red; &#125; .right &#123; float: right; width: 200px; height: 200px; background: blue; &#125; .main &#123; margin-left: 120px; margin-right: 220px; height: 200px; background: green; &#125;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt; #圣杯布局123456789101112131415161718192021222324252627282930313233.container &#123; margin-left: 120px; margin-right: 220px;&#125;.main &#123; float: left; width: 100%; height:300px; background: green;&#125;.left &#123; position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -200px; background: blue;&#125;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; #双飞翼布局12345678910111213141516171819202122232425262728293031323334353637.content &#123; float: left; width: 100%;&#125;.main &#123; height: 200px; margin-left: 110px; margin-right: 220px; background: green;&#125;.main::after &#123; content: &#x27;&#x27;; display: block; font-size:0; height: 0; zoom: 1; clear: both;&#125;.left &#123; float:left; height: 200px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; float: right; height: 200px; width: 200px; margin-left: -200px; background: blue;&#125;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt; #29 stylus/sass/less区别 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性 Scss和LESS语法较为严谨，LESS要求一定要使用大括号“{}”，Scss和Stylus可以通过缩进表示层次与嵌套关系 Scss无全局变量的概念，LESS和Stylus有类似于其它语言的作用域概念 Sass是基于Ruby语言的，而LESS和Stylus可以基于NodeJS NPM下载相应库后进行编译； #30 postcss的作用 可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大 PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树 通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer postcss可以对sass处理过后的css再处理 最常见的就是autoprefixer #31 css样式（选择器）的优先级 计算权重确定 !important 内联样式 后写的优先级高 #32 自定义字体的使用场景 宣传/品牌/banner等固定文案 字体图标 #33 如何美化CheckBox `` 属性 for 和 id 隐藏原生的 `` :checked + #34 伪类和伪元素的区别 伪类表状态 伪元素是真的有元素 前者单冒号，后者双冒号 #35 base64的使用 用于减少 HTTP 请求 适用于小图片 base64的体积约为原图的4/3 #36 自适应布局思路： 左侧浮动或者绝对定位，然后右侧margin撑开 使用``包含，然后靠负margin形成bfc 使用flex #37 请用CSS写一个简单的幻灯片效果页面 知道是要用CSS3。使用animation动画实现一个简单的幻灯片效果 123456789101112131415161718192021222324252627282930/**css**/.ani&#123; width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: &quot;loops&quot;; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite;&#125;@-webkit-keyframes &quot;loops&quot; &#123; 0% &#123; background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat; &#125; 25% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; &#125; 50% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat; &#125; 75% &#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; &#125; 100% &#123; background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat; &#125;&#125; #38 什么是外边距重叠？重叠的结果是什么？ 外边距重叠就是margin-collapse 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 #39 rgba()和opacity的透明效果有什么不同？ rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度， 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！ 40 css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing #41 如何垂直居中一个浮动元素？1234567891011121314151617181920212223242526/**方法一：已知元素的高宽**/#div1&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; //父元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; //二分之一的height，width margin-left: -100px;&#125;/**方法二:**/#div1&#123; width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; //父元素需要相对定位 left: 0; top: 0; right: 0; bottom: 0;&#125; 如何垂直居中一个``?（用更简便的方法。） 123456#container /**&lt;img&gt;的容器设置如下**/&#123; display:table-cell; text-align:center; vertical-align:middle;&#125; #42 px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 #43 Sass、LESS是什么？大家为什么要使用他们？ 他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。 例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js) 为什么要使用它们？ 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译 #44 知道css有个content属性吗？有什么作用？有什么应用？ css的content属性专门应用在 before/after伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。 1234567891011/**一种常见利用伪类清除浮动的代码**/.clearfix:after &#123; content:&quot;.&quot;; //这里利用到了content属性 display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1;&#125; #45 水平居中的方法 元素为行内元素，设置父元素text-align:center 如果元素宽度固定，可以设置左右margin为auto; 如果元素为绝对定位，设置父元素position为relative，元素设left:0;right:0;margin:auto; 使用flex-box布局，指定justify-content属性为center display设置为tabel-ceil #46 垂直居中的方法 将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle 使用flex布局，设置为align-item：center 绝对定位中设置bottom:0,top:0,并设置margin:auto 绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值 文本垂直居中设置line-height为height值 #47 如何使用CSS实现硬件加速？ 硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能， 一般触发硬件加速的CSS属性有transform、opacity、filter，为了避免2D动画在 开始和结束的时候的repaint操作，一般使用tranform:translateZ(0) #48 重绘和回流（重排）是什么，如何避免？ DOM的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何 属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分 重新绘制到屏幕上的过程称为重绘。引起重排的原因有 添加或者删除可见的DOM元素， 元素位置、尺寸、内容改变， 浏览器页面初始化， 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排， 减少重绘和重排的方法： 不在布局信息改变时做DOM查询 使用cssText或者className一次性改变属性 使用fragment 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素 #49 说一说css3的animation css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from、to或者是百分比来定义 每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式， 这些相关的动画子属性有：animation-name定义动画名、animation-duration定义动画播放的时长、animation-delay定义动画延迟播放的时间、animation-direction定义 动画的播放方向、animation-iteration-count定义播放次数、animation-fill-mode定义动画播放之后的状态、animation-play-state定义播放状态，如暂停运行等、animation-timing-function 定义播放的方式，如恒速播放、艰涩播放等。 #50 左边宽度固定，右边自适应 左侧固定宽度，右侧自适应宽度的两列布局实现 html结构 1234&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;left&quot;&gt;固定宽度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;自适应宽度&lt;/div&gt;&lt;/div&gt; 在外层div（类名为outer）的div中，有两个子div，类名分别为left和right，其中left为固定宽度，而right为自适应宽度 方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应 123456789101112131415.outer &#123; width: 100%; height: 500px; background-color: yellow;&#125;.left &#123; width: 200px; height: 200px; background-color: red; float: left;&#125;.right &#123; height: 200px; background-color: blue;&#125; 方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 width设置为 auto 的时候（或者不设置，默认为 auto ），绝对定位元素会根据其 left 和 right 自动伸缩其大小 12345678910111213141516171819.outer &#123; width: 100%; height: 500px; background-color: yellow; position: relative;&#125;.left &#123; width: 200px; height: 200px; background-color: red;&#125;.right &#123; height: 200px; background-color: blue; position: absolute; left: 200px; top:0; right: 0;&#125; 方法3：将左侧div进行绝对定位，然后右侧div设置margin-left: 200px 1234567891011121314151617.outer &#123; width: 100%; height: 500px; background-color: yellow; position: relative;&#125;.left &#123; width: 200px; height: 200px; background-color: red; position: absolute;&#125;.right &#123; height: 200px; background-color: blue; margin-left: 200px;&#125; 方法4：使用flex布局 1234567891011121314151617.outer &#123; width: 100%; height: 500px; background-color: yellow; display: flex; flex-direction: row;&#125;.left &#123; width: 200px; height: 200px; background-color: red;&#125;.right &#123; height: 200px; background-color: blue; flex: 1;&#125; 51 两种以上方式实现已知或者未知宽度的垂直水平居中123456789101112131415161718192021222324252627282930313233343536373839404142/** 1 **/.wraper &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin: -50px 0 0 -50px; &#125;&#125;/** 2 **/.wraper &#123; position: relative; .box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125;/** 3 **/.wraper &#123; .box &#123; display: flex; justify-content:center; align-items: center; height: 100px; &#125;&#125;/** 4 **/.wraper &#123; display: table; .box &#123; display: table-cell; vertical-align: middle; &#125;&#125; #52 如何实现小于12px的字体效果 transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block; 1transform: scale(0.7); css的属性，可以缩放大小 #三、JavaScript#1 闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 好处：能够实现封装和缓存等； 坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除 #2 说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 #3 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 #4 请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定 #5 Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = &#x27;wang&#x27;;&#125;function Child()&#123; this.age = 28;&#125; Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性 #6 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window #7 事件模型 W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true 阻止捕获：阻止事件的默认行为，例如click - 后的跳转。在W3c中，使用preventDefault()方法，在IE下设置window.event.returnValue = false #8 new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this #9 Ajax原理 Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 123456789101112131415161718/** 1. 创建连接 **/var xhr = null;xhr = new XMLHttpRequest()/** 2. 连接服务器 **/xhr.open(&#x27;get&#x27;, url, true)/** 3. 发送请求 **/xhr.send(null);/** 4. 接受请求 **/xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; /** false **/ fail &amp;&amp; fail(xhr.status); &#125; &#125;&#125; ajax 有那些优缺点? 优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新（局部刷新） 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 #10 如何解决跨域问题? 首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口“三者相同，即便两个不同的域名指向同一个ip地址，也非同源 那么怎样解决跨域问题的呢？ 通过jsonp跨域 1234567891011var script = document.createElement(&#x27;script&#x27;);script.type = &#x27;text/javascript&#x27;;// 传参并指定回调执行函数为onBackscript.src = &#x27;http://www.....:8080/login?user=admin&amp;callback=onBack&#x27;;document.head.appendChild(script);// 回调执行函数function onBack(res) &#123; alert(JSON.stringify(res));&#125; document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &#x27;domain.com&#x27;; var user = &#x27;admin&#x27;;&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 123document.domain = &#x27;domain.com&#x27;;// 获取父窗口中变量alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user); nginx代理跨域 nodejs中间件代理跨域 后端在头部信息里面设置安全域名 #11 模块化开发怎么做？ 立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); #12 异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack #13 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包使用不当 #14 XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML #15 谈谈你对webpack的看法 WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 #16 说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站A，并在本地生成Cookie 在不登出A的情况下，访问危险网站B CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 #18 用过哪些设计模式？ 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this对象; #19 为什么要有同源限制？ 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 #20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 #21 javascript有哪些方法定义对象 对象字面量： var obj = &#123;&#125;; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); #22 常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一,，但是全局效率很低，一般是如下这样解决： 1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125; IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. #23 说说你对promise的了解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled与 rejected一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject #24 你觉得jQuery源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 #25 vue、react、angular Vue.js 一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters AngularJS 是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令 react React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 #26 Node的应用场景 特点： 1、它是一个Javascript运行环境 2、依赖于Chrome V8引擎进行代码解释 3、事件驱动 4、非阻塞I/O 5、单进程，单线程 优点： 高并发（最重要的优点） 缺点： 1、只支持单核CPU，不能充分利用CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 #27 谈谈你对AMD、CMD的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 es6模块 CommonJS、AMD、CMD CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用 AMD 异步，需要定义回调define方式 es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 es6还可以导出类、方法，自动适用严格模式 #28 那些操作会造成内存泄漏 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） #29 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 #30 介绍js的基本数据类型 Undefined、Null、Boolean、Number、String #31 介绍js有哪些内置对象 Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error #32 说几条写JavaScript的基本规范 不要在同一行声明多个变量 请使用===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 #33 JavaScript有几种类型的值 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 #34 javascript创建对象的几种方式 javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 1person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;; 用function来模拟无参的构造函数 12345678function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function()&#123; alert(person.name+&quot; hello...&quot;);&#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); &#125;&#125;var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 用原型方式来创建 1234567function Dog()&#123;&#125;Dog.prototype.name=&quot;旺财&quot;;Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;);&#125;var wangcai =new Dog();wangcai.eat(); 用混合方式来创建 123456789 function Car(name,price)&#123; this.name=name; this.price=price;&#125;Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);&#125;var camry =new Car(&quot;凯美瑞&quot;,27);camry.sell(); #35 eval是做什么的 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;) #36 null，undefined 的区别 undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 37 [“1”, “2”, “3”].map(parseInt) 答案是多少 [1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。 map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。 #38 javascript 代码中的”use strict”;是什么意思 use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 #39 JSON 的了解 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&#x27;(&#x27;+ str +&#x27;)&#x27;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); #40 js延迟加载的方式有哪些 defer和async、动态创建DOM方式（用得最多）、按需异步载入js #41 同步和异步的区别 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 #42 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 #43 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 #44 说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 禁止this指向全局对象 #45 attribute和property的区别是什么 attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 #46 谈谈你对ES6的理解 新增模板字符串（为JavaScript提供了简单的字符串插值功能） 箭头函数 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。 let命令实际上就增加了块级作用域。 还有就是引入module模块的概念 #47 ECMAScript6 怎么写class么 这个语法糖可以让有OOP基础的人更快上手js，至少是一个官方的实现了 但对熟悉js的人来说，这个东西没啥大影响；一个Object.creat()搞定继承，比class简洁清晰的多 #48 什么是面向对象编程及面向过程编程，它们的异同和优缺点 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 面向对象是以功能来划分问题，而不是步骤 #49 面向对象编程思想 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计 优点 易维护 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的 易扩展 开发工作的重用性、继承性高，降低重复工作量。 缩短了开发周期 #50 对web标准、可用性、可访问性的理解 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 #51 如何通过JS判断一个数组 ```instanceof 12345678 方法 - `instanceof` 运算符是用来测试一个对象是否在其原型链原型构造函数的属性```javascriptvar arr = [];arr instanceof Array; // true ```constructor 12345678 方法 - `constructor`属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数```javascriptvar arr = [];arr.constructor == Array; //true 最简单的方法 这种写法，是 jQuery 正在使用的 12345Object.prototype.toString.call(value) == &#x27;[object Array]&#x27;// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1);&#125; ES5新增方法isArray() 1234var a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false #52 谈一谈let与var的区别 let命令不存在变量提升，如果在let前使用，会导致报错 如果块区中存在let和const命令，就会形成封闭作用域 不允许重复声明，因此，不能在函数内部重新声明参数 #53 map与forEach的区别 forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined #54 谈一谈你理解的函数式编程 简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论 它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式” #55 谈一谈箭头函数与普通函数的区别？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 #56 谈一谈函数中this的指向 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 《javascript语言精髓》中大概概括了4种调用方式： 方法调用模式 函数调用模式 构造器调用模式 12graph LRA--&gt;B apply/call调用模式 #57 异步编程的实现方式 回调函数 优点：简单、容易理解 缺点：不利于维护，代码耦合高 事件监听(采用时间驱动模式，取决于某个事件是否发生)： 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数 缺点：事件驱动型，流程不够清晰 发布/订阅(观察者模式) 类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者 Promise对象 优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数； 缺点：编写和理解，相对比较难 Generator函数 优点：函数体内外的数据交换、错误处理机制 缺点：流程管理不方便 async函数 优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。 缺点：错误处理机制 #58 对原生Javascript了解程度 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript #59 Js动画与CSS动画区别及相应实现 ```CSS3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 的动画的优点 - 在性能上会稍微好一些，浏览器会对`CSS3`的动画做一些优化 - 代码相对简单- 缺点 - 在动画控制上不够灵活 - 兼容性不好- `JavaScript`的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容`IE6`，并且功能强大。对于一些复杂控制的动画，使用`javascript`会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑`CSS`吧### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_60-js-数组和对象的遍历方式，以及几种方式的比较)60 JS 数组和对象的遍历方式，以及几种方式的比较&gt; 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历- `for in`循环- `for`循环- `forEach` - 这里的 `forEach`回调中两个参数分别为 `value`，`index` - `forEach` 无法遍历对象 - IE不支持该方法；`Firefox` 和 `chrome` 支持 - `forEach` 无法使用 `break`，`continue` 跳出循环，且使用 `return` 是跳过本次循环- 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题- 在方式一中，`for-in`需要分析出`array`的每个属性，这个操作性能开销很大。用在 `key` 已知的数组上是非常不划算的。所以尽量不要用`for-in`，除非你不清楚要处理哪些属性，例如 `JSON`对象这样的情况- 在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 `array` 里存放的都是 `DOM` 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_61-gulp是什么)61 gulp是什么- `gulp`是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成- Gulp的核心概念：流- 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向- gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作- Gulp的特点： - **易于使用**：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理 - **构建快速** 利用 `Node.js` 流的威力，你可以快速构建项目并减少频繁的 `IO` 操作 - **易于学习** 通过最少的 `API`，掌握 `gulp` 毫不费力，构建工作尽在掌握：如同一系列流管道### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_62-说一下vue的双向绑定数据的原理)62 说一下Vue的双向绑定数据的原理- `vue.js` 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_63-事件的各个阶段)63 事件的各个阶段- 1：捕获阶段 ---&gt; 2：目标阶段 ---&gt; 3：冒泡阶段- `document` ---&gt; `target`目标 ----&gt; `document`- 由此， addEventListener123的第三个参数设置为 true123和 false12345678910111213141516171819202122232425262728293031323334 的区别已经非常清晰了 - `true`表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件 - `false`表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_64-let-var-const)64 let var const**let**- 允许你声明一个作用域被限制在块级中的变量、语句或者表达式- let绑定不受变量提升的约束，这意味着let声明不会被提升到当前- 该变量处于从块开始到初始化处理的“暂存死区”**var**- 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的- 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明**const**- 声明创建一个值的只读引用 (即指针)- 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 `const`申明基本数据类型时- 再将其值改变时，将会造成报错， 例如 `const a = 3` ; `a = 5`时 将会报错- 但是如果是复合类型时，如果只改变复合类型的其中某个`Value`项时， 将还是正常使用### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_65-快速的让一个数组乱序)65 快速的让一个数组乱序```javascriptvar arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); #66 如何渲染几万条数据并不卡住界面 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt;控件&lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector(&quot;ul&quot;); function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement(&quot;li&quot;); li.innerText = Math.floor(Math.random() * total); fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add); &#125; &#125; loop(); &#125;, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; #67 希望获取到页面中所有的checkbox怎么做？ 不使用第三方框架 12345678var domList = document.getElementsByTagName(‘input’)var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) &#123; //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) &#123; checkBoxList.push(domList[len]); &#125;&#125; #68 怎样添加、移除、移动、复制、创建和查找节点创建新节点 123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 添加、移除、替换、插入 1234appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入 查找 123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值getElementById() //通过元素Id，唯一性 #69 正则表达式 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？ 当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\\\表示一个\\）。使用正则表达字面量的效率更高 邮箱的正则匹配： 1var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; #70 Javascript中callee和caller的作用？ caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成） 12345678910111213141516var result=[]; function fn(n)&#123; //典型的斐波那契数列 if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 1; &#125;else&#123; if(result[n])&#123; return result[n]; &#125;else&#123; //argument.callee()表示fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2); return result[n]; &#125; &#125; &#125; #71 window.onload和$(document).ready 原生JS的window.onload与Jquery的$(document).ready(function()&#123;&#125;)有什么不同？如何用原生JS实现Jq的ready方法？ window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕 12345678910111213141516function ready(fn)&#123; if(document.addEventListener) &#123; //标准浏览器 document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; //注销事件, 避免反复触发 document.removeEventListener(&#x27;DOMContentLoaded&#x27;,arguments.callee, false); fn(); //执行函数 &#125;, false); &#125;else if(document.attachEvent) &#123; //IE document.attachEvent(&#x27;onreadystatechange&#x27;, function() &#123; if(document.readyState == &#x27;complete&#x27;) &#123; document.detachEvent(&#x27;onreadystatechange&#x27;, arguments.callee); fn(); //函数执行 &#125; &#125;); &#125; &#125;; #72 addEventListener()和attachEvent()的区别 addEventListener()是符合W3C规范的标准方法; attachEvent()是IE低版本的非标准方法 addEventListener()支持事件冒泡和事件捕获; - 而attachEvent()只支持事件冒泡 addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加&#39;on&#39; 如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行,attachEvent()会按照事件绑定的顺序倒序执行 #73 获取页面所有的checkbox12345678var resultArr= [];var input = document.querySelectorAll(&#x27;input&#x27;);for( var i = 0; i &lt; input.length; i++ ) &#123; if( input[i].type == &#x27;checkbox&#x27; ) &#123; resultArr.push( input[i] ); &#125;&#125;//resultArr即中获取到了页面中的所有checkbox #74 数组去重方法总结方法一、利用ES6 Set去重（ES6中最常用） 123456function unique (arr) &#123; return Array.from(new Set(arr))&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;] 方法二、利用for嵌套for，然后splice去重（ES5中最常用） 1234567891011121314function unique(arr)&#123; for(var i=0; i&lt;arr.length; i++)&#123; for(var j=i+1; j&lt;arr.length; j++)&#123; if(arr[i]==arr[j])&#123; //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN和&#123;&#125;没有去重，两个null直接消失了 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。 想快速学习更多常用的ES6语法 方法三、利用indexOf去重 12345678910111213141516function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var array = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (array .indexOf(arr[i]) === -1) &#123; array .push(arr[i]) &#125; &#125; return array;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) // [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN、&#123;&#125;没有去重 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组 方法四、利用sort() 1234567891011121314151617function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return; &#125; arr = arr.sort() var arrry= [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i-1]) &#123; arrry.push(arr[i]); &#125; &#125; return arrry;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined] //NaN、&#123;&#125;没有去重 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对 方法五、利用对象的属性不能相同的特点进行去重 1234567891011121314151617181920function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var arrry= []; var obj = &#123;&#125;; for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; arrry.push(arr[i]) obj[arr[i]] = 1 &#125; else &#123; obj[arr[i]]++ &#125; &#125; return arrry;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;] //两个true直接去掉了，NaN和&#123;&#125;去重 方法六、利用includes 12345678910111213141516function unique(arr) &#123; if (!Array.isArray(arr)) &#123; console.log(&#x27;type error!&#x27;) return &#125; var array =[]; for(var i = 0; i &lt; arr.length; i++) &#123; if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值 array.push(arr[i]); &#125; &#125; return array&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //&#123;&#125;没有去重 方法七、利用hasOwnProperty 123456789function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(item, index, arr)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;] //所有的都去重了 利用hasOwnProperty 判断是否存在对象属性 方法八、利用filter 123456789function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; &#125;);&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] 方法九、利用递归去重 12345678910111213141516171819202122function unique(arr) &#123; var array= arr; var len = array.length; array.sort(function(a,b)&#123; //排序后更加方便去重 return a - b; &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(array[index] === array[index-1])&#123; array.splice(index,1); &#125; loop(index - 1); //递归loop，然后数组去重 &#125; &#125; loop(len-1); return array;&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined] 方法十、利用Map数据结构去重 12345678910111213141516function arrayNonRepeatfy(arr) &#123; let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) &#123; if(map .has(arr[i])) &#123; // 如果有该key值 map .set(arr[i], true); &#125; else &#123; map .set(arr[i], false); // 如果没有该key值 array .push(arr[i]); &#125; &#125; return array ;&#125; var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;]; console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined] 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果 方法十一、利用reduce+includes 123456function unique(arr)&#123; return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);&#125;var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] 方法十二、[…new Set(arr)] 12[...new Set(arr)]//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码） #75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS） 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件 mousedown事件触发后，开始拖拽 mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置 mouseup时，拖拽结束 需要注意浏览器边界的情况 #76 Javascript全局函数和全局变量全局变量 Infinity 代表正的无穷大的数值。 NaN 指示某个值是不是数字值。 undefined 指示未定义的值。 全局函数 decodeURI() 解码某个编码的 URI。 decodeURIComponent() 解码一个编码的 URI 组件。 encodeURI() 把字符串编码为 URI。 encodeURIComponent() 把字符串编码为 URI 组件。 escape() 对字符串进行编码。 eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。 isFinite() 检查某个值是否为有穷大的数。 isNaN() 检查某个值是否是数字。 Number() 把对象的值转换为数字。 parseFloat() 解析一个字符串并返回一个浮点数。 parseInt() 解析一个字符串并返回一个整数。 String() 把对象的值转换为字符串。 unescape() 对由escape() 编码的字符串进行解码 #77 使用js实现一个持续的动画效果定时器思路 1234567var e = document.getElementById(&#x27;e&#x27;)var flag = true;var left = 0;setInterval(() =&gt; &#123; left == 0 ? flag = true : left == 100 ? flag = false : &#x27;&#x27; flag ? e.style.left = ` $&#123;left++&#125;px` : e.style.left = ` $&#123;left--&#125;px`&#125;, 1000 / 60) requestAnimationFrame 123456789101112131415161718192021222324//兼容性处理window.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();var e = document.getElementById(&quot;e&quot;);var flag = true;var left = 0;function render() &#123; left == 0 ? flag = true : left == 100 ? flag = false : &#x27;&#x27;; flag ? e.style.left = ` $&#123;left++&#125;px` : e.style.left = ` $&#123;left--&#125;px`;&#125;(function animloop() &#123; render(); requestAnimFrame(animloop);&#125;)(); 使用css实现一个持续的动画效果 123456animation:mymove 5s infinite;@keyframes mymove &#123; from &#123;top:0px;&#125; to &#123;top:200px;&#125;&#125; animation-name 规定需要绑定到选择器的 keyframe名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画 #78 封装一个函数，参数是定时器的时间，.then执行回调函数123function sleep (time) &#123; return new Promise((resolve) =&gt; setTimeout(resolve, time));&#125; #79 怎么判断两个对象相等？123456789101112obj=&#123; a:1, b:2&#125;obj2=&#123; a:1, b:2&#125;obj3=&#123; a:1, b:&#x27;2&#x27;&#125; 可以转换为字符串来判断 12JSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false #80 项目做过哪些性能优化？ 减少 HTTP 请求数 减少 DNS 查询 使用 CDN 避免重定向 图片懒加载 减少 DOM 元素数量 减少DOM 操作 使用外部 JavaScript 和 CSS 压缩 JavaScript 、 CSS 、字体、图片等 优化 CSS Sprite 使用 iconfont 字体裁剪 多域名分发划分内容到不同域名 尽量减少 iframe 使用 避免图片 src 为空 把样式表放在link 中 把JavaScript放在页面底部 #81 浏览器缓存 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间） Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存） ETag（表示资源内容的唯一标识，随服务器response返回） If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） #82 WebSocket 由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket被发明出来 相比与 http 具有以下有点 支持双向通信，实时性更强； 可以发送文本，也可以二进制文件； 协议标识符是 ws，加密后是 wss ； 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部； 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 无跨域问题。 实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可 #83 尽可能多的说出你对 Electron 的理解 最最重要的一点，electron 实际上是一个套了 Chrome 的 nodeJS程序 所以应该是从两个方面说开来 Chrome （无各种兼容性问题）； NodeJS（NodeJS 能做的它也能做） #84 深浅拷贝浅拷贝 Object.assign 或者展开运算符 深拷贝 可以通过 JSON.parse(JSON.stringify(object)) 来解决 123456789let a = &#123; age: 1, jobs: &#123; first: &#x27;FE&#x27; &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = &#x27;native&#x27;console.log(b.jobs.first) // FE 该方法也是有局限性的 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 #85 防抖/节流防抖 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 使用 underscore 的源码来解释防抖动/** * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */_.debounce = function(func, wait, immediate) &#123; var timeout, args, context, timestamp, result; var later = function() &#123; // 现在和上一次时间戳比较 var last = _.now() - timestamp; // 如果当前间隔时间少于设定时间且大于0就重新设置定时器 if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; // 否则的话就是时间到了执行回调函数 timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; // 获得时间戳 timestamp = _.now(); // 如果定时器不存在且立即执行函数 var callNow = immediate &amp;&amp; !timeout; // 如果定时器不存在就创建一个 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; // 如果需要立即执行函数的话 通过 apply 执行 result = func.apply(context, args); context = args = null; &#125; return result; &#125;; &#125;; 整体函数实现 对于按钮防点击来说的实现 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;object&#125; options 如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。 * 如果想忽略结尾函数的调用，传入&#123;trailing: false&#125; * 两者不能共存，否则函数不能执行 * @return &#123;function&#125; 返回客户调用函数 */_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = &#123;&#125;; // 定时器回调函数 var later = function() &#123; // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;; #86 谈谈变量提升？ 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境 接下来让我们看一个老生常谈的例子，var 12345678b() // call bconsole.log(a) // undefinedvar a = &#x27;Hello world&#x27;function b() &#123; console.log(&#x27;call b&#x27;)&#125; 变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 123456789b() // call b secondfunction b() &#123; console.log(&#x27;call b fist&#x27;)&#125;function b() &#123; console.log(&#x27;call b second&#x27;)&#125;var b = &#x27;Hello world&#x27; 复制代码var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用 #87 什么是单线程，和异步的关系 单线程 - 只有一个线程，只能做一件事 原因 - 避免 1DOM 渲染的冲突 浏览器需要渲染 DOM JS 可以修改 DOM 结构 JS 执行的时候，浏览器 DOM 渲染会暂停 两段 JS 也不能同时执行（都修改 DOM 就冲突了） webworker 支持多线程，但是不能访问 DOM 解决方案 - 异步 #88 是否用过 jQuery 的 Deferred #89 前端面试之hybrid http://blog.poetries.top/2018/10/20/fe-interview-hybrid/ #90 前端面试之组件化 http://blog.poetries.top/2018/10/20/fe-interview-component/ #91 前端面试之MVVM浅析 http://blog.poetries.top/2018/10/20/fe-interview-mvvm/ #92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置123456789101112131415161718192021const box = document.getElementById(&#x27;box&#x27;);function isIcon(target) &#123; return target.className.includes(&#x27;icon&#x27;);&#125;box.onClick = function(e) &#123; e.stopPropagation(); const target = e.target; if (isIcon(target)) &#123; target.style.border = &#x27;1px solid red&#x27;; &#125;&#125;const doc = document;doc.onclick = function(e) &#123; const children = box.children; for(let i; i &lt; children.length; i++) &#123; if (isIcon(children[i])) &#123; children[i].style.border = &#x27;none&#x27;; &#125; &#125;&#125; #93 请简单实现双向数据绑定mvvm123456789101112&lt;input id=&quot;input&quot;/&gt;const data = &#123;&#125;;const input = document.getElementById(&#x27;input&#x27;);Object.defineProperty(data, &#x27;text&#x27;, &#123; set(value) &#123; input.value = value; this.value = value; &#125;&#125;);input.onChange = function(e) &#123; data.text = e.target.value;&#125; #94 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)1234567891011var instance = null;class Storage &#123; static getInstance() &#123; if (!instance) &#123; instance = new Storage(); &#125; return instance; &#125; setItem = (key, value) =&gt; localStorage.setItem(key, value), getItem = key =&gt; localStorage.getItem(key)&#125; #95 说说event loop 首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务macrotask（setTimeout、setInterval）进行执行 #96 说说事件流事件流分为两种，捕获事件流和冒泡事件流 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段 #97 为什么canvas的图片为什么过有跨域问题#98 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块 https://www.jianshu.com/p/f54d265f7aa4 #99 请手写实现一个promise https://segmentfault.com/a/1190000013396601 #100 说说从输入URL到看到页面发生的全过程，越详细越好 首先浏览器主进程接管，开了一个下载线程。 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。 将下载完的内容转交给Renderer进程管理。 Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。 css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。 绘制结束后，关闭TCP连接，过程有四次挥手 #101 描述一下this this，函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里 102 说一下浏览器的缓存机制 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存 对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。 对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存 协商缓存相关设置 Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。Exprires的缺陷是必须保证服务端时间和客户端时间严格同步。 Cache-control：max-age：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题， If-None-Match/ETag：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回If-None-Match标识是否表示匹配。 Last-modified/If-Modified-Since：第一次请求的时候服务端返回Last-modified表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比 #103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？ 该组件需要提供hook指定渲染位置，默认渲染在body下面。 然后改组件可以指定外层样式，如宽度等 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。 另外组件是可控的，需要外层传入visible表示是否可见。 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。 组件高度可能大于页面高度，组件内部需要滚动条。 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容 #104 caller和callee的区别callee caller返回一个函数的引用，这个函数调用了当前的函数。 使用这个属性要注意 这个属性只有当函数在执行时才有用 如果在javascript程序中，函数是由顶层调用的，则返回null functionName.caller: functionName是当前正在执行的函数。 123function a() &#123; console.log(a.caller)&#125; callee callee放回正在执行的函数本身的引用，它是arguments的一个属性 使用callee时要注意: 这个属性只有在函数执行时才有效 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length 它可以用来递归匿名函数。 123function a() &#123; console.log(arguments.callee)&#125; #105 ajax、axios、fetch区别jQuery ajax 12345678$.ajax(&#123; type: &#x27;POST&#x27;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;); 优缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） axios 1234567891011121314axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 优缺点： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF fetch 12345678try &#123; let response = await fetch(url); let data = response.json(); console.log(data);&#125; catch(e) &#123; console.log(&quot;Oops, error&quot;, e);&#125; 优缺点： fetcht只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 fetch默认不会带cookie，需要添加配置项 fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费 fetch没有办法原生监测请求的进度，而XHR可以 #四、jQuery#1 你觉得jQuery或zepto源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; &#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 #2 jQuery 的实现原理 (function(window, undefined) &#123;&#125;)(window); jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题 window.jQuery = window.$ = jQuery; 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量 #3 jQuery.fn 的 init 方法返回的 this 指的是什么对象 jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象 用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法 #4 jQuery.extend 与 jQuery.fn.extend 的区别 $.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法 $.extend(object); // 为jQuery添加“静态方法”（工具方法） 123456$.extend(&#123; min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);$.min(2,3); // 2$.max(4,5); // 5 $.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展 1234var settings = &#123;validate:false, limit:5&#125;;var options = &#123;validate:true, name:&quot;bar&quot;&#125;;$.extend(settings, options); // 注意：不支持第一个参数传 false// settings == &#123;validate:true, limit:5, name:&quot;bar&quot;&#125; $.fn.extend(json); // 为jQuery添加“成员函数”（实例方法） 123456789$.fn.extend(&#123; alertValue: function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125;&#125;);$(&quot;#email&quot;).alertValue(); #5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝 浅拷贝（只复制一份原始对象的引用） var newObject = $.extend(&#123;&#125;, oldObject); 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝） var newObject = $.extend(true, &#123;&#125;, oldObject); #6 jQuery 的队列是如何实现的 jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。 主要应用于 animate()，ajax，其他要按时间顺序执行的事件中 12345678910111213141516171819202122var func1 = function()&#123;alert(&#x27;事件1&#x27;);&#125;var func2 = function()&#123;alert(&#x27;事件2&#x27;);&#125;var func3 = function()&#123;alert(&#x27;事件3&#x27;);&#125;var func4 = function()&#123;alert(&#x27;事件4&#x27;);&#125;// 入栈队列事件$(&#x27;#box&#x27;).queue(&quot;queue1&quot;, func1); // push func1 to queue1$(&#x27;#box&#x27;).queue(&quot;queue1&quot;, func2); // push func2 to queue1// 替换队列事件$(&#x27;#box&#x27;).queue(&quot;queue1&quot;, []); // delete queue1 with empty array$(&#x27;#box&#x27;).queue(&quot;queue1&quot;, [func3, func4]); // replace queue1// 获取队列事件（返回一个函数数组）$(&#x27;#box&#x27;).queue(&quot;queue1&quot;); // [func3(), func4()]// 出栈队列事件并执行$(&#x27;#box&#x27;).dequeue(&quot;queue1&quot;); // return func3 and do func3$(&#x27;#box&#x27;).dequeue(&quot;queue1&quot;); // return func4 and do func4// 清空整个队列$(&#x27;#box&#x27;).clearQueue(&quot;queue1&quot;); // delete queue1 with clearQueue #7 jQuery 中的 bind(), live(), delegate(), on()的区别 bind() 直接绑定在目标元素上 live() 通过冒泡传播事件，默认document上，支持动态数据 delegate() 更精确的小范围使用事件代理，性能优于 live on() 是最新的1.9版本整合了之前的三种方式的新事件绑定机制 #8 是否知道自定义事件 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅” JS 原生支持自定义事件，示例： 1234document.createEvent(type); // 创建事件event.initEvent(eventType, canBubble, prevent); // 初始化事件target.addEventListener(&#x27;dataavailable&#x27;, handler, false); // 监听事件target.dispatchEvent(e); // 触发事件 jQuery 里的fire 函数用于调用jQuery自定义事件列表中的事件 #9 jQuery 通过哪个方法和 Sizzle 选择器结合的 Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点 jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合 #10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来12345678910111213// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现 $.array2json = function(array) &#123; return JSON.stringify(array); &#125; $.json2array = function(array) &#123; // $.parseJSON(array); // 3.0 开始，已过时 return JSON.parse(array); &#125; // 调用 var json = $.array2json([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); var array = $.json2array(json); #11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的1234567$(&quot;#btn&quot;).on(&quot;mouseover mouseout&quot;, func);$(&quot;#btn&quot;).on(&#123; mouseover: func1, mouseout: func2, click: func3&#125;); #12 针对 jQuery 的优化方法 缓存频繁操作DOM对象 尽量使用id选择器代替class选择器 总是从#id选择器来继承 尽量使用链式操作 使用时间委托 on绑定事件 采用jQuery的内部函数data()来存储数据 使用最新版本的 jQuery #13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢 在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$(&#39;.tab&#39;).stop().slideUp(); #14 jQuery UI 如何自定义组件 通过向 $.widget() 传递组件名称和一个原型对象来完成 $.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype); #15 jQuery 与 jQuery UI、jQuery Mobile 区别 jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX jQuery UI 是建立在 jQuery 库上的一组用户界面交互、特效、小部件及主题 jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架 #16 jQuery 和 Zepto 的区别？ 各自的使用场景 jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile Zepto从一开始就定位移动设备，相对更轻量级。它的API 基本兼容jQuery`，但对PC浏览器兼容不理想 #17 jQuery对象的特点 只有 JQuery对象才能使用 JQuery 方法 JQuery 对象是一个数组对象 #五、Bootstrap#1 什么是Bootstrap？以及为什么要使用Bootstrap？ Bootstrap 是一个用于快速开发 Web应用程序和网站的前端框架。Bootstrap是基于 HTML、CSS、JAVASCRIPT 的 Bootstrap具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以Bootstrap被广泛应用 #2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？ 使用Bootstrap时，需要使用 HTML5 文档类型（Doctype）。`` 因为Bootstrap使用了一些 HTML5 元素和 CSS 属性，如果在 Bootstrap创建的网页开头不使用 HTML5 的文档类型（Doctype），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过 W3C 标准的验证 #3 什么是Bootstrap网格系统 Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类 响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 #4 Bootstrap 网格系统（Grid System）的工作原理 （1）行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。 （2）使用行来创建列的水平组。 （3）内容应该放置在列内，且唯有列可以是行的直接子元素。 （4）预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。 （5）列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。 （6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4 #5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么 超小设备手机（&lt;768px）：.col-xs-* 小型设备平板电脑（&gt;=768px）：.col-sm-* 中型设备台式电脑（&gt;=992px）：.col-md-* 大型设备台式电脑（&gt;=1200px）：.col-lg-* #6 Bootstrap 网格系统列与列之间的间隙宽度是多少 间隙宽度为30px（一个列的每边分别是15px） #7 如果需要在一个标题的旁边创建副标题，可以怎样操作 在元素两旁添加``，或者添加.small的class #8 用Bootstrap，如何设置文字的对齐方式？ class=&quot;text-center&quot; 设置居中文本 class=&quot;text-right&quot; 设置向右对齐文本 class=&quot;text-left&quot; 设置向左对齐文本 #9 Bootstrap如何设置响应式表格？ 增加class=&quot;table-responsive&quot; #10 使用Bootstrap创建垂直表单的基本步骤？ （1）向父``元素添加role=&quot;form&quot;； （2）把标签和控件放在一个带有class=&quot;form-group&quot;的``中，这是获取最佳间距所必需的； （3）向所有的文本元素、、``添加class=&quot;form-control&quot; #11 使用Bootstrap创建水平表单的基本步骤？ （1）向父``元素添加class=&quot;form-horizontal&quot;； （2）把标签和控件放在一个带有class=&quot;form-group&quot;的``中； （3）向标签添加class=&quot;control-label&quot;。 #12 使用Bootstrap如何创建表单控件的帮助文本？ 增加class=&quot;help-block&quot;的span标签或p标签。 #13 使用Bootstrap激活或禁用按钮要如何操作？ 激活按钮：给按钮增加.active的class 禁用按钮：给按钮增加disabled=&quot;disabled&quot;的属性 #14 Bootstrap有哪些关于\" class=\"lazyload\" data-srcset=\"\" srcset=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=的class？ （1）.img-rounded 为图片添加圆角 （2）.img-circle 将图片变为圆形 （3）.img-thumbnail 缩略图功能 （4）.img-responsive 图片响应式 (将很好地扩展到父元素) #15 Bootstrap中有关元素浮动及清除浮动的class？ （1）class=&quot;pull-left&quot; 元素浮动到左边 （2）class=&quot;pull-right&quot; 元素浮动到右边 （3）class=&quot;clearfix&quot; 清除浮动 #16 除了屏幕阅读器外，其他设备上隐藏元素的class？ `class=”sr-only”`` #17 Bootstrap如何制作下拉菜单？ （1）将下拉菜单包裹在class=&quot;dropdown&quot;的``中； （2）在触发下拉菜单的按钮中添加：class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot; （3）在包裹下拉菜单的ul中添加：class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot; （4）在下拉菜单的列表项中添加：role=&quot;presentation&quot;。其中，下拉菜单的标题要添加class=&quot;dropdown-header&quot;，选项部分要添加tabindex=&quot;-1&quot;。 #18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？ （1）用class=&quot;btn-group&quot;的``去包裹按钮组；class=&quot;btn-group-vertical&quot;可设置垂直按钮组。 （2）btn-group的优先级高于btn-group-vertical的优先级。 #19 Bootstrap如何设置按钮的下拉菜单？ 在一个 .btn-group 中放置按钮和下拉菜单即可。 #20 Bootstrap中的输入框组如何制作？ （1）把前缀或者后缀元素放在一个带有class=&quot;input-group&quot;中的``中 （2）在该内，在`class=&quot;input-group-addon&quot;`的里面放置额外的内容； （3）把放在元素的前面或后面。 #21 Bootstrap中的导航都有哪些？ （1）导航元素：有class=&quot;nav nav-tabs&quot;的标签页导航，还有class=&quot;nav nav-pills&quot;的胶囊式标签页导航； （2）导航栏：class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;； （3）面包屑导航：class=&quot;breadcrumb&quot; #22 Bootstrap中设置分页的class？ 默认的分页：class=&quot;pagination&quot; 默认的翻页：class=&quot;pager&quot; #23 Bootstrap中显示标签的class？ 1class=&quot;label&quot; #24 Bootstrap中如何制作徽章？ 126 #25 Bootstrap中超大屏幕的作用是什么？ 设置class=&quot;jumbotron&quot;可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距 #六、微信小程序#1 微信小程序有几个文件 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式， js 逻辑处理，网络请求json小程序设置，如页面注册，页面标题及 tabBar。 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window 背景色，配置导航条样式，配置默认标题。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 配置全局 css #2 微信小程序怎样跟事件传值 给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或onload的param参数获取。但 data - 名称不能有大写字母和不可以存放对象 #3 小程序的 wxss 和 css 有哪些不一样的地方？ wxss的图片引入需使用外链地址 没有 Body；样式可直接使用 import 导入 #4 小程序关联微信公众号如何确定用户的唯一性 使用 wx.getUserInfo 方法 withCredentials 为 true 时 可获取 encryptedData，里面有 union_id。后端需要进行对称解密 #5 微信小程序与vue区别 生命周期不一样，微信小程序生命周期比较简单 数据绑定也不同，微信小程序数据绑定需要使用{{ something }}，vue 直接:就可以 显示与隐藏元素，vue中，使用 v-if 和 v-show 控制元素的显示和隐藏，小程序中，使用wx-if和hidden 控制元素的显示和隐藏 事件处理不同，小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event) 绑定事件,vue：使用 v-on:event 绑定事件，或者使用@event 绑定事件 数据双向绑定也不也不一样在 vue中,只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是 vue非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data中声明的变量。 #七、webpack相关#1 打包体积 优化思路 提取第三方库或通过引用外部文件的方式引入第三方库 代码压缩插件UglifyJsPlugin 服务器启用gzip压缩 按需加载资源文件 require.ensure 优化devtool中的source-map 剥离css文件，单独打包 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致 #2 打包效率 开发环境采用增量构建，启用热更新 开发环境不做无意义的工作如提取css计算文件hash等 配置devtool 选择合适的loader 个别loader开启cache 如babel-loader 第三方库采用引入方式 提取公共代码 优化构建时的搜索路径 指明需要构建目录及不需要构建目录 模块化引入需要的部分 #3 Loader编写一个loader 1loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader 12345678910111213141516// 定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); //返回JavaScript源码，必须是String或者Buffer return `module.exports = &#x27;$&#123;result&#125;&#x27;`;&#125;//使用&#123; test: /\\.txt$/, use: [ &#123; &#x27;./path/reverse-txt-loader&#x27; &#125; ]&#125;, #4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化构建优化 减少编译体积 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime 并行编译 happypack、thread-loader、uglifyjsWebpackPlugin开启并行 缓存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin开启缓存、babel-loader开启缓存 预编译 dllWebpackPlugin &amp;&amp; DllReferencePlugin、auto-dll-webapck-plugin 性能优化 减少编译体积 Tree-shaking、Scope Hositing hash缓存 webpack-md5-plugin 拆包 splitChunksPlugin、import()、require.ensure 八、编程题#1 写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&#x27;on&#x27; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&#x27;on&#x27; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&#x27;on&#x27; + type, handler); &#125; else &#123; element[&#x27;on&#x27; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125; #2 如何判断一个对象是否为数组123456function isArray(arg) &#123; if (typeof arg === &#x27;object&#x27;) &#123; return Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;; &#125; return false;&#125; #3 冒泡排序 每次比较相邻的两个数，如果后一个比前一个小，换位置 1234567891011121314151617var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) &#123;for (var i = 0; i &lt; arr.length - 1; i++) &#123; for(var j = 0; j &lt; arr.length - i - 1; j++) &#123; if(arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;return arr;&#125;console.log(bubbleSort(arr)); #4 快速排序 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边 123456789101112131415161718192021222324var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125;console.log(quickSort(arr)); #5 编写一个方法 求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(&quot;你好,as&quot;)); #6 bind的用法，以及如何实现bind的函数和需要注意的点 bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。 一个简单的bind函数实现如下 123456Function.prototype.bind = function(ctx) &#123; var fn = this; return function() &#123; fn.apply(ctx, arguments); &#125;;&#125;; #7 实现一个函数clone 可以对JavaScript中的5种主要的数据类型,包括Number、String、Object、Array、Boolean）进行值复 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计 12345678910111213141516171819202122232425262728293031323334// 方法一： Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o; &#125; //方法二： /** * 克隆一个对象 * @param Obj * @returns */ function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = []; //创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125;else if (Obj instanceof Object)&#123; buf = &#123;&#125;; //创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; //普通变量直接赋值 return Obj; &#125; &#125; #8 下面这个ul，如何点击每一列的时候alert其index \b考察闭包 12345678910111213141516171819202122232425&lt;ul id=”test”&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt; // 方法一： var lis=document.getElementById(&#x27;2223&#x27;).getElementsByTagName(&#x27;li&#x27;); for(var i=0;i&lt;3;i++) &#123; lis[i].index=i; lis[i].onclick=function()&#123; alert(this.index); &#125;//方法二：var lis=document.getElementById(&#x27;2223&#x27;).getElementsByTagName(&#x27;li&#x27;);for(var i=0;i&lt;3;i++)&#123; lis[i].index=i; lis[i].onclick=(function(a)&#123; return function() &#123; alert(a); &#125; &#125;)(i);&#125; #9 定义一个log方法，让它可以代理console.log的方法1234567可行的方法一： function log(msg) &#123; console.log(msg); &#125; log(&quot;hello world!&quot;) // hello world! 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是： 123function log()&#123; console.log.apply(console, arguments);&#125;; #10 输出今天的日期 以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 1234567891011var d = new Date(); // 获取年，getFullYear()返回4位的数字 var year = d.getFullYear(); // 获取月，月份比较特殊，0是1月，11是12月 var month = d.getMonth() + 1; // 变成两位 month = month &lt; 10 ? &#x27;0&#x27; + month : month; // 获取日 var day = d.getDate(); day = day &lt; 10 ? &#x27;0&#x27; + day : day; alert(year + &#x27;-&#x27; + month + &#x27;-&#x27; + day); #11 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序123456789var iArray = []; funtion getRandom(istart, iend)&#123; var iChoice = istart - iend +1; return Math.floor(Math.random() * iChoice + istart; &#125; for(var i=0; i&lt;10; i++)&#123; iArray.push(getRandom(10,100)); &#125; iArray.sort(); #12 写一段JS程序提取URL中的各个GET参数 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如&#123;a:&#39;1&#39;, b:&#39;2&#39;, c:&#39;&#39;, d:&#39;xxx&#39;, e:undefined&#125; 123456789function serilizeUrl(url) &#123; var result = &#123;&#125;; url = url.split(&quot;?&quot;)[1]; var map = url.split(&quot;&amp;&quot;); for(var i = 0, len = map.length; i &lt; len; i++) &#123; result[map[i].split(&quot;=&quot;)[0]] = map[i].split(&quot;=&quot;)[1]; &#125; return result; &#125; #13 写一个function，清除字符串前后的空格 使用自带接口trim()，考虑兼容性： 123456789if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\\s+/, &quot;&quot;).replace(/\\s+$/,&quot;&quot;); &#125;&#125; // test the function var str = &quot; \\t\\n test string &quot;.trim(); alert(str == &quot;test string&quot;); // alerts &quot;true&quot; #14 实现每隔一秒钟输出1,2,3…数字1234567for(var i=0;i&lt;10;i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j+1) &#125;,j*1000) &#125;)(i)&#125; #15 实现一个函数，判断输入是不是回文字符串1234function run(input) &#123; if (typeof input !== &#x27;string&#x27;) return false; return input.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) === input;&#125; #16、数组扁平化处理 实现一个flatten方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组 12345function flatten(arr)&#123; return arr.reduce(function(prev,item)&#123; return prev.concat(Array.isArray(item)?flatten(item):item); &#125;,[]);&#125; #九、其他#1 负载均衡 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用 http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱） 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量 #2 CDN 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 #3 内存泄漏 定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。 js中可能出现的内存泄漏情况 结果：变慢，崩溃，延迟大等，原因： 全局变量 dom清空时，还存在引用 ie中使用闭包 定时器未清除 子元素存在引起的内存泄露 避免策略 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 注意程序逻辑，避免“死循环”之类的 ； 避免创建过多的对象 原则：不用了的东西要及时归还。 减少层级过多的引用 #4 babel原理 ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码 #5 js自定义事件 三要素： document.createEvent() event.initEvent() element.dispatchEvent() 12345678910111213141516171819202122232425262728// (en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function()&#123; var demo = document.getElementById(&quot;demo&quot;); demo.addEvent(&quot;test&quot;,function()&#123;console.log(&quot;handler1&quot;)&#125;); demo.addEvent(&quot;test&quot;,function()&#123;console.log(&quot;handler2&quot;)&#125;); demo.onclick = function()&#123; this.triggerEvent(&quot;test&quot;); &#125;&#125;Element.prototype.addEvent = function(en,fn)&#123; this.pools = this.pools || &#123;&#125;; if(en in this.pools)&#123; this.pools[en].push(fn); &#125;else&#123; this.pools[en] = []; this.pools[en].push(fn); &#125;&#125;Element.prototype.triggerEvent = function(en)&#123; if(en in this.pools)&#123; var fns = this.pools[en]; for(var i=0,il=fns.length;i&lt;il;i++)&#123; fns[i](); &#125; &#125;else&#123; return; &#125;&#125; #6 前后端路由差别 后端每次路由请求都是重新访问服务器 前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合 #十、综合#1 谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 #2 什么样的前端代码是好的 高复用低耦合，这样文件小，好维护，而且好扩展。 具有可用性、健壮性、可靠性、宽容性等特点 遵循设计模式的六大原则 #3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 实现界面交互 提升用户体验 基于NodeJS，可跨平台开发 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； #4 你觉得前端工程的价值体现在哪 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） #5 平时如何管理你的项目 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理 #6 组件封装 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作 分析布局 初步开发 化繁为简 组件抽象 十一、一些常见问题 自我介绍 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你们部门的开发流程是怎样的 你认为哪个项目做得最好？ 说下工作中你做过的一些性能优化处理 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你为什么要离开前一家公司？ 你对加班的看法 你希望通过这份工作获得什么？","categories":[],"tags":[]},{"title":"第20章：应用数学","slug":"SystemArchitect/第20章：应用数学","date":"2021-08-10T16:00:00.000Z","updated":"2021-08-11T08:36:03.608Z","comments":true,"path":"2021/08/11/SystemArchitect/第20章：应用数学/","link":"","permalink":"https://alloceee.github.io/2021/08/11/SystemArchitect/%E7%AC%AC20%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/","excerpt":"","text":"数学建模2.数学建模的过程（1）模型准备：了解问题的实际背景，明确其实际意义，掌握对象的各种信息。用数学语言来描述问题。 （2）模型假设：根据实际对象的特征和建模的目的，对问题进行必要的简化，并用精确的语言提出一些恰当的假设。 （3）模型建立：在假设的基础上，利用适当的数学工具来刻画各变量之间的数学关系，建立相应的数学结构。只要能够把问题描述清楚，尽量使用简单的数学工具。 （4）模型求解：利用获取的数据资料，对模型的所有参数作出计算（估计）。 （5）模型分析：对所得的结果进行数学上的分析。 在对实际应用问题建立数学模型并求得结果后，还需要根据建模的目的和要求，利用相关知识，结合研究对象的特点，进行模型分析。 模型分析工作主要包括模型的合理性分析、模型的误差分析和参数的灵敏性分析等，一般不包括模型的先进性分析。 （6）模型检验：将模型分析结果与实际情形进行比较，以此来验证模型的准确性、合理性和适用性。如果模型与实际较吻合，则要对计算结果给出其实际含义，并进行解释。如果模型与实际吻合较差，则应该修改假设，再次重复建模过程。 （7）模型应用：应用方式因问题的性质和建模的目的而异。 3.数学建模的方法 （1）直接分析法：根据对问题内在机理的认识，直接构造出模型。 （2）类比法：根据类似问题的模型构造新模型。 （3）数据分析法：通过试验，获得与问题密切相关的大量数据，用统计分析方法进行建模。 （4）构想法：对将来可能发生的情况给出逻辑上合理的设想和描述，然后用已有的方法构造模型，并不断修正完善，直至用户比较满意为止。","categories":[],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Allocee"},{"title":"第16章：安全性和保密性设计","slug":"SystemArchitect/第16章：安全性和保密性设计","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-10T09:08:01.027Z","comments":true,"path":"2021/08/10/SystemArchitect/第16章：安全性和保密性设计/","link":"","permalink":"https://alloceee.github.io/2021/08/10/SystemArchitect/%E7%AC%AC16%E7%AB%A0%EF%BC%9A%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E4%BF%9D%E5%AF%86%E6%80%A7%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"加密和解密在加密和解密的过程中，如果采用的加密密钥与解密密钥相同，或者从一个很容易计算出另一个，则这种方法叫作对称密钥密码体制，也叫作单钥密码体制。反之，如果加密和解密的密钥并不相同，或者从一个很难计算出另外一个，就叫作不对称密钥密码系统或者公开密钥密码体制，也叫作双钥密码体制。 对称密钥加密算法 对称密钥加密算法有多种，例如，DES（Data Encryption Standard，数据加密标准）、 IDEA（International Data Encryption Algorithm，国际数据加密算法）、Skipjack、3DES、GDES、 New DES、Lucifer、FEAL N、LOKI 91、RC4、RC5 等。 1．DES 算法 DES 算法的过程，简单来说，就是把要加密的明文分成 64 位的数据段作为输入，再使用根据 64 位密钥变化生成的 52 个子密钥，对输入的数据段依次进行初始置换、16 轮 迭代、逆初始置换，然后得到 64 位密文。 DES 的解密过程与加密过程几乎相同，只是子密钥的使用顺序不一样。加密时依次使用的部分参数 K1 K2 K3 …K16，在解密时则按照 K16 K15 K14 …K1 顺序使用。其他算法完全一样，这也是 DES 容易使用的一个方面。 2．IDEA 算法 IDEA 在加密运算中所处理的数据段大小也是 64 位，但是所用的密钥长度为 128 位，而且采用更加复杂的加密算法，目的是保证它不会被轻易破译。另外，IDEA 实现非常方便，既可以通过软件实现，也可以通过硬件实现。 IDEA 算法对数据的处理是以 64 位为单位的，在加密前把要加密的明文按每 64 位作为一个数据段进行分割然后分别加密。 IDEA 的解密过程与加密过程基本相同，所不同的就是解密子密钥的产生方式与加密子密钥的产生方式不一样，解密的其他运算过程同加密一样，也是把 64 位数据段分成 4 个 16 位的数据段，然后经过八轮迭代变换和一轮输出变换，就可以得到对应的明文结果。 不对称秘钥加密算法公开密钥加密方法中，要想达到良好的加密效果，算法上必须做到：在计算上产生密钥非常容易；已知公钥的情况下对明文加密在计算上很容易实现；已知私钥的情况下对密文解密在计算上很容易实现；尽管用于加密和解密的两个密钥在数学上是相关的，但是在已知公钥的情况下，要想求得私钥在计算上不可行；已知公钥和密文的情况下，要想求得明文在计算上不可行。只有做到以上几点，才能有效地防止攻击者对算法的破译。 不对称密钥加密算法有多种，例如，RSA、ECC、背包密码、McEliece、Diffe Hellman、Rabin、Ong Fiat Shamir、零知识证明的算法、椭圆曲线、EIGamal 等。 RSA 的加密原理它是第一个既能用于数据加密也能用于数字签名的算法。 1．RSA 加密过程 首先把需要加密的明文按比特位分成等长的数据段，使得每个数据段对应的十进制数小于 N，即数据段的长度小于 log2N。然后依次对每个明文数据段 m 做加密运算可以得到密文 c∶c = me mod N。 相应的，解密时对密文数据段做解密运算就可以得到明文 m∶m = ce mod N。 2．RSA 数字签名 RSA 加密算法不仅可以用于信息的加密，而且还可以用于发送者的身份验证或数字签名。例如，用户 B 要向 A 发送一个信息 m，而且要让 A 确信该信息就是 B 本人发出的。为此，B 用自己的私钥 SK = (N，d)对信息加密得到密文 c∶c = md mod N，然后把 c 发送给 A。A 收到密文后，使用 B 的公钥 PK = (N，e)对密文进行解密得到明文 m∶m = ce mod N。这样，经过验证，A 可以确认信息 m 确实是 B 发出的，因为只有 B 本人才有与该公钥对应的私钥，其他人即使知道公钥，也无法猜出或计算出 B 的私钥来冒充他发送加密信息。 数字签名与数字水印散列函数是一种公开的数学函数。散列函数运算的输入信息也可叫作报文。散列函数运算后所得到的结果叫做散列码或者叫做信息摘要。 常见的散列函数有 MD5、SHA、HMAC 等。 MD5 是一种非常著名的散列算法，已经成为国际标准，具有很好的安全性能。MD5 算法在对输入的报文进行计算时，是以 512 位为单位进行处理的，结果生成一个 128 位长的消息摘要；SHA、HMAC 等算法都是对任意长度的报文以 512 位为单位进行处理，最后得出一个 160 位的消息摘要。 消息摘要是用来保证数据完整性的。传输的数据一旦被修改那么计算出的摘要就不同，只要对比两次摘要就可确定数据是否被修改过。因此其目的是为了防止发送的消息被篡改。 对摘要进行加密的目的是防止抵赖 数字签名对于计算机系统中传送、存储的重要文件、数据、信息等，一般需要有某种方式来确认其真实性，即接收者能够确认自己得到的信息确实是由该信息所声称的发送者发出的，而不是由非法入侵者伪造、冒充发出的，并且还要能够保证信息在传送、存储中没有被恶意篡改，这样这份信息才能真实地反映发送方的意图。另外，对于发送方来说，如果发出一份信息，还必须有一定的措施阻止其否认自己发出信息的行为，即不可否认性。 数字签名主要由两个算法组成：签名算法和验证算法。通过使用签名算法签名一个消息，所得到的签名能够通过一个验证算法来验证签名的真实性和有效性。 目前已经有大量的数字签名算法，例如，RSA 数字签名算法、EI Gamal、Fiat-Shamir、Guillon-Oucsquerrter、DSS（Digital Signature Standard，数字签名标准）、DSA（Digital Signature Algorithm，数字签名算法）、椭圆曲线等。 1．RSA 结合 MD5 数字签名前面讲过，RSA 公钥加密技术本身就可以用来实现数字签名。但是仅仅使用公钥加密算法进行数字签名的运算量比较大，尤其是要传送的信息量比较大时，速度会更加慢。显然，直接用这种方法进行数字签名并不是很好的选择。 而散列算法（例如，MD5 算法）就有很好的特性，它能对每一个不同长度的信息产生相互不同的、独特的、简短的消息摘要。这个消息摘要可以看作这个信息特有的“指纹”，因而非常适合用作数字签名。 通过散列算法对原始数据进行散列，再对散列码进行公钥加密就可以很好地实现数字签名。 它的特点是：它代表了文件的特征，具有唯一性。只要文件发生哪怕一位数据的改变，或者签名者有任何差别，数字签名的值也将随之而发生改变；不同的文件和签名者得到的是不同的数字签名。 RSA 结合 MD5 数字签名的主要过程是： （1）信息发送者 A 要向 B 发送一份信息，A 先按双方约定的散列算法对该信息进行散列运算，得到一个该信息特有的消息摘要 H，从前面所述可以知道，只要改动信息中任何一位，重新计算出的消息摘要值就会与原先的值不相符。这样就保证了信息的不可更改性。 （2）接着把该消息摘要用 A 自己的私钥加密，得到 A 对该信息的数字签名 S。 （3）然后 A 把信息原文与数字签名 S 一起发送给 B。 （4）当 B 收到后，先用 A 的公钥对数字签名 S 解密得到 A 的消息摘要 H。 （5）再用同样的散列算法对收到的信息进行散列运算，得到消息摘要 H’。 （6）比较 H 与 H’，如相等则说明信息确实来自它所声称的发送者 A。 RSA 用于数字签名的一个重要的特点是能够证实信息发送方的身份及电子文件的可靠性和完整性，它对于发送方和被发送的信息都是独一无二的，具有可验证性和不可否认的权威性特点；另一个重要的特点是它通过在计算机之间交换数字证书就可以确定当事者就是他们所宣称的人。（防止抵赖） 2．数字签名标准DSS 是美国国家标准与技术学会的数字签名标准，自 1991 年提出以来又经过广泛的修改。DSS 为计算和验证数字签名指定了一个数字签名算法——DSA。 DSS 中指定 SHA 作为其散列算法，它对原始信息进行运算后产生 160 位的消息摘要，然后 DSS 把这一消息摘要与一个用作这个特殊签名的随机数作为输入送到数字签名算法中，经过运算生成数字签名。 该数字签名函数还依赖于发送方的私钥 SK 和一个对许多通信方都公开的由重要的公钥集合组成的全局公钥。 接收方在收到消息摘要和签名后将其作为验证函数的输入。验证函数还依赖于全局公钥和与发送方的私钥相匹配的公钥 PK，这样只有发送方用其自己的私钥才能产生有效的签名。 通过数字签名可以有效地保证数据的完整性，防止第三方伪造或发送方的抵赖","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第18章：软件的知识产权保护","slug":"SystemArchitect/第18章：软件的知识产权保护","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-10T09:11:55.112Z","comments":true,"path":"2021/08/10/SystemArchitect/第18章：软件的知识产权保护/","link":"","permalink":"https://alloceee.github.io/2021/08/10/SystemArchitect/%E7%AC%AC18%E7%AB%A0%EF%BC%9A%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%BF%9D%E6%8A%A4/","excerpt":"我国十分重视知识产权的保护，出台了一系列的相关法律法规。其中主要包括《著作权法》、《计算机软件保护条件》、《专利法》、《商标法》和《反不正当竞争法》。","text":"我国十分重视知识产权的保护，出台了一系列的相关法律法规。其中主要包括《著作权法》、《计算机软件保护条件》、《专利法》、《商标法》和《反不正当竞争法》。 著作权法著作权法及实施条件的客体是指受保护的作品。这里的作品，是指文学、艺术和自然科学、社会科学、工程技术领域内具有独创性并能以某种有形形式复制的智力成果。 1.作品类型（9种）(1)文字作品：包括小说、诗词、散文、论文等以文字形式表现的作品。 (2)口述作品：是指即兴的演说、授课、法庭辩论等以口头语言形式表现的作品。 (3)音乐、戏剧、曲艺、舞蹈、杂技作品。 (4)美术、摄影作品。 (5)电影、电视、录像作品。 (6)工程设计、产品设计图纸及其说明。 (7)地图、示意图等图形作品。 (8)计算机软件。 (9)法律、行政法规规定的其他作品。 2.职务作品为完成单位工作任务所创作的作品，称为职务作品。如果该职务作品是利用单位的物质技术条件进行创作，并由单位承担责任的；或者有合同约定，其著作权属于单位。那么作者将仅享有署名权，其他著作权归单位享有。 其他职务作品，著作权仍由作者享有，单位有权在业务范围内优先使用，并且在两年内，未经单位同意，作者不能够许可其他人、单位使用该作品。 3．著作权人的确定 著作权法在认定著作权人时，是根据创作的事实进行的，而创作就是指直接产生文学、艺术和科学作品的智力活动。而为他人创作进行组织，提供咨询意见、物质条件或者进行其他辅助工作，不属于创作的范围，不被确认为著作权人。 如果在创作的过程中，有多人参与，那么该作品的著作权将由合作的作者共同享有。合作的作品是可以分割使用的，作者对各自创作的部分可以单独享有著作权，但不能够在侵犯合作作品整体的著作权的情况下行使。 如果遇到作者不明的情况，那么作品原件的所有人可以行使除署名权以外的著作权，直到作者身份明确。 如果作品是委托创作的，著作权的归属应通过委托人和受托人之间的合同来确定。如果没有明确的约定，或者没有签订相关合同，则著作权仍属于受托人。 4.著作权法根据著作权法及实施条例规定，著作权人对作品享有 5 种权利。 发表权：即决定作品是否公之于众的权利。 署名权：即表明作者身份，在作品上署名的权利。 修改权：即修改或者授权他人修改作品的权利。 保护作品完整权：即保护作品不受歪曲、篡改的权利。 使用权、使用许可权和获取报酬权、转让权：即以复制、表演、播放、展览、发行、摄制电影、电视、录像或者改编、翻译、注释、编辑等方式使用作品的权利；以及许可他人以上述方式使用作品，并由此获得报酬的权利。 1．著作权保护期限根据著作权法相关规定，著作权的保护是有一定期限的。 ① 著作权属于公民。署名权、修改权、保护作品完整权的保护期没有任何限制，永远 属于保护范围。而发表权、使用权和获得报酬权的保护期为作者终生及其死亡后的 50 年（第 50 年的 12 月 31 日）。作者死亡后，著作权依照继承法进行转移。 ② 著作权属于单位。发表权、使用权和获得报酬权的保护期为 50 年（首次发表后的 第 50 年的 12 月 31 日），若 50 年内未发表的，不予保护。但单位变更、终止后，其著 作权由承受其权利义务的单位享有。 2．使用许可当 第三方需要使用时，需得到著作权人的使用许可，双方应签订相应的合同。合同中应包括许可使用作品的方式，是否专有使用，许可的范围与时间期限，报酬标准与方法，违约责任。在合同未明确许可的权力，需再次经著作权人许可。合同的有效期限不超过 10年，期满时可以续签。 对于出版者、表演者、录音录像制作者、广播电台、电视台而言，在下列情况下使用作品，可以不经著作权人许可、不向其支付报酬。但应指名作者姓名、作品名称，不得侵犯其他著作权。 为个人学习、研究或者欣赏，使用他人已经发表的作品。为介绍、评论某一个作品或者说明某一个问题，在作品中适当引用他人已经发表的作品。 为报道时间新闻，在报纸、期刊、广播、电视节目或者新闻记录影片中引用已经发表的作品。 报纸、期刊、广播电台、电视台刊登或者播放其他报纸、期刊、广播电台、电视台已经发表 的社论、评论员文章。 报纸、期刊、广播电台、电视台刊登或者播放在公众集会上发表的讲话，但作者声明不许刊 登、播放的除外。 为学校课堂教学或者科学研究，翻译或者少量复制已经发表的作品，供教学或者科研人员使 用，但不得出版发行。 国家机关为执行公务使用已经发表的作品。 图书馆、档案馆、纪念馆、博物馆、美术馆等为陈列或者保存版本的需要，复制本馆收藏的 作品。 免费表演已经发表的作品。 对设置或者陈列在室外公共场所的艺术作品进行临摹、绘画、摄影、录像。将已经发表的汉族文字作品翻译成少数民族文字在国内出版发行。 将已经发表的作品改成盲文出版 绘画、书法、雕塑等美术作品的原件可以买卖、赠与。但是，获得一件美术作品并不意味着获得该作品的著作权。我国著作权法第18条规定：“美术等作品原件所有权的转移。不视为作品著作权的转移，但美术作品原件的展览权由原件所有人享有”。这就是说，艺术类作品物转移的事实并不引起美术作品著作权的转移，受让人只是取得物的所有权和作品原件的展览权，作品的著作权仍然由作者等著作权人享有。除了艺术类作品之外，对任何原件所有权可能转移的作品，如书籍、软件等都要注意区分作品物质载体的财产权和作品的著作权这两种不同的权利。 一般来讲，一个软件只有开发完成并固定下来才能享有软件著作权。如果一个软件一直处于开发状态中，其最终的形态并没有固定下来，则法律无法对其进行保护。因此，条例（法律）明确规定软件著作权自软件开发完成之日起产生。当然，现在的软件开发经常是一项系统工程，一个软件可能会有很多模块，而每一个模块能够独立完成某一项功能。自该模块开发完成后就产生了著作权。所以说，自该软件开发完成后就产生了著作权。 任何人都可以利用反向编译技术、净室技术和反向工程技术等获取他人软件所使用的思路、原理、结构、算法、处理过程和运行方法等设计要素，直接用与自己的软件产品中，这在著作权法上不构成侵权。 在我国，自专利申请日起计算，发明专利的保护器为20年，实用新型专利权和外观设计专利权的期限为10年；商标权的保护期限为自核准注册之日起10年，但可以根据其所有人的需要无线续展权利期限；软件著作权受法律保护的期限是作者终生及其死亡后50年。一旦保护期满，权利将终止，成为社会公众可以自由使用的知识。 发表权是指作者决定作品是否公之于众和以何种方式公之于众的权利。发表权作为著作权人的一种权利，其包含两种含义：一是权利人有权决定是否发表，或许可他人发表；二是权利人有权以某种方式发表，如出版、发行、展览、销售等，以及确定在什么时间、地点发表。在一些情况下，作者虽未将作品公之于众，但可推定作者同意发表其作品。例如，作者许可他人使用其未发表的作品意味着作者同意发表其作品， 认为作者已经行使发表权。又如，作者将其未发表的作品原件所有权转让给他人，意味着发表权与著作财产权的一起行使，即作者的发表权也已行使完毕，已随着财产权转移。再如，展览尚未发表的作品即为作品的发表，展览行为必然附带着发表，所以推定已经行使了发表权。发表权是一次性权利，即发表权行使一次后，不再享有发表权。例如，第一次出版、第一次表演、上网公布等都属于行使发表权。以后再次使用作品与发表权无关，而是行使作品的使用权。发表权须借助一定的作品使用方式行使，即作品的公之于众要以某种确定的方式实现。也就是说，发表权难以孤立地行使，要以某种确定的方式实现，如书籍的出版、剧本的上演、绘画的展出等，既是作品的发表，同时也是作品的使用。在我国商标权的取得实行的是注册原则，即商标所有人只有依法将自己的商标注册后，商标注册人才能取得商标权，其商标才能得到法律的保护。M画家并未将其美术作品实施商标注册，不享有其美术作品的商标权，因此L公司的行为未侵犯M画家的商标权，而是侵犯了M画家的在先权利。在先权利包括著作权、外观设计专利权、商号权、 地理标志权、姓名权等。展览权是将作品原件或复制件公开陈列的权利。公开陈列的作品既可以是已经发表的作品，也可以是尚未发表的作品。画展、书法展、摄影展等都是公开陈列。 商标注册是指商标所有人为了取得商标专用权，将其使用的商标，依照法律的注册条件、 原则和程序，向商标局提出注册申请，商标局经过审核，准予注册的法律制度。 注册商标 时使用的商标标识须具备可视特征，且不得与他人先取得的合法权力相冲突，不得违反公序 良俗。 具备可视性（显著性），要求必须为视觉可感知，可以是平面的文字、图形、字母、 数字，也可以是三维立体标志或者颜色组合以及上述要素的组合。显著性要求商标的构成要 素必须便于区别。读音相同也属于相同商标，相同商标注册遵循的原则是谁先申请谁拥有，同时（同一天）申请则看谁先使用，如果无法判断可以通过协商来确定归属，协商不成可抽签决定结果。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第19章：标准化知识","slug":"SystemArchitect/第19章：标准化知识","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-10T08:59:41.971Z","comments":true,"path":"2021/08/10/SystemArchitect/第19章：标准化知识/","link":"","permalink":"https://alloceee.github.io/2021/08/10/SystemArchitect/%E7%AC%AC19%E7%AB%A0%EF%BC%9A%E6%A0%87%E5%87%86%E5%8C%96%E7%9F%A5%E8%AF%86/","excerpt":"","text":"标准化概论、标准分级与标准类型、软件开发规范与文档标准 标准分级与标准类型根据制定机构和适用范围的不同，标准可分为若干个级别。按类型划分，标准可分为强制性标准和推荐性标准。 标准分级根据《中华人民共和国标准化法》，国内标准分为国家标准、行业标准、地方标准和企业标准。在全球范围内，标准的分级方式并不统一，一般可分为国际标准、行业标准、区域标准和企业标准等。 1．国际标准 国际标准是指由国际联合机构制定和公布，提供各国参考的标准。国际标准化组织、国 际电工委员会和国际电信联盟制定的标准均为国际标准。此外，被 ISO 认可、收入 KWIC 索引中的其他 25 个国际组织制定的标准，也视为国际标准。 2.国家标准GB（或 GB/T）：中华人民共和国国家标准 ANSI（American NationalStandards Institute）：美国国家标准协会标准。 FIPS-NBS（Federal InformationProcessing Standards，National Bureau of Standards）：美国国家标准局联邦信息处理标准。 BS（British Standard）：英国国家标准。 JIS（Japanese Industrial Standard）：日本工业标准。 3.行业标准行业标准是指由行业机构、学术团体或国防机构制定，并适用于某个业务领域的标准，举例如下。 IEEE：电气电子工程师学会标准。 GJB：中华人民共和国国家军用标准，由国防科学技术工业委员会批准，适合于国防部门和军队。 DOD-STD（Department OfDefense STanDards）：美国国防部标准，适用于美国国防部门。 MIL-S（MILitary Standards）：美国军用标准，适用于美国军队内部。 SJ：中国电子行业标准 4．区域/地方标准ARS：非洲地区标准，由非洲地区标准化组织制定。 EN：欧洲标准，由欧洲标准化委员会制定。 PAS：泛美标准，由泛美技术标准委员会制定。 在国内，地方标准是指由地方行政主管部门制定，仅适用于本地的标准，其标准代号一般以 DB 开头。根据《中华人民共和国标准化法》，地方标准由省、自治区、直辖市标准化行政主管部门制定，并报国务院标准化行政主管部门和国务院有关行政主管部门备案。 5．企业标准企业标准以 Q 字开头 6．各级标准之间的关系 《中华人民共和国标准化法》明确规定了国家标准、行业标准、地方标准和企业标准之 间的关系。 （1）对需要在全国范围内统一的技术要求，应当制定国家标准。 （2）对没有国家标准而又需要在全国某个行业范围内统一的技术要求，可以制定行业 标准。在公布国家标准之后，该项行业标 准即行废止。 （3）对没有国家标准和行业标准而又需要在省、自治区、直辖市范围内统一的工业产 品的安全、卫生要求，可以制定地方标准。在公布国家标准或者行业标准之后，该项地方标 准即行废止。 （4）企业生产的产品没有国家标准和行业标准的，应当制定企业标准，作为组织生产 的依据。已有国家标准或者行业标准的，国家鼓励企业制定严于国家标准或者行业标准的企 业标准，在企业内部适用。 《中华人民共和国标准化法》同时规定，“国家鼓励积极采用国际标准”，但并没有明确 指出：当国家标准与国际标准不一致时，应当采用哪个标准。按照国际惯例，当一国产品在 另一国销售时，应当优先适用销售地的国家标准。 强制性标准与推荐性标准强制性国家标准以 GB 开头，推荐性国家标准以 GB/T 开头。但应注意，此项规定并 不适用于国家早期发布的标准，当时的国家标准统一以 GB 开头。 强制性标准可分为全文强制和条文强制两种形式。 《中华人民共和国标准化法》规定：强制性标准，必须执行。不符合强制性标准的产品， 禁止生产、销售和进口。生产、销售、进口不符合强制性标准的产品的，由法律、行政法规 规定的行政主管部门依法处理，法律、行政法规未作规定的，由工商行政管理部门没收产品 和违法所得，并处罚款；造成严重后果构成犯罪的，对直接责任人员依法追究刑事责任。 推荐性标准，国家鼓励企业自愿采用。这类标准，不具有强制性，任何单位均有权决定 是否采用，主要通过经济手段或市场因素自行调节。违犯这类标准，不构成经济或法律方面 的责任。但应当指出，推荐性标准一经接受并采用，或各方商定同意纳入经济合同中，就成 为各方必须共同遵守的技术依据，具有法律上的约束性。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"","slug":"SystemArchitect/第15章：基于中间件的开发","date":"2021-08-09T01:37:42.780Z","updated":"2021-08-12T06:53:34.679Z","comments":true,"path":"2021/08/09/SystemArchitect/第15章：基于中间件的开发/","link":"","permalink":"https://alloceee.github.io/2021/08/09/SystemArchitect/%E7%AC%AC15%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第13章：开发管理","slug":"SystemArchitect/第13章：开发管理","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-11T02:15:42.666Z","comments":true,"path":"2021/08/09/SystemArchitect/第13章：开发管理/","link":"","permalink":"https://alloceee.github.io/2021/08/09/SystemArchitect/%E7%AC%AC13%E7%AB%A0%EF%BC%9A%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/","excerpt":"一般的项目管理可以分为范围管理、时间管理、费用管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整体管理9个知识领域。 对于软件的开发管理来讲，软件范围管理、软件进度管理、软件成本管理、软件配置管理（属于整体管理）、软件质量管理、软件风险管理、开发人员管理（属于人力资源管理）7个方面的管理尤为重要。","text":"一般的项目管理可以分为范围管理、时间管理、费用管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整体管理9个知识领域。 对于软件的开发管理来讲，软件范围管理、软件进度管理、软件成本管理、软件配置管理（属于整体管理）、软件质量管理、软件风险管理、开发人员管理（属于人力资源管理）7个方面的管理尤为重要。 首先要考虑三个约束条件：项目范围、时间进度、成本预算。 项目的范围、时间与成本项目范围管理主要包括 项目启动、范围计划编制、范围定义、范围核实和范围变更控制5个部分的内容。 项目启动：批准项目启动或者允许项目进入下一个阶段； 范围计划编制：将生产项目产品所需进行的项目工作渐进明细和形成文件的过程； 项目范围定义：把主要的项目可交付成果分解成更小、更易管理的单元，以达到如下目的 提高对成本、时间及资源估算的准确性。 为绩效测量与控制定义一个基准计划。 便于进行明确的职责分配 范围核实：项目干系人（发起人、客户）正式接受项目范围的过程。范围核实需要审查可交付成果和工作结果，以确保它们都已经正确圆满地完成。如果项目被提前终止，范围核实过程应当对项目完成程度建立文档。范围核实与质量控制是不同的，范围核实是有关工作结果的“接收”，而质量控制是有关工作结果的正确性。 项目范围变更控制涉及的是： 对造成范围变更的因素施加影响，以确保这些变更得到一致认可； 确定范围变更是否已经发生； 当范围变更发生时对实际变更进行管理。 范围变更控制必须与其他控制管理过程（进行控制、成本控制和质量控制）结合在一起使用，才能取得良好的效果。 在初步项目范围说明书中已文档化的主要的可交付物、假设和约束条件的基础上准备详细的项目范围说明书，是项目成功的关键。范围定义的输入包括一下内容： （1）项目章程。如果项目章程或初始的范围说明书没有在项目执行组织中使用，同样的信息需要进一步收集和开发，以产生详细的项目范围说明书。 （2）项目范围管理计划； （3）组织过程资产； （4）批准的变更申请。 项目成本管理软件项目的成本不仅包括开发成本，也包括开发之前立项阶段及软件在运行中的费用。此外，操作者的培训费用和项目所使用的各种硬件设施费用也都是整个项目成本的一部分。 包括**资源计划编制、成本估算、成本预算、成本控制 **4 个主要部分内容。 资源计划编制是确定为完成项目各活动需什么资源（人、设备、材料）和这些资源的数量。 成本估算就是计算出完成一个项目的各活动所需各资源成本的近似值。成本估算是定价要考虑的因素之一。成本估算包括确认和考虑各种不同的成本估算替代方案。 成本预算是把估算的总成本分配到单个活动或工作包上去，建立基准计划来度量项目实际绩效。 成本控制的内容有： 对造成成本基准计划变化的因素施加影响，以保证这种变化得到一致认可； 确定成本基准计划是否已经发生变化；当变化发生和正在发生时，对这种变化执行管理。 成本控制包括以下方面： 监测成本执行情况，以寻找出并掌握计划的偏差及原因。 确保所有变更都准确地记录在成本基准计划中。 防止把不正确、不适宜或未批准的变更纳入成本基准成本。 将批准的变更通知项目干系人。 采取措施，把预计的成本控制在可接受的范围内。 项目时间管理包括**活动定义、活动排序、活动历时估算、进度计划编制、进度控制 **5 个部分内容。 活动定义是对 WBS 中规定的可交付成果或半成品的产生所必须进行的具体活动进行定义，并形成文档。 活动排序是确定各活动之间的依赖关系，并形成文档。 项目活动历时估算是根据项目范围和资源的相关信息为进度表设定历时输入的过程。 制订进度计划要决定项目活动的开始和结束日期。 进度控制涉及的是： 对造成进度变更的因素施加影响，以确保这些变更得到一致认可； 确定进度变更是否已经发生；当变更发生时对实际变更进行管理。 配置管理与文档管理软件文档管理2. 文档的归类按照文档产生和使用的范围，软件文档大致可分为 3 类：开发文档；管理文档；产品文档。 另外，软件文档从用途上还可以分为内部文档和外部文档。 其中，内部文档包括项目开发计划、需求分析、架构设计说明、详细设计说明、构件索引、构件成分说明、构件接口及调用说明、类索引、类属性及方法说明、测试报告、测试统计报告、质量监督报告、源代码、文档分类版本索引和软件安装打包文件等。 外部文档主要包括软件安装手册、软件操作手册、在线帮助、系统性能指标报告和系统操作索引等。 文档是影响软件可维护性的决定因素。软件系统的文档可以分为用户文档和系统文档两类。 用户文档主要描述所交付系统的功能和使用方法，并不关心这些功能是怎样实现的。用户文档是了解系统的第一步，它可以让用户获得对系统准确的初步印象。 用户文档至少应该包括下述5方面的内容。① 功能描述：说明系统能做什么。② 安装文档：说明怎样安装这个系统以及怎样使系统适应特定的硬件配置。③ 使用手册：简要说明如何着手使用这个系统(通过丰富的例子说明怎样使用常用的系统功能，并说明用户操作错误是怎样恢复和重新启动的)。④ 参考手册：详尽描述用户可以使用的所有系统设施以及它们的使用方法，并解释系统可能产生的各种出错信息的含义(对参考手册最主要的要求是完整，因此通常使用形式化的描述技术)。⑤ 操作员指南(如果需要有系统操作员的话)：说明操作员应如何处理使用中出现的各种情况。 系统文档是从问题定义、需求说明到验收测试计划这样一系列和系统实现有关的文档。描述系统设计、实现和测试的文档对于理解程序和维护程序来说是非常重要的。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第14章：信息系统基础知识","slug":"SystemArchitect/第14章：信息系统基础知识","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-11T02:08:06.646Z","comments":true,"path":"2021/08/09/SystemArchitect/第14章：信息系统基础知识/","link":"","permalink":"https://alloceee.github.io/2021/08/09/SystemArchitect/%E7%AC%AC14%E7%AB%A0%EF%BC%9A%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"信息系统工程信息系统工程的概念系统是由相互作用和相互依赖的若干部分，按一定规律结合成的、具有特定功能的有机整体。系统有下述特性： （1）集合性。系统是由许多元素有机地组成的整体。每个元素服从整体，追求全局最优。 （2）相关性。系统的各个组成部分之间是互相联系、互相制约的。 （3）目的性。任何系统都是有目的和目标的。 （4）层次性。一个系统往往由多个部门（或部分）组成。每个部门可看作一个小的系统，称为子系统，子系统之下又可划分为子子系统。系统具有层次结构。 （5）环境适应性。任何系统都是存在并活动于一个特定的环境之中，与环境不断进行物质、能量和信息的交换。系统必须适应环境。 1.系统的分类按照系统功能划分：工业控制系统、信息管理系统、军事系统和经济系统等。 按照系统与外界的关系划分：封闭系统和开放系统。 按照系统的内部结构划分：开环系统和闭环系统等。 按照抽象程度将系统分为：概念系统（描述系统的主要特征和大致轮廓）、逻辑系统（脱离实现细节的合理系统）和物理系统（实际存在的系统）。 2.系统工程的定义系统工程是以研究大规模复杂系统为对象的一门交叉学科。它把自然科学和社会科学的某些思想、理论、方法、策略和手段等根据总体协调的需要，有机的联系起来，应用定量和定性分析相结合的方法和计算机等技术工具，对系统的构成要素、组织结构、信息交换和反馈控制等功能进行分析、设计、制造和服务，从而达到最优规划、最优设计、最优控制和最优管理的目的。 霍尔三维结构是由逻辑维、时间维和知识维组成的立体空间结构。 1.逻辑维 运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤： （1）明确问题 （2）建立价值体系或评价体系 （3）系统分析 （4）系统综合 （5）系统方案的优化选择 （6）决策“决策就是管理”，“决策就是决定”，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂 （7）指定计划有了决策就是付诸实施，实施就要依靠严格的有效地计划 2.时间维（工作进程） 对于一个具体的工作项目，从制定规划起一直到更新为止，全部过程可分为七个阶段： （1）规划阶段：即调研、程序设计阶段，目的在于谋求活动的规划和战略； （2）拟定方案：提出具体的计划方案； （3）研制阶段：作出研制方案及生产计划； （4）生产阶段：生产出系统的零部件及整个系统，并提出安装计划； （5）安装阶段：将系统安装完毕，并完成系统的运行计划； （6）运行阶段：系统按照预期的用途开展服务； （7）更新阶段：即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。 3.知识维（专业科学知识） 系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术，霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其它相应的专业基础知识。 企业信息化与电子商务企业门户企业门户是一个信息技术平台，这个平台可以提供个性化的信息服务，为企业提供一个单一的访问企业各种信息资源的应用该程序的入口。 1.主要功能： （1）能够将一个机构现有的互联网址和服务完全合并而且相互兼容。 （2）能够支持开放标准和应用编程接口，让平台得以轻易容纳新的应用程序。 （3）能够接入一个由支持企业门户网站架构的伙伴和专业服务公司所组成的网络。 （4）能够多渠道接入网站，如互联网至公司内联网、话音网络、无线网络等。 （5）能够以统一的服务作为企业门户网站各种服务的基础，让用户享有多种便利，如一次登入、个人化接口等。当用户进入门户网站的不同部分时，系统可以记住用户的身份以提供合适的信息。 2．企业门户的分类按照实际应用领域，企业门户可以划分为三类：信息门户、知识门户和应用门户。 企业信息门户重点强调为访问数据结构和无结构数据提供统一入口，实现收集、访问、管理和无缝集成。 企业知识门户提供了一个创造、搜集和传播企业知识的平台，通过企业知识门户，员工可以与工作团队中的其他成员取得联系，寻找能够提供帮助的专家。 企业应用门户是一个用来提高企业的集中贸易能力、协同能力和信息管理能力的平台。它以商业流程和企业应用为核心，将商业流程中功能不同的应用模块通过门户集成在一起，提高公司的集中贸易能力、协同能力和信息管理能力。 客户关系管理（CRM）客户关系管理（CRM）系统将市场营销的科学管理理念通过信息技术的手段集成在软件上，能够企业构建良好的客户关系。 在客户管理系统中，销售自动化是其中是最为基本的模板，营销自动化作为销售自动化的补充，包括营销计划的编制和执行、计划结果分析等功能。 客户服务与支持是CRM系统的重要功能。目前，客户服务与支持的主要手段有两种，分别是呼叫中心和互联网。 CRM系统能够与ERP系统在财务、制造、库存等环节进行连接，两者之间虽然关系比较独立，但由于两者之间具有一定的关系，因此会形成一定的闭环反馈结构。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第17章：系统的可靠性分析与设计","slug":"SystemArchitect/第17章：系统的可靠性分析与设计","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-09T02:05:07.734Z","comments":true,"path":"2021/08/09/SystemArchitect/第17章：系统的可靠性分析与设计/","link":"","permalink":"https://alloceee.github.io/2021/08/09/SystemArchitect/%E7%AC%AC17%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"提高系统可靠性的措施信息冗余信息冗余是指通过在数据中附加冗余的信息以达到故障检测、故障掩蔽或容错的目的。应用最广泛的是海明校验码、奇偶校验码。 CRC校验码CRC即循环冗余校验码：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接受设备也执行类似的算法，以保证数据传输的正确性和完整性。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第8章：系统分析与设计方法","slug":"SystemArchitect/第8章：系统分析与设计方法","date":"2021-08-08T16:00:00.000Z","updated":"2021-08-09T01:36:45.449Z","comments":true,"path":"2021/08/09/SystemArchitect/第8章：系统分析与设计方法/","link":"","permalink":"https://alloceee.github.io/2021/08/09/SystemArchitect/%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第7章：系统规划","slug":"SystemArchitect/第7章：系统规划","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-09T08:02:41.075Z","comments":true,"path":"2021/08/08/SystemArchitect/第7章：系统规划/","link":"","permalink":"https://alloceee.github.io/2021/08/08/SystemArchitect/%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%92/","excerpt":"","text":"新旧系统的分析与比较遗留系统的评价方法遗留系统的演化策略 淘汰策略 第3象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的商业价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。 完全淘汰是一种极端性策略，一般是企业的业务产生了根本的变化，遗留系统基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。对遗留系统的完全淘汰是企业资源的根本浪费，应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。 继承策略 第4象限为低水平、高价值区，即遗留系统的技术含量较低，可满足系统运作的功能或性能要求，但具有较高的商业价值，目前企业业务对该系统仍有很大的依赖性。对这种遗留系统的演化策略为继承。 在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。 要做到对遗留系统的继承，必须对系统进行分析，得到旧系统的功能模型和数据模型，这种分析可以部分代替或验证系统的需求分析。 如果遗留系统的维护文档不完整，而又必须解析系统的功能模型和数据模型，那将是一项十分艰巨的任务。这时可使用有关系重构的CASE工具，通过分析系统的代码生成系统结构图或其他报告。 改造策略 第1象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有较大的生命力，且具有较高的商业价值，基本上能够满足企业业务运作和决策支持的要求。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。 这些改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变。数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型转化的过程。 集成策略 第2象限为高水平、低价值区，即遗留系统的技术含量较高，但其商业价值较低，可能只完成某个部分（或子系统）的业务管理。这种系统在各自的局部领域里工作良好，但从企业全局来看，多个这样的系统，他们各自基于不同的平台，不同的数据模型，无法互联互通，数据还不一致，这就是很严重的问题了。 对这种遗留系统的演化策略为集成。 在集成过程中，可采用由互连系统构成的系统的架构，遗留系统可作为从属属性来描述。 移植工作移植工作大体上分为计划阶段、准备阶段、转化阶段、测试阶段、验证阶段。 1.计划阶段在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）、系统运行三个方面，探讨如何转换新系统，决定移植方法，确立移植工作体制及移植日程。 2.准备阶段在准备阶段要进行移植方面的研究，准备转换所需的资料，该阶段的作业质量将对以后的生产效率产生很大的影响。 3.转化阶段这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。 4.测试阶段这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。 5.验证阶段这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Allocee"},{"title":"","slug":"大前端/17-前端综合/网友对本项目提的建议","date":"2021-08-06T01:17:26.119Z","updated":"2021-07-28T07:34:11.403Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/网友对本项目提的建议/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/%E7%BD%91%E5%8F%8B%E5%AF%B9%E6%9C%AC%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%9A%84%E5%BB%BA%E8%AE%AE/","excerpt":"","text":"图片的宽度，最好不要超过800px，否则在github上显示不完整，甚至无法显示。 建议把图片压缩后再上传。图片大小最好控制在100kb左右。比如说，javascript-tutorial-cn这个项目，在这方面就做得很好。 比如20180223_2201.gif这张图，原本是500kb，我压缩后重新上传，是200kb。 再比如20180611_2130.png这张图，原本是400kb，我压缩后重新上传，是200kb。","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/前端开发积累","date":"2021-08-06T01:17:26.117Z","updated":"2021-07-28T07:34:11.403Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/前端开发积累/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"SPU 和 SKUSKU（stock keeping unit）：库存量单位。 SKU是物理上不可分割的最小库存单元。通俗来讲，你可以把 sku 理解成是「最小单元」。 SPU（Standard Product Unit）：标准化产品单元。是商品信息聚合的最小单位。通俗来讲，你可以把 spu 理解成是「某一类的单元」。 比如说，针对 Kindle paperwhite4 这款阅读器，颜色分白色、黑色两种。那么，白色和黑色的sku是不一样的。因此，Kindle paperwhite4 这款阅读器有「两个sku、一个spu」。 再比如说，针对 iPhone 8 这款手机，颜色有银色、红色、金色三种，存储空间有分64G、256G两种。那么，64G和256G的sku是不一样的；不同的颜色，也代表着不同的sku。因此，iPhone 8 这款手机有「六个sku、一个spu」。 单品：对一种商品而言，当其品牌、型号、配置、等级、花色、包装容量、单位、生产日期、保质期、用途、价格、产地等属性中任一属性与其他商品存在不同时，可称为一个单品。 移动端WebApp前端真机调试：iPhone/iOS借助Safari进行真机调试（1）手机端：设置 → Safari → 高级 → Web 检查器 → 开。 （2）mac端：Safari → 偏好设置 → 高级 → 在菜单栏中显示“开发”菜单。 （3）在 OS X 中启动 Safari 之后，以 USB 电缆正常接入 iOS 设备，并在此移动设备上启动 Safari。此时点击计算机上的 Safari 菜单中的“开发”，可以看到有 iOS 设备的名称显示，其子菜单项即为移动设备上 Safari 的所有标签页，点击任意一个开始调试。如下： 参考链接： 移动端前端开发真机调试攻略 iOS、Android 之类的如何调试 Web APP","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/前端博客推荐","date":"2021-08-06T01:17:26.115Z","updated":"2021-07-28T07:34:11.403Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/前端博客推荐/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/%E5%89%8D%E7%AB%AF%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90/","excerpt":"","text":"前端博客推荐 冴羽的博客：https://github.com/mqyqingfeng/Blog 冴羽写博客的地方，预计写四个系列：JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。 颜乐乐：https://github.com/yanlele/node-index 在头条做前端，博客内容很全，尤其是“单元测试”系列。","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/UserAgent","date":"2021-08-06T01:17:26.113Z","updated":"2021-07-28T07:34:11.401Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/UserAgent/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/UserAgent/","excerpt":"","text":"前言我们知道，在控制台里可以添加很多设备。我们需要点击 edit，手动添加： img 添加时，是根据 User agent 来识别的： img 不同浏览器（包括微信内置的浏览器）的 useragent 信息，是不一样的，我们可以根据 navigator.userAgent属性来获取。 比如说，我们在控制台输入navigator.userAgent，如下： 上图显示，MacOS上的Chrome浏览器的 UserAgent 是： 1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36&quot; 不同浏览器的 UserAgentiPhone版微信： 1Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E233 MicroMessenger/6.3.15 NetType/WIFI Language/zh_CN Android版微信： 1Mozilla/5.0 (Linux; Android 5.0.1; GT-I9502 Build/LRX22C; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/43.0.2357.121 Mobile Safari/537.36 MicroMessenger/6.1.0.78_r1129455.543 NetType/WIFI Android版微信： 1Mozilla/5.0 (Linux; Android 5.0.1; GT-I9502 Build/LRX22C; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/43.0.2357.121 Mobile Safari/537.36 MicroMessenger/6.1.0.78_r1129455.543 NetType/WIFI 参考链接 判断微信内置浏览器的UserAgent 微信内置浏览器UserAgent的判断","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/json相关","date":"2021-08-06T01:17:26.112Z","updated":"2021-07-28T07:34:11.402Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/json相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/json%E7%9B%B8%E5%85%B3/","excerpt":"","text":"json中根据键获取值参考链接： http://yuxisanren.iteye.com/blog/1895807 https://blog.csdn.net/w405722907/article/details/72828041","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/json字符串的解析和遍历","date":"2021-08-06T01:17:26.110Z","updated":"2021-07-28T07:34:11.402Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/json字符串的解析和遍历/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E9%81%8D%E5%8E%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(value,key) in myData&quot;&gt; &lt;p&gt;&#123;&#123;key&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;value.name&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var dataList = [ &#123; id: 11492948852, price: &quot;49.90&quot; &#125;, &#123; id: 11492948847, price: &quot;39.90&quot; &#125; ]; var datas = &#123;&#125;; var dataList2 = &#123; &quot;11492948852&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;jfs/t3136/15/8874896477/153924/ee5100df/58cb7fa8N64311629.jpg&quot;, &quot;color&quot;: &quot;白色 &quot;, &quot;name&quot;: &quot;【多色可选】丽装铺园纯色百搭简约打底T恤女 白色 XL&quot;, &quot;size&quot;: &quot;XL&quot; &#125;, &quot;11492948847&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;jfs/t3109/27/9469817576/176241/aa424d04/58d4c849Ne22114ed.jpg&quot;, &quot;color&quot;: &quot;灰色 &quot;, &quot;name&quot;: &quot;【多色可选】丽装铺园纯色百搭简约打底T恤女 灰色 S&quot;, &quot;size&quot;: &quot;S &quot; &#125;, &quot;11325444606&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;jfs/t4447/354/3613344795/347891/4800da35/5901549fN468c7073.jpg&quot;, &quot;color&quot;: &quot;叶脉-五骨&quot;, &quot;name&quot;: &quot;迷你超轻小太阳伞雨伞小清新口袋伞 黑胶防晒五折两用遮阳伞 防紫外线折叠太阳伞 叶脉-五骨 五折伞&quot;, &quot;size&quot;: &quot;五折伞&quot; &#125;, &quot;11492948848&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;jfs/t3076/90/7623078170/152165/9fe8c39d/58b94105N8ed8d2c0.jpg&quot;, &quot;color&quot;: &quot;橘色 &quot;, &quot;name&quot;: &quot;【多色可选】丽装铺园纯色百搭简约打底T恤女 橘色 M&quot;, &quot;size&quot;: &quot;M&quot; &#125; &#125; dataList.forEach(function (item) &#123; for (item2 in dataList2) &#123; if (item.id == item2) &#123; console.log(&#x27;匹配成功&#x27;); datas[item.id] = &#123; imagePath: dataList2[item2].imagePath, name: dataList2[item2].name &#125; &#125; &#125; &#125;) console.log(JSON.stringify(datas)); new Vue(&#123; el: &quot;#app&quot;, data: &#123; myData: dataList2, &#125;, methods:&#123; clickMethod:function()&#123; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/html相关","date":"2021-08-06T01:17:26.108Z","updated":"2021-07-28T07:34:11.402Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/html相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/html%E7%9B%B8%E5%85%B3/","excerpt":"","text":"SSI：服务器端嵌入SSI：Server Side Include，服务器端嵌入。 通俗点讲，就是在本地的html页面中，插入服务器上的文件。即：静态页面中，插入动态的代码。 比如： 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;!--#include virtual=&quot;/sinclude/common/head_inc.shtml&quot;--&gt; &lt;!--#include virtual=&quot;/sinclude/common/head_shortcut.shtml&quot;--&gt; &lt;!--#include virtual=&quot;head.shtml&quot;--&gt;&lt;/head&gt; 上面的代码中，注释里的代码，就是SSI部分，它加载的是服务器端的html页面。","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/css开发相关","date":"2021-08-06T01:17:26.106Z","updated":"2021-07-28T07:34:11.401Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/css开发相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/css%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/","excerpt":"","text":"p标签里的文字溢出怎么办加一个属性即可： 12word-break: break-all;","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/ajax相关","date":"2021-08-06T01:17:26.104Z","updated":"2021-07-28T07:34:11.401Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/ajax相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/ajax%E7%9B%B8%E5%85%B3/","excerpt":"","text":"jsonp ajaxajax跨域访问是一个老问题了，解决方法很多，比较常用的是JSONP方法，JSONP方法是一种非官方方法，而且这种方法只支持GET方式，不如POST方式安全。 意思是说，如果后台返回的数据类型是jsonp，那么前端的请求方式只能是get，不能是post。 如果跨域使用POST方式，可以使用创建一个隐藏的iframe来实现，与ajax上传图片原理一样，但这样会比较麻烦。 因此，在前端使用post方法，数据类型是json的情况下，如果想跨域的话，可以通过设置Access-Control-Allow-Origin来实现跨域访问比较简单。 参考链接： ajax 设置Access-Control-Allow-Origin实现跨域访问","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/2019年-前端日记","date":"2021-08-06T01:17:26.101Z","updated":"2021-07-28T07:34:11.400Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/2019年-前端日记/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/2019%E5%B9%B4-%E5%89%8D%E7%AB%AF%E6%97%A5%E8%AE%B0/","excerpt":"","text":"2019-04-02Vue屏幕宽度自适应： https://blog.csdn.net/qq_25386583/article/details/77161478 https://blog.csdn.net/xuaner8786/article/details/81565219 2019-04-07 控制iframe中的页面只显示一部分：https://blog.csdn.net/iteye_18722/article/details/81918563 2019-04-091Date.parse(&quot;2019/04/20 18:14:00&quot;) 上方代码转换的结果，单位是毫秒，不是秒。 2019-04-2312345const a = [];const b = &#123;&#125;;console.log(Boolean(a));console.log(Boolean(b)); 上方代码的打印结果均为true。 具体解释，可以看我在 03-JavaScript基础/03-变量的强制类型转换.md这篇文章里讲到的转换为Boolean。 所以，我们平时在写业务代码的时候，“判断是否为空对象/空数组”，不能直接写成 if (myObj)或者if(myArray)，会踩坑。 判断不否为空数组，可以用： 1if (myArray.length) 判断不为空对象，可以用 ： 1if (JSON.stringify(myObj) !== &#x27;&#123;&#125;&#x27;) 2019-04-26我们知道，在移动端页面尅发时，单位一般是采用 rem。 设计稿如果是750px宽，那么，默认换算的单位如下：16px = 1rem。但是这种换算比较麻烦。我们可以在 html里加上如下代码： 123456&lt;style&gt; html &#123; font-size: 20px; font-size: 5.3333333vw; &#125;&lt;/style&gt; 这样的话，换算单位就变成了：20px = 1rem。 2019-05-16 数组随机打乱顺序：https://www.zhihu.com/question/68330851/answer/262111061 最佳的打乱算法是Fisher-Yates算法。 2019-05-16Vue的全局变量空间：this.$root.data，我们可以在这里面存放数据。比如this.$root.data.skuIdList。 2019-05-17 css 动画实现闪烁效果：https://blog.csdn.net/wangxiuyan0228/article/details/80701523 2019-05-20数组赋值的正确写法： 1this.todayList.splice(0, 0, ...dataList); 对象赋值的正确写法： 1Object.assign(this.dataObj, dataObj); 上方代码中，是将dataObj 的值追加到this.dataObj中。如果对象里属性名相同，会被覆盖。 2019-05-20-css3动画水平/镜像翻转参考链接1：https://www.oschina.net/question/2443483_247744 代码实现举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; @keyframes featuresicon &#123; 0% &#123; transform: scaleX(1); &#125; 20% &#123; transform: scaleX(1); &#125; 50% &#123; transform: scaleX(0); &#125; 80% &#123; transform: scaleX(1); &#125; 100% &#123; transform: scaleX(1); &#125; &#125; .cube &#123; width: 40px; height: 40px; background: url(images/bg2.png) left 0 no-repeat; animation: featuresicon 1.3s linear alternate none infinite; &#125; body &#123; background-color: cornflowerblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;cube&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 参考链接2：https://blog.csdn.net/wjnf012/article/details/78679131 代码实现：（立体感更强一点） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;*&#123; padding: 0; margin: 0;&#125;.cube&#123; display: block; color: #ffffff; text-align: center; width: 40px; height: 40px; border-radius: 4px; /* background-color: #9a6ad8 */ background: url(images/bg.png) left 0 no-repeat; animation: proRotate 1.3s ease-in-out 500ms alternate none infinite;&#125;@keyframes proRotate &#123; 0%&#123;transform:perspective(200px) rotateY(180deg);&#125; 100%&#123;transform:perspective(200px) rotateY(0deg);&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;test_wrap&quot;&gt; &lt;div class=&quot;cube&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;body&gt;&lt;/html&gt; 2019-05-22-判断字符串是否为纯中文参考链接：https://blog.csdn.net/wozaixiaoximen/article/details/48340061 2019-05-24 VScode代码格式化后不符合ESLint风格问题处理：https://blog.csdn.net/SilenceJude/article/details/81589784 2019-05-27-针对 text 文本的属性举例12345678910111213141516&amp;_promote &#123; margin-left: 10px; display: inline-block; height: 20px; padding: 4px; line-height: 20px; background: #fff0f0; border-radius: 4px; font-size: 20px; color: #ff4142; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; vertical-align: middle;&#125; 尤其要研究一下 vertical-align: middle;这个属性。 2019-06-11已知某背景图片的尺寸是：586 * 931。现只截图图片的上面一部分区域（586 * 810）做展示。代码实现如下： 标签部分： 123&lt;div class=&quot;img&quot;&gt; &lt;/div&gt; css部分：（重点是 background 属性的写法） 1234567.img&#123; width: 586rpx; height: 810rpx; background: url(&#x27;https://img11.360buyimg.com/jdphoto/s586x931_jfs/t1/27766/15/3237/102443/5c258955Ee307620e/21a744b0d2e065b3.png&#x27;) 0 0/cover no-repeat; margin: 0 auto;&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/2018年-前端日记","date":"2021-08-06T01:17:26.099Z","updated":"2021-07-28T07:34:11.400Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/2018年-前端日记/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/2018%E5%B9%B4-%E5%89%8D%E7%AB%AF%E6%97%A5%E8%AE%B0/","excerpt":"","text":"2018年4月份2018-04-25 userAgent相关：判断微信内置浏览器的UserAgent 2018-04-26前端相关： 流程图制作工具：ProcessOn api方法的浏览器兼容性问题，可以在这个网站上看：https://caniuse.com/ CSS3的兼容性问题，不一定要使用-webkit-, -moz-, -o-, -ms-等私有前缀。可以使用 PostCSS。知乎 浏览器常见的内核有：V8、WebKit。另外腾讯还有个X5。 要查一下display none 和 visibility hidden的区别。 ES 的各个版本在 Node 环境下的支持情况，可以查看这个网站：http://node.green/ promise的实现，关键词：Promises/A、Promises/B、bluebird 综合： whistle安装证书后，可以拦截 https 请求。但是，我现在又不想拦截了，该怎么卸载证书呢？ 2018-04-27 strider：可以用来部署项目。 有必要了解一下电商1.0、电商2.0、电商3.0的概念。 2018-05-02 location.pathname：获取 url 的后半部分。参考链接：# 代码解读：callback &amp;&amp; callback()的含义 2018-05-03 各种框架实现的todo项目：http://todomvc.com/ 对比 sass、less、stylus 这三个css预处理器，zqc说，后面两个已经不怎么用了。sass 比 less强大，stylus的书写方式比较奇怪。 npm命令中，–save 和 –save-dev的区别。参考链接：http://pwcong.me/2017/01/05/npm%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E6%97%B6--save-%E4%B8%8E--save-dev-%E7%9A%84%E5%8C%BA%E5%88%AB/ 2018-05-07 Vue组件的注册 有一种组件注册的方式是 Vue+jQuery： 12345678910Vue.component(&#x27;my-div&#x27;, $.extend(&#123; props:[], methods:&#123; &#125;, filters:&#123; &#125;&#125;), vueTpl.subs.myDiv) 根据 zqc 的建议，不一定要使用$.extend()，还可以使用object.assign()。 2018-05-08 sku、spu的概念 2018-05-09 输入框正则的匹配 让输入框仅支持输入单个id，且为字符串。如果输入多个id，或者非数字的字符，则自动删除： 1v-on:keyup=&quot;querysku = querysku.replace(/\\D/,&#x27;&#x27;)&quot; 2018-05-10 如果在控制台看到网络请求陈功，数据也获取成功，但是在ajax里走的是 error（数据获取失败），说明是 ajax代码的判断逻辑有问题。 服务器返回的json数据到底是对象还是字符串？ josn数据里的字段，有顺序吗？比如下面这段： 123456789101112131415161718&#123; &quot;1492948848&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;hehe.jpg&quot;, &quot;color&quot;: &quot;橘色 &quot;, &quot;name&quot;: &quot;【多色可选】丽装铺园纯色百搭简约打底T恤女 橘色 M&quot;, &quot;size&quot;: &quot;M&quot; &#125;, &quot;1492948847&quot;: &#123; &quot;3&quot;: &quot;1&quot;, &quot;spec&quot;: &quot;&quot;, &quot;imagePath&quot;: &quot;lala.jpg&quot;, &quot;color&quot;: &quot;灰色 &quot;, &quot;name&quot;: &quot;【多色可选】丽装铺园纯色百搭简约打底T恤女 灰色 S&quot;, &quot;size&quot;: &quot;S &quot; &#125;&#125; 答案：顺序不重要。 Vue开发中，在其他地方用到Vue实例中的数据时，一定要用this，或者是vm.$data.myName之类的。 疑问：下面的src路径的前面，为何要加//： 1&lt;img v-bind:src=&quot;&#x27;//img14.smyhvae.com/evalpic/s240x240_&#x27;+value.imagePath&quot; /&gt; 我发现，控制台看到的输出src中，会自动加上http。如果前面不加//则表示相对路径。 2018-05-11 将逗号分隔的字符串，转换为数组： str.split(&quot;,&quot;)。即使数组中只有一个元素，也可以这样用。参考链接：# 2018-05-14 ajax发的是post请求，但是后台却只收到了部分数据怎么办？答案：前端的post请求记得加content-type字段，否则会被识别成 get 请求。 获取jsonp的数据，只能用get请求。如果要用post请求，那就传json数据，另外，可能还要解决跨域的问题。跨域需要在后台配置，三行代码即可。 p标签里的文字溢出怎么办？ whistle该怎样mock数据？ 2018-05-16 在控制台看标签的样式，发现有些样式是出现在element.style中的（比如图片的尺寸），但是在代码里并没有找到。那是因为，这些样式是在 js 代码中计算出来的。 图片自适应显示 视区相关单位vw, vh..简介以及可实际应用场景 jingwen推荐的iconMoon图标网站。网址：https://icomoon.io/ 2018-06-01 PingFangSC字体是iOS独有的字体。PingFangSC-Regular是常规字体，PingFangSC-Semibold是加粗字体。如果我在代码里设置了这个字体，那么，ios上可以看到效果，但是Android上看不到效果，仍然会采用Android系统默认的字体。 2018-06-041、git相关： 把 branch1 中的某条记录(比如myLog)，提交到 branch2中。做法如下： 先切换到branch2中，然后输入如下命令： 1git cherry-pick myLog 2018-06-051、font-size： font-size的最小值为12。 也就是说，浏览器的最小字体为12，要是再小于这个值，是不生效的。如果想要小于12，需要在浏览器的高级设置里去修改。 2、git 多分支同时开发： 现在有这样一个场景：我要同时开发一个项目里的两个功能。今天上午开发功能1，下午开发功能2。明天上午改功能1的bug，明天下午改功能2的bug。 相当于是，我现在是并行开发两个功能了，要怎么通过git来进行协作呢？ 目前考虑到的姣好的方式是： 从master拉分支branch1，此分支专门用来开发功能1，改功能1的bug。 再从master拉分支branch2，此分支专门用来开发功能2，改功能2的bug。 以后需要上线哪个功能，就从那个分支merge代码到master。 3、其他： 两个span之间默认有5px的 margin shadow-root：下一代。 2018-06-07 原生js实现淡入淡出效果 通过 jQuery 获取Dom的时候，比如$(&#39;#topNavTop&#39;).css(&#39;background&#39;,&#39;red&#39;)记得要指明是 id 还是 class。 每次开发一个新的需求，记得要问清楚：“H5和小程序”都要做吗？要做的话，工作量基本乘以2。 2018-06-14 pv、uv的概念 2018-06-21 今天学会了 iPhone上WebApp的真机调试，感觉很高端呀。具体可以看我在本文件夹中写的《前端开发积累》这篇文章。 2018-06-27没想到，&#39;&#39;和&#39; &#39;竟然还有区别。 2018-06-30并列条件： 来看下面这段代码： 12var num = 80;console.log(50 &lt; num &lt;= 70); 上面的代码，你认为打印的结果是什么？其实，它打印的结果是 true。 如果我们要实现并列条件，千万不要使用 if(50 &lt; num &lt; 70)，而是要使用if(num &gt; 50 &amp;&amp; num &lt;=70)。 2018-07-16FAQ：问答系统 FAQ是英文Frequently Asked Questions的缩写，中文意思就是“经常问到的问题”，或者更通俗地叫做“常见问题解答”。 2018-08-0312let temp = 0.123;let temp2 = temp.toFixed(2); 上方代码中，temp2的结果是0.12，但是请注意，temp的类型Number型，而temp2的类型却是String型。 2018-08-15flex布局常用的三行代码： 123display: flex;justify-content: center; // 子元素在横轴的对齐方式 （左右居中）align-items: center; // 子元素在竖轴的对齐方式（上下居中） 2018-08-16用CSS3 transition属性实现淡入淡出轮播图：https://segmentfault.com/a/1190000007648070 2018-08-20小程序问题： 用小程序调试时，如果出现故障（比如item点击无响应），可能是微信开发者工具IDE的版本太低了。注意，IDE上上虽然提示是最新版，但不一定是官网的最新版。所以，要去官网下载最新版。 如果还是不行，看看是不是自己的代码写错了。有时候，代码写错了，不一定会有报错提示哦。 css问题： css3实现的switch开关按钮：https://codepen.io/chutou/pen/qdGZQr 2018-08-22两个span之间去空格 html+css如何删除行内元素之间的空白/空隙：http://www.manongjc.com/article/2171.html 方法二亲测有效：让父亲的font-size为0，然后具体设置子元素的font-size 去除inline-block元素间间距的N种方法：https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/ 2018-08-28-修改用户的cookie1document.cookie=&quot;visitkey=98&quot; 2018-09-20需求：当导航条滚动到屏幕顶部时（举例顶部的距离 &lt; 0时），就设置导航条为fixed。 实现：如果要设置为导航条为fixed，正确的做法应该是：给导航条这个父亲一个高度进行占位，然后让导航条的儿子为fixed。而不是让父亲为 fixed。 2018-09-27如何让微信小程序禁止下拉_解决小程序下拉出现空白的情况：http://www.fly63.com/article/detial/1069 我遇到问题的原因是：背景图太大，超出了视图。 2018-10-12小程序代码中，如果我这样写view的度样式： 12height: 60rpx;line-height: 1.5rem; 上面的这种写法，并不会让里面的文字上下居中，我在 iPhone 7 plus 中看到的结果是：文字偏上移。 正确的做法是：（单位一致用rpx，不要把两个单位混用） 12height: 60rpx;line-height: 60rpx; 2018-10-21时间戳和年月日的转换：https://blog.csdn.net/qq_26747571/article/details/53289120?locationNum=10&amp;fps=1 2018-11-28css实现圆环进度条：https://blog.csdn.net/wanglei1991gao/article/details/80009252 2018-12-13对象数组通过对象的属性进行排序：https://blog.csdn.net/xiaobing_hope/article/details/68638706","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/03-深圳IT互联网大厂有哪些（2019年版）","date":"2021-08-06T01:17:26.097Z","updated":"2021-07-28T07:34:11.400Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/03-深圳IT互联网大厂有哪些（2019年版）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/03-%E6%B7%B1%E5%9C%B3IT%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%882019%E5%B9%B4%E7%89%88%EF%BC%89/","excerpt":"","text":"深圳IT互联网大厂有哪些（2019年版） 本文更新于201905。 一线大厂 腾讯 华为 阿里（深圳） 百度（深圳） 京东（深圳） 头条（深圳） 二线大厂 大疆 oppo（深圳） 商汤科技（人工智能领域独角兽） 平安系列（平安科技、平安寿险、平安产险、平安金融等，各自独立，可分开投简历） 顺丰 微众银行 三线大厂 有赞（深圳） 中兴 金蝶、随手记（随手记属于金蝶旗下，但可以分开投简历） vivo Shopee（东南亚最大的电商平台） 迅雷 互联网金融 乐信 广发 中信 招商 其他（不仅限于IT领域） 恒大、万科 珍爱网（福利超好，但招人少） shein（跨境时尚电商）","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/03-前端学习分享（微信群）","date":"2021-08-06T01:17:26.095Z","updated":"2021-07-28T07:34:11.399Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/03-前端学习分享（微信群）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/03-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB%EF%BC%88%E5%BE%AE%E4%BF%A1%E7%BE%A4%EF%BC%89/","excerpt":"","text":"前言我建了一个“前端学习”的微信交流群。加我微信（bootmei），拉你进群： 进群暗号：前端学习。 进群要求：少提问、少闲聊、多分享（长期潜水的，就不必了）。 你也可以关注微信公众号「千古壹号」，学习代码之外的技能。 以下内容，来自微信群的部分优质分享。不定期更新。文中涉及的内容和链接，均为群友自主推荐、自主分享。 2019-05-101、深圳-团长： 新手学习Node.js 推荐狼叔的《如何正确学习Node.js》，地址：https://github.com/i5ting/How-to-learn-node-correctly Node.js国内交流社区：https://cnodejs.org/ 推荐书籍：《Node.js实战》（第二版）、《Node.js调试指南》、《深入浅出Node.js》（有一定的基础后再看）、《更了不起的Node.js》（据说今年会出版） 备注：在一个QQ群里看到的，仅供参考。 2、深圳-团长： promise的各种用法：https://github.com/sindresorhus/promise-fun 小组的一位同事，今天在周会上重点分享和讲解了这个项目，说这个项目非常吊。 如果掌握了 promise 的深层次用法，绝对吊打面试官。 我看了下这个项目作者的介绍，也很牛逼：2014年之后，作为自由职业者，全职做开源社区的项目。一边做开源项目，一边背包环游东南亚，目前已经在泰国曼谷定居，但仍然每天都在做开源。 3、广州-小阳： VS Code插件推荐：Code Runner 我之前想跑js代码，都是写在html文件里的，然后就找到了这个。可以直接运行。 4、深圳-团长： 高效易用的自动标注工具：PxCook（像素大厨）。软件下载链接：https://www.fancynode.com.cn/pxcook 可以直接标注 Photoshop、Sketch 的设计原稿。很方便。 我们小组的一位前端妹子刚刚在用，大呼好用，于是一堆人跑过去围观。所以我推荐下。 2019-05-091、上海-前端-强子： 《从Oracle的裁员，到“技术专家陷阱”》 2、上海-前端-强子： 阮一峰推特更新：https://juejin.im/user/5a586bc66fb9a01cb1391339 3、深圳-团长： 推荐一个chrome插件：FireShot。滚动截长图，很流畅。 3、杭州~nan： 《零基础转行去阿里做前端，创业当 CTO，他是如何做到的？》 4、广州-斌桑： 《考研到底值不值得》 2019-05-081、深圳-团长： 带你了解一下科技类图书四大社：https://www.jianshu.com/p/b65ac62bf407 到目前为止有三个品牌真正立起来了，读者认、作者也认： 人民邮电出版社：图灵公司，合资企业 电子工业出版社：博文视点，全资子公司 机械工业出版社：华章公司，合资公司 而清华大学出版社没有一个拿得出手的品牌，有些可惜。 2、上海-乐亦栗： 偶然发现张鑫旭大佬一篇旧文，分享出来希望对大家有用。 话说我为什么要闭关学习：http://www.zhangxinxu.com/life/?p=98 一点感慨：就算张鑫旭大佬从事别的事业，肯定也是拔尖的。 3、深圳-核桃： 2018年8月中级前端开发推荐书籍：https://zhuanlan.zhihu.com/p/40761206 张鑫旭的《CSS世界》真是写的是真的好，准备翻出来看第三遍了。我最近看的书都是按照这个书单看的，前面基本还可以，从《Node.js:来一打C++扩展》后面开始感觉就有点get不到书里面的主题了。 2019-05-071、广州 lien： 《编程语言的发展趋势：从没有分号，到DSL》 2019-05-061、深圳-团长： Python - 100天从新手到大师：https://github.com/jackfrued/Python-100-Days 这个项目的作者是 千锋培训机构的讲师。 1、广州 lien： 我司用的 mock 工具是：eoLinker AMS 开源版本4.0 2、上海-前端-邱明： 《一名【合格】前端工程师的自检清单》 2019-05-051、上海-前端-强子： 《阿里云前端技术周刊》：https://github.com/aliyunfe/weekly 2、武汉-林夕之间： 国内10大前端团队网站：https://zhuanlan.zhihu.com/p/60091235 3、深圳-pubdreamcc： 腾讯新闻前端团队维护的一个周刊：https://github.com/Tnfe/TNFE-Weekly 4、上海-gzd： vue 作者写的 todolist：http://todomvc.com/examples/vue/ 2019-05-011、深圳-团长： 《那些年的体验技术部》 2、广州-古力： 《JavaScript 高性能数组去重》 2019-04-301、成都-颜乐乐： https://github.com/frontend9/fe9-library 这个是阿里蚂蚁为首的一群开发者发起的一个组织， 专门做前端知识布道工作， 输出各种高质量技术文章、以及各种技术教程。里面的文章从出门级别到架构级别的，各种框架测试其他应用层面的应有尽有。 2019-04-281、上海-前端-强子： 分享一个小程序，名叫「GitHub专业版」。 2、深圳-核桃： 看到一篇to b产品UX &amp; UI 设计总结不错。 “后台产品” UX &amp; UI 设计总结（上）- 设计要点概括：https://zhuanlan.zhihu.com/p/28787738 3、广州Brenner： web安全学习笔记：https://websec.readthedocs.io/ 4、北京～夜微凉： 可能是最全的前端动效库汇总：https://juejin.im/post/5cc089eae51d456e7d189f9d 5、成都-颜乐乐： 前一段时间还撸了一个 node 爬虫：TS+puppeteer+cheerio+fs-extra https://github.com/yanlele/node-spider 因为用了headless brower 所以就算是单页应用 也不要用怕爬去不到数据、模仿浏览器访问也不用担心 ip 被封。 python 和 node 爬虫适应范围不一样。python 可以做分布式集群、做数据管理和分析， 可以直接同构代码一把梭。node 爬虫， 更加贴近于前端节点访问请求。 如果没有企业级需求， 每天抓个几百万的那种， 个人项目临时整点儿数据和或者临时需要抓取 数据，node 很好用的。 很简单一个道理， 我们一个后台应用， 对接十几个Java服务， 需要一个调度者去支配这些服务和调度这些服务。 当然Java也可充当这个角色， 但是node的异步非阻塞模型， 显然这这个场景， 比Java优势大。 可以参考阿里技术体系，他们nodejs 在服务端基本上就是发挥这个作用， 传统后端 controller -&gt; service -&gt; model, 可以理解为nodejs 中间层就干了 一个 controller 和 view 的工作， java 可以专注于service 业务实现。 推荐阅读文章： 使用JavaScript写爬虫：https://zhuanlan.zhihu.com/p/53763115 6、成都-颜乐乐： mysql相关的书籍推荐：《深入浅出MySQL 数据库开发 优化与管理维护》 2019-04-271、上海-前端-强子： 猴子都能懂的Git入门：https://backlog.com/git-tutorial/cn/ 2、广州-萧雪圣： 像玩游戏闯关一样学习git！: https://learngitbranching.js.org/ 2019-04-261、成都-颜乐乐： 推荐一个，前端测试，全干货。陆陆续续总结整理了大半年才成了现在的体系： https://github.com/yanlele/node-index/tree/master/book/13%E3%80%81%E6%B5%8B%E8%AF%95%E4%B8%93%E9%A2%98 前端单元测试，非常重要。很简单的一个例子，别人写了一个很复杂的模块功能，怎么学习别人的代码？最简单的办法，就是跑测试。 测试对于学习代码和看源码非常重要。 （深圳-团长 备注：会前端单元测试，是很加分的。虽然我不会，但准备学一学。） （上海-前端-强子 备注：这个不错，别人的发的东西，先加入到需整理列表里面，后面空闲了，慢慢消化，内化成自己的知识体系。） 2、成都-颜乐乐： 再推荐一个，学习javascript数据结构与算法。是当年吃《javascript数据结构与算法 [巴西] Loiane Groner 著 孙晓博等译》 这本书总结的熟肉 https://github.com/yanlele/node-index/tree/master/book/09%E3%80%81%E5%AD%A6%E4%B9%A0javascript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95 吃完了文章很多东西， 用自己的语言方式组织精简过，也加了很多自己的理解和备注。 3、成都-颜乐乐： 吃了《javascript设计模式》 张容铭 著 这本书之后， 吐出来的熟肉： https://github.com/yanlele/node-index/tree/master/book/04%E3%80%81js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F 这个数设计模式思想非常好，写的很棒，不过基本上都是ES5语法，这本书上出现的所有 demo 被我改成了es6 写法，计思想被我精简过和加上了一些自己的备注理解。 4、北京-Rocky： 各种免费的 PDF 在线工具：https://www.ilovepdf.com/ 5、深圳-团长： 一名【合格】前端工程师的自检清单：https://juejin.im/post/5cc1da82f265da036023b628 6、成都-颜乐乐： 关于 css 实现多行文字截断问题：https://segmentfault.com/a/1190000008649988 7、杭州~nan： 《2019第4届中国前端开发者大会》 8、深圳-团长： 《深圳IT互联网大厂有哪些（2019年版）》 9、深圳-工兵： IOS加阻尼滑动可能导致的bug和处理方法：https://www.cnblogs.com/hrone/p/10143960.html （团长备注：滚动穿透、阻尼滑动，都是移动端的常见问题，可以关注下。） 2019-04-181、深圳-团长： 蓝湖：一款产品文档和设计图的在线协作平台。网址：https://lanhuapp.com 最近在做一个需求，我们设计师用到了这个网站。大家可以了解下，拓展视野。 （广州-萧雪圣补充：蓝湖，这个我上家和现在公司都在用，UI用这个出效果图，标注好各种尺寸，前端也比较好开发，还可以直接下载切图，用得好是个能提高开发效率的工具。） 2018-12-271、上海-前端-强子： 前端大佬汇总：http://caibaojian.com/c/qianduan （团长备注：几位前端大佬，基本都在里面了，除了我。） 2、广州Brenner： Canvas: Draw on the web（HTML5 Canvas 教程）：https://www.yuque.com/airing/canvas （上海-前端-强子 备注：这个很不错，我前几天做分享战绩的时候就用到这个了。）","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/02-2019年Web前端最新导航","date":"2021-08-06T01:17:26.093Z","updated":"2021-07-28T07:34:11.399Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/02-2019年Web前端最新导航/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/02-2019%E5%B9%B4Web%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E5%AF%BC%E8%88%AA/","excerpt":"","text":"本文的最新内容将在GitHub上实时更新。欢迎在GitHub上关注我，一起入门和进阶前端。 前言本文列出了很多与前端有关的常见网站、博客、工具等，整体来看比较权威。有些东西已经过时了，我就不列出来了。 学是一方面，也是最主要的方面；但还有一个作用，比如，“这个前端框架你都不知道啊”、“这个前端大牛你都没听说过啊” ，此时，这份清单就能起到作用了。如果你能把清单里列出的内容都了解下，逼格也会高很多。 技术社区 GitHub：https://github.com/ 高质量的内容创作和分享平台。 请记住，作为一个码农，GitHub 代表了你的名片。 stackoverflow：https://stackoverflow.com/ 遇到技术问题请先Google，很多答案都能在 stackoverflow 上找到。 技术博客 掘金：https://juejin.im/ 掘金已经被前端同学攻陷了。目前来看，国内的很多优质前端文章，都在掘金上。 如果你刚开始写前端博客，可以考虑在掘金上发文章。当然，文章最好在掘金、博客园、知乎上做同步。 博客园：https://www.cnblogs.com/ 一个很纯粹的技术博客平台。 知乎：https://www.zhihu.com/ 很多做技术的同学也开始玩知乎了，阿里的不少前端大牛在知乎上就非常活跃。 CSDN：https://www.csdn.net/ 广告太多，但奈何你这么老牌。 segmentfault：https://segmentfault.com/ 比较低调的技术博客平台。 GitHub 排名统计 GitHub 中国区排名：https://githuber.cn/search?language=JavaScript 这个网站虽然比较小众，但排名还是相对比较准的。 GitHub 中国区排名：http://githubrank.com/ 这个排名很久没更新了，早就不准了；而且还经常打不开。 GitHub 全球排名：https://gitstar-ranking.com/ 这个排名很权威。如果你的项目超过 10k star，就能上榜，跻身全球 GitHub 项目前1000名。 GitHub trending（官网推荐）：https://github.com/trending 你的项目要是能上 GitHub trending，绝对火得一塌糊涂。 资讯 虎嗅网：https://www.huxiu.com/ 36氪：https://36kr.com/ 利器：https://liqi.io/ 采访优秀的创造者，邀请他们来分享工作时所使用的工具。 湾区日报：https://wanqu.co/ 每天推送 5 篇优质英文文章。 Solidot：https://www.solidot.org/ 品玩：https://www.pingwest.com/ 极客公园：http://www.geekpark.net/ 框架 Vue.js：https://cn.vuejs.org/ React：https://reactjs.org/ Angular：https://angular.cn/ AngularJS：https://angularjs.org/ Koa：https://koa.bootcss.com/ 基于 Node.js 平台的下一代 Web 开发框架。 Express：http://www.expressjs.com.cn/ 基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 Egg：https://eggjs.org/zh-cn/ Egg 继承于 Koa。 Koa 是一个非常优秀的框架，然而对于企业级应用来说，它还比较基础。而 Egg 选择了 Koa 作为其基础框架，在它的模型基础上，进一步对它进行了一些增强。 Electron：https://www.electronjs.cn/ Electron（原名为Atom Shell）是GitHub开发的一个开源js框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。 也就是说，我们可以用 js 语言开发客户端软件了。其实呢，VS Code 这个客户端软件就是用 js 语言写的。 Redux：https://www.redux.org.cn/ Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 ReactNative：https://reactnative.cn/ 使用JavaScript编写原生移动应用。 mpvue：http://mpvue.com/ 基于 Vue.js 的小程序开发框架。 UI框架 Bootstrap：http://www.bootcss.com/ ElementUI：http://element-cn.eleme.io/ 基于 Vue.js 的组件库。 iView：https://www.iviewui.com/ 一套基于 Vue.js 的高质量 UI 组件库。 Ant Design：https://ant.design 基于 React 的 UI 组件库，主要用于研发企业级中后台产品。官网推出了 Ant Design pro 作为示例，可以看看。 Ant Design Mobile：https://mobile.ant.design/ 一个基于 Preact / React / React Native 的 移动端 UI 组件库。 Ant Design of Vue：https://vue.ant.design/docs/vue/introduce-cn/ Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 类库 jQuery：http://jquery.com/ Zepto.js：https://zeptojs.com/ 可以理解成是移动端的 jQuery。 ECharts：https://echarts.baidu.com/ 使用 JavaScript 实现的开源可视化库。 CSS Sass：https://sass-lang.com/ Sass 是成熟、稳定、强大的 CSS 扩展语言。入门文档可以看：http://sass.bootcss.com/ Less：http://lesscss.org/ 给 CSS 加点料。入门文档可以看：https://less.bootcss.com/ Stylus：http://stylus-lang.com/ 构建 NPM：https://www.npmjs.com/ Yarn：https://yarnpkg.com/zh-Hans/ Webpack：https://webpack.js.org/ Gulp：https://www.gulpjs.com.cn/ Babel：https://babeljs.io/ ESLint：https://cn.eslint.org/ 可组装的JavaScript和JSX检查工具。 PostCSS：https://www.postcss.com.cn/ 用 JavaScript 工具和插件转换 CSS 代码的工具 调试抓包 whistle：https://wproxy.org/whistle/ 代理抓包工具，很好很强大。 Fiddler：https://www.telerik.com/fiddler 代理抓包工具。 Mock数据 Easy Mock：https://www.easy-mock.com 编辑器 &amp;&amp; IDE VS Code：https://code.visualstudio.com/ Sublime Text：https://www.sublimetext.com/ WebStorm：https://www.jetbrains.com/webstorm/ Atom：https://atom.io/ 编码规范 Bootstrap编码规范：https://codeguide.bootcss.com/ es6编程风格：http://es6.ruanyifeng.com/#docs/style Airbnb Javascript Style Guide：https://github.com/airbnb/javascript 静态站点搭建工具 Hexo：https://hexo.io/zh-cn/ VuePress：https://www.vuepress.cn/ GitBook：https://www.gitbook.com/ 设计工具 墨刀：原型设计工具。网址：https://modao.cc/ 蓝湖：一款产品文档和设计图的在线协作平台。网址：https://lanhuapp.com PxCook（像素大厨）：高效易用的自动标注工具。软件下载链接：https://www.fancynode.com.cn/pxcook 图标 Font Awesome：http://www.fontawesome.com.cn/ Iconfont：https://www.iconfont.cn/ icomoon：https://icomoon.io/ EasyIcon：https://www.easyicon.net/ icons8：https://icons8.cn/ IconStore：https://iconstore.co/ iconninja：http://www.iconninja.com/ 工具 CanIUse：https://caniuse.com/ 浏览器兼容性查询。前端同学必须要知道。 国家企业信用信息公示系统：http://www.gsxt.gov.cn 通过这个网站，我们可以查到任何一家公司的基本信息（成立时间、法定代表人等）。如果你在这个网站上没有找到某公司的信息，放心吧，这个公司一定是个骗子。 ProcessOn：https://www.processon.com/ 在线制作流程图。推荐。 幕布：https://mubu.com 极简大纲笔记、一键生成思维导图。非常好用。 JSON格式化：http://www.bejson.com/ 草料二维码：https://cli.im/ 短链生成：http://www.sina.lt GitHub短网址：https://git.io/ 图片压缩：https://www.yasuotu.com/ 图片转base64：http://imgbase64.duoshitong.com/ 在线PS：https://www.photopea.com/ 图片在线裁剪：https://www.asqql.com/gifc/ 多数据源IP地址查询：https://haoip.cn/ Gif添加字幕：http://www.yingjingtu.com/ Photoshop的投影参数转换为 CSS代码：https://psd2css.mezw.com/ 将Photoshop设计文件图层中的混合选项参数快速转换为CSS3代码，以节省前端开发人员的时间和精力。 Get Emoji：https://emoji.svend.cc/ 图片转Ascii：http://picascii.com/ 视频转GIF：https://github.com/vvo/gifify OCR文字识别：https://app.xunjiepdf.com/ocr 团队 腾讯AlloyTeam：http://www.alloyteam.com/ 腾讯社交用户体验ISUX：https://isux.tencent.com/ 淘宝FED | 淘宝前端团队：http://taobaofed.org/ 阿里巴巴国际UED：http://www.aliued.com/ 京东 | 凹凸实验室：https://aotu.io/ 饿了么前端:https://zhuanlan.zhihu.com/ElemeFE 百度前端研发部FEX：http://fex.baidu.com/ 360 | 奇舞团：https://75team.com/ 知道创宇FED：https://knownsec-fed.com/ 前端大牛阮一峰（蚂蚁金服） GitHub：https://github.com/ruanyf 博客：http://www.ruanyifeng.com/blog/ 尤雨溪 GitHub：https://github.com/yyx990803 博客：http://blog.evanyou.me/ 知乎：https://www.zhihu.com/people/evanyou 玉伯 GitHub：https://github.com/lifesinger 博客：https://github.com/lifesinger/blog 知乎：https://www.zhihu.com/people/lifesinger 司徒正美（去哪儿） GitHub：https://github.com/RubyLouvre 博客：http://www.cnblogs.com/rubylouvre/ 知乎：https://www.zhihu.com/people/si-tu-zheng-mei 张鑫旭（腾讯） GitHub：https://github.com/zhangxinxu 博客：https://www.zhangxinxu.com/ 知乎：https://www.zhihu.com/people/iamzhangxinxu 迷渡 GitHub：https://github.com/justjavac 知乎：https://www.zhihu.com/people/justjavac.com 羡辙 | Ovilia GitHub：https://github.com/Ovilia 知乎：https://www.zhihu.com/people/ovilia 云谦（陈成） GitHub：https://github.com/sorrycc 博客：https://sorrycc.com/ 云谦装了啥：https://github.com/sorrycc/awesome-tools 偏右 GitHub：https://github.com/afc163 知乎：https://www.zhihu.com/people/afc163 黄峰达/Phodal Huang（ThoughtWorks） GitHub：https://github.com/phodal 博客：https://www.phodal.com/ 知乎：https://www.zhihu.com/people/phodal 贺师俊/Hax（百姓网） GitHub：https://github.com/hax 博客：http://johnhax.net/ 知乎：https://www.zhihu.com/people/he-shi-jun 大漠链接： GitHub：https://github.com/airen 大漠的GitHub上没啥东西。 博客：https://www.w3cplus.com 知乎：https://www.zhihu.com/people/w3cplus 介绍： 常用昵称“大漠”，W3CPlus创始人，目前就职于淘宝。对HTML5、CSS3和CSS处理器等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对CSS3和动画的研究，是国内最早研究和使用CSS3和CSS处理器技术的一批人。现在主要在探讨学习JavaScript、React和Vue相关技术知识。CSS、CSS处理器和Web动画中国布道者。2014年出版《图解CSS3：核心技术与案例实战》。 EGOIST 博客：https://egoist.sh/ GitHub：https://github.com/egoist 冴羽链接： GitHub：https://github.com/mqyqingfeng 博客：https://github.com/mqyqingfeng/Blog 知乎：https://www.zhihu.com/people/qing-feng-yi-yang 李靖/小胡子哥（淘宝网） GitHub：https://github.com/barretlee 博客：https://www.barretlee.com/ 知乎：https://www.zhihu.com/people/barretlee/ cangdu GitHub：https://github.com/bailicangdu Jackson Tian GitHub：https://github.com/JacksonTian 博客：http://jacksontian.org/ 题叶（饿了么、前 Teambition） GitHub：https://github.com/jiyinyiyong 博客：http://tiye.me/ 杨健（今日头条） GitHub：https://github.com/hardfist 知乎：https://www.zhihu.com/people/hardfist 流形 （阿里巴巴数据技术与产品部前端团队负责人） 知乎：https://www.zhihu.com/people/arcthur/ 总结如果你有发现新的内容，欢迎在 GitHub 上提交 issues。","categories":[],"tags":[]},{"title":"","slug":"大前端/17-前端综合/01-2019年Web前端入门自学路线","date":"2021-08-06T01:17:26.091Z","updated":"2021-07-28T07:34:11.398Z","comments":true,"path":"2021/08/06/大前端/17-前端综合/01-2019年Web前端入门自学路线/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/17-%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/01-2019%E5%B9%B4Web%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"本文的最新内容将在GitHub上实时更新。欢迎在GitHub上关注我，一起入门和进阶前端。 我之前写过一篇文章：《裸辞两个月，海投一个月，从Android转战Web前端的求职之路》。这篇文章讲述了我在转型过程中的亲身经历和感受，不少童鞋私信问我怎么入门前端，于是有了这篇文章。 Web前端入门的自学路线 新手入门前端，需要学习的基础内容有很多，如下。 一、HTML、CSS基础、JavaScript语法基础。学完基础后，可以仿照电商网站（例如京东、小米）做首页的布局。 二、JavaScript语法进阶。包括：作用域和闭包、this和对象原型等。相信我，JS语法，永远是面试中最重要的部分。 三、jQuery、Ajax等。jQuery没有过时，它仍然是前端基础的一部分。 四、ES6语法。这部分属于JS新增的语法，面试必问。其中，关于promise、async等内容要尤其关注。 五、HTML5和CSS3。要熟悉其中的新特性。 六、canvas。面试时，有的公司不一定会问canvas，靠运气。如果时间不够，这部分的内容可以先不学。但如果你会，绝对属于加分项。 七、移动Web开发、Bootstrap等。要注意移动开发中的适配和兼容性问题。 八、前端框架：Vue.js和React。这两个框架至少要会一个。入门时，建议先学Vue.js，上手相对容易。但无论如何，同时掌握 Vue 和 React 才是合格的前端同学。 九、Node.js。属于加分项，如果时间不够，可以先不学，但至少要知道 node 环境的配置。 十、自动化工具：构建工具 Webpack、构建工具 gulp、CSS 预处理器 Sass 等。注意，Sass 比 Less 用得多，gulp 比 grunt 用得多。 十一、前端综合：HTTP协议、跨域通信、安全问题（CSRF、XSS）、浏览器渲染机制、异步和单线程、页面性能优化、防抖动（Debouncing）和节流阀（Throtting）、lazyload、前端错误监控、虚拟DOM等。 十二、编辑器相关。Sublime Text 是每个学前端的人都要用到的编辑器。另外，前端常见的IDE有两个：WebStorm 和 Visual Studio Code。WebStorm什么都好，可就是太卡顿；VS Code就相对轻量很多。个人总结一下：新手一般用 WebStorm，入门之后，用 VS Code 的人更多。 十三、TypeScript（简称TS）。ES 是 JS 的标准，TS 是 JS 的超集。TS属于进阶内容，建议把上面的基础掌握之后，再学TS。 推荐的图文教程我在GitHub上有一个Web前端入门的学习教程，非常详细，地址是： https://github.com/qianguyihao/Web 非常详细和贴心，你值得star。 学习交流我建了一个“前端学习”的微信交流群，目前来看，学习氛围很不错。加我微信（bootmei），拉你进群： 进群暗号：前端学习。 进群要求：少提问、少闲聊、多分享（长期潜水的，就不必了）。 推荐的技术博客 阮一峰 张鑫旭 推荐的书籍 《你不知道的JavaScript》 上面这套书有上、中、下三本，你都可以读一读。如果时间不够，那就先读第一本。 《网络是怎样连接的》 程序员面试的时候，经常会被问的一个问题是：“在浏览器的地址栏输入url，按下回车后，发生了什么？” 为了清楚这个问题，看上面这本书，足够了。如果你想入门计算机网络，这本书也是必读的。评价非常高。 关于这个问题，也可以看下面这篇文章：浏览器输入 URL 后发生了什么？ 《CSS世界》 关于 CSS 的书籍，首先推荐这本书，我身边的大佬们都说这本书好。虽然我不是大牛，但我也觉得这本书很好。 如果 js 熟练，说明你是有技术深度的前端；如果 css 熟练，说明你是有经验的前端。 推荐的链接 前端导航：https://www.cnblogs.com/qianguyihao/p/10701923.html 这个导航里列出了很多常见网站、博客、工具等，整体来看比较权威。 学是一方面，也是最主要的方面；但还有一个作用，比如，“这个前端框架你都不知道啊”、“这个前端大牛你都没听说过啊” 。此时，这份清单就能起到作用了。如果能把清单里列出的内容都了解下，逼格也会高很多。 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web 如果你想查看前端的 api 文档，请首先去 MDN上看。很官方，很正规。 不要去什么 w3school 上看，可能有很多错误。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/前端的几道题目","date":"2021-08-06T01:17:26.086Z","updated":"2021-07-28T07:34:11.398Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/前端的几道题目/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/","excerpt":"","text":"几道面试题 页面布局如何实现一个三栏布局，要求两边固定宽度、中间自适应。此题可以考察的知识点： 圣杯布局 双飞翼布局 flex布局（css3） 让元素垂直居中方式一：如果宽高已知，可以利用绝对定位。 方式二：用 translate 位移来做。（在宽高未知的情况下，也可以这样做） 123456div &#123; background-color: red; position: absolute; 绝对定位的盒子 top: 50%; 首先，让上边线居中 transform: translateY(-50%); 然后，利用translate，往上走自己宽度的一半【推荐写法】&#125; 方式三：flex 布局 12345parentElement&#123; display: flex;/*Flex布局*/ display: -webkit-flex; /* Safari */ align-items: center;/*设置子元素在侧轴方向上的布局*/&#125; 参考链接： https://www.zhihu.com/question/20543196 水平垂直居中方案与flexbox布局 变量提升问题：说一下你对JavaScript变量提升的理解。 定义： 在函数体内部，声明变量，会把该变量提升到函数体的最顶端。注意：只提升变量声明，不赋值。 代码1： 123456fn();function fn() &#123; var x = 1; var y = 2;&#125; 上方代码中： （1）给fn创建函数上下文，找到fn中所有用var声明的变量（即x和y）； （2）将这些变量初始化为undefined； （3）将x赋值为1，将y赋值为2。 代码2： 123456fn2();function fn2() &#123; console.log(2);&#125; 上方代码中： （1）创建全局上下文，找到所有用function声明的变量，在环境中“创建”这些变量。 （2）将这些变量初始化，并赋值为 function()&#123; console.log(2) &#125;（并不是undefined） （3）开始执行代码fn2(); 代码3：（let的出现） 1234&#123; let x = 1 x = 2&#125; 上方代码中： （1）找到所有用 let 声明的变量，在环境中「创建」这些变量 （2）开始执行代码（注意现在还没有初始化） （3）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined） （4）执行 x = 2，对 x 进行「赋值」 代码4： 12345let x = &#x27;global&#x27;&#123; console.log(x) // Uncaught ReferenceError: x is not defined let x = 1&#125; 原因有两个： console.log(x) 中的 x 指的是下面的 x，而不是全局的 x 执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区） 看到这里，你应该明白了 let 到底有没有提升： let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。 参考链接： 我用了两个月的时间才理解 let this问题：下方代码的打印结果是什么？ 123456789101112function A() &#123; this.name = &#x27;smyhvae&#x27;;&#125;A.prototype.test = function () &#123; setTimeout(function () &#123; console.log(this.name); &#125;, 1)&#125;var a = new A();a.test(); 打印结果是window.name，但实际的结果是空的。 这个神奇的特性，被用来解决跨域数据传递。（网上可以查一下iframe相关） 总结1：this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。即：谁调用，指向谁。 举例： 123456789var name = &#x27;全局&#x27;;function getName() &#123; var name = &#x27;局部&#x27;; return this.name;&#125;;alert(getName()); 上方代码的打印结果是：全局。 分析：getName()这个函数其实是window调用的，所以this指向的window，因为外部有name这个变量，所以打印结果为全局。 总结2：没有明确的当前对象时，this永远指向window。这个在setTimeout里比较常见。 apply、call、bind的区别链式调用问题：如何实现类似jQuery的链式调用？ 答案：一直return this就好了。 Yslow和pageSpeedYslow和pageSpeed你知道怎么用吗？你记得其中多少规则？ DNS的查询时间问题：前端怎样拿到DNS的查询时间？ H5中的方法：performance.timingwindow.performance这个api可以用来做前端性能监控。其中，timing这个方法。。 参考链接： https://github.com/fredshare/blog/issues/5","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/Vue开发积累","date":"2021-08-06T01:17:26.084Z","updated":"2021-07-28T07:34:11.397Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/Vue开发积累/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/Vue%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"Vue 开发积累001：scoped 关键字的作用在 xx.vue 组件中，我们可能会遇到带 scoped 关键字的样式。比如： 1234567891011121314151617&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h3 &#123; margin: 40px 0 0;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 上方的scoped表示的是作用域化，样式只对当前子组件生效。","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/09-lazyload&防抖动和节流阀","date":"2021-08-06T01:17:26.082Z","updated":"2021-07-28T07:34:11.397Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/09-lazyload&防抖动和节流阀/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/09-lazyload&%E9%98%B2%E6%8A%96%E5%8A%A8%E5%92%8C%E8%8A%82%E6%B5%81%E9%98%80/","excerpt":"","text":"lazyload用的最多的场景是： 图片lazyload 组件lazyload 现在一般都单独做css的lazyload或者js的lazyload，因为这种方式，其实还是要加载图片和组件。 图片lazyload图片一般是页面最大的资源，所以非首屏延迟加载很重要（让首屏尽快显示）。 防抖动（Debouncing）和节流阀（Throtting）参考链接： 实例解析防抖动（Debouncing）和节流阀（Throttling）","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/04-前端监控技术","date":"2021-08-06T01:17:26.080Z","updated":"2021-07-28T07:34:11.397Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/04-前端监控技术/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/04-%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/","excerpt":"","text":"前言要监控的内容： 业务数据 稳定性 性能 错误 用户操作路径 怎么监控： PV/UV、业务操作上报 根据上报寻找异常 将页面性能数据上报 将页面产生错误上报 跟踪用户操作路径","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/02-数组的常见操作","date":"2021-08-06T01:17:26.078Z","updated":"2021-07-28T07:34:11.396Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/02-数组的常见操作/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/02-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"前言数组在实战开发中，使用得相当频繁。前端同学通过接口拿到json数据后，往往需要把数据进行各种形式的变换和展示。这个时候，数组的常见操作，就发挥了很大的作用。 如果你对数组的基础知识不太熟悉，建议回去看看03-JavaScript的基础知识。 掌握了基础知识之后，我们再来看看，实战开发中，数组都有哪些常见操作。 数组的常见操作从对象数组中，将属性的值提取为数组一般人可能会想着通过 for 循环进行遍历，但这种做法不够简洁。 最佳答案： 12345678const arr1 = [ &#123; skuId: &quot;123&quot;, name: &quot;商品1&quot; &#125;, &#123; skuId: &quot;456&quot;, name: &quot;商品2&quot; &#125;, &#123; skuId: &quot;789&quot;, name: &quot;商品3&quot; &#125;];const skuIdArr = arr1.map(item =&gt; item.skuId); // 将数组 arr1 中的 skuId字段提取为一个新的数组console.log(JSON.stringify(skuIdArr)); 打印结果： 1[&quot;123&quot;,&quot;456&quot;,&quot;789&quot;] 参考链接：https://codeday.me/bug/20170426/12102.html","categories":[],"tags":[]},{"title":"","slug":"大前端/16-前端进阶/01-前端常见专有名词","date":"2021-08-06T01:17:26.076Z","updated":"2021-07-28T07:34:11.396Z","comments":true,"path":"2021/08/06/大前端/16-前端进阶/01-前端常见专有名词/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/16-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/01-%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/","excerpt":"","text":"性能相关 防抖和节流 滚动穿透 样式相关 多行文字截断","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/面经链接推荐","date":"2021-08-06T01:17:26.071Z","updated":"2021-07-28T07:34:11.396Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/面经链接推荐/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/%E9%9D%A2%E7%BB%8F%E9%93%BE%E6%8E%A5%E6%8E%A8%E8%8D%90/","excerpt":"","text":"2018-01-25 有时在面试时，我都替候选人着急——候选人完全可以在面试前准备 2018-01-26 转眼人到中年：前端老程序员无法忘怀的一次百度电话面试 八年前的面经，咋记得这么清楚？ 2018-01-27 16年毕业的前端er在杭州求职ing 2018-02-04 2018秋招前端总结 2018-02-25 前端开发面试题(CSS) 超过20家的前端面试题 来聊聊前端工程师的面试套路 我的前端进阶之路（面试题） 这几个链接里讲到了 less。听说面试爱问 less 和 Sass的区别。 2018-03-02 记录前端的面试日常(持续更新) 2018-03-06 我遇到的前端面试题2017 里面有很多面试跳槽里的内容。","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/清单","date":"2021-08-06T01:17:26.069Z","updated":"2021-07-28T07:34:11.395Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/清单/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/%E6%B8%85%E5%8D%95/","excerpt":"","text":"01.md CommonJS、RequireJS(AMD) SeaJS（CMD）区别Webpack 打包WebSocketES6会 ES6 是应该的部分，不算加分项。","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/异步","date":"2021-08-06T01:17:26.068Z","updated":"2021-07-28T07:34:11.395Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/异步/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/%E5%BC%82%E6%AD%A5/","excerpt":"","text":"面试题20180321面试题1234567891011console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 1000);setTimeout(function () &#123; console.log(3);&#125;, 0);console.log(4); 20180321面试题123456var arr = [1, 2, 3];for (var i = 0; i &lt; arr.length; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 0);&#125; 打印结果：3，3，3","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/函数","date":"2021-08-06T01:17:26.066Z","updated":"2021-07-28T07:34:11.395Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/函数/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/%E5%87%BD%E6%95%B0/","excerpt":"","text":"123456789var arr = [1, 2, 3];fun(arr);console.log(arr);function fun(a) &#123; a = [];&#125; 上方代码的打印结果是：[1,2,3]","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/20180116-博客园：一年经验初探阿里巴巴前端社招","date":"2021-08-06T01:17:26.064Z","updated":"2021-07-28T07:34:11.395Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/20180116-博客园：一年经验初探阿里巴巴前端社招/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/20180116-%E5%8D%9A%E5%AE%A2%E5%9B%AD%EF%BC%9A%E4%B8%80%E5%B9%B4%E7%BB%8F%E9%AA%8C%E5%88%9D%E6%8E%A2%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%89%8D%E7%AB%AF%E7%A4%BE%E6%8B%9B/","excerpt":"","text":"博客园：一年经验初探阿里巴巴前端社招 文章来源：https://www.cnblogs.com/fsyz/p/8298921.html 一般阿里社招都是招3-5年的P6+高级工程师，当初自己一年经验也没有想过有这个面试机会。 虽然没想着换工作，但是经常关注一些招聘网站的信息，某一天，在某boss上有个人找我，叫我发一下简历，我一看是阿里的某技术专家，虽然之前也有阿里的在某boss上给我要简历，但是我深知自己经验不足，然后给boss说我是16届的，只有一年经验，然后就没有然后了。这次我依然这么回复，但是这boss说，没关系，他喜欢基础好的，让我可以试一试，于是我也抱着试一试的心态发了简历。 简历发过去之后，boss就给我打了电话，让我简单的介绍一下自己，我就噼里啪啦说了一些，还说了一些题外话。然后boss就开始问我问题。 由于面了四轮，所以最开始的面试记忆有点模糊了，细细回想，又感觉记忆犹新。 1.电话初探1.说一下你了解CSS盒模型。我就说了一下IE的怪异盒模型和标注浏览器的盒模型，然后可以通过box-sizing属性控制两种盒模型的变换。 2.说一下box-sizing的应用场景。这个也不难，简单说了一两个应用场景，具体就不一一细说了。 3.说一下你了解的弹性FLEX布局.这个我也比较了解，各种概念和属性能想到的说了一大堆，也扯到了Grid布局，基本这个也没啥问题。 4.说一下一个未知宽高元素怎么上下左右垂直居中。说了一下flex弹性布局的实现，说了一下兼容性，扯到了postcss的一些东西，然后说了一下常规的兼容性比较好的实现。 5.说一下原型链，对象，构造函数之间的一些联系。这个我之前写过相关的文章，自己也有比较深入的理解，所以这个也不在话下，噼里啪啦说了一大堆，也不知道面试官听得咋样。 6.DOM事件的绑定的几种方式说了三种，然后说了一些冒泡，默认事件，以及DOM2，DOM3级的一些标准。 7.说一下你项目中用到的技术栈，以及觉得得意和出色的点，以及让你头疼的点，怎么解决的。这个因人而异，开放性问题，主要考察平时项目的一些积累吧，这个我回答感觉也比较ok。 8.有没有了解http2.0,websocket,https，说一下你的理解以及你所了解的特性。这个我看过一些文章，但是没有什么印象，扯了一些概念，但是回答的不是很深。 第一轮电话初探，大约面了50分钟，就记起来这么多，还有一些细节问题可能淡忘了，总体来说，面的都是以基础为主，然后boss说把我简历推荐给内部，进行正式的社招流程。 一轮技术面然后当天晚上一个女的面试官就给我打电话了，说八点半进行下一轮技术面试，没想到效率这么快，我都没怎么准备。这次就直接省略自我介绍了。 1.webpack的入口文件怎么配置，多个入口怎么分割啥的，我也没太听清楚。这个自己就说了一下自己的理解，以及自己用node写的多入口怎么配置，然后面试官说不是多入口配置，然后我又说了一下自己的理解，然后这题就过了。 2.我看到你的项目用到了Babel的一个插件：transform-runtime以及stage-2，你说一下他们的作用。这个我也还算比较了解，就说了一下ES的一些API，比如generator啥的默认不转换，只转换语法，需要这个来转换，然后说profill啥的，扯了一下stage-1，stage-2，stage-3，这个问题回答还算清楚。 3.我看到你的webpack配置用到webpack.optimize.UglifyJsPlugin这个插件，有没有觉得压缩速度很慢，有什么办法提升速度。这个我主要回答了一下，我之前也没怎么了解，一个想到是缓存原理，压缩只重新压缩改变的，还有就是减少冗余的代码，压缩只用于生产阶段，然后面试官问还有呢？我就说，还可以从硬件上提升，可以得到质的飞跃，比如换台I9处理器的电脑。。。。 4.简历上看见你了解http协议。说一下200和304的理解和区别这个噼里啪啦说了一堆，协商缓存和强制缓存的区别，流程，还有一些细节，提到了expires,Cache-Control,If-none-match,Etag,last-Modified的匹配和特征，这一块之前有过比较详细的了解，所以还是应答如流。 5.DOM事件中target和currentTarget的区别这个没答上来。。。 6.说一下你平时怎么解决跨域的。以及后续JSONP的原理和实现以及cors怎么设置。我就说了一下Jason和cors,然后问我JSONP的原理以及cors怎么设置，这一块自己也实践过，所以还是对答如流的。 7.说一下深拷贝的实现原理。这个也还好，就是考虑的细节不是很周全，先是说了一种JSON.stringify和JSON.parse的实现，以及这种实现的缺点，主要就是非标准JSOn格式无法拷贝以及兼容性问题，然后问了我有么有用过IE8的一个什么JSON框架，我也不记得是什么了，因为我压根没听过，然后说了一下尾递归实现深拷贝的原理，还问了我typeof null是啥，这个当然是Object。。。 8.说一下项目中觉得可以改进的地方以及做的很优秀的地方？这个也是因人而异，开放性问题，大致扯了一下自己的经历，也还OK。 最后问了有什么需要问的地方，面试到这里基本就结束了，大约面了一个多钟头，还是蛮累的。总体来说，回答的广度和深度以及细节都还算OK，觉得这轮面试基本没什么悬念。 二轮技术面过了几天，接到阿里另一个面试官的电话，上一轮面试通过了，这次是二轮技术面，说估计一个钟头。这次依然跳过自我介绍之类的，直奔主题。 1.有没有自己写过webpack的loader,他的原理以及啥的，记得也不太清楚。这个我就说了一下，然后loader配置啥的，也还ok。 2.有没有去研究webpack的一些原理和机制，怎么实现的。这个我简单说了一下我自己了解的，因为这一块我也没深入去研究，所以说的应该比较浅。 3.babel把ES6转成ES5或者ES3之类的原理是什么，有没有去研究。这一块我说了一下自己的思路，大致也还OK，我也没去深入研究怎么转换的，之前好像看过类似的文章，自己也只观察过转换之后的代码是啥样的，至于怎么转换的规则，真的没去深入观察。 4.git大型项目的团队合作，以及持续集成啥的。这里我就说了一下自己了解的git flow方面的东西，因为没有实战经验，所以我就选择性说明了这一块的不熟练，然后面试官也没细问。 5.什么是函数柯里化？以及说一下JS的API有哪些应用到了函数柯里化的实现？这个我就说了一下函数柯里化一些了解，以及在函数式编程的应用，最后说了一下JS中bind函数和数组的reduce方法用到了函数柯里化。 6.ES6的箭头函数this问题，以及拓展运算符。这一块主要是API和概念的问题，扯了一些规范以及严格模式下其他情况this只想问题。 7.JS模块化Commonjs,UMD,CMD规范的了解，以及ES6的模块化跟其他几种的区别，以及出现的意义。这个也是说了一下自己的理解和认知，自己对模块化历史以及一些规范都有所涉猎，这一块也还凑合。 8.说一下Vue实现双向数据绑定的原理，以及vue.js和react.js异同点，如果让你选框架，你怎么怎么权衡这两个框架，分析一下。主要是发布订阅的设计模式，还有就是ES5的Object.defineProperty的getter和setter机制，然后顺便扯了一下Angular的脏检测，以及alvon.js最先用到这种方式。然后扯了一下vue.js和react.js异同点，权衡框架选择，调研分析之类，噼里啪啦说了一大堆。 9.我看你也写博客，说一下草稿的交互细节以及实现原理。这一款就按照自己用过简书或者掘金，SG这类草稿的体验，详细说了一下，这个开放性问题，说到点基本就OK。 最后面试官问我有什么想问的吗，面试到这里基本就结束了，差不多面了一个小时，说过几天就会给答复，如果过了就会去阿里园区进行下一轮的技术面。 三轮技术面上一轮发挥感觉没前两轮发挥好，所以还是有点不自信的，没想到第三天后，就来电话了，通知我去阿里园区面试。 因为阿里西溪园区距离我不到十公里，我就踩着共享单车一点钟就出发了，天气比较热，飘在路上，百感交集，身边一辆法拉利轰鸣而过，又一辆兰博基尼呼啸而过，我心里一万头草泥马奔腾，MLGB，心里暗想，为神马开这车的人不是此刻看文章的你？ 走到半路了，面试官给我打电话了，说我怎么还没到，说约定的是两点钟，我一下子就懵逼了，短信只有一个游客访问ID，并没有通知我具体时间，反正不管谁的疏忽，我肯定是要迟到了，于是我快马加鞭，踩着贼难骑的共享单车，背着微风，一路狂奔，到阿里园区已是汗流浃背，油光满面，气喘乎乎。。。 面试迟到了，印象肯定不好，加上满头大汗的形象也不太好，加上自己饥渴难耐，这面是估计要GG了，一进来就直奔主题，这次是两个大Boss面试我。 第一个面试官1.先自我介绍一下，说一下项目的技术栈，以及项目中遇到的一些问题啥的。这个问题就是个开场白，简要说明一下，问题都不大，这个面试官就是第一次打电话给我面试的那个boss，所以技术那块boss心里也有个底细，所以没再问技术问题。 2.一个业务场景，面对产品不断迭代，以及需求的变动该怎么应对，具体技术方案实现。具体业务场景，我就不一一描述，Boss在白板上画了一个大致的模块图，然后做了一些需求描述。然后需求一层一层的改变，然后往下挖，主要是考察应对产品能力，以及对代码的可维护性和可拓展性这些考察，开放性问题，我觉得还考察一些沟通交流方面的能力，因为有些地方面试官故意说得很含糊，反正就是一个综合能力，以及对产品的理解，中间谈到怎么实现，也问到了一些具体的点，记得问到的有一下几个。 ① 怎么获取一个元素到视图顶部的距离。② getBoundingClientRect获取的top和offsetTop获取的top区别③事件委托 第二个面试官1.业务场景：比如说百度的一个服务不想让阿里使用，如果识别到是阿里的请求，然后跳转到404或者拒绝服务之类的？主要是考察http协议头Referer，然后怎么判断是阿里的ip或者啥的，我也不太清楚。 2.二分查找的时间复杂度怎么求，是多少。。。排序的还算清楚一点，查找真的不知所措，没回答上来，也没猜，意义不大，不会就是不会。 3.XSS是什么，攻击原理，怎么预防。这个很简单，跨站脚本攻击XSS(cross site scripting)，攻击类型主要有两种：反射型和存储型，简单说了一下如何防御： ①转义②DOM解析白名单③第三方库④CSP 自己对web安全这块系统学习过，前前后后大约了解了很多，对于XSS,CSRF,点击劫持，Cookie安全，HTTP窃听篡改，密码安全，SQL注入，社会工程学都有一定了解，所以这个自然也不在话下。 4.线性顺序存储结构和链式存储结构有什么区别？以及优缺点。我是类比JS数组和对象来回答的，反正还算凑合吧，自己都数据结构这块多少还是有些印象，所以入了前端，对数据结构和算法确实一直淡忘了。 5.分析一下移动端日历，PC端日历以及桌面日历的一些不同和需要注意的地方。这个我能想到的大致都说了一遍，不同的场景交互和细节以及功能都有所偏差，以及功能的侧重都可能不同。 6.白板写代码，用最简洁的代码实现数组去重。我写了两种实现方式：ES6实现： […new Set([1,2,3,1,’a’,1,’a’])]ES5实现： [1,2,3,1,’a’,1,’a’].filter(function(ele,index,array){ return index===array.indexOf(ele)})7.怎么实现草稿，多终端同步，以及冲突问题？这个回答的不算好，本来也想到类比git的处理方式，但是说的时候往另外一个方面说了，导致与面试官想要的结果不一样。 最后说目前的工作经验达不到P6水平，业务类稍弱，阿里现在社招只要P6的高级工程师，但是可以以第二梯队进去，就是以第三方签署就业协议，一年后可以转正，就是俗称的外包。多少还是有点遗憾，面了四轮面了个外包，最后放弃这份工作了。 最后，感谢boss一直以来的关照和器重。 学习前端的同学们，欢迎加入前端学习交流群 前端学习交流QQ群：461593224","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/05-BAT爱考的JS面试题","date":"2021-08-06T01:17:26.062Z","updated":"2021-07-28T07:34:11.394Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/05-BAT爱考的JS面试题/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/05-BAT%E7%88%B1%E8%80%83%E7%9A%84JS%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"this 在各个场景下的指向","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/04-变量提升的题目","date":"2021-08-06T01:17:26.060Z","updated":"2021-07-28T07:34:11.394Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/04-变量提升的题目/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/04-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E7%9A%84%E9%A2%98%E7%9B%AE/","excerpt":"","text":"变量提升先说三句总结性的话： let 的「创建」过程被提升了，但是初始化没有提升。 var 的「创建」和「初始化」都被提升了。 function 的「创建」「初始化」和「赋值」都被提升了。 变量提升的规律在进入一个执行上下文后，先把 var 和 function 声明的变量前置，再去顺序执行代码。 PS：作用域分为全局作用域和函数作用域，用var声明的变量，只在自己所在的所用域有效。 我们举例来看看下面的代码。 代码 1： 1234567console.log(fn);var fn = 1;function fn() &#123;&#125;console.log(fn); 相当于： 12345678var fn = undefined;function fn() &#123;&#125;console.log(fn);fn = 1;console.log(fn); 打印结果： 代码 2： 1234console.log(i);for (var i = 0; i &lt; 3; i++) &#123; console.log(i)&#125; 相当于： 123456var i = undefined;console.log(i);for (i = 0; i &lt; 3; i++) &#123; console.log(i);&#125; 打印结果： 代码 3： 1234567891011var a = 1;function fn() &#123; a = 2; console.log(a) var a = 3; console.log(a)&#125;fn();console.log(a); 相当于： 1234567891011121314var a = undefined;function fn() &#123; var a a = 2 console.log(a) a = 3 console.log(a)&#125;;a = 1;fn();console.log(a); 打印结果： 参考链接：https://github.com/jirengu/javascript-tutorial 声明时的重名问题假设a被声明为变量，紧接着a又被声明为函数，原则是：声明会被覆盖（先来后到，就近原则）。 PS： 如果a已经有值，再用 var 声明是无效的。 如果a已经有值，紧接着又被赋值，则赋值会被覆盖。 举例1： 1234567var fn; //fn被声明为变量function fn() &#123;// fn被声明为function，就近原则&#125;console.log(fn); //打印结果：function fn()&#123;&#125; 举例2： 12345function fn() &#123;&#125; //fn被声明为function，且此时fn已经被赋值，这个值就是function的对象var fn; //fn已经在上一行被声明且已经有值， 再 var 无效，并不会重置为 undefinedconsole.log(fn) //打印结果：function fn()&#123;&#125; 既然再var无效，但是再function，是有效的： 1234567function fn() &#123;&#125; //fn被声明为function，且此时fn已经有值，这个值就是function的对象function fn() &#123; //此时fn被重复赋值，会覆盖上一行的值 console.log(&#x27;smyhvae&#x27;);&#125;console.log(fn) 打印结果： 函数作用域中的变量提升（两点提醒）提醒1： 在函数作用域也有声明提前的特性： 使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 因此，在函数中，没有var声明的变量都会成为全局变量，而且并不会提前声明。 举例1： 12345678910var a = 1;function foo() &#123; console.log(a); a = 2; // 此处的a相当于window.a&#125;foo();console.log(a); //打印结果是2 上方代码中，foo()的打印结果是1。如果去掉第一行代码，打印结果是Uncaught ReferenceError: a is not defined 提醒2：定义形参就相当于在函数作用域中声明了变量。 1234567function fun6(e) &#123; console.log(e);&#125;fun6(); //打印结果为 undefinedfun6(123);//打印结果为123 其他题目20180321面试题： 1234567var a = 1;if (a &gt; 0) &#123; console.log(a); var a = 2;&#125;console.log(a); 打印结果： 12312 上方代码中，不存在块级作用域的概念。if语句中用var定义的变量，让然是全局变量。 顺便延伸一下，用let定义的变量，是在块级作用域内有效。 12 12 12 12 12","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/03-JS相关","date":"2021-08-06T01:17:26.058Z","updated":"2021-07-28T07:34:11.393Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/03-JS相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/03-JS%E7%9B%B8%E5%85%B3/","excerpt":"","text":"JS 有哪些数据类型 基本数据类型：string number bool undefined null 引用数据类型：object、symbol。 另外，object 包括：数组、函数、正则、日期等对象。NaN属于number类型。 注意，数据类型里，没有数组。因为数组属于object（一旦说数组、函数、正则、日期、NaN是数据类型，直接0分）。 Promise 怎么使用then： 1$.ajax(...).then(成功函数, 失败函数) 链式 then： 1$.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2) 如何自己生成 Promise 对象： 12345678function xxx()&#123; return new Promise(function(resolve, reject)&#123; setTimeout(()=&gt;&#123; resolve() 或者 reject() &#125;,3000) &#125;) &#125; xxx().then(...) ajax手写123456789let xhr = new XMLHttpRequest(); xhr.open(&#x27;POST&#x27;, &#x27;/xxxx&#x27;); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; console.log(xhr.responseText) &#125; &#125; xhr.send(&#x27;a=1&amp;b=2&#x27;); 闭包是什么123456789101112131415function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2;&#125;var f = fn1(); //执行外部函数fn1，返回的是内部函数fn2f() // 3 //执行fn2f() // 4 //再次执行fn2console.log(a); // 会报错：a is not defined 参考链接： JS 中的闭包是什么？ 这段代码里的 this 是什么？1、fn() 里面的 this 就是 window 2、fn() 是 strict mode，this 就是 undefined 3、a.b.c.fn() 里面的 this 就是 a.b.c 4、new F() 里面的 this 就是新生成的实例 5、() =&gt; console.log(this) ，这个this指的是外面的 this。 参考链接： this 的值到底是什么？ 什么是立即执行函数？作用是？立即执行函数： （1）声明一个匿名函数，（2）马上调用这个匿名函数。如下： 12345(function(a, b) &#123; var name; //声明一个局部变量 console.log(&quot;a = &quot; + a); console.log(&quot;b = &quot; + b);&#125;)(123, 456); 作用：创建一个独立的作用域，防止污染全局变量。 因为我们只能通过函数的形式声明一个局部变量。当有了ES6之后，我们可以通过let来定义一个局部变量： 123&#123; let name&#125; 上面这段代码，就相当于立即执行函数。有了let，立即执行函数就毫无意义。 参考链接： ES6 新特性async/await 语法了解吗？目的是什么？目的：把异步代码写成同步代码的形式。 我们知道，promise是这样写的： 123456789101112131415161718192021222324let promise = new Promise((resolve, reject) =&gt; &#123; //进来之后，状态为pending console.log(&#x27;111&#x27;); //这一行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) &#123; console.log(&#x27;333&#x27;); resolve();//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled &#125; else &#123; reject();//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected &#125;&#125;)console.log(&#x27;222&#x27;);//调用promise的then()promise.then(() =&gt; &#123; //如果promise的状态为fullfilled，则执行这里的代码 console.log(&#x27;成功了&#x27;); &#125; , () =&gt; &#123; //如果promise的状态为rejected，则执行这里的代码 console.log(&#x27;失败了&#x27;); &#125;) 有了await之后，可以直接替换掉then。如下： 123456789101112131415function returnPromise()&#123; return new Promise( function(resolve, reject)&#123; setTimeout(()=&gt;&#123; resolve(&#x27;success&#x27;) &#125;,3000) &#125;)&#125;returnPromise().then((result)=&gt;&#123; result === &#x27;success&#x27;&#125;)var result = await returnPromise()result === &#x27;success&#x27; 如何实现深拷贝方式一：JSON 来深拷贝12var a = &#123;...&#125;;var b = JSON.parse(JSON.stringify(a)); //先将对象转成json字符串，然后再转成对象 缺点：JSON 不支持函数、引用、undefined、RegExp、Date…… 方式二：递归拷贝123456789101112131415161718function clone(object)&#123; var object2 if(! (object instanceof Object) )&#123; return object &#125;else if(object instanceof Array)&#123; object2 = [] &#125;else if(object instanceof Function)&#123; object2 = eval(object.toString()) &#125;else if(object instanceof Object)&#123; object2 = &#123;&#125; &#125; 你也可以把 Array Function Object 都当做 Object 来看待，参考 https://juejin.im/post/587dab348d6d810058d87a0a for(let key in object)&#123; object2[key] = clone(object[key]) &#125; return object2&#125; 如何实现数组去重方式1：计数排序的逻辑（只能针对正整数）123456789101112var a = [4,2,5,6,3,4,5]var hashTab = &#123;&#125;for(let i=0; i&lt;a.length;i++)&#123; if(a[i] in hashTab)&#123; // 什么也不做 &#125;else&#123; hashTab[ a[i] ] = true &#125;&#125;//hashTab: &#123;4: true, 2: true, 5: true, 6:true, 3: true&#125;console.log(Object.keys(hashTab)) // [&#x27;4&#x27;,&#x27;2&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;3&#x27;] 方式二：set1Array.from(new Set(a)); ###方式三 如何用正则实现 string.trim()123function trim(string) &#123; return string.replace(/^\\s+|\\s+$/g, &#x27;&#x27;)&#125; JS 原型是什么？参考链接： 什么是 JS 原型链？ ES 6 中的 class 了解吗？参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes 如何实现继承 构造函数 原型链 extends 12 12 12 12","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/03-http","date":"2021-08-06T01:17:26.057Z","updated":"2021-07-28T07:34:11.394Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/03-http/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/03-http/","excerpt":"","text":"HTTP 状态码知道哪些？301 和 302 的区别： 301 永久重定向，浏览器会记住（有缓存） 302 临时重定向（无缓存） HTTP 缓存怎么做？强缓存： Expires或Cache-Control 协商缓存： 第一对：Last-Modified、If-Modified-Since 第二对：ETag、If-None-Match Cookie 是什么？Session 是什么？Cookie HTTP响应通过 Set-Cookie 设置 Cookie 浏览器访问指定域名是必须带上 Cookie 作为 Request Header Cookie 一般用来记录用户信息 Session Session 是服务器端的内存（数据） session 一般通过在 Cookie 里记录 SessionID 实现 SessionID 一般是随机数 LocalStorage 和 Cookie 的区别是什么？ Cookie 会随请求被发到服务器上，而 LocalStorage 不会 Cookie 大小一般4k以下，LocalStorage 一般5Mb 左右 GET 和 POST 的区别是什么？GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 需要注意的是，web 中的 get/post 只是 http 中的 get/post 的子集。http 中的 get 与 post 只是单纯的名字上的区别，get 请求的数据也可以放在 request body 中，只是浏览器没有实现它，但是 get 并不只是在 web 中使用 参考链接： http://www.cnblogs.com/zichi/p/5229108.html https://zhuanlan.zhihu.com/p/22536382","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/02-HTML和CSS相关","date":"2021-08-06T01:17:26.054Z","updated":"2021-07-28T07:34:11.393Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/02-HTML和CSS相关/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/02-HTML%E5%92%8CCSS%E7%9B%B8%E5%85%B3/","excerpt":"","text":"HTML 相关你是如何理解 HTML 语义化的？语义化：指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。 举例：段落用 p，边栏用 aside，主要内容用 main 标签。 好处： 便于开发者阅读和维护 有利于SEO：让浏览器的爬虫和辅助技术更好的解析， 语义化标签介绍： 在HTML5出来之前，我们习惯于用div来表示页面的章节或者不同模块，但是div本身是没有语义的。但是现在，HTML5中加入了一些语义化标签，来更清晰的表达文档结构。 20180322_1120.jpg 参考链接： 初探 · HTML5语义化 meta viewport 是做什么用的，怎么写？1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 控制页面在移动端不要缩小显示。 canvas 元素是干什么的？看 MDN 的 canvas 入门手册。 说一下CSS盒模型可以参考本人的另外一篇文章：CSS盒模型及BFC css reset 和 Normalize.css 有什么区别 此题考英文。 二者都是用来统一浏览器的默认样式： reset：重置。相对「暴力」，不管你有没有用，统统重置成一样的效果，且影响的范围很大，讲求跨浏览器的一致性。（一刀切） Normalize.css ：标准化。相对「平和」，注重通用的方案，重置掉该重置的样式，保留有用的 user agent 样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。（去伪存真） 参考链接： Normalize.css 与传统的 CSS Reset 有哪些区别？ CSS3初始化代码Normalize.css中文版 谈谈一些有趣的 CSS 话题 前端面试之CSS总结(上) 如何居中（必考）水平居中1、行内元素：（文字、图片等水平居中） 给父亲设置： 12text-align: center; 另外，让文字的行高 等于 盒子的高度，可以让单行文本垂直居中。 2、块级元素：（让标准流中的盒子水平居中） 给元素设置：（让当前元素在父亲里剧中） 12345//方式一 margin: auto;方式二margin: 0 auto; 上面的代码， margin: auto相当于margin: auto auto auto auto。margin: 0 auto相当于margin: 0 auto 0 auto，四个值分别对应上右下左。 垂直方向：根据规范，margin-top: auto 和 margin-bottom: auto，其计算值为0。 水平方向：水平方向的 auto，其计算值取决于可用空间（剩余空间）。 参考链接：https://www.zhihu.com/question/21644198/answer/22392394 垂直居中/水平居中（元素的高度已知）方法：绝对定位 + margin-top 如果盒子是绝对定位的，此时已经脱标了，margin:auto无效。如果还想让其居中（位于父亲的正中间），可以这样做： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .parent &#123; height: 300px; /*高度已知*/ position: relative; border: 1px solid red; &#125; .child &#123; width: 200px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -150px; margin-top: -50px; border: 1px solid green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如上方代码所示，我们先让这个高度为100px的盒子，上边线居中，然后向上移动宽度的一半(50px)，就达到了垂直居中的效果。水平居中的原理类似。 效果： 垂直居中/水平居中（元素的高度未知）方法1：模拟表格法 将父元素设置为display:table，然后将子元素也（就是要垂直居中显示的元素）设置为display:table-cell，然后加上vertical-align:middle来实现。 html代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .parent &#123; display: table; width: 300px; height: 300px; border: 10px solid pink; &#125; .child &#123; display: table-cell; vertical-align: middle; /*来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。*/ height: 200px; /*此处的宽高设置无效*/ width: 200px; border: 10px solid blue; &#125; /*实现的效果：让单元格(.child)里的内容(.content)垂直居中*/ .content &#123; width: 100px; height: 100px; border: 10px solid green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;测试垂直居中效果测试垂直居中效果测试垂直居中效果测试垂直居中效果&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 方式二：绝对定位 + margin:auto 12345.element &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */&#125; 代码两个关键点： 上下左右均0位置定位； margin: auto 方式三：用绝对定位 + translate 位移来做 123456div &#123; background-color: red; position: absolute; 绝对定位的盒子 top: 50%; 首先，让上边线居中 transform: translateY(-50%); 然后，利用translate，往上走自己宽度的一半【推荐写法】&#125; 方式四：flex 布局 12345.parent&#123; display: flex;/*Flex布局*/ display: -webkit-flex; /* Safari */ align-items: center;/*设置子元素在侧轴方向上的布局*/&#125; 参考链接： 七种方式实现垂直居中 margin:auto实现绝对定位元素的水平垂直居中 选择器的优先级如何确定 选择器越具体，优先级越高。 #xxx 大于 .yyy 同样优先级，写在后面的覆盖前面的。 color: red !important; 优先级最高。 BFC 是什么overflow:hidden ：取消父子 margin 合并。 （另一种推荐做法：padding-top: 0.1px;） 如何清除浮动（1）overflow: hidden （2）.clearfix 清除浮动写在爸爸身上 12345678910.clearfix::after &#123; content: &#x27;&#x27;; display: block; clear: both;&#125;/* 兼容 IE */.clearfix &#123; zoom: 1;&#125; 参考链接 互联网公司招聘启事的正确阅读方式","categories":[],"tags":[]},{"title":"","slug":"大前端/15-面试题积累/01-我的面试经历 by smyhvae","date":"2021-08-06T01:17:26.052Z","updated":"2021-07-28T07:34:11.393Z","comments":true,"path":"2021/08/06/大前端/15-面试题积累/01-我的面试经历 by smyhvae/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/15-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/01-%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%20by%20smyhvae/","excerpt":"","text":"20180323什么是闭包，闭包有什么作用。ES6的新特性有哪些。作用域、函数扩展（扩展运算符、默认参数、箭头函数）、异步promise、模块化。 追问：const常量有什么作用？确定不能修改吗？修改之后会报错吗？你有没有试过？当时我的答案是斩钉截铁地说不能改，其实我说错了。后来查了一下，准确答案是： 如果是值类型，值不可变 如果是引用类型，地址不可变 所以说，虽然我不能修改引用类型的指向，但是我可以修改引用类型里的属性值。 参考链接：https://segmentfault.com/q/1010000012836140?sort=created 追问：const的原理是什么？面试官问：如果你定义了const，什么是常量？是它的值还是引用？比如说，我定义了一个const 的array，那我能往里面插入数据吗？ 箭头函数和匿名函数有什么区别吗？箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 普通函数的this指向是动态作用域；箭头函数的this指向是依据词法作用域。 参考链接：https://zhuanlan.zhihu.com/p/25093389 可以讲一下promise的状态吗？追问：如果我写setTimeout（0），再写一个promise，哪个先执行？我回答错了。 正确答案是：任务队列可以有多个，promise的任务队列，优先级更高。具体答案还需要再仔细看看。 http有了解吗？ 可以讲一下它的握手过程吗？ http的缓存有了解吗？ get和post区别 做过CDN吗？答得不具体。 百度百科的解释是：其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 Vue相关 vue的双向绑定怎么实现的？我是说怎么实现？ 我当时是回答MVVM模式。其实还需要答出Object.defineProperty( )的细节，以及虚拟DOM。 Vue里还有什么呢？ 数据驱动、组件化。 事件绑定：onClick和addEventListener的区别说一下DOM里的事件冒泡用Webpack做过哪些功能？追问：ES6转成ES5，改动代码，发现页面自动刷新。你说一下整个流程。问的是webpack 自动刷新的流程。我没回答好。 追问：既然webpack可以用来配置服务器，如果我要联调，怎么办？问：启动了webpack，就可以直接连接到后端吗？ 说一下跨域gzip压缩有了解吗你做过什么项目？说一下？答：我做过电商网站。 追问：遇到过什么问题吗？ 答：我遇到了性能的问题。 追问：那你说一下性能的问题 我就答出了性能相关的五大点。 node和express有了解吗？追问requireJS，是异步的吗？是异步的。 Vue你是怎么用的？是把所有的代码都写在一个页面里的吗答：我是模块化写的。 问：怎么分类？ 追问：vuex的的作用 移动端的触摸事件了解吗？ touchstart touchmove touchend touchcancel（touchcancel当触点由于某些原因被中断时触发） 模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。 移动端的浏览器和电脑浏览器的 touch事件，有区别吗？我说我没了解过。 追问：移动端默认会有0.2秒的延迟。 我后来查了一下： 点击延迟：是指移动端浏览器在 touchend 和 click 之间存在 300ms ～ 350ms 的延迟。 为了判断用户是否是进行双击操作。因为移动端双击是放大文字的手势操作。 主要是从点击屏幕上的元素到触发元素的 click 事件，移动浏览器会有大约 300 毫秒的等待时间。这是因为浏览器想看看你是不是要进行双击（double tap）操作。 解决方法： 将click事件换成touch end事件 FastClick：FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。 事件发生顺序：在移动端，手指点击一个元素，会经过：touchstart –&gt; touchmove -&gt; touchend –》click。 如何自定义事件自定义事件的代码如下： 12345678 var myEvent = new Event(&#x27;clickTest&#x27;); element.addEventListener(&#x27;clickTest&#x27;, function () &#123; console.log(&#x27;smyhvae&#x27;); &#125;);//元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 说一下状态码手机端的web开发，怎么和原生做交互？问：比如web网页，想调用手机的拍照功能，怎么做？再比如怎么分享到朋友圈？ vue的生命周期，有了解吗create和mount有什么区别吗 什么时候执行update","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/z-计算机网络","date":"2021-08-06T01:17:26.047Z","updated":"2021-07-28T07:34:11.392Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/z-计算机网络/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"HTTP最强资料大全","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/z-推荐文章","date":"2021-08-06T01:17:26.045Z","updated":"2021-07-28T07:34:11.392Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/z-推荐文章/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","excerpt":"","text":"征服JavaScript面试系列 | 众城翻译 征服 JavaScript 面试：什么是闭包？ 征服 JavaScript 面试：什么是函数组合 征服JavaScript面试系列：类继承和原型继承的区别 征服 JavaScript 面试：什么是纯函数 征服 JavaScript 面试: 什么是函数式编程？ 征服 JavaScript 面试: 什么是 Promise？","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/z-其他","date":"2021-08-06T01:17:26.043Z","updated":"2021-07-28T07:34:11.392Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/z-其他/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-%E5%85%B6%E4%BB%96/","excerpt":"","text":"前端基础闭包和作用域，面试喜欢问。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/z-web安全","date":"2021-08-06T01:17:26.042Z","updated":"2021-07-28T07:34:11.392Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/z-web安全/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-web%E5%AE%89%E5%85%A8/","excerpt":"","text":"前言攻击的原理也许你能讲出来，主要是想知道如何发现这个网站的漏洞，毕竟大部分的网站都已经把用户输入的内容各种花式过滤了","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/23-面试技巧 by smyhvae","date":"2021-08-06T01:17:26.039Z","updated":"2021-07-28T07:34:11.391Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/23-面试技巧 by smyhvae/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/23-%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%20by%20smyhvae/","excerpt":"","text":"写简历的注意事项 最多可以写“深入了解”，但不要写“精通”。 遇到不知道的问题，该怎么回答 这块儿我没了解过，准备回去看一下。 这块儿我没研究过，您有没有好的资料，我可以补充一下细节。 写不出详细的代码，但是知道思路。 项目经历 面试要体现项目的设计思路、方案设计等 模块化思维（1）模块化设计的关键词：封装、继承；把通用的模块先抽象，后具体，达到复用。【面试记住】 比如，panel、按钮、轮播图、列表等等，都可以提取为抽象的组件，复用。 （2）页面有哪几个模块 （3）每个模块分成不同的文件，然后在index页面中import。 ES6新特性 let、const 函数扩展：参数默认值、箭头函数、扩展运算符... for … of 循环 map 模块化 薪资面试官；”你要求多少薪资？” 我：“能给个范围吗？”","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/22-网友面经","date":"2021-08-06T01:17:26.037Z","updated":"2021-07-28T07:34:11.391Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/22-网友面经/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/22-%E7%BD%91%E5%8F%8B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"2018-03-08 jawil | 一年经验初探阿里巴巴前端社招 此博主的博客签名： 20180308_1703.png 2017我遇到的前端面试题 作者整理的这些题目，很多是来自面试跳槽的视频。非常推荐。 作者说，性能优化和ES6，是必问的。 2018年web前端经典面试题及答案 写得很长啊。 2018-03-11 2017年BAT面试题大全集 bat前端面试内容记录 2018-03-18 笔记：阿里、网易、滴滴共十次前端面试碰到的问题 笔记补充：阿里、网易、滴滴共十次前端面试碰到的问题","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/21-面试题整理 by smyhvae","date":"2021-08-06T01:17:26.035Z","updated":"2021-07-28T07:34:11.391Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/21-面试题整理 by smyhvae/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/21-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%20by%20smyhvae/","excerpt":"","text":"JavaScript存储相关：请描述以下cookie、localStorage、sessionStorage的区别 在H5之前，cookie一直都是本地存储的一个重要的方法。直到后面的两个出现了， 就开始用后面的两个做本地存储。 1、cookie： 本身用于客户端和服务器端的通信。 但是它有本地存储的功能，于是就被“借用”。 我们可以通过document.cookie获取和修改cookie，获取到的其实就是一个字符串。 cookie用于存储时的缺点： 存储量太小，只有4kb 所有http请求都带着，会影响获取资源的效率 api简单，需要封装才能用。document.cookie = ... HTML5HTML5新增了哪些内容或API？使用过哪些？新元素： &lt;section&gt;、&lt;footer&gt; 和 &lt;header&gt;等 新的api： 网络存储: sessionStorage 和 localStorage 参考链接： 笔记：阿里、网易、滴滴共十次前端面试碰到的问题 CSS如何让一个div元素隐藏？你能想到的方式有几种？- ES6for each、for in、for of的区别 foreach用于遍历数组，是数组的一个方法。不支持 return。 for ... in获取的对象是index索引值。 for ... of获取的是对象里的值。 网络相关浏览器输入url到显示内容，有哪些过程（1）浏览器解析url。包括：协议、域名、端口号、资源路径、参数查询 （2）DNS解析 （3）TCP握手 （4）HTTP请求 （5）服务器处理请求 （6）浏览器渲染：DOM tree、CSS rule tree、render tree。 （7）display 参考链接： 笔记：阿里、网易、滴滴共十次前端面试碰到的问题 what-happens-when-zh_CN 码农翻身 | 小白科普：从输入网址到最后浏览器呈现页面内容，中间发生了什么？ 从输入URL到页面加载发生了什么：https://segmentfault.com/a/1190000006879700 GitHub [荐]面试题和答案：https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers 面试题和答案：https://github.com/qiu-deqing/FE-interview 有个题是，浏览器输入url，有哪些过程 讲到了Cookie和session 这个也很全：https://github.com/gnipbao/Front-end-Interview-questions https://github.com/giscafer/front-end-manual/issues/3 按时间排列2018-03-11 web前端面试题汇总：https://www.jianshu.com/p/2f7eb1ad7174 2017前端面试题及答案总结：https://yeaseonzhang.github.io/2017/09/17/2017%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93/ 2018-03-12-今日头条面试题 今日头条一面笔试面试题！！！！！完整","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/16-01.MVVM","date":"2021-08-06T01:17:26.034Z","updated":"2021-07-28T07:34:11.391Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/16-01.MVVM/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/16-01.MVVM/","excerpt":"","text":"前言MVVM的常见问题： 如何理解MVVM 如何实现MVVM 是否解读过Vue的源码 题目： 说一下使用 jQuery 和使用框架的区别 说一下对 MVVM 的理解 vue 中如何实现响应式 vue 中如何解析模板 vue 的整个实现流程 说一下使用 jQuery 和使用框架的区别MVVM / VueMVVM模式 Model：负责数据存储 View：负责页面展示 View Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示 数据驱动视图，只关心数据变化，DOM操作被封装。 MVVM / Vue的三要素 响应式：vue 如何监听到 data 的每个属性变化？ 模板引擎：vue 的模板如何被解析，指令如何处理？ 渲染：vue 的模板如何被渲染成 html ？以及渲染过程 什么是虚拟 DOM传统的web开发，是利用 jQuery操作DOM，这是非常耗资源的。 我们可以在 JS 的内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析，一次性插入到html里去。这就形成了虚拟 DOM。 Vue1.0没有虚拟DOM，Vue2.0改成了基于虚拟DOM。 如何理解MVCC指的是Controller。控制器能够控制视图的变化，也能控制数据的变化。 单项通信。一般情况下是：view 发出命令给控制器，控制器处理业务逻辑后控制 Model，Model再去改 view。 hybrid使用场景不是所有的场景都适合用 hybrid： 使用原生应用：体验要求极致，变化不频繁（如头条的首页） 使用 hybrid：体验要求高，变化频繁（如新闻详情页） 使用H5：体验无要求、不常用（比举报、反馈等）","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/15-虚拟DOM","date":"2021-08-06T01:17:26.032Z","updated":"2021-07-28T07:34:11.390Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/15-虚拟DOM/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/15-%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"前言vdom 是 vue 和 React 的核心，先讲哪个都绕不开它。 vdom 比较独立，使用也比较简单。 如果面试问到 vue 和 React 和实现，免不了问 vdom： vdom 是什么？为何会存在 vdom？ vdom 的如何应用，核心 API 是什么 介绍一下 diff 算法 什么是 vdom什么是 vdomDOM操作是昂贵的。 步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/11-02.ES6","date":"2021-08-06T01:17:26.030Z","updated":"2021-07-28T07:34:11.390Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/11-02.ES6/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11-02.ES6/","excerpt":"","text":"Class和普通构造函数有何区别 我们经常会用ES6中的Class来代替JS中的构造函数做开发。 Class 在语法上更加贴合面向对象的写法 Class 实现继承更加易读、易理解 更易于写 java 等后端语言的使用 本质还是语法糖，使用 prototype","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/11-01.ES6：模块化的使用和编译环境","date":"2021-08-06T01:17:26.028Z","updated":"2021-07-28T07:34:11.390Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/11-01.ES6：模块化的使用和编译环境/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11-01.ES6%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言ES6的主要内容 模块化的使用和编译环境 Class与JS构造函数的区别 Promise的用法 ES6其他常用功能 本文来讲“模块化的使用和编译环境”。 面试常见问题 ES6 模块化如何使用，开发环境如何打包 Class 和普通构造函数有何区别 Promise 的基本使用和原理 总结一下 ES6 其他常用功能 ES6的现状 开发环境已经普及使用 浏览器环境却支持不好（需要开发环境编译） 内容很多，重点了解常用语法 面试：开发环境的使用 + 重点语法的掌握 模块化的基本语法（1）util1.js： 12345export default var a = 100;export function foo &#123; console.log(&#x27;util1-foo&#x27;);&#125; export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出。 有了默认输出之后，其他模块加载该模块时，import命令可以为该匿名变量/函数，起任意的名字。 上面的代码中，默认输出是一个变量。当然，我们也可以换成默认输出一个匿名函数： 123export default function() &#123; console.log(&#x27;util1-function&#x27;);&#125; （2）util2.js： 12345678910export var myUtil2 = &#x27;this is util2&#x27;;export function fn1() &#123; console.log(&#x27;util2-fn1&#x27;);&#125;export function fn2() &#123; console.log(&#x27;util2-fn2&#x27;);&#125; 上方代码中，我把一个变量和两个函数作为了导出。 （3）index.js：","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/11-00.JavaScript高级面试：前言","date":"2021-08-06T01:17:26.026Z","updated":"2021-07-28T07:34:11.389Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/11-00.JavaScript高级面试：前言/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11-00.JavaScript%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%89%8D%E8%A8%80/","excerpt":"","text":"前言一、基础知识： ES 6常用语法：class 、module、Promise等 原型高级应用：结合 jQuery 和 zepto 源码 异步全面讲解：从原理到 jQuery 再到 Promise 二、框架原理： 虚拟DOM：存在价值、如何使用、diff算法 MVVM vue：MVVM、vue响应式、模板解析、渲染 组件化 React：组件化、JSX、vdom、setState 三、混合开发： hybrid H5 前端客户端通讯 内容优势 面试官爱问“源码”、“实现”。 介绍常用框架实现原理 介绍hybrid原理和应用 ES6 模块化的使用和编译环境 Class与JS构造函数的区别 Promise的用法 ES6其他常用功能 异步 什么是单线程，和异步有什么关系","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/10-02.前端错误监控","date":"2021-08-06T01:17:26.023Z","updated":"2021-07-28T07:34:11.389Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/10-02.前端错误监控/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/10-02.%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/","excerpt":"","text":"前言错误监控包含的内容是： 前端错误的分类 每种错误的捕获方式 上报错误的基本原理 面试时，可能有两种问法： 如何监测 js 错误？（开门见山的方式） 如何保证产品质量？（其实问的也是错误监控） 前端错误的分类包括两种： 即时运行错误（代码错误） 资源加载错误 每种错误的捕获方式即时运行错误的捕获方式方式1：try … catch。 这种方式要部署在代码中。 方式2：window.onerror函数。这个函数是全局的。 1window.onerror = function(msg, url, row, col, error) &#123; ... &#125; 参数解释： msg为异常基本信息 source为发生异常Javascript文件的url row为发生错误的行号 方式二中的window.onerror是属于DOM0的写法，我们也可以用DOM2的写法：window.addEventListener(&quot;error&quot;, fn);也可以。 问题延伸1： window.onerror默认无法捕获跨域的js运行错误。捕获出来的信息如下：（基本属于无效信息） 比如说，我们的代码想引入B网站的b.js文件，怎么捕获它的异常呢？ 解决办法：在方法二的基础之上，做如下操作： （1）在b.js文件里，加入如下 response header，表示允许跨域：（或者世界给静态资源b.js加这个 response header） 1Access-Control-Allow-Origin: * （2）引入第三方的文件b.js时，在&lt;script&gt;标签中增加crossorigin属性； 参考链接： window.onerror的总结 前端代码异常日志收集与监控 捕获页面中全局Javascript异常 问题延伸2： 只靠方式二中的window.onerror是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把堆栈信息作为msg打印出来，堆栈里很详细。 资源加载错误的捕获方式上面的window.onerror只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，object.onerror捕获后就会终止（不会冒泡给window），所以window.onerror并不能捕获资源加载错误。 方式1：object.onerror。img标签、script标签等节点都可以添加onerror事件，用来捕获资源加载的错误。 方式2：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。 举例： 浏览器打开一个网站，在Console控制台下，输入： 1performance.getEntries().forEach(function(item)&#123;console.log(item.name)&#125;) 或者输入： 1performance.getEntries().forEach(item=&gt;&#123;console.log(item.name)&#125;) 上面这个api，返回的是数组，既然是数组，就可以用forEach遍历。打印出来的资源就是已经成功加载的资源。； 再输入document.getElementsByTagName(&#39;img&#39;)，就会显示出所有需要加载的的img集合。 于是，document.getElementsByTagName(&#39;img&#39;)获取的资源数组减去通过performance.getEntries()获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。 这种方式非常有用，一定要记住。 方式3；Error事件捕获。 源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如： 总结：如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。 参考链接： 前端错误监控原理与实战 （作者的这篇文章参考了面试内容） 错误上报的两种方式方式一：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式） 方式二：利用Image对象上报（推荐。网站的监控体系都是采用的这种方式） 方式二的实现方式如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //通过Image对象进行错误上报 (new Image()).src = &#x27;http://smyhvae.com/myPath?badjs=msg&#x27;; // myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开浏览器，效果如下： 上图中，红色那一栏表明，我的请求已经发出去了。点进去看看： 这种方式，不需要借助第三方的库，一行代码即可搞定。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/10-01.页面性能优化","date":"2021-08-06T01:17:26.021Z","updated":"2021-07-28T07:34:11.389Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/10-01.页面性能优化/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/10-01.%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言提升页面性能优化的方法有哪些： 1、资源压缩合并，减少http请求 2、非核心代码异步加载 –&gt; 异步加载的方式 –&gt; 异步加载的区别 如果回答出非核心代码异步加载，就会层层深入。 3、利用浏览器缓存 –&gt; 缓存的分类 –&gt; 缓存的原理 缓存是所有性能优化的方式中最重要的一步，这个一定要答好。【重要】 有的人可能会回答local storage 和session storage，其实不是这个。浏览器缓存和存储不是一回事。 4、使用CDN 浏览器第一次打开页面时，缓存是起不了作用的。CDN这一条，一定要说出来。 5、DNS预解析 一、资源压缩合并，减少http请求 合并图片（css sprites）、CSS和JS文件合并、CSS和JS文件压缩 图片较多的页面也可以使用 lazyLoad 等技术进行优化。 精灵图等 二、非核心代码异步加载异步加载的方式：（这里不说框架，只说原理） 动态脚本加载 defer async 动态脚本加载使用document.createElement创建一个script标签，即document.createElement(&#39;script&#39;)，然后把这个标签加载到body上面去。 参考链接： javascript 异步加载 动态脚本加载的那部分代码，看不太懂。 defer通过异步的方式加载defer1.js文件： 1&lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt; async HTmL5新增特性。 通过异步的方式加载async1.js文件： 1&lt;script src=&quot;./async1.js&quot; async&gt;&lt;/script&gt; defer和async的区别 defer：在HTML解析完之后才会执行。如果是多个，则按照加载的顺序依次执行。 async：在加载完之后立即执行。如果是多个，执行顺序和加载顺序无关。 代码举例： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--通过异步的方式引入两个外部的js文件--&gt; &lt;script src=&quot;./defer1.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;./defer2.js&quot; defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log(&#x27;同步任务&#x27;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方打印的结果是： 123同步任务defer1defer2 因为defer的加载是有顺序的，所以两个引入defer文件按顺序执行。如果把引入的文件改为async的方式加载，打印的结果可能是： 123同步任务async2async1 参考链接： 浅谈script标签的defer和async 三、利用浏览器缓存缓存：资源文件（比如图片）在本地的硬盘里存有副本，浏览器下次请求的时候，可能直接从本地磁盘里读取，而不会重新请求图片的url。 缓存分为： 强缓存 协商缓存 强缓存强缓存：不用请求服务器，直接使用本地的缓存。 强缓存是利用 http 响应头中的**Expires或Cache-Control**实现的。【重要】 浏览器第一次请求一个资源时，服务器在返回该资源的同时，会把上面这两个属性放在response header中。比如： 注意：这两个response header属性可以只启用一个，也可以同时启用。当response header中，Expires和Cache-Control同时存在时，Cache-Control的优先级高于Expires。 下面讲一下二者的区别。 1、Expires：服务器返回的绝对时间。 是较老的强缓存管理 response header。浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires的时间之前，就能命中缓存，否则就不行。 如果缓存没有命中，浏览器直接从服务器请求资源时，Expires Header在重新请求的时候会被更新。 缺点： 由于Expires是服务器返回的一个绝对时间，存在的问题是：服务器的事件和客户端的事件可能不一致。在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改客户端时间，就能影响缓存命中的结果。所以，在http1.1中，提出了一个新的response header，就是Cache-Control。 2、Cache-Control：服务器返回的相对时间。 http1.1中新增的 response header。浏览器第一次请求资源之后，在接下来的相对时间之内，都可以利用本地缓存。超出这个时间之后，则不能命中缓存。重新请求时，Cache-Control会被更新。 协商缓存协商缓存：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。 当浏览器对某个资源的请求没有命中强缓存（也就是说超出时间了），就会发一个请求到服务器，验证协商缓存是否命中。 协商缓存是利用的是两对Header： 第一对：Last-Modified、If-Modified-Since 第二对：ETag、If-None-Match ETag（Entity Tag）：被请求变量的实体值”。 **1、Last-Modified、If-Modified-Since**。过程如下： （1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上Last-Modified这个 response header，这个header表示这该资源在服务器上的最后修改时间： （2）浏览器再次请求这个资源时，会加上If-Modified-Since这个 request header，这个header的值就是上一次返回的Last-Modified的值： （3）服务器收到第二次请求时，会比对浏览器传过来的If-Modified-Since和资源在服务器上的最后修改时间Last-Modified，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，服务器不会返回 Last-Modified 这个 response header）；如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response header： （4）浏览器如果收到304的响应，就会从缓存中加载资源。 缺点： Last-Modified、If-Modified-Since一般来说都是非常可靠的，但面临的问题是： 服务器上的资源变化了，但是最后的修改时间却没有变化。 如果服务器端在一秒内修改文件两次，但产生的Last-Modified却只有一个值。 这一对header就无法解决这种情况。于是，下面这一对header出场了。 **2、ETag、If-None-Match**。过程如下： （1）浏览器第一次请求一个资源，服务器在返回这个资源的同时，会加上ETag这个 response header，这个header是服务器根据当前请求的资源生成的唯一标识。这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间无关，所以也就很好地补充了Last-Modified的不足。如下： （2）浏览器再次请求这个资源时，会加上If-None-Match这个 request header，这个header的值就是上一次返回的ETag的值： 3）服务器第二次请求时，会对比浏览器传过来的If-None-Match和服务器重新生成的一个新的ETag，判断资源是否有变化。如果没有变化则返回304 Not Modified，但不返回资源内容（此时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag并无变化）。如果有变化，就正常返回资源内容（继续重复整个流程）。这是服务器返回304时的response header： （4）浏览器如果收到304的响应，就会从缓存中加载资源。 提示：如果面试官问你：与浏览器缓存相关的http header有哪些？你能写出来吗？这是一个亮点。 参考链接： 浏览器缓存知识小结及应用[荐] 四、使用CDN怎么最快地让用户请求资源。一方面是让资源在传输的过程中变小，另外就是CDN。 要注意，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的，使用CDN，效果就很明显。 五、DNS预解析（dns-prefetch）通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。 第一步：打开或关闭DNS预解析 你可以通过在服务器端发送 X-DNS-Prefetch-Control 报头。或是在文档中使用值为 http-equiv 的meta标签： 1&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; 需要说明的是，在一些高级浏览器中，页面中所有的超链接（&lt;a&gt;标签），默认打开了DNS预解析。但是，如果页面中采用的https协议，很多浏览器是默认关闭了超链接的DNS预解析。如果加了上面这行代码，则表明强制打开浏览器的预解析。（如果你能在面试中把这句话说出来，则一定是你出彩的地方） 第二步：对指定的域名进行DNS预解析 如果我们将来可能从 smyhvae.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容： 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.smyhvae.com/&quot;&gt; 当我们从该 URL 请求一个资源时，就不再需要等待 DNS 解析的过程。该技术对使用第三方资源特别有用。 参考链接： 前端性能优化 - 资源预加载[荐] DNS预解析详解 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/09-02.js运行机制：异步和单线程","date":"2021-08-06T01:17:26.019Z","updated":"2021-07-28T07:34:11.389Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/09-02.js运行机制：异步和单线程/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/09-02.js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"前言面试时，关于同步和异步，可能会问以下问题： 同步和异步的区别是什么？分别举一个同步和异步的例子 一个关于 setTimeout 的笔试题 前端使用异步的场景哪些？ 面试时，关于js运行机制，需要注意以下几个问题： 如何理解JS的单线程 什么是任务队列 什么是 EventLoop 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 JS的异步和单线程 因为是单线程，所以必须异步。 我们通过题目来解释以下。 题目一：异步现有如下代码： 1234567console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 1000);console.log(3);console.log(4); 上面的代码中，我们很容易知道，打印的顺序是1，3，4，2。因为你会想到，要等一秒之后再打印2。 可如果我把延时的时间从1000改成0： 123456console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 0);console.log(3);console.log(4); 上方代码中，打印的顺序仍然是1，3，4，2。这是为什么呢？我们来分析一下。 总结： js 是单线程（同一时间只能做一件事），而且有一个任务队列：全部的同步任务执行完毕后，再来执行异步任务。第一行代码和最后一行代码是同步任务；但是，**setTimeout是异步任务**。 于是，执行的顺序是： 先执行同步任务console.log(1) 遇到异步任务setTimeout，要挂起 执行同步任务console.log(3) 全部的同步任务执行完毕后，再来执行异步任务console.log(2)。 很多人会把这个题目答错，这是因为他们不懂 js 的运行机制。 注意上面那句话：同步任务执行完毕后，再来执行异步任务。也就是说，如果同步任务没有执行完，异步任务是不会执行的。为了解释这句话，我们来看下面这个例子。 题目二：异步现有如下代码： 12345console.log(&#x27;A&#x27;);while (1) &#123;&#125;console.log(&#x27;B&#x27;); 我们很容易想到，上方代码的打印结果是A，因为while是同步任务，代码会陷入死循环里出不来，自然也就无法打印B。可如果我把代码改成下面的样子： 12345678910console.log(&#x27;A&#x27;);setTimeout(function () &#123; console.log(&#x27;B&#x27;);&#125;)while (1) &#123;&#125; 上方代码的打印结果仍然是A。因为while是同步任务，setTimeout是异步任务，所以还是那句话：如果同步任务没有执行完，队列里的异步任务是不会执行的。 题目三：同步123456console.log(&#x27;A&#x27;);alert(&#x27;haha&#x27;); //1秒之后点击确认console.log(&#x27;B&#x27;); alert函数是同步任务，我只有点击了确认，才会继续打印B。 同步和异步的对比我们在上面列举了异步和同步的例子。现在来描述一下区别：【重要】 因为setTimeout是异步任务，所以程序并不会卡在那里，而是继续向下执行（即使settimeout设置了倒计时一万秒）；但是alert函数是同步任务，程序会卡在那里，如果它没有执行，后面的也不会执行（卡在那里，自然也就造成了阻塞）。 前端使用异步的场景什么时候需要等待，就什么时候用异步。 定时任务：setTimeout（定时炸弹）、setInterval（循环执行） 网络请求：ajax请求、动态&lt;img&gt;加载 事件绑定（比如说，按钮绑定点击事件之后，用户爱点不点。我们不可能卡在按钮那里，什么都不做。所以，应该用异步） ES6中的Promise 代码举例： 1234567console.log(&#x27;start&#x27;);var img = document.createElement(&#x27;img&#x27;);img.onload = function () &#123; console.log(&#x27;loaded&#x27;);&#125;img.src = &#x27;/xxx.png&#x27;;console.log(&#x27;end&#x27;); 上图中，先打印start，然后执行img.src = &#39;/xxx.png&#39;，然后打印end，最后打印loaded。 任务队列和Event Loop（事件循环）任务队列所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 总结：只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。【重要】 Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 在理解Event Loop时，要理解两句话： 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 容易答错的题目12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000);&#125; 很多人以为上面的题目，答案是0,1,2,3。其实，正确的答案是：3,3,3,3。 分析：for 循环是同步任务，setTimeout是异步任务。for循环每次遍历的时候，遇到settimeout，就先暂留着，等同步任务全部执行完毕（此时，i已经等于3了），再执行异步任务。 我们把上面的题目再加一行代码。最终代码如下： 123456for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000);&#125;console.log(i); 如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？可能会有两种答案： A. 60% 的人会描述为：3 -&gt; 3 -&gt; 3 -&gt; 3，即每个 3 之间都有 1 秒的时间间隔； B. 40% 的人会描述为：3 -&gt; 3,3,3，即第 1 个 3 直接输出，1 秒之后，连续输出 3 个 3。 循环执行过程中，几乎同时设置了 3 个定时器，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B。 上面这个题目的参考链接： 80% 应聘者都不及格的 JS 面试题 深入浅出Javascript事件循环机制(上)","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/09-01.浏览器渲染机制","date":"2021-08-06T01:17:26.017Z","updated":"2021-07-28T07:34:11.388Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/09-01.浏览器渲染机制/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/09-01.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/","excerpt":"","text":"前言 接下来的几篇文章，讲一下二面的内容。 二面的内容： 渲染机制 JS 运行机制 页面性能 错误监控 本文接下来讲渲染机制。 渲染机制包括的内容： 什么是DOCTYPE及作用 浏览器渲染过程 面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。 Reflow：重排 面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。 Repaint：重绘 Layout：布局 这里的Layout指的是浏览器的Layout。 什么是DOCTYPE及作用定义DTD（Document Type Definition）：文档类型定义。 是一系列的语法规则，用来定义XML或者(X)HTML文件类型。浏览器会使用DTD来判断文本类型，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我） DOCTYPE：用来声明DTD规范。 一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的） 常见的DOCTYPE声明有几种 面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。 1、HTML 4.01 Strict：（严格的） 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。 2、HTML 4.01 Transitional：（传统的） 12&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。 3、HTML 5： 1&lt;!DOCTYPE html&gt; 总结： 面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。 面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是&lt;!DOCTYPE html&gt;。 浏览器的渲染过程浏览器的渲染过程非常复杂，但是面试只用说几句话就行了，不然太耗时间。如何快速简洁地描述清楚，是关键。 这里先解释一下几个概念，方便大家理解： DOM Tree：浏览器将HTML解析成树形的数据结构（DOM 树）。 CSS Rule Tree：浏览器将CSS解析成树形的数据结构。 Render Tree: DOM和CSSOM合并后生成Render Tree。（虽然有了Render Tree，但并不知道节点的位置，需要依靠接下来的layout） layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置(宽高、颜色等)。 painting：按照算出来的规则，通过显卡，把内容画到屏幕上。 display：打击看到的最终效果。 参考链接： 浏览器渲染原理及流程[荐] Reflow：重排定义重排 Reflow：DOM结果中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放在它该出现的位置，这个过程称之为Reflow。 什么时候触发 Reflow 增加、删除、修改DOM节点时，会导致 Reflow 或 Repaint。 移动DOM的位置，或是加个动画的时候 修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的） 当用户Resize窗口时（移动端没有这个问题），或是滚动的时候，有可能会触发（具体要看浏览器的规则）。 修改网页的默认字体时（这个影响非常严重）。 面试总结： 首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你怎么避免reflow，这个自己去查查吧。 Repaint：重绘定义Repaint重绘制：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为 Repaint。 说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。 什么时候触发 Repaint DOM改动 CSS改动 其实，就是判断当前呈现的内容是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。 面试总结： 面试官经常会问：“如何尽量减少Repaint的频率？” 注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。 答案： （1）如果需要创建多个DOM节点，可以使用DocumentFragment创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好） （2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。 参考链接：如何减少浏览器repaint和reflow ?","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/08-算法问题","date":"2021-08-06T01:17:26.015Z","updated":"2021-07-28T07:34:11.388Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/08-算法问题/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/08-%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言算法主要包括： 1、排序 排序一定要准备。 2、堆栈、队列、链表 队列和链表可以不准备，但是堆栈一定要准备。 一个小技巧：JS的数组本身就具备堆栈和队列的特性。比如：top、push、shift、unshift这四个api，本身就帮我们实现了堆栈和队列。 堆栈：先进后出。 3、递归 递归是一定不能偷懒的。算法比较难的时候，一般要用到递归。 4、波兰式和逆波兰式 总结： 比如阿里，如果基础题答的很好，但是算法不会，那可能通不过。 还有金融类的，必考算法。比如阿里云，里面的业务就是算法的，所以肯定考算法。 排序上面的排序这么多，我们要记住下面这三个： 快速排序：https://segmentfault.com/a/1190000009426421 选择排序：https://segmentfault.com/a/1190000009366805 希尔排序：https://segmentfault.com/a/1190000009461832 如果你还要学一个，那就是冒泡排序。 题目中，会给你一个算法题， 排序只是其中一个步骤。而且，并不会指定你要求用哪种排序。 堆栈、队列、链表参考链接： https://juejin.im/entry/58759e79128fe1006b48cdfd 上面这个链接是转载的。原创博主的系列文章是： 数组、队列、链表 排序 递归参考链接： JavaScript中的递归 递归理解起来不难，但是用的时候很难，因为你没抓住他的本质。递归的终止条件是什么？参数是怎么传递的？一定要搞清楚。 很多人说：“我知道这道题是考递归，但是我就是不知道该怎么写”。这个面试官很无奈。 波兰式和逆波兰式 如果复习时间很紧张，这部分也不用准备了。也不是所有的公司都会问。 推荐链接： 理论：http://www.cnblogs.com/chenying99/p/3675876.html 源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js 总结如果实在答不来，就说，这个算法我不是很会，只知道一些基本概念。 如果第一面就碰到算法题，这个公司不用去了。说明这个公司是招算法的，不是招前端的。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/07-安全问题：CSRF和XSS","date":"2021-08-06T01:17:26.013Z","updated":"2021-07-28T07:34:11.388Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/07-安全问题：CSRF和XSS/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/07-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9ACSRF%E5%92%8CXSS/","excerpt":"","text":"前言面试中的安全问题，明确来说，就两个方面： CSRF：基本概念、攻击方式、防御措施 XSS：基本概念、攻击方式、防御措施 这两个问题，一般不会问太难。 有人问：SQL注入算吗？答案：这个其实跟前端的关系不是很大。 CSRF问的不难，一般问： CSRF的基本概念、缩写、全称 攻击原理 防御措施 如果把攻击原理和防御措施掌握好，基本没什么问题。 1、CSRF的基本概念、缩写、全称CSRF（Cross-site request forgery）：跨站请求伪造。 PS：中文名一定要记住。英文全称，如果记不住也拉倒。 2、CSRF的攻击原理 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。 从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件： （1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录） （2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。 我们在讲CSRF时，一定要把上面的两点说清楚。 温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。 举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。 3、CSRF如何防御方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个token； （2）客户端提交的表单中带着这个token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌： 把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。 方法三、Referer 验证： Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。 XSS1、XSS的基本概念XSS（Cross Site Scripting）：跨域脚本攻击。 接下来，我们详细讲一下 XSS 的内容。 预备知识：HTTP、Cookie、Ajax。 XSS的攻击原理XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。 最后导致的结果可能是： 盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 XSS的攻击方式 1、反射型 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。 2、存储型 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。 XSS的防范措施（encode + 过滤）XSS的防范措施主要有三个： 1、编码： 对用户输入的数据进行HTML Entity编码。 如上图所示，把字符转换成 转义字符。 Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。 比如说这段代码： 1&lt;script&gt;alert(1)&lt;/script&gt; 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。 进行编码处理之后，L在浏览器中的显示结果就是&lt;script&gt;alert(1)&lt;/script&gt;，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。 参考链接：4类防御XSS的有效方法 2、过滤： 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容） 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正 避免直接对HTML Entity进行解码。 使用DOM Parse转换，校正不配对的DOM标签。 备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。 比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。 还有一种简洁的答案： 首先是encode，如果是富文本，就白名单。 CSRF 和 XSS 的区别面试官还可能喜欢问二者的区别。 区别一： CSRF：需要用户先登录网站A，获取 cookie。 XSS：不需要登录。 区别二：（原理的区别） CSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 其他XSS关于XSS，推荐几个网站： http://html5sec.org/ 里面列出了很多XSS的例子，可以长见识。如果你专门研究XSS，可以看看。 FreeBuf网站上的专栏作者：Black-Hole 比如，他的第一篇文章就讲到了XSS的原理分析与解剖。有句话摘抄如下：弹窗只是测试xss的存在性和使用性。 比如，这个人还有篇文章写自动化检测CSRF（第一章）。大公司做网站，一般会做嗅探服务（比如自动化工具做CSRF的检测、自动化的方式控制安全风险）。 另外，可能还有些工具，可以扫描代码本身有没有一些安全问题。 GitHub | Cure53 这是GitHub上的一个德国组织。 上面的项目都跟安全相关，有些仓库是可以直接运行的。如果你不需要定制，就可以直接用别人的，没必要自己写XSS库、XSS的过滤之类的，避免麻烦。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/06-跨域通信类","date":"2021-08-06T01:17:26.011Z","updated":"2021-07-28T07:34:11.387Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/06-跨域通信类/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/06-%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。 前端通信类的问题，主要包括以下内容： 1、什么是同源策略及限制 同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。 2、前后端如何通信 如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。 3、如何创建Ajax Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？ 这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。 4、跨域通信的几种方式 这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、跨域有几种方式。 下面分别讲解。 同源策略的概念和具体限制同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释） 具体解释： （1）源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。 （2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住） Cookie、LocalStorage和IndexDB无法获取。 无法获取和操作DOM。 不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。 前后端如何通信主要有以下几种方式： Ajax：不支持跨域。 WebSocket：不受同源策略的限制，支持跨域。 CORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax。 如何创建Ajax 关于Ajax请求，可以看本人的基础文章：Ajax入门和发送http请求 在回答 Ajax 的问题时，要回答以下几个方面： 1、XMLHttpRequest 的工作原理 2、兼容性处理 XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。 3、事件的触发条件 4、事件的触发顺序 XMLHttpRequest有很多触发事件，每个事件是怎么触发的。 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）（1）创建XMLHttpRequest 对象。 （2）使用open方法设置请求的参数。open(method, url, 是否异步)。 （3）发送请求。 （4）注册事件。 注册onreadystatechange事件，状态改变时就会调用。 如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 （5）获取返回的数据，更新UI。 发送 get 请求和 post 请求get请求举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送get_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 绑定点击事件 document.querySelector(&#x27;#btnAjax&#x27;).onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var ajaxObj = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 ajaxObj.open(&#x27;get&#x27;, &#x27;02-ajax.php&#x27;); // （3）发送请求 ajaxObj.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 ajaxObj.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log(&#x27;数据返回成功&#x27;); // 数据是保存在 异步对象的 属性中 console.log(ajaxObj.responseText); // 修改页面的显示 document.querySelector(&#x27;h1&#x27;).innerHTML = ajaxObj.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post 请求举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送put_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open(&#x27;post&#x27;, &#x27;02.post.php&#x27;); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); // 将数据通过send方法传递 xhr.send(&#x27;name=fox&amp;age=18&#x27;); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; onreadystatechange 事件注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。 readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 事件的触发条件 事件的触发顺序 上图的参考链接： 你真的会使用XMLHttpRequest吗？ 实际开发中用的 原生Ajax请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var util = &#123;&#125;;//获取 ajax 请求之后的jsonutil.json = function (options) &#123; var opt = &#123; url: &#x27;&#x27;, type: &#x27;get&#x27;, data: &#123;&#125;, success: function () &#123; &#125;, error: function () &#123; &#125;, &#125;; util.extend(opt, options); if (opt.url) &#123; //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); var data = opt.data, url = opt.url, type = opt.type.toUpperCase(); dataArr = []; &#125; for (var key in data) &#123; dataArr.push(key + &#x27;=&#x27; + data[key]); &#125; if (type === &#x27;GET&#x27;) &#123; url = url + &#x27;?&#x27; + dataArr.join(&#x27;&amp;&#x27;); xhr.open(type, url.replace(/\\?$/g, &#x27;&#x27;), true); xhr.send(); &#125; if (type === &#x27;POST&#x27;) &#123; xhr.open(type, url, true); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(dataArr.join(&#x27;&amp;&#x27;)); &#125; xhr.onload = function () &#123; if (xhr.status === 200 || xhr.status === 304) &#123; //304表示：用缓存即可。206表示获取媒体资源的前面一部分 var res; if (opt.success &amp;&amp; opt.success instanceof Function) &#123; res = xhr.responseText; if (typeof res === &#x27;string&#x27;) &#123; res = JSON.parse(res); //将字符串转成json opt.success.call(xhr, res); &#125; &#125; &#125; else &#123; if (opt.error &amp;&amp; opt.error instanceof Function) &#123; opt.error.call(xhr, res); &#125; &#125; &#125;;&#125; Ajax 的推荐链接：https://segmentfault.com/a/1190000006669043 跨域通信的几种方式方式如下： 1、JSONP 2、WebSocket 3、CORS 4、Hash 5、postMessage 上面这五种方式，在面试时，都要说出来。 1、JSONP面试会问：JSONP的原理是什么？怎么实现的？ 在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。 JSONP的原理：通过&lt;script&gt;标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过&lt;script&gt;标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。 JSONP的实现： 比如说，客户端这样写： 1&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt; 上面的src中，data=name是get请求的参数，myjsonp是和后台约定好的函数名。服务器端这样写： 1234myjsonp(&#123; data: &#123;&#125;&#125;) 于是，本地要求创建一个myjsonp 的全局函数，才能将返回的数据执行出来。 实际开发中，前端的JSONP是这样实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script&gt; var util = &#123;&#125;; //定义方法：动态创建 script 标签 /** * [function 在页面中注入js脚本] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.createScript = function (url, charset) &#123; var script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;); charset &amp;&amp; script.setAttribute(&#x27;charset&#x27;, charset); script.setAttribute(&#x27;src&#x27;, url); script.async = true; return script; &#125;; /** * [function 处理jsonp] * @param &#123;[type]&#125; url [description] * @param &#123;[type]&#125; onsucess [description] * @param &#123;[type]&#125; onerror [description] * @param &#123;[type]&#125; charset [description] * @return &#123;[type]&#125; [description] */ util.jsonp = function (url, onsuccess, onerror, charset) &#123; var callbackName = util.getName(&#x27;tt_player&#x27;); //事先约定好的 函数名 window[callbackName] = function () &#123; //根据回调名称注册一个全局的函数 if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123; onsuccess(arguments[0]); &#125; &#125;; var script = util.createScript(url + &#x27;&amp;callback=&#x27; + callbackName, charset); //动态创建一个script标签 script.onload = script.onreadystatechange = function () &#123; //监听加载成功的事件，获取数据 if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123; script.onload = script.onreadystatechange = null; // 移除该script的 DOM 对象 if (script.parentNode) &#123; script.parentNode.removeChild(script); &#125; // 删除函数或变量 window[callbackName] = null; //最后不要忘了删除 &#125; &#125;; script.onerror = function () &#123; if (onerror &amp;&amp; util.isFunction(onerror)) &#123; onerror(); &#125; &#125;; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去 &#125;;&lt;/script&gt; 2、WebSocketWebSocket的用法如下： 123456789101112131415161718192021//var ws = new WebSocket(&#x27;wss://echo.websocket.org&#x27;); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。//把请求发出去ws.onopen = function (evt) &#123; console.log(&#x27;Connection open ...&#x27;); ws.send(&#x27;Hello WebSockets!&#x27;);&#125;;//对方发消息过来时，我接收ws.onmessage = function (evt) &#123; console.log(&#x27;Received Message: &#x27;, evt.data); ws.close();&#125;;//关闭连接ws.onclose = function (evt) &#123; console.log(&#x27;Connection closed.&#x27;);&#125;; Websocket的推荐链接：http://www.ruanyifeng.com/blog/2017/05/websocket.html 面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。 3、CORSCORS 可以理解成是既可以同步、也可以异步的Ajax。 fetch 是一个比较新的API，用来实现CORS通信。用法如下： 12345678// url（必选），options（可选）fetch(&#x27;/some/url/&#x27;, &#123; method: &#x27;get&#x27;,&#125;).then(function (response) &#123; //类似于 ES6中的promise&#125;).catch(function (err) &#123; // 出错了，等价于 then 的第二个参数，但这样更好用更直观&#125;); CORS的推荐链接：http://www.ruanyifeng.com/blog/2016/04/cors.html 推荐链接里有详细的配置。 另外，如果面试官问：“CORS为什么支持跨域的通信？” 答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。 4、Hashurl的#后面的内容就叫Hash。Hash的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。 补充：url的?后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。 使用举例： 场景：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。 现在，我这个A页面想给B页面发消息，怎么操作呢？ （1）首先，在我的A页面中： 123//伪代码var B = document.getElementsByTagName(&#x27;iframe&#x27;);B.src = B.src + &#x27;#&#x27; + &#x27;jsonString&#x27;; //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B （2）然后，在B页面中： 1234// B中的伪代码window.onhashchange = function () &#123; //通过onhashchange方法监听，url中的 hash 是否发生变化 var data = window.location.hash;&#125;; 5、postMessage()方法 H5中新增的postMessage()方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。 场景：窗口 A (http:A.com)向跨域的窗口 B (http:B.com)发送信息。步骤如下。 （1）在A窗口中操作如下：向B窗口发送数据： 12// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage(&#x27;data&#x27;, &#x27;http://B.com&#x27;); //这里强调的是B窗口里的window对象 （2）在B窗口中操作如下： 123456// 在窗口B中监听 message 事件Awindow.addEventListener(&#x27;message&#x27;, function (event) &#123; //这里强调的是A窗口里的window对象 console.log(event.origin); //获取 ：url。这里指：http://A.com console.log(event.source); //获取：A window对象 console.log(event.data); //获取传过来的数据&#125;, false); 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/05-02.面向对象：类的定义和继承的几种方式","date":"2021-08-06T01:17:26.010Z","updated":"2021-07-28T07:34:11.387Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/05-02.面向对象：类的定义和继承的几种方式/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/05-02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言类与实例： 类的声明 生成实例 类与继承： 如何实现继承：继承的本质就是原型链 继承的几种方式 类的定义、实例化类的定义/类的声明方式一：用构造函数模拟类（传统写法） 123function Animal1() &#123; this.name = &#x27;smyhvae&#x27;; //通过this，表明这是一个构造函数&#125; 方式二：用 class 声明（ES6的写法） 12345class Animal2 &#123; constructor() &#123; //可以在构造函数里写属性 this.name = name; &#125;&#125; 控制台的效果： 实例化类的实例化很简单，直接 new 出来即可。 1console.log(new Animal1(),new Animal2()); //实例化。如果括号里没有参数，则括号可以省略 继承的几种方式继承的本质就是原型链。 继承的方式有几种？每种形式的优缺点是？这些问题必问的。其实就是考察你对原型链的掌握程度。 方式一：借助构造函数12345678910function Parent1() &#123; this.name = &#x27;parent1 的属性&#x27;;&#125;function Child1() &#123; Parent1.call(this); //【重要】此处用 call 或 apply 都行：改变 this 的指向 this.type = &#x27;child1 的属性&#x27;;&#125;console.log(new Child1); 【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了Parent1.call(this);，意思是：让Parent的构造函数在child的构造函数中执行。发生的变化是：改变this的指向，parent的实例 –&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。 打印结果： 上方结果表明：child先有了 parent 实例的属性（继承得以实现），再有了child 实例的属性。 分析： 这种方式，虽然改变了 this 的指向，但是，Child1 无法继承 Parent1 的原型。也就是说，如果我给 Parent1 的原型增加一个方法： 12Parent1.prototype.say = function () &#123;&#125;; 上面这个方法是无法被 Child1 继承的。如下： 方法二：通过原型链实现继承1234567891011121314/*通过原型链实现继承 */function Parent() &#123; this.name = &#x27;Parent 的属性&#x27;;&#125;function Child() &#123; this.type = &#x27;Child 的属性&#x27;;&#125;Child.prototype = new Parent(); //【重要】console.log(new Child()); 打印结果： 【重要】上方代码中，最重要的那行：每个函数都有prototype属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，我们把Parent的实例赋值给了Child的prototye，从而实现继承。此时，Child构造函数、Parent的实例、Child的实例构成一个三角关系。于是： new Child.__proto__ === new Parent()的结果为true 分析： 这种继承方式，Child 可以继承 Parent 的原型，但有个缺点： 缺点是：如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变。 如下： 上面的代码中， child1修改了arr属性，却发现，child2的arr属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。 造成这种缺点的原因是：child1和child2共用原型。即：chi1d1.__proto__ === child2__proto__是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。 方式三：组合的方式：构造函数 + 原型链就是把上面的两种方式组合起来： 123456789101112131415/*组合方式实现继承：构造函数、原型链 */function Parent3() &#123; this.name = &#x27;Parent 的属性&#x27;; this.arr = [1, 2, 3];&#125;function Child3() &#123; Parent3.call(this); //【重要1】执行 parent方法 this.type = &#x27;Child 的属性&#x27;;&#125;Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法var child = new Child3(); 这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。 这种方式的缺点是：让父亲Parent的构造方法执行了两次。 1 ES6中的继承方式，一带而过即可，重点是要掌握ES5中的继承。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/05-01.创建对象和原型链","date":"2021-08-06T01:17:26.008Z","updated":"2021-07-28T07:34:11.386Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/05-01.创建对象和原型链/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/05-01.%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"前言面向对象的三大特性 封装 继承 多态 原型链的知识原型链是面向对象的基础，是非常重要的部分。有以下几种知识： 创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new 运算符 创建对象有几种方法方式一：字面量12var obj11 = &#123;name: &#x27;qianguyihao&#x27;&#125;;var obj12 = new Object(name: &#x27;qianguyihao&#x27;); //内置对象（内置的构造函数） 上面的两种写法，效果是一样的。因为，第一种写法，obj11会指向Object。 第一种写法是：字面量的方式。 第二种写法是：内置的构造函数 方式二：通过构造函数1234var M = function (name) &#123; this.name = name;&#125;var obj3 = new M(&#x27;smyhvae&#x27;); 方法三：Object.create12var p = &#123;name:&#x27;smyhvae&#x27;&#125;;var obj3 = Object.create(p); //此方法创建的对象，是用原型链连接的 第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的原型（name是p原型里的属性），构造函数是Objecet 。 原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。 原型、构造函数、实例三者之间的关系 1、构造函数通过 new 生成实例 2、构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 3、原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示： 12345var Foo = function (name) &#123; this.name = name;&#125;var foo = new Foo(&#x27;smyhvae&#x27;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true： 4、实例的__proto__指向原型。也就是说，foo.__proto__ === Foo.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。 Foo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。 原型链原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。 Object是原型链的顶端。 原型可以起到继承的作用。原型里的方法都可以被不同的实例共享： 1234//给Foo的原型添加 say 函数Foo.prototype.say = function () &#123; console.log(&#x27;&#x27;);&#125; 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说： foo instance of Foo的结果为true，因为foo.__proto__ === Foo.prototype为true。 foo instance of Objecet的结果也为true，因为Foo.prototype.__proto__ === Object.prototype为true。 但我们不能轻易的说：foo 一定是 由Object创建的实例。这句话是错误的。我们来看下一个问题就明白了。 分析一个问题问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？ 分析：这就要用到原型的constructor属性了。 foo.__proto__.constructor === Foo的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 new 运算符当new Foo()时发生了什么： （1）创建一个新的空对象实例。 （2）将此空对象的隐式原型指向其构造函数的显示原型。 （3）执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。 （4）如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。 参考《JS高程》6.2.2 类继承和原型继承的区别12345","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/04-HTTP协议","date":"2021-08-06T01:17:26.006Z","updated":"2021-07-28T07:34:11.386Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/04-HTTP协议/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/04-HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一面中，如果有笔试，考HTTP协议的可能性较大。 前言一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要讲的内容； 缓存 CSRF攻击 HTTP协议的主要特点 简单快速 灵活 无连接 无状态 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：无连接、无状态。 我们分别来解释一下。 简单快速简单：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。 灵活http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。 无连接连接一次，就会断开，不会继续保持连接。 无状态客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。 有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。 HTTP报文的组成部分 在回答此问题时，我们要按照顺序回答： 先回答的是，http报文包括：请求报文和响应报文。 再回答的是，每个报文包含什么部分。 最后回答，每个部分的内容是什么 请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。 请求体：数据部分。 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 HTTP方法包括： GET：获取资源 POST：传输资源 put：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。 get 和 post 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。 head 可能偶尔用的到。 get 和 post的区别 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。 有一点要强调，get是相对不隐私的，而post是相对隐私的。 我们大概要记住以下几点： 1、浏览器在回退时，get不会重新请求，但是post会重新请求。【重要】 2、get请求会被浏览器主动缓存，而post不会。【重要】 3、get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。 5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。 http状态码http状态码分类： 常见的http状态码： 部分解释： 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。 301：重定向（永久）。 302：重定向（临时）。 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。 400和401用的不多。403指的是请求被拒绝。404指的是资源不存在。 持久链接/http长连接 如果你能答出持久链接，这是面试官很想知道的一个点。 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。 注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 长连接中的管线化 如果能答出管线化，则属于加分项。 管线化的原理长连接时，默认的请求这样的： 1请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3 长连接中的管线化，请求是这样的： 1请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。 管线化的注意事项面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/03-DOM事件的总结","date":"2021-08-06T01:17:26.004Z","updated":"2021-07-28T07:34:11.386Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/03-DOM事件的总结/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/03-DOM%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言要学习事件的基础内容，请看先本人的这篇基础文章： JavaScript基础：事件对象Event和冒泡 知识难度不大，只是大家需要系统地学习。 知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ….”。 DOM事件模型、DOM事件流 面试官如果问你“DOM事件模型”，你不一定知道怎么回事。其实说的就是捕获和冒泡。 DOM事件流，指的是事件传递的三个阶段。 描述DOM事件捕获的具体流程 讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。 能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。 Event对象的常见应用（Event的常用api方法） DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。 自定义事件（非常重要） 一般人可以讲出事件和注册事件，但是如果让你讲自定义事件，能知道的人，就更少了。 事件委托 业务中经常用到。 下面分别讲解。 DOM事件的级别DOM事件的级别，准确来说，是DOM标准定义的级别。包括： DOM0的写法： 123element.onclick = function () &#123;&#125; 上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。 DOM2的写法： 123element.addEventListener(&#x27;click&#x27;, function () &#123;&#125;, false); 【重要】上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）。如果不写，则默认为false。 DOM3的写法： 123element.addEventListener(&#x27;keyup&#x27;, function () &#123;&#125;, false); DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。 PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。 总结：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。 DOM事件模型、DOM事件流DOM事件模型DOM事件模型讲的就是捕获和冒泡，一般人都能回答出来。 捕获：从上往下。 冒泡：从下（目标元素）往上。 DOM事件流DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。 类似于Android里面的事件传递。 完整的事件流，分三个阶段： （1）捕获：从 window 对象传到 目标元素。 （2）目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。 （3）冒泡：从目标元素传到 Window 对象。 描述DOM事件捕获的具体流程 很少有人能说完整。 捕获的流程 说明：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。 PS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 代码如下： 123456789101112131415161718192021222324window.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 window&quot;);&#125;, true);document.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 document&quot;);&#125;, true);document.documentElement.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 html&quot;);&#125;, true);document.body.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 body&quot;);&#125;, true);fatherBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 father&quot;);&#125;, true);childBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 child&quot;);&#125;, true); 补充一个知识点： 在 js中： 如果想获取 body 节点，方法是：document.body； 但是，如果想获取 html节点，方法是document.documentElement。 冒泡的流程与捕获的流程相反 Event对象的常见 api 方法用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法： 方法一1event.preventDefault(); 解释：阻止默认事件。 比如，已知&lt;a&gt;标签绑定了click事件，此时，如果给&lt;a&gt;设置了这个方法，就阻止了链接的默认跳转。 方法二：阻止冒泡这个在业务中很常见。 有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。 w3c的方法：（火狐、谷歌、IE11） 1event.stopPropagation(); IE10以下则是： 1event.cancelBubble = true; 兼容代码如下： 12345678910111213box3.onclick = function (event) &#123; alert(&quot;child&quot;); //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125; 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。 方法三：设置事件优先级12event.stopImmediatePropagation(); 这个方法比较长，一般人没听说过。解释如下： 比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到stopImmediatePropagation方法了。做法是：在事件A的响应函数中加入这句话。 大家要记住 event 有这个方法。 属性4、属性5（事件委托中用到）12345event.currentTarget //当前所绑定的事件对象。在事件委托中，指的是【父元素】。event.target //当前被点击的元素。在事件委托中，指的是【子元素】。 上面这两个属性，在事件委托中经常用到。 总结：上面这几项，非常重要，但是容易弄混淆。 自定义事件自定义事件的代码如下： 12345678 var myEvent = new Event(&#x27;clickTest&#x27;); element.addEventListener(&#x27;clickTest&#x27;, function () &#123; console.log(&#x27;smyhvae&#x27;); &#125;);//元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作： 123456789var myEvent = new Event(&#x27;clickTest&#x27;);element.addEventListener(&#x27;clickTest&#x27;, function () &#123; console.log(&#x27;smyhvae&#x27;);&#125;);setTimeout(function () &#123; element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest&#125;, 1000); 事件委托参考本人这篇文章的最后一段： JavaScript基础：事件对象Event和冒泡","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/02-CSS盒模型及BFC","date":"2021-08-06T01:17:26.002Z","updated":"2021-07-28T07:34:11.386Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/02-CSS盒模型及BFC/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/02-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 题目：谈一谈你对CSS盒模型的认识专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： （1）基本概念：content、padding、margin。 （2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。 （3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 （4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 （5）实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。 （6）BFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。 总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。 接下来，我们把上面的六条，依次讲解。 标准盒模型和IE盒子模型标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 CSS如何设置这两种模型代码如下： 12345/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 备注：盒子默认为标准盒模型。 JS如何设置、获取盒模型对应的宽和高方式一：通过DOM节点的 style 样式获取1element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。 这种方式有局限性，但应该了解。 方式二（通用型）1window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。 方式三（IE独有的）1element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。 方式四1element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。 此 api 可以拿到四个属性：left、top、width、height。 总结： 上面的四种方式，要求能说出来区别，以及哪个的通用型更强。 margin塌陷/margin重叠标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。 我们来看几个例子。 兄弟元素之间如下图所示： 子元素和父元素之间123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .father &#123; background: green; &#125; /* 给儿子设置margin-top为10像素 */ .son &#123; height: 100px; margin-top: 10px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。 儿子这个盒子： 父亲这个盒子： 上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。 善于使用父亲的padding，而不是儿子的margin 其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。 我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。 BFC（边距重叠解决方案）BFC的概念BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。 另外还有个概念叫IFC。不过，BFC问得更多。 BFC 的原理/BFC的布局规则【非常重要】BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括： （1）BFC 内部的子元素，在垂直方向，边距会发生重叠。 （2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） （3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） （4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC有以下几种方法： 方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex 参考链接： BFC原理详解 BFC详解 前端精选文摘：BFC 神奇背后的原理 下面来看几个例子，看看如何生成BFC。 BFC 的应用举例1：解决 margin 重叠 当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。 比如说，针对下面这样一个 div 结构： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot;&gt; &lt;/p&gt;&lt;/div&gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了： 1234&lt;div class=&quot;father&quot;&gt; &lt;p class=&quot;son&quot; style=&quot;overflow: hidden&quot;&gt; &lt;/p&gt;&lt;/div&gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。 举例2：BFC区域不与float区域重叠： 针对下面这样一个div结构； 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father-layout &#123; background: pink; &#125; .father-layout .left &#123; float: left; width: 100px; height: 100px; background: green; &#125; .father-layout .right &#123; height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father-layout&quot;&gt; &lt;div class=&quot;left&quot;&gt; 左侧，生命壹号 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。 如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性） 123&lt;div class=&quot;right&quot; style=&quot;overflow: hidden&quot;&gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，&lt;/div&gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。 举例3：清除浮动 现在有下面这样的结构： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; background: pink; &#125; .son &#123; float: left; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; 生命壹号 &lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。 如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下： 为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/01-页面布局","date":"2021-08-06T01:17:26.000Z","updated":"2021-07-28T07:34:11.385Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/01-页面布局/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/","excerpt":"","text":"前端面试（前言）面试基础 页面布局 CSS盒模型：是CSS的基石。 DOM事件 HTTP协议 面向对象 原型链：能说出原型链的始末 面试进阶 通信：普通的通信、跨域通信 安全：CSRF、XSS。 算法 回答问题时要注意的（1）题干的要求真的是字面要求的这么简单吗？ （2）答案怎么写，技巧在哪里 （3）如果想证明我的实力，应该有几种答案？ 本文来讲一下页面布局。 题目：页面布局问题：假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。 分析： 初学者想到的答案有两种： 方法1：浮动 方法2：绝对定位。 但要求你能至少写出三四种方法，才算及格。剩下的方法如下： 方法3：flexbox。移动开发里经常用到。 方法4：表格布局 table。虽然已经淘汰了，但也应该了解。 方法5：网格布局 grid。 下面分别讲解。 方法1 和方法2方法1、浮动： 左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。 方法2、绝对定位： 左侧设置为绝对定位， left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left 和right 都为300px，即可。中间的宽度会自适应。 使用article标签作为容器，包裹左、中、右三个部分。 方法1 和方法2 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0px; margin: 0px; &#125; .layout &#123; margin-bottom: 150px; &#125; .layout article div &#123; /*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/ height: 100px; &#125; /* 方法一 start */ .layout.float .left &#123; float: left; width: 300px; background: red; &#125; .layout.float .right &#123; float: right; width: 300px; background: blue; &#125; .layout.float .center &#123; background: green; &#125; /* 方法一 end */ /* 方法二 start */ .layout.absolute .left-center-right &#123; position: relative; &#125; .layout.absolute .left &#123; position: absolute; left: 0; width: 300px; background: red; &#125; /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */ .layout.absolute .center &#123; position: absolute; left: 300px; right: 300px; background: green; &#125; .layout.absolute .right &#123; position: absolute; right: 0; width: 300px; background: blue; &#125; /* 方法二 end */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 方法一：浮动 start --&gt; &lt;!-- 输入 section.layout.float，即可生成 --&gt; &lt;section class=&quot;layout float&quot;&gt; &lt;!-- 用 article 标签包裹左、中、右三个部分 --&gt; &lt;article class=&quot;left-right-center&quot;&gt; &lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; 浮动解决方案 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- 方法一：浮动 end --&gt; &lt;section class=&quot;layout absolute&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;绝对定位解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 注意上方代码中， className 定义和使用，非常规范。 效果如下： 方法3、flexbox布局将左中右所在的容器设置为display: flex，设置两侧的宽度后，然后让中间的flex = 1，即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout article div &#123; height: 100px; &#125; .left-center-right &#123; display: flex; &#125; .layout.flex .left &#123; width: 300px; background: red; &#125; .layout.flex .center &#123; flex: 1; background: green; &#125; .layout.flex .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout flex&quot;&gt; &lt;article class=&quot;left-center-right-&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;flex布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方法4、表格布局 table设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .layout.table div &#123; height: 100px; &#125; /* 重要：设置容器为表格布局，宽度为100% */ .layout.table .left-center-right &#123; width: 100%; display: table; height: 100px; &#125; .layout.table .left-center-right div &#123; display: table-cell; /* 重要：设置三个模块为表格里的单元*/ &#125; .layout.table .left &#123; width: 300px; background: red; &#125; .layout.table .center &#123; background: green; &#125; .layout.table .right &#123; width: 300px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout table&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;表格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 方法5、网格布局 grid1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; /* 重要：设置容器为网格布局，宽度为100% */ .layout.grid .left-center-right &#123; display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; /* 重要：设置网格为三列，并设置每列的宽度。即可。*/ &#125; .layout.grid .left &#123; background: red; &#125; .layout.grid .center &#123; background: green; &#125; .layout.grid .right &#123; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;网格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果： 延伸：五种方法的对比 五种方法的优缺点 考虑中间模块的高度问题 兼容性问题：实际开发中，哪个最实用？ 方法1：浮动： 优点：兼容性好。 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。 方法:2：绝对定位 优点：快捷。 缺点：导致子元素也脱离了标准文档流，可实用性差。 方法3：flex 布局（CSS3中出现的） 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。 方法4：表格布局 优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局 缺点：因为三个部分都当成了单元格来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。 什么时候用 flex 布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。 方法5：网格布局 CSS3中引入的布局，很好用。代码量简化了很多。 PS：面试提到网格布局，说明我们对新技术是有追求的。 延伸：如果题目中去掉高度已知问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？ 分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。 答案是：flex 布局和表格布局可以通用，其他三个布局都不能用了。 页面布局的变通 上下高度固定，中间自适应，这个在移动端的页面中很常见。 总结涉及到的知识点： （1）语义化掌握到位：每个区域用section、article代表容器、div代表块儿。如果通篇都用 div，那就是语义化没掌握好。 （2）页面布局理解深刻。 （3）CSS基础知识扎实。 （4）思维灵活且积极上进。题目中可以通过网格布局来体现。 （5）代码书写规范。注意命名。上面的代码中，没有一行代码是多的。","categories":[],"tags":[]},{"title":"","slug":"大前端/14-前端面试/00-准备","date":"2021-08-06T01:17:25.998Z","updated":"2021-07-28T07:34:11.385Z","comments":true,"path":"2021/08/06/大前端/14-前端面试/00-准备/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/00-%E5%87%86%E5%A4%87/","excerpt":"","text":"前言面试分为三部分 技术面试：问技术问题。 负责人面试：考察综合能力。比如：项目把控能力、项目深度、项目架构、业务等。 hr 面试：侧重于性格、沟通、潜力等。 每轮面试在一小时左右。 每轮面试的知识点一面： 主要考察基础知识。 页面布局 CSS盒模型、DOM事件 HTTP 协议、原型链 面向对象、通信 前端安全、算法 二面： 渲染机制 JS 运行机制 页面性能 错误监控 三面： 不再关注技术层面。 业务能力 团队协作能力 带人能力 终面： 职业竞争力 职业规划 面试成功需要：技术过关、面试技巧等。 校招和社招各自看中的层面校招： 知识：40% 能力：59% 经验：1% 社招： 知识：30%。比如协议、业务的认知程度。 能力：50%。比如架构、业务的抽象能力、项目的把控能力。 经验：20%。项目的体现。 以上仅供参考。 面试准备面试准备包括以下四个部分： 职位描述（JD）的分析 业务分析 技术栈准备 自我介绍 每个公司又有一套成熟的技术栈。比如在构建工具上，百度用 fis3、美团用 Gulp。 你要面哪个公司，要先看看对方要求的技术栈。 上面四个部分，我们接下来详细介绍。 职位描述（JD）的分析介绍概念： 职位描述：注重的是工作职责。 任职要求：要求的是工作能力。通常描述得很细致。 PS：前端的知识庞大，不可能所有的内容都准备好，但是要向“任职要求”靠拢。 分析职位描述（JD）的目的是： 快速识别出这个岗位是否是自己喜欢的、想要的。 目前的技能是否能胜任岗位的要求。短期内的准备能否胜任。 举例1：京东 web 前端的职位描述如下： 职位描述： （1）面试时，会同时考虑到 PC 端和移动端两个部分。 （2）App H5开发指的是两层意思： Hybrid 技术栈。 纯 H5 开发。和 native 开发没有关系，比如活动、专题。 （3）调试数据接口：要学习一下怎么模拟数据。 （4）前端组件库的建立：要求较高但非常重要。体现在： 基本功要扎实，原生 js、css的理解要到位。 之前有没有前端组件库相关的项目经验 是否通读过其他的 UI 组件库。 （5）优化与重构：难度比第四条更大。 PS：前三条是基本知识，第四条、第五条属于进阶。 任职要求： （1）3年以上工作经验：不要太较真工作年限。精通 H5 特性：说明公司很看重移动端。了解H5最新规范：贵公司希望我对新技术是有追求的，比如ES6等。 （2）要求我们对面向对象部分有足够的了解。组件化的编程也离不开面向对象。 （3）体现了几点： 熟悉 Web 标准：熟悉最新的标准即可。 表现与数据分离：MVC框架。 语义化：这个词千万不要忽视。不是什么都用 div。 实际经验：利用框架开发的过程中，遇到过哪些问题？没有实际经验的话，也要提前准备几个问题。 （4）以下几点： 前端架构分析与设计...：说明此岗位并不面对初级岗位。因为工作一至两年的人，大部分都是做业务开发，缺少系统的架构能力。 我们要准备一个项目的架构（比如公司现有的项目）重新梳理，包含：目录结构的设计、复用性设计、模块化设计、自动化测试、上线流是什么。 易读、易维护的代码：面试过程中一定会让你写代码，来体现。要求；每个函数的功能要单一、能抽象尽量抽象。符合这两个原则，基本就满足了“易读、易维护”。 高质量、高效率的代码，短时间内不好准备。 （5）用户可用性、用户体验、用户研究：考察的不是技术，而是候选人对于产品体验的理解。不仅仅只是完成功能而已。 （6）强烈兴趣等，是公司企业文化的一种要求。多去GitHub上看看别人的项目里用的什么新技术、多看博客。短时间内无法准备。 （7）了解Sass和Less：这是基本技能。 （8）熟悉web构建工具：新手推荐学习 Glup，而不是 grunt。当然，你要知道 Glup 和 grunt 的区别。 PS：了解、熟悉、精通，是有区别的。 （9）暂时可以忽略。如果 职位描述里没有要求Node.js，而你只会一点点 Node.js，那不建议你面试的时候把Node.js体现出来。否则是给自己挖坑。 举例2：艺龙的 web 前端的职位描述如下： 此方位 职位描述： （1）系统化设计：说的比较笼统。其实指的就是模块化设计、前后端分离（数据渲染交给前端）。 （2）几点： 前半句：并没有说 H5 是放在移动端做，可能同时包含 PC 和移动端。 后半句：可以看出公司对 H5 动画的要求很高。动画有三种方式：用DOM写、SVG 的path做动画、canvas。canvas 又分 2D 和 3D。我们要看岗位描述里怎么要求的。既然提到CSS3，那么CSS3里面的animation、tansition也要了解。 （3）微信项目，要准备： 小程序：比如看贵公司有小程序吗？我们自己要准备简单的开发和文档、组件化的内容。 微信支付。 对微信开发中的哪些坑，要了解 （4）和京东的第四条很像，既要会框架，也要会组件化设计。但京东的侧重从零开始，而艺龙侧重于：有的就维护，没有的就开发。 岗位要求： （1）各种web前端技术：用词不严谨。 （2）几点： Web标准：JS的最新标准是ES6。 可用性、可访问性：侧重于网站的性能。 前端要做性能监控、错误监控。JS异常分为两种：运行异常、资源加载错误。一般人只能说出第一种异常。 （3）工程化：工程化已经是前端的必备技能。webpack是必须的工具，grunt已经过时了，如果公司提到，还是要了解。Gulp用的很多。 （4）写得比较虚，面试时基本很难考察。面试时，如果写代码，要注意代码风格，该用 class、id、标签时，要注意区分。 （5）要准备一下 Node.js。至少熟悉一门：可能要求全栈开发。 （6）逻辑性强：能说出123。 业务分析 业务分析 CSS3 动画是重点准备的内容。 jQuery 要准备事件委托、选择器等。 ES6语法：import、export等。 比如http://jr.jx.com/这个网站： 通过简单分析源码，我们初步得知网站的以下几点： jQuery vue 框架 ES6 webpack 打包工具 技术栈准备 上图中，左侧是前端技术核心，右侧是前端工程化。 左侧： jQuery：要注意看源码。看源码时，要看这几个：核心架构、事件委托是什么、插件机制、兼容性。 三大框架：都是mvvm框架，准备一至两个即可，或者精心准备一个。面试时会问得很细。比如阿里会经常问Vue的源码。建议找网上的源码分析的文章。 Node.js：如果没有相关项目经历，就尽量不要提。 右侧： npm：npm的常见命令、npm scripts 怎么用的。 webpack：有个中文网站，讲的内容比较全。 自我介绍面试问的问题，很大层次上，取决你的简历和自我介绍。 简历简历中最重要的四个信息： 基本信息：姓名、年龄、手机、邮箱、籍贯。 学历：从大到小写。硕士 -&gt; 本科。 工作经历：时间、公司、岗位、职责、技术栈、业绩。业绩是大多数人所忽略的。 开源项目、Github、说明。 自我评价可以不写。 项目的业绩上，要包括：技术收益和业绩收益。 自我陈述1、把握面试的沟通方向。 如果陈述中谈到项目，面试官可能会问： 负责了什么项目，项目是做什么的 和前端的结合点是？你的角色是？项目中承担了什么责任？ 你在项目中的成绩？ 如果你说自己是项目负责人，会被问到： 该项目怎么分配？有几个人参与？ 作为负责人，你的角色是什么？是项目管理还是技术管理？ 遇到技术难点，如何解决？ 提问题如果在深入问题时，碰到不会的，不要说“我不知道”。建议回答： 我要回去思考一下。 这方面我没有经验，能不能指点一下？ 有什么建议或者参考资料吗？我想把这个东西弄懂。 2、阔达、自信的适度发挥。","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/10-React Navive初识","date":"2021-08-06T01:17:25.994Z","updated":"2021-07-28T07:34:11.384Z","comments":true,"path":"2021/08/06/大前端/13-React基础/10-React Navive初识/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/10-React%20Navive%E5%88%9D%E8%AF%86/","excerpt":"","text":"搭建开发环境官方文档：https://reactnative.cn/docs/getting-started.html 安装Node、homebrew、Watchman安装 homebrew： 1 安装 watchman： 1brew install watchman Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。 安装 React Native 的命令行工具（react-native-cli）安装 react-native-cli： 1npm install -g react-native-cli React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 创建新项目1react-native init MyApp --version 0.44.3 编译并运行 React Native 应用在 ios 模拟器上运行： 1react-native run-ios 调试官网文档：https://reactnative.cn/docs/debugging.html 访问 App 内的开发菜单如果是在 iOS 模拟器中运行，还可以按下Command + D快捷键，Android 模拟器对应的则是Command⌘ + M（windows 上可能是 F1 或者 F2），或是直接在命令行中运行adb shell input keyevent 82来发送菜单键命令。","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/09-AntD框架的upload组件上传图片时遇到的一些坑","date":"2021-08-06T01:17:25.992Z","updated":"2021-07-28T07:34:11.384Z","comments":true,"path":"2021/08/06/大前端/13-React基础/09-AntD框架的upload组件上传图片时遇到的一些坑/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/09-AntD%E6%A1%86%E6%9E%B6%E7%9A%84upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"","text":"前言本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。 前端做文件上传这个功能，是很有技术难度的。既然框架给我们提供好了，那就直接用呗。结果用的时候，发现 upload 组件的很多bug。下面来列举几个。 备注：本文写于2019-03-02，使用的 antd 版本是 3.13.6。 使用 AntD 的 upload 组件做图片的上传因为需要上传多张图片，所以采用的是照片墙的形式。上传成功后的界面如下： （1）上传中： （2）上传成功： （3）图片预览： 按照官方提供的实例，特此整理出项目开发中的完整写法，亲测有效。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* eslint-disable */import &#123; Upload, Icon, Modal, Form &#125; from &#x27;antd&#x27;;const FormItem = Form.Item;class PicturesWall extends PureComponent &#123; state = &#123; previewVisible: false, previewImage: &#x27;&#x27;, imgList: [], &#125;; handleChange = (&#123; file, fileList &#125;) =&gt; &#123; console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 this.setState(&#123; imgList: fileList, &#125;); &#125;; handleCancel = () =&gt; this.setState(&#123; previewVisible: false &#125;); handlePreview = file =&gt; &#123; this.setState(&#123; previewImage: file.url || file.thumbUrl, previewVisible: true, &#125;); &#125;; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =&gt; &#123; //限制图片 格式、size、分辨率 const isJPG = file.type === &#x27;image/jpeg&#x27;; const isJPEG = file.type === &#x27;image/jpeg&#x27;; const isGIF = file.type === &#x27;image/gif&#x27;; const isPNG = file.type === &#x27;image/png&#x27;; if (!(isJPG || isJPEG || isGIF || isPNG)) &#123; Modal.error(&#123; title: &#x27;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~&#x27;, &#125;); return; &#125; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isLt2M) &#123; Modal.error(&#123; title: &#x27;超过2M限制，不允许上传~&#x27;, &#125;); return; &#125; return (isJPG || isJPEG || isGIF || isPNG) &amp;&amp; isLt2M &amp;&amp; this.checkImageWH(file); &#125;; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) &#123; let self = this; return new Promise(function(resolve, reject) &#123; let filereader = new FileReader(); filereader.onload = e =&gt; &#123; let src = e.target.result; const image = new Image(); image.onload = function() &#123; // 获取图片的宽高，并存放到file对象中 console.log(&#x27;file width :&#x27; + this.width); console.log(&#x27;file height :&#x27; + this.height); file.width = this.width; file.height = this.height; resolve(); &#125;; image.onerror = reject; image.src = src; &#125;; filereader.readAsDataURL(file); &#125;); &#125; handleSubmit = e =&gt; &#123; const &#123; dispatch, form &#125; = this.props; e.preventDefault(); form.validateFieldsAndScroll((err, values) =&gt; &#123;// values 是form表单里的参数 // 点击按钮后，将表单提交给后台 dispatch(&#123; type: &#x27;mymodel/submitFormData&#x27;, payload: values, &#125;); &#125;); &#125;; render() &#123; const &#123; previewVisible, previewImage, imgList &#125; = this.state; // 从 state 中拿数据 const uploadButton = ( &lt;div&gt; &lt;Icon type=&quot;plus&quot; /&gt; &lt;div className=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; ); return ( &lt;div className=&quot;clearfix&quot;&gt; &lt;Form onSubmit=&#123;this.handleSubmit&#125; hideRequiredMark style=&#123;&#123; marginTop: 8 &#125;&#125;&gt; &lt;FormItem label=&quot;图片图片&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&#x27;myImg&#x27;)( &lt;Upload action=&quot;//jsonplaceholder.typicode.com/posts/&quot; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data=&#123;file =&gt; (&#123; // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, &#125;)&#125; listType=&quot;picture-card&quot; fileList=&#123;this.state.imgList&#125; onPreview=&#123;this.handlePreview&#125; // 点击图片缩略图，进行预览 beforeUpload=&#123;this.handleBeforeUpload&#125; // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange=&#123;this.handleChange&#125; // 每次上传图片时，都会触发这个方法 &gt; &#123;this.state.imgList.length &gt;= 9 ? null : uploadButton&#125; &lt;/Upload&gt; )&#125; &lt;/FormItem&gt; &lt;/Form&gt; &lt;Modal visible=&#123;previewVisible&#125; footer=&#123;null&#125; onCancel=&#123;this.handleCancel&#125;&gt; &lt;img alt=&quot;example&quot; style=&#123;&#123; width: &#x27;100%&#x27; &#125;&#125; src=&#123;previewImage&#125; /&gt; &lt;/Modal&gt; &lt;/div&gt; ); &#125;&#125;export default PicturesWall; 上传后，点击图片预览，浏览器卡死的问题依据上方的代码，通过 Antd 的 upload 组件将图片上传成功后，点击图片的缩略图，理应可以在当前页面弹出 Modal，预览图片。但实际的结果是，浏览器一定会卡死。 定位问题发现，原因竟然是：图片上传成功后， upload 会将其转为 base64编码。base64这个字符串太大了，点击图片预览的时候，浏览器在解析一大串字符串，然后就卡死了。详细过程描述如下。 上方代码中，我们可以把 handleChange(file, fileList)方法中的 file、以及 fileList打印出来看看。 file指的是当前正在上传的 单个 img，fileList是已上传的全部 img 列表。 当我上传完 两张图片后， 打印结果如下： file的打印的结果如下： 1234567891011121314151617181920212223&#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-5&quot;, &quot;width&quot;: 600, &quot;height&quot;: 354, &quot;lastModified&quot;: 1546701318000, &quot;lastModifiedDate&quot;: &quot;2019-01-05T15:15:18.000Z&quot;, &quot;name&quot;: &quot;e30e7b9680634b2c888c8bb513cc595d.jpg&quot;, &quot;size&quot;: 31731, &quot;type&quot;: &quot;image/jpeg&quot;, &quot;percent&quot;: 100, &quot;originFileObj&quot;: &#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-5&quot;, &quot;width&quot;: 600, &quot;height&quot;: 354 &#125;, &quot;status&quot;: &quot;done&quot;, &quot;thumbUrl&quot;: &quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z&quot;, &quot;response&quot;: &#123; &quot;retCode&quot;: 0, &quot;imgUrl&quot;: &quot;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg&quot;, &quot;photoid&quot;: 271850 &#125;&#125; fileList 的打印结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[ &#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-3&quot;, &quot;width&quot;: 1000, &quot;height&quot;: 667, &quot;lastModified&quot;: 1501414799000, &quot;lastModifiedDate&quot;: &quot;2017-07-30T11:39:59.000Z&quot;, &quot;name&quot;: &quot;29381f30e924b89914e91b33.jpg&quot;, &quot;size&quot;: 135204, &quot;type&quot;: &quot;image/jpeg&quot;, &quot;percent&quot;: 100, &quot;originFileObj&quot;: &#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-3&quot;, &quot;width&quot;: 1000, &quot;height&quot;: 667 &#125;, &quot;status&quot;: &quot;done&quot;, &quot;thumbUrl&quot;: &quot;data:image/jpeg;base64,/E3ju1tlaK1fzJOnHQU3LsLV7HO6Zrk11MZJ7luT0A4FZuRagi9quvzQQ4iuEJ7ZpqTG4djDsPFl2Lg733f8C4q+YhQ8zoYfGSqoMmfwo5huLL0HjiyPDSYPvxRdC1XQvxeLrB8fvl/OnoLmL9vrdvvYS3NGFVe2YsASOh71JfQyrqV2mXLHOcccVSIYEnDyZO9XXB9KYH//Z&quot;, &quot;response&quot;: &#123; &quot;retCode&quot;: 0, &quot;msg&quot;: &quot;success&quot;, &quot;imgUrl&quot;: &quot;http://qianguyihao.com/hfwpjouiurewnmbhepr689.jpg&quot;, &#125; &#125;, &#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-5&quot;, &quot;width&quot;: 600, &quot;height&quot;: 354, &quot;lastModified&quot;: 1546701318000, &quot;lastModifiedDate&quot;: &quot;2019-01-05T15:15:18.000Z&quot;, &quot;name&quot;: &quot;e30e7b9680634b2c888c8bb513cc595d.jpg&quot;, &quot;size&quot;: 31731, &quot;type&quot;: &quot;image/jpeg&quot;, &quot;percent&quot;: 100, &quot;originFileObj&quot;: &#123; &quot;uid&quot;: &quot;rc-upload-1551084269812-5&quot;, &quot;width&quot;: 600, &quot;height&quot;: 354 &#125;, &quot;status&quot;: &quot;done&quot;, &quot;thumbUrl&quot;: &quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z&quot;, &quot;response&quot;: &#123; &quot;retCode&quot;: 0, &quot;imgUrl&quot;: &quot;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg&quot;, &quot;photoid&quot;: 271850 &#125; &#125;] 上方的json数据中，需要做几点解释： （1）response 字段里面的数据，就是请求接口后，后台返回给前端的数据，里面包含了图片的url链接。 （2）status 字段里存放的是图片上传的实时状态，包括上传中、上传完成、上传失败。 （3）thumbUrl字段里面存放的是图片的base64编码。 这个base64编码非常非常长。当点击图片预览的时候，其实就是加载的 thumbUrl 这个字段里的资源，难怪浏览器会卡死。 解决办法：在 handleChange方法里，图片上传成功后，将 thumbUrl 字段里面的 base64 编码改为真实的图片url。代码实现如下： 1234567891011121314151617handleChange = (&#123; file, fileList &#125;) =&gt; &#123; console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =&gt; &#123; if (imgItem &amp;&amp; imgItem.status == &#x27;done&#x27; &amp;&amp; imgItem.response &amp;&amp; imgItem.response.imgUrl) &#123; imgItem.thumbUrl = imgItem.response.imgUrl; &#125; &#125;); this.setState(&#123; imgList: fileList, &#125;);&#125;; 新需求：编辑现有页面上面一段的代码中，我们是在新建的页面中，从零开始上传图片。 现在有个新的需求：如何编辑现有的页面呢？也就是说，现有的页面在初始化时，是默认有几张图片的。当我编辑这个页面时，可以对现有的图片做增删，也能增加新的图片。而且要保证：新建页面和编辑现有页面，是共用一套代码。 我看到upload 组件有提供 defaultFileList 的属性。我试了下，这个defaultFileList 的属性根本没法儿用。 那就只要手动实现了。我的model层代码，是用 redux 写的。整体的实现思路如下：（这个也是在真正在实战中用到的代码） （1）PicturesWall.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/* eslint-disable */import &#123; Upload, Icon, Modal, Form &#125; from &#x27;antd&#x27;;const FormItem = Form.Item;class PicturesWall extends PureComponent &#123; state = &#123; previewVisible: false, previewImage: &#x27;&#x27;, &#125;; // 页面初始化的时候，从接口拉取默认的图片数据 componentDidMount() &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;mymodel/getAllInfo&#x27;, payload: &#123; params: xxx &#125;, &#125;); &#125; handleChange = (&#123; file, fileList &#125;) =&gt; &#123; const &#123; dispatch &#125; = this.props; // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =&gt; &#123; if (imgItem &amp;&amp; imgItem.status == &#x27;done&#x27; &amp;&amp; imgItem.response &amp;&amp; imgItem.response.imgUrl) &#123; imgItem.thumbUrl = imgItem.response.imgUrl; &#125; &#125;); dispatch(&#123; type: &#x27;mymodel/setImgList&#x27;, payload: fileList, &#125;); &#125;; handleCancel = () =&gt; this.setState(&#123; previewVisible: false &#125;); handlePreview = file =&gt; &#123; this.setState(&#123; previewImage: file.url || file.thumbUrl, previewVisible: true, &#125;); &#125;; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =&gt; &#123; //限制图片 格式、size、分辨率 const isJPG = file.type === &#x27;image/jpeg&#x27;; const isJPEG = file.type === &#x27;image/jpeg&#x27;; const isGIF = file.type === &#x27;image/gif&#x27;; const isPNG = file.type === &#x27;image/png&#x27;; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!(isJPG || isJPEG || isGIF || isPNG)) &#123; Modal.error(&#123; title: &#x27;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~&#x27;, &#125;); &#125; else if (!isLt2M) &#123; Modal.error(&#123; title: &#x27;超过2M限制，不允许上传~&#x27;, &#125;); &#125; &#125; // 参考链接：https://github.com/ant-design/ant-design/issues/8779 return new Promise((resolve, reject) =&gt; &#123; if (!(isJPG || isJPEG || isGIF || isPNG)) &#123; reject(file); &#125; else &#123; resolve(file &amp;&amp; this.checkImageWH(file)); &#125; &#125;); &#125;; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) &#123; let self = this; return new Promise(function(resolve, reject) &#123; let filereader = new FileReader(); filereader.onload = e =&gt; &#123; let src = e.target.result; const image = new Image(); image.onload = function() &#123; // 获取图片的宽高，并存放到file对象中 console.log(&#x27;file width :&#x27; + this.width); console.log(&#x27;file height :&#x27; + this.height); file.width = this.width; file.height = this.height; resolve(); &#125;; image.onerror = reject; image.src = src; &#125;; filereader.readAsDataURL(file); &#125;); &#125; handleSubmit = e =&gt; &#123; const &#123; dispatch, form &#125; = this.props; e.preventDefault(); const &#123; mymodel: &#123; imgList &#125;, // 从props中拿默认的图片数据 &#125; = this.props; form.validateFieldsAndScroll((err, values) =&gt; &#123; // values 是form表单里的参数 // 点击按钮后，将表单提交给后台 // start 问题描述：当编辑现有页面时，如果针对已经存在的默认图片不做修改，则不会触发 upload 的 onChange方法。此时提交表单，表单里的 myImg 字段是空的。 // 解决办法：如果发现存在默认图片，则追加到表单中 if (!values.myImg) &#123; values.myImg = &#123; fileList: [] &#125;; values.myImg.fileList = imgList; &#125; // end dispatch(&#123; type: &#x27;mymodel/submitFormData&#x27;, payload: values, &#125;); &#125;); &#125;; render() &#123; const &#123; previewVisible, previewImage &#125; = this.state; // 从 state 中拿数据 const &#123; mymodel: &#123; imgList &#125;, // 从props中拿到的图片数据 &#125; = this.props; const uploadButton = ( &lt;div&gt; &lt;Icon type=&quot;plus&quot; /&gt; &lt;div className=&quot;ant-upload-text&quot;&gt;Upload&lt;/div&gt; &lt;/div&gt; ); return ( &lt;div className=&quot;clearfix&quot;&gt; &lt;Form onSubmit=&#123;this.handleSubmit&#125; hideRequiredMark style=&#123;&#123; marginTop: 8 &#125;&#125;&gt; &lt;FormItem label=&quot;图片上传&quot; &#123;...formItemLayout&#125;&gt; &#123;getFieldDecorator(&#x27;myImg&#x27;)( &lt;Upload action=&quot;//jsonplaceholder.typicode.com/posts/&quot; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data=&#123;file =&gt; (&#123; // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, &#125;)&#125; listType=&quot;picture-card&quot; fileList=&#123;imgList&#125; // 改为从 props 里拿图片数据，而不是从 state onPreview=&#123;this.handlePreview&#125; // 点击图片缩略图，进行预览 beforeUpload=&#123;this.handleBeforeUpload&#125; // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange=&#123;this.handleChange&#125; // 每次上传图片时，都会触发这个方法 &gt; &#123;this.state.imgList.length &gt;= 9 ? null : uploadButton&#125; &lt;/Upload&gt; )&#125; &lt;/FormItem&gt; &lt;/Form&gt; &lt;Modal visible=&#123;previewVisible&#125; footer=&#123;null&#125; onCancel=&#123;this.handleCancel&#125;&gt; &lt;img alt=&quot;example&quot; style=&#123;&#123; width: &#x27;100%&#x27; &#125;&#125; src=&#123;previewImage&#125; /&gt; &lt;/Modal&gt; &lt;/div&gt; ); &#125;&#125;export default PicturesWall; （2）mymodel.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/* eslint-disable */import &#123; routerRedux &#125; from &#x27;dva/router&#x27;;import &#123; message, Modal &#125; from &#x27;antd&#x27;;import &#123; getGoodsInfo, getAllGoods,&#125; from &#x27;../services/api&#x27;;import &#123; trim, getCookie &#125; from &#x27;../utils/utils&#x27;;export default &#123; namespace: &#x27;mymodel&#x27;, state: &#123; form: &#123;&#125;, list: [], listDetail: [], goodsList: [], goodsListDetail: [], pagination: &#123; pageSize: 10, total: 0, current: 1, &#125;, imgList: [], //图片 &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; history.listen(location =&gt; &#123; if (location.pathname !== &#x27;/xx/xxx&#x27;) return; if (!location.state || !location.state.xxxId) return; dispatch(&#123; type: &#x27;fetch&#x27;, payload: location.state, &#125;); &#125;); &#125;, &#125;, effects: &#123; // 接口。获取所有工厂店的列表 (步骤02) *getAllInfo(&#123; payload &#125;, &#123; select, call, put &#125;) &#123; yield put(&#123; type: &#x27;form&#x27;, payload, &#125;); console.log(&#x27;params:&#x27; + JSON.stringify(payload)); let params = &#123;&#125;; params = payload; const response = yield call(getGoodsInfo, params); console.log(&#x27;smyhvae response:&#x27; + JSON.stringify(response)); if (response.error) return; yield put(&#123; type: &#x27;allInfo&#x27;, payload: (response.data &amp;&amp; response.data.map(item =&gt; (&#123; xx1: item.yy1, xx2: item.yy2, &#125;))) || [], &#125;); // response 里包含了接口返回给前端的默认图片数据 if (response &amp;&amp; response.data &amp;&amp; response.data[0] &amp;&amp; response.data[0].my_jpg) &#123; let tempImgList = response.data[0].my_jpg.split(&#x27;,&#x27;); let imgList = []; if (tempImgList.length &gt; 0) &#123; tempImgList.forEach(item =&gt; &#123; imgList.push(&#123; uid: item, name: &#x27;xxx.png&#x27;, status: &#x27;done&#x27;, thumbUrl: item, &#125;); &#125;); &#125; // 通过 redux的方式 将 默认图片 传给 imgList console.log(&#x27;smyhvae payload imgList:&#x27; + JSON.stringify(imgList)); yield put(&#123; type: &#x27;setImgList&#x27;, payload: imgList, &#125;); &#125; &#125;, *setImgList(&#123; payload &#125;, &#123; call, put &#125;) &#123; console.log(&#x27;model setImgList&#x27;); yield put(&#123; type: &#x27;getImgList&#x27;, payload, &#125;); &#125;, &#125;, reducers: &#123; allInfo(state, action) &#123; return &#123; ...state, list: action.payload, &#125;; &#125;, getImgList(state, action) &#123; return &#123; ...state, imgList: action.payload, &#125;; &#125;, &#125;,&#125;; 上面的代码，可以规避 upload 组件的一些bug；而且可以在上传前，通过校验图片的尺寸、大小等，如果不满足条件，则弹出modal弹窗，阻止上传。 大功告成。本文感谢 ld 同学的支持。 其他问题 beforeUpload返回false后，文件仍然为上传中的状态 最后一段有人说，前端开发，连卖菜的都会。可如果真的遇到技术难题，还是得找个靠谱的前端同学才行。这不，来看看前端码农日常：","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/08-Ant Design的基本使用","date":"2021-08-06T01:17:25.990Z","updated":"2021-07-28T07:34:11.384Z","comments":true,"path":"2021/08/06/大前端/13-React基础/08-Ant Design的基本使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/08-Ant%20Design%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"andt 的介绍Ant Design 是基于 React 实现，开发和服务于企业级后台产品。 支持环境 现代浏览器和 IE9 及以上（需要 polyfills）。 支持服务端渲染。 Electron Electron（原名为Atom Shell）是GitHub开发的一个开源框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。 很多客户端软件都是基于 Electron 开发的。比如 VS Code。我们打开 VS Code 菜单栏的 “帮助 –&gt; 切换开发人员工具”，就会看到类似于 chrome的调试工具。 相关链接 官方文档：https://ant.design/docs/react/introduce-cn andt 的使用环境安装1npm install antd --save 代码示例我们需要什么组件，就导入该组件即可。 （1）index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js: 12345678910// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import MyComponent from &quot;./components/MyComponent.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render(&lt;MyComponent&gt;&lt;/MyComponent&gt;, document.getElementById(&quot;app&quot;)); (3)MyComponent.jsx: 12345678910111213141516171819202122import React from &quot;react&quot;;// 导入 日期选择组件import &#123; DatePicker &#125; from &quot;antd&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;在组件中引入 andt&lt;/h3&gt; &lt;DatePicker /&gt; &lt;/div&gt; ); &#125;&#125; 代码运行效果： 20190217_1500.png AntD组件表格pagination属性可以用来分页。 loading框需求：在数据显示之前，展示 loading；在数据显示之后，关闭loading。 相关问题的链接AntD pro，跳转到详情页，携带参数 ant design列表页，转跳到详情页，携带参数 ant design pro商品页带参数转到详情页 AntD pro ，必填项前面，显示星号 表单必填项label上的红色*号是怎么出现的 其他问题 面包屑层级显示问题：https://github.com/ant-design/ant-design-pro/issues/1584 from验证input框只能输入数字：https://blog.csdn.net/zr15829039341/article/details/82745239","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/07-React路由的使用","date":"2021-08-06T01:17:25.987Z","updated":"2021-07-28T07:34:11.383Z","comments":true,"path":"2021/08/06/大前端/13-React基础/07-React路由的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/07-React%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"React路由的使用使用React路由之前，我们需要先安装 react-router-dom这个包。比如： 1yarn add react-router-dom 代码举例： （1）index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js： 12345678910// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;)); （3）app.jsx: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from &quot;react&quot;;// 如果要使用 路由模块，第一步，运行 yarn add react-router-dom// 第二步，导入 路由模块// HashRouter 表示一个路由的跟容器，将来，所有的路由相关的东西，都要包裹在 HashRouter 里面，而且，一个网站中，只需要使用一次 HashRouter 就好了；// Route 表示一个路由规则， 在 Route 上，有两个比较重要的属性， path component// Link 表示一个路由的链接 ，就好比 vue 中的 &lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;import &#123; HashRouter, Route, Link &#125; from &quot;react-router-dom&quot;;import Home from &quot;./components/Home.jsx&quot;;import Movie from &quot;./components/Movie.jsx&quot;;import About from &quot;./components/About.jsx&quot;;export default class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; // 当 使用 HashRouter 把 App 根组件的元素包裹起来之后，网站就已经启用路由了 // 在一个 HashRouter 中，只能有唯一的一个根元素 // 在一个网站中，只需要使用 唯一的一次 &lt;HashRouter&gt;&lt;/HashRouter&gt; 即可 return ( &lt;HashRouter&gt; &lt;div&gt; &lt;h1&gt;这是网站的APP根组件&lt;/h1&gt; &lt;hr /&gt; &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;&amp;nbsp;&amp;nbsp; &lt;Link to=&quot;/movie&quot;&gt;电影&lt;/Link&gt;&amp;nbsp;&amp;nbsp; &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt; &lt;hr /&gt; &#123;/* Route 创建的标签，就是路由规则，其中 path 表示要匹配的路由，component 表示要展示的组件 */&#125; &#123;/* 在 vue 中有个 router-view 的路由标签，专门用来放置，匹配到的路由组件的，但是，在 react-router 中，并没有类似于这样的标签，而是 ，直接把 Route 标签，当作的 坑（占位符） */&#125; &#123;/* Route 具有两种身份：1. 它是一个路由匹配规则； 2. 它是 一个占位符，表示将来匹配到的组件都放到这个位置 */&#125; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt; &lt;hr /&gt; &lt;Route path=&quot;/movie&quot; component=&#123;Movie&#125; /&gt; &lt;hr /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;/div&gt; &lt;/HashRouter&gt; ); &#125;&#125; （4）ReactDemo/src/components/Home.jsx 12345678910111213import React from &quot;react&quot;;export default class Home extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return &lt;div&gt;Home组件&lt;/div&gt;; &#125;&#125; （5）ReactDemo/src/components/Movie.jsx 1234567891011121314import React from &quot;react&quot;;export default class Movie extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return &lt;div&gt;Movie组件&lt;/div&gt;; &#125;&#125; （6）ReactDemo/src/components/About.jsx 12345678910111213import React from &quot;react&quot;;export default class About extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return &lt;div&gt;About组件&lt;/div&gt;; &#125;&#125; 运行结果： 20190214_1000.png 匹配路由参数模糊匹配与精准匹配我们在上面的代码中，进一步修改。假设 Movie 这个组件修改成这种路由匹配方式： 1234&lt;Link to=&quot;/movie/top250&quot;&gt;电影&lt;/Link&gt;&lt;Route path=&quot;/movie&quot; component=&#123;Movie&#125; /&gt; 上面这种匹配方式，也是可以成功匹配到的。这是为啥呢？ 这是因为：默认情况下，路由中的匹配规则，是模糊匹配的。如果 路由可以部分匹配成功，就会展示这个路由对应的组件。 如果想让路由规则，进行精确匹配，可以为Route添加 exact 属性。比如下面这种写法，因为是开启了精准匹配，所以是匹配不到的：（无法匹配） 123&lt;Link to=&quot;/movie/top250/20&quot;&gt;电影&lt;/Link&gt;&lt;Route path=&quot;/movie/&quot; component=&#123;Movie&#125; exact/&gt; 另外，如果要匹配参数，可以在匹配规则中，使用 : 修饰符，表示这个位置匹配到的是参数。举例如下：（匹配正常） 123&lt;Link to=&quot;/movie/top250/20&quot;&gt;电影&lt;/Link&gt;&amp;nbsp;&amp;nbsp;&lt;Route path=&quot;/movie/:type/:id&quot; component=&#123;Movie&#125; exact/&gt; 获取路由参数继续修改上面的代码。如果我想在 Movie 组件中显示路由中的参数，怎么做呢？ 我们可以通过 props.match.params获取路由中的参数。举例做法如下： app.jsx中的匹配规则如下： 123&lt;Link to=&quot;/movie/top100/5&quot;&gt;电影&lt;/Link&gt;&amp;nbsp;&amp;nbsp;&lt;Route path=&quot;/movie/:type/:id&quot; component=&#123;Movie&#125; exact/&gt; Moivie 组件的写法如下： 1234567891011121314151617181920212223import React from &quot;react&quot;;export default class Movie extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; routeParams: props.match.params // 把路由中的参数保存到 state 中 &#125;; &#125; render() &#123; console.log(this); // 如果想要从路由规则中，提取匹配到的参数，进行使用，可以使用 this.props.match.params.*** 来访问 return ( &lt;div&gt; &#123;/* Movie --- &#123;this.props.match.params.type&#125; --- &#123;this.props.match.params.id&#125; */&#125; Movie --- &#123;this.state.routeParams.type&#125; --- &#123;this.state.routeParams.id&#125; &lt;/div&gt; ); &#125;&#125; 打印结果如下： 20190214_1030.png 工程文件： 2019-02-14-ReactDemo.zip 参考链接","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/06-React的单向数据绑定","date":"2021-08-06T01:17:25.984Z","updated":"2021-07-28T07:34:11.383Z","comments":true,"path":"2021/08/06/大前端/13-React基础/06-React的单向数据绑定/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/06-React%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"单项数据绑定在 Vue 中，可以通过 v-model 指令来实现双向数据绑定。但是，在 React 中并没有指令的概念，而且 React 默认不支持 双向数据绑定。 React 只支持，把数据从 state 上传输到 页面，但是，无法自动实现数据从 页面 传输到 state 中 进行保存。 React中，只支持单项数据绑定，不支持双向数据绑定。不信的话，我们来看下面这个例子： 1234567891011121314151617181920212223import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;呵呵哒&lt;/h3&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 上方代码中，我们尝试在 input文本框中读取 state.msg 的值，运行结果中，却弹出了警告： 20190213_2000.png 1Warning: Failed prop type: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`. 通过onChange方法，实现双向数据绑定如果针对 表单元素做 value 属性绑定，那么，必须同时为 表单元素 绑定 readOnly, 或者提供 onChange 事件： 如果是绑定readOnly，表示这个元素只读，不能被修改。此时，控制台就不会弹出警告了。 如果是绑定onChange，表示这个元素的值可以被修改，但是，要自己定义修改的逻辑。 绑定readOnly的举例如下：（表示value中的数据是只读的） 1&lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125; readOnly /&gt; 绑定 onChange 的举例如下：（通过onChange方法，实现双向数据绑定） (1)index.html: 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js: 12345678910111213141516// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 导入组件import MyComponent from &quot;./components/MyComponent.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render( &lt;div&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;)); （3）components/MyComponent.jsx 123456789101112131415161718192021222324252627282930313233343536373839import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;呵呵哒&lt;/h1&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125; onChange=&#123;this.txtChanged&#125; ref=&quot;txt&quot; /&gt; &lt;h3&gt;&#123;&quot;实时显示msg中的内容：&quot; + this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; // 为 文本框 绑定 txtChanged 事件 txtChanged = (e) =&gt; &#123; // 获取 &lt;input&gt; 文本框中 文本的3种方式： // 方式一：使用 document.getElementById // 方式二：使用 ref // console.log(this.refs.txt.value); // 方式三：使用 事件对象的 参数 e 来拿 // 此时，e.target 就表示触发 这个事件的 事件源对象，得到的是一个原生的JS DOM 对象。在这个案例里，e.target就是指文本框 // console.log(e.target.value); this.setState(&#123; msg: e.target.value &#125;); &#125;;&#125; 工程文件： 2019-02-13-ReactDemo.zip","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/05-React中绑定this并给函数传参的几种方式","date":"2021-08-06T01:17:25.982Z","updated":"2021-07-28T07:34:11.382Z","comments":true,"path":"2021/08/06/大前端/13-React基础/05-React中绑定this并给函数传参的几种方式/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/05-React%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E7%BB%99%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言我们先来看下面这段代码： components/MyComponent.jsx 12345678910111213141516171819202122232425262728293031import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;绑定This并传参&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;绑定this并传参&quot; onClick=&#123;this.changeMsg&#125; /&gt; &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; changeMsg() &#123; // 注意：这里的changeMsg()只是一个普通方法。因此，在触发的时候，这里的 this 是 undefined console.log(this); // 打印结果：undefined this.setState(&#123; msg: &quot;设置 msg 为新的值&quot; &#125;); &#125;&#125; 上面的代码中，点击按钮，执行 changeMsg() 方法，尝试修改 this.state.msg 的值。但是，这个方法执行的时候，是会报错的： 1Uncaught TypeError: Cannot read property &#x27;setState&#x27; of null 而且，打印this的结果也是 undefined。这是为啥呢？因为这里的 this 并不是指向 MyComponent 组件本身。 那如何让 changeMsg() 方法里面的 this，指向MyComponent 组件呢？办法总是有的，比如说，将changeMsg() 修改为箭头函数： 123456changeMsg = () =&gt; &#123; console.log(this); // 打印结果：MyComponent 组件 this.setState(&#123; msg: &quot;设置 msg 为新的值&quot; &#125;);&#125;; 那么，除了箭头函数可以 绑定 this，还有没有其他的方式呢？我们接下来讲一讲。 绑定 this 的方式一：bind()代码举例： 123456789101112131415161718192021222324252627282930313233import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;绑定This并传参&lt;/h1&gt; &#123;/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */&#125; &lt;input type=&quot;button&quot; value=&quot;绑定this并传参&quot; onClick=&#123;this.changeMsg1.bind(this)&#125; /&gt; &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; changeMsg1() &#123; this.setState(&#123; msg: &quot;设置 msg 为新的值&quot; &#125;); &#125;&#125; 上方代码中，我们为什么用 bind()，而不是用 call/apply 呢？因为 bind() 并不会立即调用，正是我们需要的。 注意：bind 中的第一个参数，是用来修改 this 指向的。第一个参数后面的所有参数，都将作为函数的参数传递进去。 我们来看看通过 bind() 是怎么传参的。 通过 bind() 绑定this，并给函数传参： 1234567891011121314151617181920212223242526272829import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;绑定This并传参&lt;/h1&gt; &#123;/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */&#125; &lt;input type=&quot;button&quot; value=&quot;绑定this并传参&quot; onClick=&#123;this.changeMsg1.bind(this, &quot;千古啊&quot;, &quot;壹号啊&quot;)&#125; /&gt; &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; changeMsg1(arg1, arg2) &#123; this.setState(&#123; msg: &quot;设置 msg 为新的值&quot; + arg1 + arg2 &#125;); &#125;&#125; 绑定 this 并给函数传参 的方式二：构造函数里设置 bind()我们知道，构造函数中的 this 本身就是指向组件的实例的，所以，我们可以在这里做一些事情。 代码举例： 12345678910111213141516171819202122232425262728293031323334import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; // 绑定 this 并给函数传参的方式2: 在构造函数中绑定并传参 // 注意：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。 // 也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。 this.changeMsg2 = this.changeMsg2.bind(this, &quot;千古恩&quot;, &quot;壹号恩&quot;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;绑定This并传参&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;绑定this并传参&quot; onClick=&#123;this.changeMsg2&#125; /&gt; &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; changeMsg2(arg1, arg2) &#123; this.setState(&#123; msg: &quot;设置 msg 为新的值&quot; + arg1 + arg2 &#125;); &#125;&#125; 上方代码中，需要注意的是：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。 绑定 this 并给函数传参 的方式三：箭头函数【荐】第三种方式用得最多。 代码举例： 12345678910111213141516171819202122232425262728293031323334353637import React from &quot;react&quot;;export default class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是 MyComponent 组件 默认的msg&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;绑定This并传参&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;绑定this并传参&quot; onClick=&#123;() =&gt; &#123; this.changeMsg3(&quot;千古3&quot;, &quot;壹号3&quot;); &#125;&#125; /&gt; &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; changeMsg3 = (arg1, arg2) =&gt; &#123; // console.log(this); // 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined this.setState(&#123; msg: &quot;绑定this并传参的方式3：&quot; + arg1 + arg2 &#125;); &#125;;&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/04-React组件（二）：常见属性和函数","date":"2021-08-06T01:17:25.979Z","updated":"2021-07-28T07:34:11.382Z","comments":true,"path":"2021/08/06/大前端/13-React基础/04-React组件（二）：常见属性和函数/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/04-React%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0/","excerpt":"","text":"defaultProps 和 prop-types使用 defaultProps 设置组件的默认值React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值。 格式举例： 12345// 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值static defaultProps = &#123; initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0）&#125;; 使用prop-types进行props数据类型的校验在组件中，可以通过 prop-types 把外界传递过来的属性，做类型校验。如果类型不匹配，控制台会弹出告警。 注意：如果要为 传递过来的属性做类型校验，必须安装 React 提供的 第三方包，叫做 prop-types。 格式举例： 123static propTypes = &#123; initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型&#125;; 下方代码中，在引用组件的时候，如果类型不匹配： 123456789// 使用 render 函数渲染 虚拟DOMReactDOM.render( &lt;div&gt; &#123;/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */&#125; &lt;Counter initcount=&quot;我是string类型&quot;&gt;&lt;/Counter&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;)); 控制台告警如下： 20190212_2130.png 代码举例我们把 defaultProps 和 prop-types 来举个例子。 （1）index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js: 1234567891011121314151617// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 导入计数器组件import Counter from &quot;./components/Counter.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render( &lt;div&gt; &#123;/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */&#125; &lt;Counter initcount=&#123;0&#125;&gt;&lt;/Counter&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;)); （3）/components/Counter.jsx： 123456789101112131415161718192021222324252627282930313233import React from &quot;react&quot;;// 注意： prop-types 包中职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验import ReactTypes from &quot;prop-types&quot;;export default class Counter extends React.Component &#123; constructor(props) &#123; super(props); // 初始化组件，保存的是组件的私有数据 this.state = &#123; msg: &quot;ok&quot;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 &#125;; &#125; // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = &#123; initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个 数值，为0 &#125;; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;h3&gt;这是 Counter 计数器组件 &lt;/h3&gt; &lt;p&gt;当前的计数是：&#123;this.state.count&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 &#125;&#125; 运行效果： 20190212_2100.png 事件绑定案例：点击按钮后，计数器 +1。 原生js做事件绑定代码举例： （1）index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js: 1234567891011121314151617// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// 导入计数器组件import Counter from &quot;./components/Counter.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render( &lt;div&gt; &#123;/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */&#125; &lt;Counter initcount=&#123;0&#125;&gt;&lt;/Counter&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;)); （3）/components/Counter.jsx： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React from &quot;react&quot;;// 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验import ReactTypes from &quot;prop-types&quot;;export default class Counter extends React.Component &#123; constructor(props) &#123; super(props); // 初始化组件，保存的是组件的私有数据 this.state = &#123; msg: &quot;ok&quot;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 &#125;; &#125; // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = &#123; initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） &#125;; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = &#123; initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 &#125;; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;h3&gt;这是 Counter 计数器组件 &lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;+1&quot; id=&quot;btn&quot; /&gt; &lt;p&gt;当前的计数是：&#123;this.state.count&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 &#125; // 当组件挂载到页面上之后，会进入这个生命周期函数，只要进入这个生命周期函数了，必然说明，页面上，已经有可见的DOM元素了 componentDidMount() &#123; // 在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。 // 也就是说，如果我们想操作DOM元素，最早，只能在 componentDidMount 中进行。 document.getElementById(&quot;btn&quot;).onclick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; &#125;&#125; 使用 React 提供的方法，做事件绑定代码举例： （1）index.html和 （2）main.js 的代码不变，和上一小段中的代码一致。 （3）/components/Counter.jsx： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React from &quot;react&quot;;// 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验import ReactTypes from &quot;prop-types&quot;;export default class Counter extends React.Component &#123; constructor(props) &#123; super(props); // 初始化组件，保存的是组件的私有数据 this.state = &#123; msg: &quot;ok&quot;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 &#125;; &#125; // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = &#123; initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） &#125;; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = &#123; initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 &#125;; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;h3&gt;这是 Counter 计数器组件 &lt;/h3&gt; &#123;/* 这里的 this 指向的是 Counter 组件的实例 */&#125; &lt;input type=&quot;button&quot; value=&quot;+1&quot; id=&quot;btn&quot; onClick=&#123;this.myMethod&#125; /&gt; &lt;p&gt;当前的计数是：&#123;this.state.count&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 &#125; // 点击事件的方法定义 myMethod = () =&gt; &#123; // 修改组件的state里面的值 this.setState(&#123; count: this.state.count + 1 &#125;); &#125;;&#125; 生命周期函数：shouldComponentUpdate()在 shouldComponentUpdate() 函数中，必须要求返回一个布尔值。 需要注意的是：如果返回的值是 false，则不会继续执行后续的生命周期函数，而是直接退回到了 运行中 的状态。因为此时，后续的 render 函数并没有被调用，因此页面不会被更新，但是组件的 state 状态，却被修改了。这种情况，我们也可以这样理解：如果返回值为 false，此时只是更新了 state 里面的数值，但是并没有渲染到 DOM节点上。 利用上面这个特性，我们可以来举个例子。 举例：实现 Counter 计数器只在偶数情况下更新。 实现思路：在 shouldComponentUpdate() 函数中，如果 state 中 的count 的值为奇数，就 return false；否则就 return true。 代码实现：（我们在上面的Counter.jsx代码基础之上，做添加） 123456789101112// 判断组件是否需要更新shouldComponentUpdate(nextProps, nextState) &#123; // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + &quot; ---- &quot; + nextState.count); // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // return this.state.count % 2 === 0 ? true : false return nextState.count % 2 === 0 ? true : false;&#125; 上面这部分的代码，和 render() 方法是并列的。我们需要注意里面的注释，关注 nextState 参数的用法。 在js代码中获取html标签的属性比如说，如果想获取 html标签的 innerHTML 属性，做法如下： 通过原生 js 获取： 1document.getElementById(&#x27;myh3&#x27;).innerHTML 也可以通过 React 提供的 refs 获取： 1this.refs.h3.innerHTML 代码举例： （3）/components/Counter.jsx： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React from &quot;react&quot;;// 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验import ReactTypes from &quot;prop-types&quot;;export default class Counter extends React.Component &#123; constructor(props) &#123; super(props); // 初始化组件，保存的是组件的私有数据 this.state = &#123; msg: &quot;ok&quot;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 &#125;; &#125; // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = &#123; initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） &#125;; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = &#123; initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 &#125;; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;h3&gt;这是 Counter 计数器组件 &lt;/h3&gt; &#123;/* 这里的 this 指向的是 Counter 组件的实例 */&#125; &lt;input type=&quot;button&quot; value=&quot;+1&quot; id=&quot;btn&quot; onClick=&#123;this.myMethod&#125; /&gt; &lt;h3 id=&quot;myh3&quot; ref=&quot;mymyh3&quot;&gt; 当前的计数是：&#123;this.state.count&#125; &lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 &#125; // 点击事件的方法定义 myMethod = () =&gt; &#123; // 修改组件的state里面的值 this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; // 判断组件是否需要更新 shouldComponentUpdate(nextProps, nextState) &#123; // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + &quot; ---- &quot; + nextState.count); // return this.state.count % 2 === 0 ? true : false // return nextState.count % 2 === 0 ? true : false; return true; &#125; // 组件将要更新。此时尚未更新，在进入这个 生命周期函数的时候，内存中的虚拟DOM是旧的，页面上的 DOM 元素 也是旧的 componentWillUpdate() &#123; // 经过打印分析发现：此时页面上的 DOM 节点，都是旧的，应该慎重操作，因为你可能操作的是旧DOM // console.log(document.getElementById(&#x27;myh3&#x27;).innerHTML) console.log(this.refs.mymyh3.innerHTML); &#125; // 组件完成了更新。此时，state 中的数据、虚拟DOM、页面上的DOM，都是最新的，此时，你可以放心大胆的去操作页面了 componentDidUpdate() &#123; console.log(this.refs.mymyh3.innerHTML); &#125;&#125; 上方代码中，componentWillUpdate() 和 componentDidUpdate() 方法里的代码，就是我们这一段要举的例子。 需要注意的是，&lt;h3 id=&quot;myh3&quot; ref=&quot;mymyh3&quot;&gt;这部分代码中，属性名只能小写，不能大写。 工程文件： 2019-02-12-ReactDemo.zip 生命周期函数：componentWillReceiveProps()当子组件第一次被渲染到页面上的时候，不会触发这个 函数。 只有当父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps。 代码举例： （1）index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）main.js:（引入组件） 123456789101112131415// JS打包入口文件// 1. 导入包import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import MyParent from &quot;./components/TestReceiveProps.jsx&quot;;// 使用 render 函数渲染 虚拟DOMReactDOM.render( &lt;div&gt; &lt;MyParent&gt;&lt;/MyParent&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;)); （3）TestReceiveProps.jsx：（组件的定义） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React from &quot;react&quot;;// 父组件export default class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; msg: &quot;这是父组件中的 msg 消息&quot; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;点击修改父组件的 MSG&quot; onClick=&#123;this.changeMsg&#125; /&gt; &lt;hr /&gt; &#123;/* 在父组件 Parent 中引用子组件 Son */&#125; &lt;Son pmsg=&#123;this.state.msg&#125; /&gt; &lt;/div&gt; ); &#125; changeMsg = () =&gt; &#123; this.setState(&#123; msg: &quot;修改组件的msg为新的值&quot; &#125;); &#125;;&#125;// 子组件class Son extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;这是子组件 --- &#123;this.props.pmsg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; // 组件将要接收外界传递过来的新的 props 属性值 // 当子组件第一次被渲染到页面上的时候，不会触发这个 函数； // 只有当 父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps componentWillReceiveProps(nextProps) &#123; // console.log(&#x27;被触发了！&#x27;); // 注意： 在 componentWillReceiveProps 被触发的时候，如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值 // 如果想要获取最新的属性值，需要通过 componentWillReceiveProps 的参数列表来获取 console.log(this.props.pmsg + &quot; ---- &quot; + nextProps.pmsg); &#125;&#125; 上方代码中，我们在组件 Parent 中引入了子组件 Son。重点注意 componentWillReceiveProps()函数 的注释部分。","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/03-React组件（一）：生命周期","date":"2021-08-06T01:17:25.977Z","updated":"2021-07-28T07:34:11.381Z","comments":true,"path":"2021/08/06/大前端/13-React基础/03-React组件（一）：生命周期/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/03-React%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"组件的生命周期在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生命周期。 生命周期的阶段组件生命周期分为三个阶段，下面分别来讲解。 1、组件创建阶段 组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次。 getDefaultProps 初始化 props 属性默认值。 getInitialState 初始化组件的私有数据。因为 state 是定义在组件的 constructor 构造器当中的，只要new 了 class类，必然会调用 constructor构造器。 componentWillMount() 组件将要被挂载。此时还没有开始渲染虚拟DOM。 在这个阶段，不能去操作DOM元素，但可以操作属性、状态、function。相当于 Vue 中的Create()函数。 render() 第一次开始渲染真正的虚拟DOM。当render执行完，内存中就有了完整的虚拟DOM了。 意思是，此时，虚拟DOM在内存中创建好了，但是还没有挂在到页面上。 在这个函数内部，不能去操作DOM元素，因为还没return之前，虚拟DOM还没有创建；当return执行完毕后，虚拟DOM就创建好了，但是还没有挂在到页面上。 componentDidMount() 当组件（虚拟DOM）挂载到页面之后，会进入这个生命周期函数。 只要进入到这个生命周期函数，则必然说明，页面上已经有可见的DOM元素了。此时，组件已经显示到了页面上，state上的数据、内存中的虚拟DOM、以及浏览器中的页面，已经完全保持一致了。 当这个方法执行完，组件就进入都了 运行中 的状态。所以说，componentDidMount 是创建阶段的最后一个函数。 在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。如果我们想操作DOM元素，最早只能在 componentDidMount 中进行。相当于 Vue 中的 mounted() 函数 2、组件运行阶段 有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次。 componentWillReceiveProps() 组件将要接收新属性。只有当父组件中，通过某些事件，重新修改了 传递给 子组件的 props 数据之后，才会触发这个钩子函数。 shouldComponentUpdate() 判断组件是否需要被更新。此时，组件尚未被更新，但是，state 和 props 肯定是最新的。 componentWillUpdate() 组件将要被更新。此时，组件还没有被更新，在进入到这个生命周期函数的时候，内存中的虚拟DOM还是旧的，页面上的 DOM 元素也是旧的。（也就是说，此时操作的是旧的 DOM元素） render 此时，又要根据最新的 state 和 props，重新渲染一棵内存中的 虚拟DOM树。当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时，虚拟DOM树已经和组件的 state 保持一致了，都是最新的；但是页面还是旧的。 componentDidUpdate 此时，组件完成更新，页面被重新渲染。此时，state、虚拟DOM 和 页面已经完全保持同步。 3、组件销毁阶段一辈子只执行一次。 componentWillUnmount: 组件将要被卸载。此时组件还可以正常使用。 React 生命周期的截图如下： 20190212_1745.jpg 生命周期对比： vue中的生命周期图 React Native 中组件的生命周期 组件生命周期的执行顺序1、Mounting： constructor() componentWillMount() render() componentDidMount() 2、Updating： componentWillReceiveProps(nextProps)：接收父组件传递过来的属性 shouldComponentUpdate(nextProps, nextState)：一旦调用 setState，就会触发这个方法。方法默认 return true；如果 return false，后续的方法就不会走了。 componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) 3、Unmounting： componentWillUnmount()","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/02-JSX语法介绍","date":"2021-08-06T01:17:25.975Z","updated":"2021-07-28T07:34:11.381Z","comments":true,"path":"2021/08/06/大前端/13-React基础/02-JSX语法介绍/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/02-JSX%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"JSX介绍JSX的引入如果直接让用户通过 JS 代码手动创建DOM元素，肯定是非常麻烦的。 于是，React 官方就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构。 JSX的全称JSX：JavaScript XML，一种类似于XML的JS扩展语法。也可以理解成：符合 XML 规范的 JS 语法。 需要注意的是，哪怕你在 JS 中写的是 JSX 语法（即JSX这样的标签），但是，JSX内部在运行的时候，并不是直接把 我们的 HTML 标签渲染到页面上；而是先把 类似于HTML 这样的标签代码，转换成 React.createElement 这样的JS代码，再渲染到页面中。 从这一点我们可以看出，JSX是一个对程序员友好的语法糖。 JSX语法的本质：以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上。 babel转换工具如果要直接使用 JSX 语法，需要先安装相关的 语法转换工具： 1运行 cnpm i babel-preset-react -D 这个babel包的作用是：将 JSX语法 转换为 JS语法。 安装完成后，就可以开始使用JSX语法了。 完整代码举例： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; //页面中的真实容器元素 var containDiv = document.getElementById(&quot;app&quot;); //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( &lt;div&gt; Hello, React! &lt;h2&gt;这是标题&lt;/h2&gt; &lt;/div&gt; ); //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JSX的基本语法（1）在 JSX内部 写 JS代码：如果要在 JSX 语法内部，书写 JS 代码，那么，所有的JS代码必须写到 &#123;&#125; 的内部。在{}内部，可以写任何符合JS规范的代码。 例如： 123456789var myTitle = &#x27;这是使用变量定义的 tilte 值&#x27;// 使用JSX语法 创建虚拟DOM对象var vDom = (&lt;div&gt; Hello, React! &lt;h2 title=&#123;myTitle + &#x27;vae&#x27;&#125;&gt;这是标题&lt;/h2&gt;&lt;/div&gt;); （2）当编译引擎在编译JSX代码的时候，如果遇到了&lt;，会把它当作 HTML代码 去编译；如果遇到了 &#123;&#125;， 会把方括号里面的代码当作 普通JS代码 去编译。 （3）在JSX中，如果要为元素添加class属性，则必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor。 代码举例： 12345678// 使用JSX语法 创建虚拟DOM对象var vDom = ( &lt;div&gt; Hello, React! &lt;p className=&quot;qianguyihao&quot;&gt;千古壹号&lt;/p&gt; &lt;label htmlFor=&quot;&quot; /&gt; &lt;/div&gt;); （4）在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹。 （5）如果要写注释，注释必须放到 {} 内部。例如： 123456789// 使用JSX语法 创建虚拟DOM对象var vDom = (// 这一行是注释&lt;div&gt; Hello, React! &lt;p className=&quot;qianguyihao&quot;&gt;千古壹号&lt;/p&gt; &#123;/*这一行也是注释 */&#125;&lt;/div&gt;); 最后，再举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; //页面中的真实容器元素 var containDiv = document.getElementById(&quot;app&quot;); var arr = [] for (var i = 0; i &lt; 6; i++) &#123; var p = &lt;p className=&quot;myp&quot; key=&#123;i&#125;&gt;这个是p标签&lt;/p&gt; // 注意这个地方的写法： key = &#123;i&#125; arr.push(p) &#125; //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( &lt;div&gt; Hello, React! &#123;arr&#125; &lt;/div&gt; ); //2、渲染虚拟DOM对象 ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 20190210_1501.png 创建组件的第一种方式创建组件在React中，构造函数就是一个最基本的组件。 如果想要把组件放到页面中，可以把构造函数的名称当作组件的名称，以 HTML标签形式引入页面中即可。 举例： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 这个构造函数，就相当于一个 组件 function Hello() &#123; return ( &lt;div&gt; &lt;h3&gt;这是 Hello组件 中定义的元素&lt;/h3&gt; &lt;/div&gt; ); &#125; ReactDOM.render( &lt;div&gt; &lt;Hello&gt; &lt;/Hello&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 20190210_1510.png 需要注意的是： React在解析所有标签的时候，是以标签的首字母来区分的：如果标签的首字母是小写，就按照普通的 HTML 标签来解析；如果首字母是大写，则按照 组件的形式来解析。 比如上方代码中，如果把大写的 Hello 改成小写的 hello，运行会报错，无法看到预期的结果。 结论：组件的首字母必须大写。 父组件传值给子组件代码举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 父组件中的数据 var person = &#123; name: &quot;qianguyihao&quot;, age: 27, gender: &quot;男&quot;, address: &quot;深圳&quot; &#125;; // 在子组件中，如果想要使用外部传递过来的数据，必须显示的在 构造函数参数列表中，定义 props 属性来接收 // 通过 props 得到的任何数据都是只读的，不能重新赋值 function Hello(props) &#123; return ( &lt;div&gt; &lt;h3&gt;这是 Hello子组件 中定义的元素： &#123;props.name&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125; ReactDOM.render( &lt;!-- 注意：这里的 ...Obj 语法，是 ES6中的属性扩散，表示：把这个对象上的所有属性，展开了，放到这个位置 --&gt; &lt;div&gt; &lt;Hello &#123;...person&#125;&gt; &lt;/Hello&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上方代码中，我们是想把整个person对象传递给子组件，所以采用了...Obj 语法语法。传递给子组件后，子组件获取的数据仅仅只是可读的。 class 关键字的介绍面向对象语言的三个特性：封装、继承、多态。多态 和 接口、虚拟方法有关。 class的基本用法：使用class创建对象myclass.js: 1234567891011121314151617181920212223242526272829303132333435363738394041// 以前学习的：使用构造函数创建对象function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.say = function() &#123; console.log(&quot;呵呵哒&quot;);&#125;;Person.info = 123;var p1 = new Person(&quot;zs&quot;, 20);// 本次需要学习的：class 后面跟上类名，类名后面，不需要加 () ，直接上 &#123;&#125;class Per &#123; // 在每个class类内部，都有一个 constructor 构造器， 如果没有显示定义 构造器，那么类内部默认都有个看不见的 constructor // constructor 的作用，就好比 咱们之前的 function Person()&#123; &#125; // 每当，使用 new 关键字创建 class 类实例的时候，必然会优先调用 constructor 构造器 // constructor()&#123;&#125; constructor(name, age) &#123; this.name = name; this.age = age; &#125; // 这是实例方法，必须通过 new 出来的对象调用 say() &#123; console.log(&quot;ok a &quot;); &#125; static info = 123; static sayHello() &#123; console.log(&quot;这是静态方法&quot;); &#125;&#125;var p2 = new Per(&quot;壹号&quot;, 26);console.log(p2);console.log(Per.info);console.log(Per.sayHello()); 使用 class 实现 JS 中的继承myclass2.js： 123456789101112131415161718192021222324252627282930class Person &#123; constructor(name, age) &#123; console.log(3); this.name = name; this.age = age; &#125; say() &#123; console.log(&quot;这是 Person中的 say 方法&quot;); &#125; static info = 123;&#125;// 使用 extends 实现继承，extends的前面的是子类，后面的是父类class Chinese extends Person &#123; constructor(name, age, color, language) &#123; console.log(1); // 注意： 当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用 super(name, age); this.color = color; this.language = language; console.log(2); &#125;&#125;var c1 = new Chinese(&quot;张三&quot;, 22, &quot;yellow&quot;, &quot;汉语&quot;);console.log(c1);// 父类中任何东西，子类都能继承到c1.say(); 注意上方 constructor处的注释：当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用。也就是说，在子类当中，要么不写 constructor，如果写了 constructor，就一定要把 super()也加上。 为啥我们要引入 class这个功能？就是因为， class里，永远都存在着一个 constructor。我们可以利用 constructor做很多事情。 创建组件的第二种方式：使用 class 关键字使用 class 创建的类，通过 extends 关键字，继承 React.Component 之后，这个类，就是一个组件的模板了。如果想要引用这个组件，可以把类的名称以标签的形式，导入到 JSX 中使用。 在 class 实现的组件内部，必须定义一个 render 函数。在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null。 代码举例： index.html: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component &#123; // 在 class 实现的组件内部，必须定义一个 render 函数 render() &#123; // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( &lt;div&gt; &lt;h3&gt;这是使用 class 类创建的组件 &lt;/h3&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Hello2&gt; &lt;/Hello2&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 父组件传值给子组件代码举例： index.html: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component &#123; constructor(props) &#123; super(props); console.log(props.name); // 注意：`this.state` 是固定写法，表示当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data()&#123; return &#123;&#125; &#125; 函数 // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可 this.state = &#123; msg: &quot;这是 Hello2 组件的私有msg数据&quot;, info: &quot;永不止步&quot; &#125;; &#125; // 在 class 实现的组件内部，必须定义一个 render 函数 render() &#123; // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( &lt;div&gt; &lt;h3&gt;这是使用 class 类创建的组件 &lt;/h3&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;div&gt; &lt;Hello2 name=&quot;qianguyihao&quot;&gt; &lt;/Hello2&gt; &lt;/div&gt;, document.getElementById(&quot;app&quot;) ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 方式一和方式二的对比上面的内容里，我们使用了两种方式创建组件。这两种方式，有着本质的区别，我们来对比一下。 对比： 方式一：通过 function构造函数 创建组件。内部没有 state 私有数据，只有 一个 props 来接收外界传递过来的数据。 方式二：通过 class 创建子组件。内部除了有 this.props 这个只读属性之外，还有一个专门用于 存放自己私有数据的 this.state 属性，这个 state 是可读可写的。 基于上面的区别，我们可以为这两种创建组件的方式下定义： 使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】。 本质区别： 有状态组件和无状态组件，最本质的区别，就是有无 state 属性。同时， class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数。 什么时候使用 有状态组件，什么时候使用无状态组件： （1）如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件。 （2）如果一个组件，只需要根据外界传递过来的 props，渲染固定的页面结构即可的话，此时，非常适合使用 function 创建出来的无状态组件。（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一点点）。","categories":[],"tags":[]},{"title":"","slug":"大前端/13-React基础/01-React介绍","date":"2021-08-06T01:17:25.973Z","updated":"2021-07-28T07:34:11.380Z","comments":true,"path":"2021/08/06/大前端/13-React基础/01-React介绍/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/13-React%E5%9F%BA%E7%A1%80/01-React%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"虚拟DOM和diff算法 在学习 React 之前，我们需要先了解两个概念：虚拟DOM、diff算法。 虚拟DOM问题描述： 假设我们的数据发生一点点的变化，也会被强制重建整颗DOM树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重。 解决上述问题的思路： 实现按需更新页面上的元素即可。也就是说，把 需要修改的元素，所对应的 DOM 元素重新构建；其他没有变化的数据，所对应的 DOM 节点不需要被强制更新。 具体实现方案：（如何按需更新页面上的元素） 只需要拿到 页面更新前的 内存中的DOM树，同时再拿到 页面更新前的 新渲染出来的 内存DOM树；然后，对比这两颗新旧DOM树，找到那些需要被重新创建和修改的元素即可。这样就能实现 DOM 的按需更新。 如何拿到这两棵DOM树：（即：如何从浏览器的内存住哪个获取到 浏览器私有的那两颗DOM树？） 如果要拿到浏览器私有的DOM树，那我们必须调用浏览器提供的相关JS的API才行。但是问题来了，浏览器并没有提供这样的API。既然如此，那我们可以自己模拟这两颗 新旧DOM树。 如何自己模拟这两颗 新旧DOM树：（即：如何自己模拟一个DOM节点？） 这里涉及到手动模拟DOM树的原理：使用 JS 创建一个对象，用和这个对象来模拟每一个DOM节点；然后在每个DOM节点中，又提供了类似于 children 这样的属性来描述当前DOM的子节点。这样的话，当DOM节点形成了嵌套关系，就模拟出了一颗 DOM 树。 总结： 虚拟DOM的本质：使用 JS 对象模拟DOM树。 虚拟DOM的目的：为了实现 DOM 节点的高效更新。 React内部已经帮我们实现了虚拟DOM，初学者掌握如何调用即可。 diff算法怎么实现 两颗新旧DOM树的对比 呢？这里就涉及到了 diff算法。常见的 diff算法如下： tree diff：新旧DOM树，逐层对比的方式，就叫做 tree diff。每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素。 component diff：在对比每一层的时候，组件之间的对比，叫做 component diff。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置。 element diff：在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff。 key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系。 React 介绍React 是什么 Facebook 开源的一个JS库。 一个用于动态构建用户界面的JS库。 React 的特点 Declarative（声明式编码） Component-Based（组件化编码） Learn Once, Write Anywhere（支持客户端、服务器端渲染） 高效的DOM Diff算法，最小化页面重绘 单向数据流 React高效的原因 虚拟(virtual)DOM，不总是直接操作DOM 高效的DOM Diff算法，最小化页面重绘（即“局部渲染”）。 虚拟DOM指的是：在真实DOM的上一层映射一层虚拟DOM。我们操作的是映射关系，而不是真实的DOM。假设页面的样式做了修改（比如新增了一个标签），此时修改的是虚拟DOM的样式，真实的DOM并未发生变化。那什么时候，真实的DOM会发生变化呢？ 当我把所有的内容操作完之后，转化为真实的DOM，此时要打包统一的渲染页面，于是真实的DOM发生变化，然后渲染一次。 这样做的话，可以减少页面的渲染次数。 相关网址 官网：https://reactjs.org/ GitHub 地址：https://github.com/facebook/react 截至2019-02-08，React项目已经有 121k 的star。 官网截图： 20190208_1057.png 上方截图中，有一个特性是“Learn Once, Write Anywhere”。这里的 “Anywhere” 其实指的是两个地方：一个是浏览器端，一个是服务器端。后者指的是，React支持在服务器端渲染页面。 生态介绍 Vue生态：Vue + Vue-Router + Vuex + Axios + Babel + Webpack React生态：React + React-Router + Redux + Axios + Babel + Webpack React 模块化、组件化模块 理解：向外提供特定功能的js程序, 一般就是一个js文件 理由：js代码更多更复杂 作用：简化js的编写，阅读，提高运行效率 组件 理解：用来实现特定功能效果的代码集合(html/css/js) 理由：一个界面的功能更复杂 作用：复用，简化项目编码，提高运行效率 模块化与组件化 模块化：当应用的js都以模块来编写的, 这个应用就是一个模块化的应用 组件化：当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用 面相对象与面向过程的区别面向对象编程： 重点是对象 更加关心的是干活的人 面向过程编程： 更加关心的是干活的过程 谁去干活儿不关心 React 环境搭建：写第一个Hello Worldreact.js 和 react-dom.js为了通过 React 写一个Hello World程序，我们需要先安装几个包： react.js: React的核心库。这个包，是专门用来创建React组件、组件生命周期等。 react-dom.js: 操作DOM的扩展库。这个包，主要封装了和 DOM 操作相关的包（比如，把组件渲染到页面上）。 babel.min.js: 将 JSX语法 解析为 纯JS语法代码。 方式一：本地引入相关的js库入门的时候，我们建议采取方式一。 如果是本地引入的话，可以这样写： 12345&lt;!-- 引入React相关的js库 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; 如果是通过CDN的方式引入的话，可以使用网站 https://www.bootcdn.cn/ 提供的CDN链接。 完整代码举例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入React相关的js库 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./libs/babel.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;myContainer&quot;&gt;&lt;/div&gt; &lt;!-- 注意，这一行的 type 是写 &quot;text/babel&quot;，而不是 &quot;text/javascript&quot; --&gt; &lt;script type=&quot;text/babel&quot;&gt; //页面中的真实容器元素 var containDiv = document.getElementById(&quot;myContainer&quot;); //1、创建虚拟DOM对象 var vDom = &lt;div&gt;Hello, React!&lt;/div&gt;; // 不是字符串, 不能加引号 //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码运行后，页面上的DOM结构如下： 123&lt;div id=&quot;myContainer&quot;&gt; &lt;div&gt;Hello, React!&lt;/div&gt;&lt;/div&gt; 代码解释： render的中文含义是“渲染”。render 方法的语法如下： 1ReactDOM.render(要渲染的虚拟DOM对象, 容器 container：要渲染到页面上的哪个位置); 【工程文件下载】 2019-02-08-ReactDemo.zip 方式二：npm install实际开发中，我们一般都是通过 npm install 的方式来安装 react 相关的包。 首先，新建一个空的文件夹2019-02-08-ReactDemo，作为项目的根目录。然后在根目录下执行如下命令，进行项目初始化： 1npm init --yes 上方命令执行完成后，会生成package.json文件。 然后继续执行如下命令，安装 react.js 和 react-dom.js 这两个包： 1npm i react react-dom 完整代码举例： index.html: 1 main.js: 12345678910111213141516// JS打包入口文件import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;// 在 react 中，如要要创建 DOM 元素，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数// 参数1： 是个字符串类型的参数，表示要创建的元素类型// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点// &lt;div title=&quot;this is a div&quot; id=&quot;mydiv&quot;&gt;这是一个div&lt;/div&gt;var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;);// ReactDOM.render(&#x27;要渲染的虚拟DOM元素&#x27;, &#x27;要渲染到页面上的哪个位置&#x27;);ReactDOM.render(myDiv, document.getElementById(&#x27;app&#x27;)); 上方代码中，createElement()方法介绍如下： 1React.createElement(需要创建的元素类型, 有哪些属性, 子节点) 【工程文件下载】 2019-02-09-ReactDemo.zip 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/Vue组件","date":"2021-08-06T01:17:25.968Z","updated":"2021-07-28T07:34:11.380Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/Vue组件/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/Vue%E7%BB%84%E4%BB%B6/","excerpt":"","text":"子组件的定义和注册我们在本文的第一段中，通过Vue.component形式定义的是全局组件。这一段中，我们来讲一下子组件。 在父组件中定义子组件比如说，一个账号模块是父组件，里面分为登陆模块和注册模块，这两个晓得模块就可以定义为子组件。 需要注意的是作用域的问题：我们在父组件中定义的子组件，只能在当前父组件的模板中使用；在其他的组件，甚至根组件中，都无法使用。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;account&gt; &lt;/account&gt; &lt;/div&gt; &lt;script&gt; //定义、注册组件 Vue.component(&#x27;account&#x27;, &#123; template: &#x27;&lt;div&gt;&lt;h2&gt;账号模块&lt;/h2&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;&#x27;, components: &#123; &#x27;login&#x27;: &#123; template: &#x27;&lt;h3&gt;登录模块&lt;/h3&gt;&#x27; &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们发现，既然是定义父亲&lt;account&gt;的子组件，那么，子组件&lt;login&gt;的调用，只能写在父组件&lt;account&gt;的template模板中。 显示效果： 在 Vue 根实例中定义子组件当然，我们还可以这样做：把整个 Vue 对象当成父亲，这样的话，就可以在 Vue 示例中定义一个子组件。如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;login&gt; &lt;/login&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, //在Vue实例中定义子组件 components: &#123; // components 是关键字，不能改 &#x27;login&#x27;: &#123; template: &#x27;&lt;h3&gt;登录模块&lt;/h3&gt;&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样写的话，我们定义的子组件&lt;login&gt;在整个#app区域，都是可以使用的。 上面的代码，还有另外一种写法：（把子组件的模板定义，存放到变量中）【重要】 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;login&gt; &lt;/login&gt; &lt;/div&gt; &lt;script&gt; //通过变量接收定义的子组件 var myLogin = &#123; template: &#x27;&lt;h3&gt;登录模块&lt;/h3&gt;&#x27; // template 是关键字，不能改 &#125; new Vue(&#123; el: &#x27;#app&#x27;, //在Vue实例中定义子组件 components: &#123; // components 是关键字，不能改 &#x27;login&#x27;: myLogin &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意，在定义子组件时，关键字components不要写错了。 组件之间的动态切换（暂略）我们可以利用&lt;component&gt; 标签的:is参数来进行组件之间的切换。 父组件向子组件传递数据我们要记住：父组件通过属性的形式，向子组件传递数据。 引入： 我们先来看这样一段代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 这里是父组件的范围，自定义一个数值 number --&gt; &lt;counter number=&quot;1+2&quot;&gt; &lt;/counter&gt; &lt;counter number=&quot;10+20&quot;&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; var myCounter = &#123; //【重要】这里是子组件的范围，无法直接获取父组件中的 number template: &#x27;&lt;div&gt;我是子组件。&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; &#x27;counter&#x27;: myCounter &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我想把父组件里 number 的数值传递给子组件，直接这样写，是看不到效果的： 1、父组件传值给子组件： 要通过 props 属性将number进行传递给子组件才可以。代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 这里是父组件的范围，自定义一个数值 number --&gt; &lt;counter :number=&quot;1+2&quot;&gt; &lt;/counter&gt; &lt;counter :number=&quot;10+20&quot;&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; var myCounter = &#123; //这里是子组件的范围 props: [&#x27;number&#x27;], //通过 props 属性将父亲的 number 数据传递给子组件 template: &#x27;&lt;div&gt;我是子组件。&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; &#x27;counter&#x27;: myCounter &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在&lt;counter&gt;标签中，要注意:number里的冒号。加上冒号，那么引号里的内容就是表达式（期望的结果）；否则，引号的内容只是字符串： 2、子组件获取了父组件的数据后，进行求和操作： 上方代码中，子组件已经获取了父组件的两个number，现在要求：每点击一次子组件，在子组件中将数据加 1。 一般人可能会这样写：（不推荐的写法：子组件直接修改父组件中的数据） 1234567891011var myCounter = &#123; //这里是子组件的范围 props: [&#x27;number&#x27;], //通过 props 属性将父亲的数据传递给子组件 template: &#x27;&lt;div @click=&quot;addClick&quot;&gt;我是子组件。&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27;, methods: &#123; addClick: function () &#123; this.number ++; //这种写法不推荐。不建议直接操作父组件中的数据 &#125; &#125;&#125; 上方代码的写法不推荐，因为不建议直接操作父组件中的数据。虽然数据操作成功，但是控制台会报错： img.png 这样涉及到单向数据流的概念： 父组件可以传递参数给子组件，但是反过来，子组件不要去修改父组件传递过来的参数。因为同一个参数，可能会传递给多个子组件，避免造成修改的冲突。 既然如此，我可以把父组件中的数据，在子组件中创建副本，然后我们去修改这个副本，就不会造成影响了。最终，完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 这里是父组件的范围，自定义一个数值 number --&gt; &lt;counter :number=&quot;1+2&quot;&gt; &lt;/counter&gt; &lt;counter :number=&quot;10+20&quot;&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; var myCounter = &#123; //这里是子组件的范围 props: [&#x27;number&#x27;], //通过 props 属性将父亲的数据传递给子组件 data: function () &#123; return &#123; number2: this.number &#125; &#125;, template: &#x27;&lt;div @click=&quot;addClick&quot;&gt;我是子组件。&#123;&#123;number2&#125;&#125;&lt;/div&gt;&#x27;, methods: &#123; addClick: function () &#123; this.number2 ++; //操作和修改number的副本 &#125; &#125; &#125; var vm = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; &#x27;counter&#x27;: myCounter &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子组件向父组件传值我们要记住：子组件通过事件触发的形式，向父组件传值。 **案例1:**子组件给父组件传递数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 在外层监听`mysend`事件，进而出发外层的 getData 方法 --&gt; &lt;counter v-on:mysend=&quot;getData&quot;&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;&lt;div @click = &quot;addClick&quot;&gt;发送数据给父组件&lt;/div&gt;&#x27;, //当组件被点击时，触发 addClick 方法 methods: &#123; addClick: function () &#123; //第一个参数为键(注意，要小写，不能大写)，第二个参数为值 this.$emit(&#x27;mysend&#x27;, &#x27;smyhvae&#x27;); //通过键`mysend`事件通知外面，将值`smyhvae`传给父组件 &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; getData: function (input) &#123; //通过括号里的参数，获取子组件传递过来的值 console.log(input); //打印结果：smyhvae &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例2：获取子组件的DOM对象 题目：给两个相同的子组件定义计数器，每点击一次，数值加1。然后在父组件中求和。 步骤（1）：给两个相同的子组件定义计数器，每点击一次，数值加1。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter&gt; &lt;/counter&gt; &lt;counter&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;&lt;div @click = &quot;addClick&quot;&gt;当前计数：&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27;, //当组件被点击时，调用 addClick 方法 data: function () &#123; return &#123; number: 0 //给组件定义一个数据：number &#125; &#125;, methods: &#123; addClick: function () &#123; this.number++; //定义方法：每点击一次，number 的数值加 1 &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 步骤（2）：两个子组件的数值加 1 后，通知父组件。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 在外层监听`change`事件，进而出发外层的 myClick 方法 --&gt; &lt;counter @change=&quot;myMethod&quot;&gt; &lt;/counter&gt; &lt;counter @change=&quot;myMethod&quot;&gt; &lt;/counter&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;&lt;div @click = &quot;addClick&quot;&gt;当前计数：&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27;, //当组件被点击时， data: function () &#123; return &#123; number: 0 //给组件定义一个数据：number &#125; &#125;, methods: &#123; addClick: function () &#123; this.number++; //定义方法：每点击一次，number 的数值加 1 this.$emit(&#x27;change&#x27;); //通过这一行的`change`，通知外面，内部的 addClick 方法已经执行了 &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; myMethod: function () &#123; console.log(&#x27;触发父组件&#x27;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，通过关键字emit通知父组件，子组件里的 addClick 方法被执行了。父组件得知后，执行myMethod()方法（这个方法是在Vue实例中定义的，很好理解） 步骤（3）：在父组件中求和 既然父组件已经得知子组件的 addClick 事件，那我们直接在父组件的myMethod()里定义求和的方法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 在外层监听`change`事件，进而触发外层的 myMethod 方法 --&gt; &lt;counter ref=&quot;one&quot; @change=&quot;myMethod&quot;&gt; &lt;/counter&gt; &lt;counter ref=&quot;two&quot; @change=&quot;myMethod&quot;&gt; &lt;/counter&gt; &lt;div&gt;&#123;&#123;totalData&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;&lt;div @click = &quot;addClick&quot;&gt;当前计数：&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27;, //当组件被点击时，触发 addClick方法 data: function () &#123; return &#123; number: 0 //给组件定义一个数据：number &#125; &#125;, methods: &#123; addClick: function () &#123; this.number++; //定义方法：每点击一次，number 的数值加 1 this.$emit(&#x27;change&#x27;); //通过这一行自定义的`change`，通知外面，内部的 addClick 方法已经执行了 &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; totalData: 0 &#125;, methods: &#123; myMethod: function () &#123; console.log(&#x27;触发父组件&#x27;); //通过`$refs`获取子组件中各自的number数值 var a1 = this.$refs.one.number; var a2 = this.$refs.two.number; //求和，存放在父组件的 totalData 中 this.totalData = a1 + a2; console.log(); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码的关键： 在&lt;counter&gt;标签中，通过 ref = &quot;xxx&quot;属性，给各个组件起一个别名，代表组件的引用 在父函数myMethod()中，通过this.$refs.xxx获取组件的引用。我们看一下最后两行代码在控制台的输出便知：（组件里有 number 属性）","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/Vue开发积累","date":"2021-08-06T01:17:25.965Z","updated":"2021-07-28T07:34:11.379Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/Vue开发积累/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/Vue%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"动态添加对象的属性 Vue中，动态新增对象的属性时，不能直接添加。正确的做法是：Vue.set(obj,key,value)。参考链接：# 判断一个checkbox是否被选中12345678910&lt;!-- v-model里的内容是变量，变量里的值可能是 true 后者 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;isSelected&quot;&gt;&lt;!-- 选中时，值为 true。未选中时，值为 false --&gt;&lt;span&gt;&#123;&#123;isSelected&#125;&#125;&lt;/span&gt;&lt;!-- 选中时，显示文字。未选中时，隐藏文字 --&gt;&lt;span v-if=&quot;isSelected&quot;&gt;haha&lt;/span&gt; 多个checkbox的全选和反选现在有多个checkbox的item在一个数组中，另外还有一个“全选”的checkbox按钮。 点击全选按钮，让子item全部选中： 采用 watch 监听全选按钮，然后改变子item。 当子item全部被选中时，触发全选按钮： 采用 computed 计算子item 的状态，存放到变量 allChecked 中，然后用 watch 监听 allChecked 的值。 参考链接： 问Vue.js 如何在 data 里含数组的情况下，监听数组内指定属性的变化？","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/Vue.js在开发中的常见写法积累","date":"2021-08-06T01:17:25.963Z","updated":"2021-07-28T07:34:11.379Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/Vue.js在开发中的常见写法积累/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/Vue.js%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%86%99%E6%B3%95%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"001、对象的赋值（1）在 store 中定义一个对象： 1234567userInfo: &#123; pin: &#x27;&#x27;, nickName: &#x27;&#x27;, avatarUrl: DEFAULT_AVATAR, definePin: &#x27;&#x27;, isbind: true&#125;, （2）从接口拿到数据后，给这个对象赋值： 1234567this.userInfo = &#123; ...this.userInfo, pin: res.base.curPin, nickName: res.base.nickname, avatarUrl: res.base.headImageUrl ? res.base.headImageUrl : DEFAULT_AVATAR, definePin: res.definePin&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/Vue-router路由","date":"2021-08-06T01:17:25.960Z","updated":"2021-07-28T07:34:11.379Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/Vue-router路由/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/Vue-router%E8%B7%AF%E7%94%B1/","excerpt":"","text":"前言路由：就是SPA（单页应用）的路径管理器。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/07-Vue-router路由","date":"2021-08-06T01:17:25.958Z","updated":"2021-07-28T07:34:11.379Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/07-Vue-router路由/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/07-Vue-router%E8%B7%AF%E7%94%B1/","excerpt":"","text":"什么是路由后端路由对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源。 当前端输入url请求资源时，服务器会监听到是什么url地址，那后端会返回什么样的资源呢？后端这个处理的过程就是通过路由来分发的。 总结：后端路由，就是把所有url地址都对应到服务器的资源，这个对应关系就是路由。 前端路由对于单页面应用程序来说，主要通过URL中的hash（url地址中的#号）来实现不同页面之间的切换。 同时，hash有一个特点：HTTP请求中不会包含hash相关的内容。所以，单页面程序中的页面跳转主要用hash实现。 总结：在单页应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）。 安装Vue-router的两种方式 官方文档：https://router.vuejs.org/zh/ 方式一：直接下载文件 下载网址：https://unpkg.com/vue-router/dist/vue-router.js 下载之后，放进项目工程，然后我们在引入vue.js之后，再引入vue-router.js即可： 12&lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;vue-router3.0.1.js&quot;&gt;&lt;/script&gt; 然后，我们就可以在 window全局对象中使用 VueRouter这个对象。具体解释可以看接下来的代码中的注释。 注意，只要我们导入了vue-router.js这个包，在浏览器中打开网页时，url后面就会显示#这个符号。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/06-Vue组件之间的传值","date":"2021-08-06T01:17:25.955Z","updated":"2021-07-28T07:34:11.378Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/06-Vue组件之间的传值/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/06-Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/","excerpt":"","text":"父组件向子组件传值我们可以这样理解：Vue实例就是一个父组件，而我们自定义的组件（包括全局组件、私有组件）就是子组件。 【重点】需要注意的是，子组件不能直接使用父组件中的数据。父组件可以通过props属性向子组件传值。 父组件向子组件传值的代码举例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第三步：父组件在引用子组件的时候， 通过 属性绑定（v-bind:）的形式, --&gt; &lt;!-- 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;component1 v-bind:parent-msg=&quot;msg&quot;&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=&quot;myTemplate&quot;&gt; &lt;!-- 第二步：在子组件的模板中，使用props中的属性 --&gt; &lt;h2 @click=&quot;change&quot;&gt;我是子组件。我想使用父组件中的数据parentMsg： &#123;&#123; parentMsg &#125;&#125;&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;父组件中的数据123&#x27; &#125;, methods: &#123;&#125;, components: &#123; // 子组件默认无法访问到 父组件中的 data 中的数据 和 methods 中的方法 component1: &#123; //将子组件的名称定义为 component1 template: &#x27;#myTemplate&#x27;, data() &#123; // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的 return &#123; title: &#x27;子组件私有的数据 title&#x27;, content: &#x27;子组件私有的数据 content&#x27; &#125; &#125;, // 注意： 组件中的 所有 props 中的数据，都是通过 父组件 传递给子组件的 // props 中的数据，都是只读的，无法重新赋值 props: [&#x27;parentMsg&#x27;], // 第一步：把父组件传递过来的 parentMsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; change() &#123; // 下面这行会报错，因为子组件不要直接修改父组件中的data数据 // this.parentMsg = &#x27;被修改了&#x27; &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 代码截图如下： 父组件给子组件传值的步骤： 根据上方截图，我们可以总结出父组件给子组件传值的步骤如下。 （1）在子组件的props属性中声明父亲传递过来的数据 （2）定义子组件的模板时，使用props中的属性 （3）父组件在引用子组件时，进行属性绑定。 子组件中，data中的数据和props中的数据的区别： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上。props 中的数据，都是通过 父组件 传递给子组件的。 data中的数据是可读可写的；props中的属性只是可读的，无法重新赋值，重新赋值会报错（也就是说，子组件不要直接去修改父组件中的数据）。 父组件将方法传递给子组件 父组件通过事件绑定机制，将父组件的方法传递给子组件 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件向子组件 传递 方法，是通过 事件绑定机制； v-on。当我们自定义了 一个 事件属性 parent-show（这个地方不能用驼峰命名）之后，--&gt; &lt;!-- 那么，子组件就能够，通过 emit 来调用 传递进去的 这个 方法了 --&gt; &lt;!-- 【第一步】。意思是说，`show`是父组件的方法名，`parent-show`是自定义的时间属性，稍后要在子组件中用到 --&gt; &lt;component1 @parent-show=&#x27;show&#x27;&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=&quot;myTemplate&quot;&gt; &lt;!-- 【第二步】按照正常的写法来：点击按钮，调用子组件的方法 --&gt; &lt;div @click=&quot;childClick&quot;&gt;我是子组件，点击调用父组件的方法&lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; //父组件的data // msg: &#x27;父组件中的数据&#x27; &#125;, methods: &#123; show: function () &#123; // 定义父组件的show方法 console.log(&#x27;父组件提供的方法&#x27;); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: &#x27;#myTemplate&#x27;, data() &#123; // 子组件的data return &#123; // content: &#x27;子组件私有的数据 content&#x27; &#125; &#125;, props: [&#x27;&#x27;], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // 当点击子组件的按钮时，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？ // emit 英文原意： 是触发，调用、发射。意思是，触发父组件的方法 // 【第三步】 在子组件的方法中，通过 emit 触发父组件的方法 this.$emit(&#x27;parent-show&#x27;); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：（点击子组件，触发了父组件的方法） 根据上面的代码，我们可以总结出，父组件将方法传递给子组件，分为三步，具体可以看上方代码的注释。 子组件向父组件传值上面的一段中，我们再看一遍父组件将方法传递给子组件的这段代码（一定要再看一遍，因为我们是要在此基础之上做修改）。 如果要实现子组件向父组件传值，代码是类似的，我们只需要在子组件通过emit触发父组件的方法时，把子组件的参数带出去就可以了。代码如下。 代码举例1：(将子组件中的常量传递给父组件) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;component1 @parent-show=&#x27;show&#x27;&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=&quot;myTemplate&quot;&gt; &lt;h2 @click=&quot;childClick&quot;&gt;我是子组件，点击调用父组件的方法&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; //父组件的data // msg: &#x27;父组件中的数据&#x27; &#125;, methods: &#123; // 定义父组件的方法 show: function (arg1, arg2) &#123; //【第二步】父组件里放两个参数，这个两个参数就代表着子组件中的`child 123`、`child 789` console.log(&#x27;父组件提供的方法&#x27;); console.log(&#x27;打印子组件传递过来的参数。参数一：&#x27; + arg1 + &#x27;，参数二：&#x27;+ arg2); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: &#x27;#myTemplate&#x27;, data() &#123; // 子组件的data return &#123; // content: &#x27;子组件私有的数据 content&#x27; &#125; &#125;, props: [&#x27;&#x27;], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // 子组件如果要给父组件传递参数，在触发 emit 的时候，通过参数的形式带出去就可以了 // 【第一步】在子组件里，我们带两个参数出去，传给父组件 this.$emit(&#x27;parent-show&#x27;, &#x27;child 123&#x27;, &#x27;child 789&#x27;); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：（点击&lt;h2&gt;之后） 代码举例2：（将子组件中的data数据传递给父组件，存放到父组件的data中） 在上方代码的基础之上，做改进。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;component1 @parent-show=&#x27;show&#x27;&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=&quot;myTemplate&quot;&gt; &lt;h2 @click=&quot;childClick&quot;&gt;我是子组件，点击调用父组件的方法&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; //父组件的data parentData: null &#125;, methods: &#123; // 定义父组件的方法 show: function (arg) &#123; //【第二步】父组件里放参数，这个参数就代表着子组件中的 child.data console.log(&#x27;父组件提供的方法&#x27;); this.parentData = arg; //将参数arg传递给父组件的data，也就达到了目的：子组件传递数据，赋值给父组件 console.log(&#x27;打印父组件的数据（这是子组件传过来的）：&#x27;+ JSON.stringify(this.parentData)); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: &#x27;#myTemplate&#x27;, data() &#123; // 子组件的data return &#123; childData: &#123; //定义自组件的数据 name: &#x27;smyhvae&#x27;, age: 26 &#125; &#125; &#125;, props: [&#x27;&#x27;], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // 子组件如果要给父组件传递参数，在触发 emit 的时候，通过参数的形式带出去就可以了 // 【第一步】在子组件里，通过传参的形式，把子组件的data，传给父组件 this.$emit(&#x27;parent-show&#x27;, this.childData); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：（点击&lt;h2&gt;之后） 案例：发表评论功能的实现 该案例需要完善，目前只是为了演示 localStorage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap3.3.7.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人： &#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;发表评论&quot; class=&quot;btn btn-primary&quot; @click=&quot;postComment&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = &#123; data() &#123; return &#123; user: &#x27;&#x27;, content: &#x27;&#x27; &#125; &#125;, template: &#x27;#tmpl&#x27;, methods: &#123; postComment() &#123; // 发表评论的方法 // 分析：发表评论的业务逻辑 // 提示：评论数据存到哪里去？？？ 存放到了 localStorage 中 localStorage.setItem(&#x27;cmts&#x27;, &#x27;&#x27;) // 1. 先组织出一个最新的评论数据对象 // 2. 想办法，把 第一步中，得到的评论对象，保存到 localStorage 中（注意：localStorage 只支持存放字符串数据， 因此要先调用 JSON.stringify） // 2.1 在保存 最新的 评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个 数组对象， 然后，把最新的评论， push 到这个数组 // 注意：如果获取到的 localStorage 中的 评论字符串，为空不存在， 则 可以 返回一个 &#x27;[]&#x27; // 2.2 把 最新的 评论列表数组，再次调用 JSON.stringify 转为 数组字符串，然后调用 localStorage.setItem() var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; // 第一步：一开始，从 localStorage 中获取已存在的评论 var list = JSON.parse(localStorage.getItem(&#x27;cmts&#x27;) || &#x27;[]&#x27;) //获取已存在的评论数据。【重要】需要考虑空字符串的可能性，否则返回的是undefined // 第二步：添加新的评论item list.unshift(comment) // 第三步：重新保存最新的 评论数据 到 localStorage 中 localStorage.setItem(&#x27;cmts&#x27;, JSON.stringify(list)) this.user = this.content = &#x27;&#x27; // this.loadComments() // ????? this.$emit(&#x27;func&#x27;) &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [ &#123; id: Date.now(), user: &#x27;李白&#x27;, content: &#x27;天生我材必有用&#x27; &#125;, &#123; id: Date.now(), user: &#x27;江小白&#x27;, content: &#x27;劝君更尽一杯酒&#x27; &#125;, &#123; id: Date.now(), user: &#x27;小马&#x27;, content: &#x27;我姓马， 风吹草低见牛羊的马&#x27; &#125; ] &#125;, beforeCreate() &#123; // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好 &#125;, created() &#123; //页面一开始加载的时候，就去读取 localStorage 中已存在的评论list this.loadComments() &#125;, methods: &#123; loadComments() &#123; // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem(&#x27;cmts&#x27;) || &#x27;[]&#x27;) this.list = list &#125; &#125;, components: &#123; &#x27;cmt-box&#x27;: commentBox &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，父组件定义了loadComments()方法，作用是加载 localStorage 中的评论列表。我们可以看到，页面在一开始加载的时候，就在create()生命周期中调用了loadComments()；当自组件中添加了评论之后，再次调用了loadComments()。 待改进： 不过，这段代码还有些问题：页面一开始加载的时候，读取的是 localStorage 中的评论列表。如果一开始的时候，从网络获取了已存在的列表，岂不是读不到了？ 正确的做法应该是：父组件和子组件共享 list数据，每当在子组件中 添加了一条评论之后，就往 list 中添加一条 item。 在Vue中，通过 ref 属性获取DOM元素我们当然可以使用JS原生的做法（document.getElementById）或者 jQuery 来获取DOM，但是这种做法却在无形中操作了DOM，在Vue框架中并不推荐这种做法。 我们可以通过ref属性获取DOM元素。 ref的英文单词是reference，表示引用。我们平时可以经常看到控制台会报错referenceError的错误，就和引用类型的数据有关。 在Vue中，通过 ref 属性获取DOM元素的步骤： （1）第一步：在标签中给 DOM 元素设置 ref 属性。 1&lt;h3 id=&quot;myH3&quot; ref=&quot;myTitle&quot;&gt; 今天天气太好了&lt;/h3&gt; （2）第二步：通过 this.this.$refs.xxx 获取 DOM 元素 1console.log(this.$refs.myTitle.innerText) 举例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第一步：在标签中给 DOM 元素设置 ref 属性 --&gt; &lt;h3 id=&quot;myH3&quot; ref=&quot;myTitle&quot;&gt; 今天天气太好了&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;按钮元素&quot; @click=&quot;getElement&quot; ref=&quot;myBtn&quot;&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &#x27;&lt;h1&gt;登录组件&lt;/h1&gt;&#x27;, data() &#123; return &#123; msg: &#x27;son msg&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;调用了子组件的方法&#x27;) &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; getElement() &#123; // 原生js获取DOM元素 // console.log(document.getElementById(&#x27;myTitle&#x27;).innerText) // 第二步：通过 this.this.$refs.xxx 获取 DOM 元素 console.log(this.$refs.myTitle.innerText) &#125; &#125;, components: &#123; login &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行上方代码，然后我们在控制台输入vm，就可以看到： 使用 ref 属性获取整个子组件根据上面的例子，我们可以得出规律：只要ref属性加在了DOM元素身上，我们就可以获取这个DOM元素。 那我们可以通过ref属性获取整个Vue子组件吗？当然可以。这样做的意义是：**在父组件中通过ref属性拿到了子组件之后，就可以进一步拿到子组件中的data和method。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击按钮&quot; @click=&quot;getElement&quot;&gt; &lt;login-component ref=&quot;loginTemplate&quot;&gt;&lt;/login-component&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; getElement() &#123; //在父组件中，通过ref获取整个子组件，进而获取子组件的data console.log(this.$refs.loginTemplate.myData) //在父组件中，通过ref获取整个子组件，进而获取子组件的method this.$refs.loginTemplate.showMethod() &#125; &#125;, components: &#123; &#x27;login-component&#x27;: &#123; template: &#x27;&lt;h1&gt;登录组件&lt;/h1&gt;&#x27;, data() &#123; return &#123; myData: &#x27;子组件的data&#x27; &#125; &#125;, methods: &#123; showMethod() &#123; console.log(&#x27;调用子组件的method&#x27;) &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行代码，点击按钮后，效果如下： 我们直接在控制台输入vm，可以看到：","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/05-Vue组件的定义和注册","date":"2021-08-06T01:17:25.952Z","updated":"2021-07-28T07:34:11.378Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/05-Vue组件的定义和注册/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/05-Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%B3%A8%E5%86%8C/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言什么是组件组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可。 模块化和组件化的区别 模块化：是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一 组件化：是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用 全局组件的定义和注册组件Component是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。 全局组件的定义和注册有三种方式，我们接下来讲一讲。 写法一写法一：使用Vue.extend方法定义组件，使用 Vue.component方法注册组件。 代码举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 如果要使用组件，直接把组件的名称，以 HTML 标签的形式，引入到页面中，即可 --&gt; &lt;account&gt; &lt;/account&gt; &lt;/div&gt; &lt;script&gt; //第一步：使用 Vue.extend 定义组件 var myAccount = Vue.extend(&#123; template: &#x27;&lt;div&gt;&lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt;&lt;/div&gt;&#x27; // 通过 template 属性，指定了组件要展示的HTML结构。template 是 Vue 中的关键字，不能改。 &#125;); //第二步：使用 Vue.component 注册组件 // Vue.component(&#x27;组件的名称&#x27;, 创建出来的组件模板对象) Vue.component(&#x27;account&#x27;, myAccount); //第一个参数是组件的名称（标签名），第二个参数是模板对象 new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，在注册组件时，第一个参数是标签名，第二个参数是组件的定义。 运行结果如下： 代码截图如下： 上图中，注意两点： 注意1、红框部分，要保证二者的名字是一致的。如果在注册时，组件的名称是驼峰命名，比如： 1Vue.component(&#x27;myComponent&#x27;, myAccount); //第一个参数是组件的名称（标签名），第二个参数是模板对象 那么，在标签中使用组件时，需要把大写的驼峰改为小写的字母，同时两个单词之间使用-进行连接： 12&lt;my-component&gt; &lt;/my-component&gt; 所以，为了避免名字不一致的问题，我们注册组件时，组件的名称可以直接写成my-component。比如：（避免驼峰不一致的建议写法） 1Vue.component(&#x27;my-component&#x27;, myAccount); 注意2、绿框部分，一定要用一个大的根元素（例如&lt;div&gt;）包裹起来。如果我写成下面这样，就没有预期的效果： 1template: &#x27;&lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt;&#x27; 结果如下：（并非预期的效果） 写法二写法二：Vue.component方法定义、注册组件（一步到位）。 代码如下： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;account&gt; &lt;/account&gt; &lt;/div&gt; &lt;script&gt; //定义、注册组件：第一个参数是组件的名称（标签名），第二个参数是组件的定义 Vue.component(&#x27;account&#x27;, &#123; template: &#x27;&lt;div&gt;&lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt;&lt;/div&gt;&#x27; // template 是 Vue 中的关键字，不能改。 &#125;); new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码截图如下： 上图中，同样注意两点： 1、红框部分，要保证二者的名字是一致的。 2、绿框部分，一定要用一个大的根元素（例如&lt;div&gt;）包裹起来。如果我写成下面这样，就没有预期的效果： 1template: &#x27;&lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt;&#x27; 结果如下：（并非预期的效果） 写法三【荐】 上面的写法一、写法二并不是很智能，因为在定义模板的时候，没有智能提示和高亮，容易出错。我们不妨来看看写法三。 写法三：将组件内容定义到template标签中去。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义模板 --&gt; &lt;template id=&quot;myAccount&quot;&gt; &lt;div&gt; &lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用组件 --&gt; &lt;account&gt; &lt;/account&gt; &lt;/div&gt; &lt;script&gt; //定义、注册组件 Vue.component(&#x27;account&#x27;, &#123; template: &#x27;#myAccount&#x27; // template 是 Vue 中的关键字，不能改。 &#125;); new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码截图如下： 写法三其实和方法二差不多，无非是把绿框部分的内容，单独放在了&lt;template&gt;标签中而已，这样有利于 html 标签的书写。 使用components定义私有组件我们在上一段中定义的是全局组件，这样做的时候，多个Vue实例都可以使用这个组件。 我们还可以在一个Vue实例的内部定义私有组件，这样做的时候，只有当前这个Vue实例才可以使用这个组件。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 使用Vue实例内部的私有组件 --&gt; &lt;my-login&gt;&lt;/my-login&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components: &#123; // 定义、注册Vue实例内部的私有组件 myLogin: &#123; template: &#x27;&lt;h3&gt;这是私有的login组件&lt;/h3&gt;&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 【荐】当然，我们还可以把模板的定义存放在&lt;template&gt;标签中，这样的话，模板里的html标签就可以出现智能提示和高亮，避免出错。如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义模板 --&gt; &lt;template id=&quot;loginTmp&quot;&gt; &lt;h3&gt;这是私有的login组件&lt;/h3&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 调用Vue实例内部的私有组件 --&gt; &lt;my-login&gt;&lt;/my-login&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components: &#123; // 定义、注册Vue实例内部的私有组件 myLogin: &#123; template: &#x27;#loginTmp&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果不变。 上方代码中，如果在注册私有组件时，组件的名称是驼峰命名，比如： 12345components: &#123; // 定义、注册Vue实例内部的私有组件 myLogin: &#123; template: &#x27;#loginTmp&#x27; &#125;&#125; 那么，在标签中使用组件时，需要把大写的驼峰改为小写的字母，同时两个单词之间使用-进行连接： 1&lt;my-login&gt;&lt;/my-login&gt; 所以，为了避免名字不一致的问题，我们注册组件时，组件的名称可以直接写成my-login。比如：（避免驼峰不一致的建议写法） 12345components: &#123; // 定义、注册Vue实例内部的私有组件 `my-login`: &#123; template: &#x27;#loginTmp&#x27; &#125;&#125; 为组件添加 data 和 methods既然组件是一个页面，那么，页面中可能会有一些功能要动态展示。因此，我们有必要为组件添加 data 和 methods。 代码举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义组件的模板 --&gt; &lt;template id=&quot;myAccount&quot;&gt; &lt;div&gt; &lt;!-- 在组件的模板中，调用本组件中的data --&gt; &#123;&#123;myData&#125;&#125; &lt;a href=&quot;#&quot; v-on:click=&quot;login&quot;&gt;登录1&lt;/a&gt; &lt;h2&gt;登录页面&lt;/h2&gt; &lt;h3&gt;注册页面&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第一次调用组件 --&gt; &lt;account&gt; &lt;/account&gt; &lt;!-- 第二次调用组件 --&gt; &lt;account&gt; &lt;/account&gt; &lt;/div&gt; &lt;script&gt; //定义、注册组件 Vue.component(&#x27;account&#x27;, &#123; template: &#x27;#myAccount&#x27;, //组件中的 data //【注意】组件中的data，不再是对象，而是一个方法（否则报错）；而且这个方法内部，还必须返回一个对象才行 // 组件中 的data 数据,使用方式,和实例中的 data 使用方式完全一样!!! data: function () &#123; return &#123; myData: &#x27;smyhvae&#x27; &#125; &#125;, //组件中的 method methods: &#123; login: function () &#123; alert(&#x27;login操作&#x27;); &#125; &#125; &#125;); new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码所示，我们在account组件中添加的data 和 methods，其作用域只限于account组件里，保证独立性。 注意，在为组件添加数据时，data不再是对象了，而是function，而且要通过 return的形式进行返回；否则，页面上是无法看到效果的。通过 function返回对象的形式来定义data，作用是： 上方代码中，组件&lt;account&gt;被调用了两次（不像根组件那样只能调用一次），但是每个组件里的数据 myData是各自独立的，不产生冲突。 换而言之，通过函数返回对象的目的，是为了让每个组件都有自己独立的数据存储，而不应该共享一套数据。 为什么组件的data必须是一个function我们先来看下面这样的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第一次调用组件 --&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;!-- 第二次调用组件 --&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;!-- 定义模板 --&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;让count加1&quot; @click=&quot;increment&quot;&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;#tmpl&#x27;, data: function () &#123; return dataObj //当我们return全局的dataObj的时候，子组件们会共享这个dataObj &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： 上面的例子中，将组件&lt;counter&gt;调用了两次，由于dataObj是全局对象，导致两个组件实例都可以共享这个dataObj数据。于是，我们点击任何一个组件实例的按钮，都可以让count数据加1。 现在问题来了，如果我们想让组件&lt;counter&gt;的两个实例去单独操作count数据，应该怎么做呢？我们应该修改 data中 return出去的内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;让count加1&quot; @click=&quot;increment&quot;&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component(&#x27;counter&#x27;, &#123; template: &#x27;#tmpl&#x27;, data: function () &#123; // return dataObj //当我们return全局的dataObj的时候，这个dataObj是共享的 return &#123; count: 0 &#125; // 【重要】return一个**新开辟**的对象数据 &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 如上图所示，每当我们创建一个新的组件实例时，就会调用data函数，data函数里会return一个新开辟的对象数据。这样做，就可以保证每个组件实例有独立的数据存储。 组件的切换使用v-if和v-else结合flag进行切换代码举例：（登录组件/注册组件，二选一） 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 温馨提示：`.prevent`可以阻止超链接的默认事件 --&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=true&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;flag=false&quot;&gt;注册&lt;/a&gt; &lt;!-- 登录组件/注册组件，同时只显示一个 --&gt; &lt;login v-if=&quot;flag&quot;&gt;&lt;/login&gt; &lt;register v-else=&quot;flag&quot;&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： 使用Vue提供的&lt;component&gt;标签实现组件切换上面的例子中，我们是通过flag的值来进行组件的切换。但是，flag的值只可能有两种情况，也就是说，v-if和v-else只能进行两个组件之间的切换。 那如何实现三个甚至三个以上的组件切换呢？这里，我们可以用到Vue提供的&lt;component&gt;标签。 我们先来看一下&lt;component&gt;标签的用法。 基于上面的代码，如果我想让login组件显示出来，借助&lt;component&gt;标签可以这样做： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;Vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt; &lt;!-- 【重要】component 是一个占位符, `:is` 属性,可以用来指定要展示的组件名称。这里，我们让 login 组件显示出来 --&gt; &lt;component :is=&quot;&#x27;login&#x27;&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; comName: &#x27;login&#x27; // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，提取关键代码如下： 1&lt;component :is=&quot;&#x27;login&#x27;&quot;&gt;&lt;/component&gt; 如果我想让register组件显示出来，借助&lt;component&gt;标签可以这样做： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;Vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt; &lt;!-- 【重要】component 是一个占位符, `:is` 属性,可以用来指定要展示的组件名称 --&gt; &lt;component :is=&quot;&#x27;register&#x27;&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; comName: &#x27;login&#x27; // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，提取关键代码如下： 1&lt;component :is=&quot;&#x27;register&#x27;&quot;&gt;&lt;/component&gt; 因此，如果要实现组件之间的切换，我们可以给&lt;component&gt;标签里的is属性值设置为变量即可，来看看代码实现。 实现组件切换的完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 点击按钮后，设置变量`comName`为不同的值，代表着后面的component里显示不同的组件 --&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&#x27;login&#x27;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&#x27;register&#x27;&quot;&gt;注册&lt;/a&gt; &lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt; &lt;!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 --&gt; &lt;!-- 此处的`comName`是变量，变量值为组件名称 --&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; comName: &#x27;login&#x27; // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 多个组件切换时，通过mode属性添加过渡的动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&#x27;login&#x27;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;&quot; @click.prevent=&quot;comName=&#x27;register&#x27;&quot;&gt;注册&lt;/a&gt; &lt;!-- 通过 mode 属性,设置组件切换时候的 过渡动画 --&gt; &lt;!-- 【重点】亮点是 mode=&quot;out-in&quot; 这句话 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component(&#x27;login&#x27;, &#123; template: &#x27;&lt;h3&gt;登录组件&lt;/h3&gt;&#x27; &#125;) Vue.component(&#x27;register&#x27;, &#123; template: &#x27;&lt;h3&gt;注册组件&lt;/h3&gt;&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; comName: &#x27;login&#x27; // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 20180618_2240.gif 如上方代码所示，多个组件切换时，如果要设置动画，可以用&lt;transition&gt;把组件包裹起来。需要注意的是，我给&lt;transition&gt;标签里添加了mode=&quot;out-in&quot;这种模式，它表示第一个组件消失之后，第二个组件才会出现。如果没有这个mode属性，效果如下：（第一个组件准备消失的时候，第二个组件马上就准备出现，这不是我们想要的效果） 20180618_2245.gif 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/04-Vue动画","date":"2021-08-06T01:17:25.949Z","updated":"2021-07-28T07:34:11.378Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/04-Vue动画/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/04-Vue%E5%8A%A8%E7%94%BB/","excerpt":"","text":"04-Vue动画.md 前言动画的作用：提高用户的体验，帮助用户更好的理解页面中的功能。 使用过渡类名实现动画官方文档的截图过渡类名如下： 动画进入： v-enter：动画进入之前的初始状态 v-enter-to：动画进入之后的结束状态 v-enter-active：动画进入的时间段 PS：第一、第二个是时间点；第三个是时间段。 动画离开： v-leave：动画离开之前的初始状态 v-leave-to：动画离开之后的结束状态 v-leave-active：动画离开的时间段 PS：第一、第二个是时间点；第三个是时间段。 使用举例（通过Vue的过渡类名来实现）v-enter-to和v-leave的状态是一样的。而且一般来说，v-enter和v-leave-to的状态也是一致的。所以，我们可以把这四个状态写成两组。 现在我们来做个例子：点击按钮时，让div显示/隐藏。 1、引入： 如果我们不使用动画，应该是这样做： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、使用动画：（通过Vue的过渡类名来实现） 现在，我们加淡入淡出的动画，让div显示和隐藏。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt; &lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all 1s ease; /*期间，设置过渡的属性：all表示所有的属性、时间为1秒、过渡的状态*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们使用vue提供的&lt;transition&gt;标签把需要被动画控制的元素，包裹起来；然后使用.v-enter、.v-leave-to等进行动画的定义。 运行效果如下： 3、再加一个tramsform属性进行位移： 我们在上方代码的基础之上，加一个tramsform属性，让动画有一个位移的效果。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt; &lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; /* 在动画中加入位移 */ transform: translateX(80px); /* smyhvae提示：v-enter表示，一开始让DOM元素处于靠右80px的位置 */ &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all 1s ease; /*期间，设置过渡的属性：all表示所有的属性、时间为1秒、过渡的状态*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 修改过渡类名的前缀在上一小段中，.v-enter、.v-leave-to这些过渡类名都是以v-开头的。这样做，会有一个局限性：假设有两个DOM元素都用&lt;transition&gt;进行了包裹，那这两个DOM元素就都具备了v-中所定义的动画。 那如果我们想把两个DOM元素的动画进行分开定义，该怎么做呢？这里，我们可以通过修改过渡类名的前缀来做。比如： 第一步：（自定义别名） 123&lt;transition name=&quot;my&quot;&gt; &lt;h6 v-if=&quot;flag2&quot;&gt;这是一个H6&lt;/h6&gt;&lt;/transition&gt; 上方代码中，我们加了name=&quot;my&quot;。 第二步：（我们就可以使用 my-enter、.my-leave-to这些类名了） 123456.my-enter,.my-leave-to &#123; opacity: 0; transform: translateY(70px);&#125; 完整代码举例如下； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./lib/vue-2.4.0.js&quot;&gt;&lt;/script&gt; &lt;style&gt; /* 自定义第一组样式，来控制 transition 内部的元素实现动画 */ /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all 0.8s ease; &#125; /* 自定义第二组样式，来控制 transition 内部的元素实现动画。这次，我们通过自己起的别名`name`来作为指令 */ .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(70px); &#125; .my-enter-active, .my-leave-active &#123; transition: all 1s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 第一组 --&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 使用 transition 元素，把 需要被动画控制的元素 h3，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;hr&gt; &lt;!-- 第二组 --&gt; &lt;input type=&quot;button&quot; value=&quot;toggle2&quot; @click=&quot;flag2=!flag2&quot;&gt; &lt;!-- 使用 transition 元素，把 需要被动画控制的元素 h6，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;!-- 【重点】在这里，我们给这个transition定义一个别名，叫`name`，然后，我们就可以通过 `.my-enter`等 来定义动画的样式【重要】 --&gt; &lt;transition name=&quot;my&quot;&gt; &lt;h6 v-if=&quot;flag2&quot;&gt;这是一个H6&lt;/h6&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false, flag2: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： 使用第三方animate.css类库实现动画animate.css网址： 官方网站：https://daneden.github.io/animate.css/ 代码举例： 下面的代码中，我们使用animate.css提供的bounceIn、bounceOut这两个类来做入场、离场的动画。代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;animate3.6.0.css&quot;&gt; &lt;!-- 入场 bounceIn 离场 bounceOut --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，注意： 注意1：enter-active-class和leave-active-class这两个类名是Vue动画里的关键词，不能写成自己随意起的类名。 注意2：bounceIn、bounceOut这两个类不能直接使用，要在前面加上animated这个类；否则动画是不会生效的。当然，上面的代码中，我们还可以把class = animated这个代码移到&lt;h3&gt;标签里，效果是一样的，如下： 12345&lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt;&lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot;&gt; &lt;h3 v-if=&quot;flag&quot; class=&quot;animated&quot;&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 运行效果如下： 改进1：（统一设置入场、出场动画的持续时间） 我们把上面的代码改进一下，如果我们想给入场、出场动画设置持续的时间，可以使用:duration来做。如下： 12345&lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt;&lt;!-- 使用 :duration=&quot;毫秒值&quot; 来统一设置 入场 和 离场 时候的动画时长 --&gt;&lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot; :duration=&quot;500&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 改进2：（分别设置入场、出场动画的持续时间） 12345&lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt;&lt;!-- 使用 :duration=&quot;&#123; enter: 1000, leave: 300 &#125;&quot; 来分别设置 入场的时长 和 离场的时长 --&gt;&lt;transition enter-active-class=&quot;animated bounceIn&quot; leave-active-class=&quot;animated bounceOut&quot; :duration=&quot;&#123; enter: 1000, leave: 300 &#125;&quot;&gt; &lt;h3 v-if=&quot;flag&quot;&gt;这是一个H3&lt;/h3&gt;&lt;/transition&gt; 钩子函数实现半场动画只有出场动画、没有离场动画，这种就是属于半场动画。比如你把一件商品加入收藏，会出现一个动画；当再次点击收藏按钮的时候却看不到动画效果，这就说明，只有前一半才有动画。 半场动画，可以使用钩子函数来实现。 动画的钩子函数介绍可以在属性中声明 JavaScript 钩子函数：（这八个钩子函数可以理解成是动画的生命周期） 12345678910111213&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- DOM元素 --&gt;&lt;/transition&gt; 我们可以这样理解：上面这八个钩子函数（四个入场、四个离场），对应了八个事件，我们要紧接着在methods中定义八个函数。 如果要定义半场动画，做法是：直接在methods中写入场动画的函数，不写离场动画的函数即可。 举例：使用钩子函数模拟小球半场动画现在要实现的例子是：点击按钮后，让小球进行移动。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;加入购物车&quot; @click=&quot;flag=!flag&quot;&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div class=&quot;ball&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: false &#125;, methods: &#123; // 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象 // 我们可以认为 ， el 是通过 document.getElementById(&#x27;&#x27;) 方式获取到的原生JS DOM对象 beforeEnter(el) &#123; // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式 // 设置小球开始动画之前的 起始位置 el.style.transform = &quot;translate(0, 0)&quot; // smyhvae提示：一开始的时候，让小球处于（0，0）的位置 &#125;, enter(el, done) &#123; // 【注意1】el.offsetWidth 这句话，没有实际的作用，但是，如果不写，出不来动画效果。可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth // enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 el.style.transform = &quot;translate(150px, 300px)&quot; // smyhvae 提示：让小球从（0，0）移动到 (150px, 300px) el.style.transition = &#x27;all 1s ease&#x27; // 【注意2】这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用 done() &#125;, afterEnter(el) &#123; // 动画完成之后，会调用 afterEnter // console.log(&#x27;ok&#x27;) // 动画结束后，让小球消失（直接让 flag 取反即可） this.flag = !this.flag // 因为最开始的时候，小球就是处于消失的状态，这行代码可以让小球的动画重新开始 &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下：（我们可以用这种动画效果，做类似于“加入购物车”的动画效果） 上面的代码中，有两个地方要注意： 注意1： el.offsetWidth这行代码不能少。虽然这行代码没有实际的意义，但是少了之后，动画效果出不来： 当然，我们也可以把这行代码换成el.offsetHeight、el.offsetLeft、el.offsetTop之类的，只要包含了offset就行。 注意2： enter()函数里，函数的第二个参数要加上done，函数体的最后一行要写done()，表示立即执行后面的afterEnter()函数；如果没有这个done，则会延迟执行后面的afterEnter()函数： Vue官方文档的解释是这样： 当只用 JavaScript 过渡的时候，在enter和leave中必须使用done进行回调。否则，它们将被同步调用，过渡会立即完成。 使用transition-group元素实现列表动画现在的场景是：在一个&lt;ul&gt;列表中，如果我想给指定的某个li添加动画效果，该怎么做呢？（需要声明的是，这些li是用v-for循环进行遍历的） 如果我们用&lt;transition&gt;把li包裹起来，就会让所有的li都具备了动画，这显然是不可取的。 那该怎么做呢？这里我们就可以用transition-group进行包裹。 代码举例1：点击添加按钮后，给新增的 item 加个动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; /*鼠标悬停时，出现背景色。让这个背景色的出现，也加一个淡入的动画*/ &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;transition-group&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;赵高&#x27; &#125;, &#123; id: 2, name: &#x27;秦桧&#x27; &#125;, &#123; id: 3, name: &#x27;严嵩&#x27; &#125;, &#123; id: 4, name: &#x27;魏忠贤&#x27; &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = &#x27;&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： 改进1：添加删除item的功能 基于上面的代码，我们来添加删除item的功能，代码本应该是这样写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; /*鼠标悬停时，出现背景色。让这个背景色的出现，也加一个淡入的动画*/ &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;transition-group&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;赵高&#x27; &#125;, &#123; id: 2, name: &#x27;秦桧&#x27; &#125;, &#123; id: 3, name: &#x27;严嵩&#x27; &#125;, &#123; id: 4, name: &#x27;魏忠贤&#x27; &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = &#x27;&#x27; &#125;, del(i) &#123; this.list.splice(i, 1); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： **改进2:**： 上图中，我们发现，当我删除第2个item时，第3、第4个item在往上移动的过程比会较突兀。为了改进这个地方，我们可以给.v-move、.v-leave-active加一些动画属性。最终，完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; /*鼠标悬停时，出现背景色。让这个背景色的出现，也加一个淡入的动画*/ &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */ .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active &#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;transition-group&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;赵高&#x27; &#125;, &#123; id: 2, name: &#x27;秦桧&#x27; &#125;, &#123; id: 3, name: &#x27;严嵩&#x27; &#125;, &#123; id: 4, name: &#x27;魏忠贤&#x27; &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = &#x27;&#x27; &#125;, del(i) &#123; this.list.splice(i, 1); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果如下： transition-group中appear和tag属性的作用我们可以在上面的代码基础之上，给transition-group加上appear属性，这样的话，可以让transition-group包裹的所有DOM元素在刷新时，有淡入效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */ .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active &#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt; &lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;赵高&#x27; &#125;, &#123; id: 2, name: &#x27;秦桧&#x27; &#125;, &#123; id: 3, name: &#x27;严嵩&#x27; &#125;, &#123; id: 4, name: &#x27;魏忠贤&#x27; &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = &#x27;&#x27; &#125;, del(i) &#123; this.list.splice(i, 1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改进：transition-group的tag属性 上面的代码中，我们审查一下代码元素会发现，用transition-group包裹的元素，会被默认套上一层&lt;span&gt;： 这个&lt;span&gt;虽然没有太大副作用，但是不符合代码规范。为了解决这个问题，我们可以通过tag属性给transition-group包谷的元素套上一层&lt;ul&gt;，然后把现有的&lt;ul&gt;注释掉，就可以了。最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 */ .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active &#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt; &lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot; @click=&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;赵高&#x27; &#125;, &#123; id: 2, name: &#x27;秦桧&#x27; &#125;, &#123; id: 3, name: &#x27;严嵩&#x27; &#125;, &#123; id: 4, name: &#x27;魏忠贤&#x27; &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = &#x27;&#x27; &#125;, del(i) &#123; this.list.splice(i, 1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样的话，审查元素的效果如下：","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/03-Vue中的Ajax请求","date":"2021-08-06T01:17:25.947Z","updated":"2021-07-28T07:34:11.377Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/03-Vue中的Ajax请求/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/03-Vue%E4%B8%AD%E7%9A%84Ajax%E8%AF%B7%E6%B1%82/","excerpt":"","text":"vue-resource的介绍vue-resource是Vue高度集成的第三方包。 官网链接： 文档（http相关）：https://github.com/pagekit/vue-resource/blob/master/docs/http.md vue-resource 依赖于 Vue。所以，我们要按照先后顺序，导入vue.js和vue-resource.js文件。 解释： vue.js文件向Windows对象暴露了Vue这个关键词；vue-resource.js向Vue身上挂载了this.$http这个属性。于是，我们可以直接写this.$http.get或者this.$http.post或者this.$http.jsonp来调用。 vue-resource 发送Ajax请求常见的数据请求类型包括：get、post、jsonp。下面我们分别讲一讲。 get 请求格式举例： 12345678this.$http.get(url) .then(function (result) &#123; // 当发起get请求之后，通过 .then 来设置成功的回调函数 console.log(result.body); // response.body就是服务器返回的成功的数据 var result = result.body; &#125;, function (err) &#123; //err是异常数据 &#125;); 获取到的response.body就是要获取的数据，但直接打印出来是 object，所以要记得转成string。 举例：获取数据 现规定，获取品牌数据的 api 接口说明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; width: 800px; margin: 20px auto; &#125; #tb &#123; width: 800px; border-collapse: collapse; margin: 20px auto; &#125; #tb th &#123; background-color: #0094ff; color: white; font-size: 16px; padding: 5px; text-align: center; border: 1px solid black; &#125; #tb td &#123; padding: 5px; text-align: center; border: 1px solid black; &#125; &lt;/style&gt; &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../vue-resource121.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;pname&quot;&gt; &lt;button&gt;添加数据&lt;/button&gt; &lt;table id=&quot;tb&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el :&#x27;#app&#x27;, data:&#123; list:[] &#125;, // Vue对象实例创建成功以后就会自动调用这个方法 created:function()&#123; this.getlist(); &#125;, methods:&#123; getlist:function()&#123; // 请求服务器的api获取到品牌的数据列表 this.$http.get(&#x27;http://vueapi.ittun.com/api/getprodlist&#x27;) .then(function(response)&#123; // 1、处理服务器异常信息提示 if(response.body.status != 0)&#123; alert(response.body.message); return; &#125; // 2、处理正常的数据逻辑 this.list = response.body.message; //直接将数据放到list数组当中，页面就会自动显示 console.log(this.list); &#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 上方代码中，我们用到了生命周期函数created，意思是：程序一加载，就马上在created这个函数里执行getlist()方法。 运行的结果如下： 如果我直接在浏览器中输入请求的url，获取的json数据如下：（可以看到，这种方式获取的是相同的数据） post请求格式举例： 123456789// 方法：$http.post(url, 传给服务器的请求体中的数据， &#123;emulateJSON:true&#125;)// 通过 post 方法的第三个参数&#123; emulateJSON: true &#125; ，来设置 提交的内容类型 为 普通表单数据格式this.$http.post(url, &#123; name: &#x27;奔驰&#x27; &#125;, &#123; emulateJSON: true &#125;) .then(function (response) &#123; alert(response.body.message); &#125;, function (error) &#123; &#125;); 上方代码中，post()方法中有三个参数，其中第三个参数是固定值，照着写就可以了。 代码举例：（添加数据） 现规定，添加品牌数据的 api 接口说明如下： 代码如下：（在上一段代码的基础之上，添加代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; width: 800px; margin: 20px auto; &#125; #tb &#123; width: 800px; border-collapse: collapse; margin: 20px auto; &#125; #tb th &#123; background-color: #0094ff; color: white; font-size: 16px; padding: 5px; text-align: center; border: 1px solid black; &#125; #tb td &#123; padding: 5px; text-align: center; border: 1px solid black; &#125; &lt;/style&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource121.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;pname&quot;&gt; &lt;button @click=&quot;adddata&quot;&gt;添加数据&lt;/button&gt; &lt;table id=&quot;tb&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; pname: &#x27;&#x27;, //这个 pname 是我在输入框里添加的数据。我们要把这个传给服务器 list: [] &#125;, // Vue对象实例创建成功以后就会自动调用这个方法 created: function () &#123; this.getlist(); &#125;, methods: &#123; //ajax请求：添加数据 adddata: function () &#123; // 1、获取用户填写的文本框的值只需要通过this.pname即可 // 2、调用ajax的post方法将数据上传到服务器 var url = &#x27;http://vueapi.ittun.com/api/addproduct&#x27;; var postData = &#123; name: this.pname &#125;; //【重要】键`name`是json中约定好的字段。我们把这个字段传给服务器 var options = &#123; emulateJSON: true &#125;; this.$http.post(url, postData, options).then(function (response) &#123; if (response.body.status != 0) &#123; alert(response.body.message); return; &#125; this.pname = &#x27;&#x27;; // 3、添加完成后，只需要手动再调用一次getlist（将列表数据重新加载一次），即可刷新页面上的数据 this.getlist(); &#125;); &#125;, //ajax请求：获取数据 getlist: function () &#123; this.$http.get(&#x27;http://vueapi.ittun.com/api/getprodlist&#x27;) .then(function (response) &#123; // 1、处理服务器异常信息提示 if (response.body.status != 0) &#123; alert(response.body.message); return; &#125; // 2、处理正常的数据逻辑 this.list = response.body.message; console.log(this.list); &#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 代码举例：（删除数据） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; width: 800px; margin: 20px auto; &#125; #tb &#123; width: 800px; border-collapse: collapse; margin: 20px auto; &#125; #tb th &#123; background-color: #0094ff; color: white; font-size: 16px; padding: 5px; text-align: center; border: 1px solid black; &#125; #tb td &#123; padding: 5px; text-align: center; border: 1px solid black; &#125; &lt;/style&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;vue-resource121.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;pname&quot;&gt; &lt;button @click=&quot;adddata&quot;&gt;添加数据&lt;/button&gt; &lt;table id=&quot;tb&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!-- 具体要删除哪个item，不能写死。所以要根据id来删 --&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;deldata(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; pname: &#x27;&#x27;, //这个 pname 是我在输入框里添加的数据。我们要把这个传给服务器 list: [] &#125;, // Vue对象实例创建成功以后就会自动调用这个方法 created: function () &#123; this.getlist(); &#125;, methods: &#123; //ajax请求：添加数据 adddata: function () &#123; // 1、获取用户填写的文本框的值只需要通过this.pname即可 // 2、调用ajax的post方法将数据上传到服务器 var url = &#x27;http://vueapi.ittun.com/api/addproduct&#x27;; var postData = &#123; name: this.pname &#125;; //【重要】键`name`是json中约定好的字段。我们把这个字段传给服务器 var options = &#123; emulateJSON: true &#125;; this.$http.post(url, postData, options).then(function (response) &#123; if (response.body.status != 0) &#123; alert(response.body.message); return; &#125; this.pname = &#x27;&#x27;; // 3、直接将列表数据重新加载一次，即可刷新页面上的数据 this.getlist(); &#125;); &#125;, //ajax请求：获取数据 getlist: function () &#123; this.$http.get(&#x27;http://vueapi.ittun.com/api/getprodlist&#x27;) .then(function (response) &#123; // 1、处理服务器异常信息提示 if (response.body.status != 0) &#123; alert(response.body.message); return; &#125; // 2、处理正常的数据逻辑 this.list = response.body.message; console.log(this.list); &#125;); &#125;, // ajax请求：删除数据 deldata: function (id) &#123; this.$http.get(&#x27;http://vueapi.ittun.com/api/delproduct/&#x27; + id) .then(function (response) &#123; if (response.body.status != 0) &#123; alert(response.body.message); return; &#125; // 刷新列表 this.getlist(); &#125;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; jsonp 格式举例： 12345678// 利用vue-resource中的jsonp方法实现跨域请求数据，这里要注意的是：// url后面不需要跟callback=fn这个参数了，jsonp方法会自动加上this.$http.jsonp(&#x27;http://vuecms.ittun.com/api/getlunbo?id=1&#x27;) .then(function (response) &#123; console.log(JSON.stringify(response.body)); &#125;, function (err) &#123; //err是异常数据 &#125;); 请求结果： JSONP的实现原理由于浏览器的安全性限制，默认不允许Ajax发起跨域（协议不同、域名不同、端口号不同）的请求。浏览器认为这种访问不安全。 JSONP的实现原理：通过动态创建script标签的形式，用script标签的src属性，代表api接口的url，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）。 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的api接口； 服务器api接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了 axios除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求。 通过Vue全局配置api接口的url地址api接口的url地址包括：绝对路径+相对路径。 我们在做Ajax请求的时候，所填写的url建议填相对路径，然后把绝对路径放在全局的位置。 Vue就提供了这个功能。举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则 不会启用根路径做拼接； Vue.http.options.root = &#x27;http://smyhvae/&#x27;; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;&#x27;, list: [ // 存放所有品牌列表的数组 ] &#125;, created() &#123; // 当 vm 实例 的 data 和 methods 初始化完毕后，vm实例会自动执行created 这个生命周期函数 this.getAllList() &#125;, methods: &#123; getAllList() &#123; // 获取所有的品牌列表 // 分析： // 1. 由于已经导入了 Vue-resource这个包，所以 ，可以直接通过 this.$http 来发起数据请求 // 2. 根据接口API文档，知道，获取列表的时候，应该发起一个 get 请求 // 3. this.$http.get(&#x27;url&#x27;).then(function(result)&#123;&#125;) // 4. 当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result // 5. 先判断 result.status 是否等于0，如果等于0，就成功了，可以 把 result.message 赋值给 this.list ; 如果不等于0，可以弹框提醒，获取数据失败！ this.$http.get(&#x27;api/getprodlist&#x27;).then(result =&gt; &#123; // 注意： 通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if (result.status === 0) &#123; // 成功了 this.list = result.message &#125; else &#123; // 失败了 alert(&#x27;获取数据失败！&#x27;) &#125; &#125;) &#125; &#125; &#125;);&lt;/script&gt; 如上方代码所示，第一步是在全局的位置写绝对路径： 1Vue.http.options.root = &#x27;http://smyhvae/&#x27;; 第二步是在Ajax请求的url中写相对路径：（注意，前面不要带/） 1this.$http.get(&#x27;api/getprodlist&#x27;)","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/02-Vue实例的生命周期函数","date":"2021-08-06T01:17:25.944Z","updated":"2021-07-28T07:34:11.377Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/02-Vue实例的生命周期函数/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/02-Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"介绍 vue实例的生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。 生命周期钩子：就是生命周期事件的别名而已。 生命周期钩子 = 生命周期函数 = 生命周期事件。 生命周期函数的主要分类 根据上面这张图，我们把生命周期函数主要分为三类。 1、创建期间的生命周期函数 beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板。我们可以在这里进行Ajax请求。 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示。（mounted之后，表示真实DOM渲染完了，可以操作DOM了） 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;hello vuejs&#x27; &#125;, // 这是第1个生命周期函数，表示实例完全被创建出来之前，会执行它 beforeCreate: function () &#123; console.log(&#x27;01 beforeCreate&#x27;, this.msg); //注意：在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, // 这是第2个生命周期函数 created: function () &#123; console.log(&#x27;02 created&#x27;, this.msg); //注意：如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, // 这是第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 beforeMount: function () &#123; console.log(&#x27;03 beforeMount&#x27;, this.msg); // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, // 这是第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 mounted: function () &#123; console.log(&#x27;04 mounted&#x27;, this.msg); // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了 // 此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 打印结果： 运行期间的生命周期函数 beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。 PS：数据发生变化时，会触发这两个方法。不过，我们一般用watch来做。 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改flag&quot; @click=&quot;myMethod&quot;&gt; &lt;h3 id=&quot;h3&quot;&gt;&#123;&#123; flag &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;hello vue&#x27;, flag: false &#125;, methods: &#123; myMethod: function () &#123; this.flag = true; &#125; &#125;, // 接下来的是运行中的两个事件 // 这时候，我们的界面还没有被更新【但是，数据被更新了吗？ 数据肯定被更新了】 beforeUpdate() &#123; console.log(&#x27;-------------05 beforeUpdate&#x27;, this.msg); // 结论：当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 console.log(&#x27;界面上DOM元素显示的内容：&#x27; + document.getElementById(&#x27;h3&#x27;).innerText) console.log(&#x27;data 中的 msg 数据：&#x27; + this.flag) &#125;, updated() &#123; console.log(&#x27;-------------06 updated&#x27;, this.msg); // 结论：updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 console.log(&#x27;界面上DOM元素显示的内容：&#x27; + document.getElementById(&#x27;h3&#x27;).innerText) console.log(&#x27;data 中的 msg 数据：&#x27; + this.flag) &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 当我们点击按钮后，运行效果是： 可以看出： 当执行 beforeUpdate 的时候，页面中的显示的数据还是旧的，但此时 data 数据是最新的 updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 3、销毁期间的生命周期函数 beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 PS：可以在beforeDestory里清除定时器、或清除事件绑定。 生命周期函数图解 PS：图片来自网络。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-06.自定义按键修饰符&自定义指令","date":"2021-08-06T01:17:25.942Z","updated":"2021-07-28T07:34:11.376Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-06.自定义按键修饰符&自定义指令/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-06.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6&%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"v-on的按键修饰符Vue 内置的按键修饰符通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下： Vue内置的按键修饰符： 12345678910.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right1.0.8+版本：支持单字母的按键别名。 比如说，keyup指的是：键盘（任何键位）抬起时的监听事件。.enter指的是：按enter键的按键修饰符。我们把这两个结合起来看看。 @keyup.enter举例：按enter键后的监听事件 @keyup.enter=&quot;addData&quot;表示：按住enter键后，执行addData()方法。全称是v-on:key.enter=&quot;addData&quot;。 我们还是拿01-04这篇文章中的列表功能来举例。之前是点击“添加”按钮后，列表中会添加一个item。现在要求：在输入框中按enter键后，也能添加一个item。 核心代码如下： 1&lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot; @keyup.enter=&quot;addData&quot;&gt; 注意，如果写成@keyup=&quot;addData&quot;，效果却是：只要键盘的任何键位打了字（还没来得及按enter键），就会执行addData()方法，这种效果显然不是我们想要的。所以要加上修饰符.enter，表示只针对enter键。 自定义的按键修饰符如果我们直接在代码的&lt;input&gt;标签里写@keyup.f2=&quot;addData&quot;，那么，按住「F2键」后，是没有效果的，因为「F2键」不是内置的按键修饰符（如果F2不能验证，你可以试一下F7）。 我们知道，每个按键都有一个键盘码。参考链接： js 里面的键盘事件对应的键码 通过查阅，我们知道了「F2键」的键盘码为113，那代码可以这样写：（按住F2键后，执行 addData 方法） 1&lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot; @keyup.113=&quot;addData&quot;&gt; 虽然键盘码很全，但是不好记呀。于是，接下来，我们给键盘码定义别名。 自定义全局按键修饰符： 12//自定义全局按键修饰符Vue.config.keyCodes.f2 = 113; 上方代码的书写位置，与自定义全局过滤器的位置，是并列的。 然后，我们就可以使用键盘码的别名了。 自定义全局指令自定义全局指令的举例1举例1：让指定文本框自动获取焦点 如果我们想实现这个例子，原生js的写法是： 12//原生js写法：网页一打开，就让指定的输入框自动获取焦点document.getElementById(&#x27;search&#x27;).focus() 代码的位置： 但我们不建议这样做。我们可以通过Vue中的自定义指令来实现这个例子。步骤如下。 （1）使用Vue.directive()自定义全局指令： 12345678910111213141516171819//自定义全局指令 v-focus：让文本框自动获取焦点//参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀//参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作Vue.directive(&#x27;focus&#x27;, &#123; //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 &#125;&#125;) 上方的代码中，如果我们把el.focus()这行代码写在bind方法里，是没有效果的（但不会报错）。没有效果是因为，在执行到bind方法的时候，元素还没有插入到dom中去。 由此可以看看出：bind、inserted、updated这三个钩子函数的执行时机不同，且执行的次数有区别。 （2）在指定的文本框上加``： 1&lt;input type=&quot;text&quot; id=&quot;search&quot; v-model=&quot;keywords&quot; v-focus&gt; 完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 搜索框： &lt;input type=&quot;text&quot; id=&quot;search&quot; v-model=&quot;name&quot; v-focus&gt; &lt;/div&gt; &lt;script&gt; //自定义全局指令 v-focus，让文本框自动获取焦点 //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀 //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(&#x27;focus&#x27;, &#123; //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;smyhvae&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义全局指令：使用钩子函数的第二个binding参数拿到传递的值举例2：设置DOM元素的color样式 参考举例1中的写法，我们可能会这样给DOM元素设置样式： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 搜索框： &lt;input type=&quot;text&quot; id=&quot;search&quot; v-model=&quot;name&quot; v-color&gt; &lt;/div&gt; &lt;script&gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(&#x27;color&#x27;, &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 el.style.color = &#x27;red&#x27;; &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如上方代码所示，我们自定义了一个指令v-color，然后在input标签中用上了这个指令，就给元素设置了color属性。但是这个代码有个弊端是：color的属性值在定义指令的时候，被写死了。如何完善呢？我们可以在DOM元素中传参。一起来看看。 代码如下：【荐】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 搜索框1： &lt;input type=&quot;text&quot; id=&quot;search&quot; v-model=&quot;name&quot; v-color=&quot;&#x27;green&#x27;&quot;&gt; &lt;/div&gt; &lt;script&gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(&#x27;color&#x27;, &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 // 意思是说，我们可以把样式的代码写到bind中去（即使这个时候，dom元素还没有被创建） bind: function (el, binding) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 console.log(binding.name); //打印结果：color console.log(binding.value); //打印结果：green console.log(binding.expression); //&#x27;green&#x27; el.style.color = binding.value// 通过bining拿到v-color中传递过来的值 &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;smyhvae&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中,bind方法里传递的第二个参数binding，可以拿到DOM元素中v-color里填的值。注意，v-color=&quot;&#39;green&#39;&quot;，这里面写的是字符串常量；如果去掉单引号，就成了变量，不是我们想要的。 效果： 自定义全局指令的简写形式： 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式： 123Vue.directive(&#x27;color&#x27;, function (el, binding) &#123; //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.color = binding.value&#125;) 自定义私有指令自定义私有指令：在某一个 vue 对象内部自定义的指令称之为私有指令。这种指令只有在当前vue对象的el指定的监管区域有用。 代码举例：（设置文字的font-weight属性） 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span v-fontweight=&quot;600&quot;&gt;生命壹号&lt;/span&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;smyhvae&#x27; &#125;, //自定义私有指令 directives: &#123; &#x27;fontweight&#x27;: &#123; bind: function (el, binding) &#123; el.style.fontWeight = binding.value; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 注意， el.style.fontWeight设置属性值，至少要600，否则看不到加粗的效果。 自定义私有指令的简写形式： 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式： 123456//自定义私有指令（简写形式）directives: &#123; &#x27;fontweight&#x27;: function (el, binding) &#123; //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.fontWeight = binding.value; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-05.自定义过滤器：时间格式化举例","date":"2021-08-06T01:17:25.940Z","updated":"2021-07-28T07:34:11.376Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-05.自定义过滤器：时间格式化举例/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-05.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BE%E4%BE%8B/","excerpt":"","text":"前言 我们接着上一篇文章01-04来讲。 过滤器的概念概念：Vue.js 允许我们自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值表达式、 v-bind表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示。 Vue1.X中的系统过滤器Vue提供了一系列的固定逻辑来使程序员更加容易的实现这些功能，这些过滤器称之为系统过滤器。 系统过滤器是Vue1.0中存在的，在Vue2.0中已经删除了。 系统过滤器的使用，可以参考参考文档：http://v1-cn.vuejs.org/api/#过滤器 Vue也提供了一个接口用来供程序员定义属于自己的特殊逻辑，Vue称之为自定义过滤器。我们接下来讲一讲。 自定义全局过滤器文档地址：http://v1-cn.vuejs.org/guide/custom-filter.html 全局过滤器的基本使用我们可以用全局方法Vue.filter()自定义一个全局过滤器。这样的话，每一个Vue的对象实例（每一个VM实例）都可以拿到这个过滤器。它接收两个参数：过滤器的名称 、过滤器函数。 比如说，我要将曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人这句 msg 中的“单纯”改为“邪恶”。可以这样做： （1）在差值表达式中这样调用： 1&lt;p&gt;&#123;&#123; msg | msgFormat &#125;&lt;/p&gt; 上方代码的意思是说： 管道符前面的msg：要把 msg 这段文本进行过滤， 管道符后面的msgFormat：是通过msgFormat这个过滤器进行来操作。 （2）定义过滤器msgFormat： 123456// Vue.filter 中的第一个参数是过滤器的名称，第二个参数是具体的过滤器函数// 定义一个 Vue 全局的过滤器，名字叫做 msgFormatVue.filter(&#x27;msgFormat&#x27;, function (myMsg) &#123; // function 的第一个参数指的是管道符前面的 msg // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return myMsg.replace(/单纯/g, &#x27;邪恶&#x27;)&#125;) 上方代码解释： Vue.filter(‘过滤器的名称’, 具体的过滤器函数)中的第一个参数指的就是过滤器的名称（必须和管道符后面的名称完全一致），第二个参数是具体的过滤器函数 过滤器函数function中，第一个参数指的管道符前面的msg。 replace()方法是用来做字符串的替换的。第一个参数如果只写成单纯，那么就会只修改 msg 中的第一个单纯字样。所以这里就用正则去匹配msg 中所有的单纯字样。 最终，完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 过滤器 msgFormat 对 msg 进行过滤--&gt; &lt;p&gt;&#123;&#123; msg | msgFormat &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#x27;msgFormat&#x27;, function (myMsg) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 //将 myMsg 中的所有`单纯`字样，修改为`邪恶` return myMsg.replace(/单纯/g, &#x27;邪恶&#x27;) &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#x27; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网页显示效果如下： 给过滤器添加多个参数上面的举例代码中，&#123;&#123; msg | msgFormat &#125;&#125;中，过滤器的调用并没有加参数，其实它还可以添加多个参数。 接下来，我们在上面的举例代码中进行改进。 改进一：过滤器加一个参数。如下： 将 msg 这个字符串中的“单纯”改为 xxx 变量。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 【重要】通过 过滤器 msgFormat 对 msg 进行过滤。括号里的参数代表 function中的 arg2--&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;xxx&#x27;) &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#x27;msgFormat&#x27;, function (myMsg, arg2) &#123; // 字符串的 replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为上面的xxx //将 myMsg 中的所有`单纯`字样，修改为 arg2 return myMsg.replace(/单纯/g, arg2) &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#x27; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意代码中那行重要的注释：括号里的参数代表 function中的 arg2。 改进二：过滤器加两个参数。如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 过滤器 msgFormat 对 msg 进行过滤--&gt; &lt;!-- 【重要】括号里的第一个参数代表 function 中的 arg2，括号里的第二个参数代表 function 中的 arg3--&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;【牛x】&#x27;, &#x27;【参数arg3】&#x27;) &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#x27;msgFormat&#x27;, function (myMsg, arg2, arg3) &#123; // 字符串的 replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为 xxx //将 myMsg 中的所有`单纯`字样，修改为`arg2 + arg3` return myMsg.replace(/单纯/g, arg2 + arg3) &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#x27; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 改进3：同时使用多个过滤器 对 msg 同时使用多个过滤器。例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 两个过滤器（msgFormat、myFilter2）对 msg 进行过滤--&gt; &lt;!-- 将 msg 交给第一个过滤器来处理，然后将处理的结果交给第二个过滤器来处理--&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;【牛x】&#x27;, &#x27;【参数arg3】&#x27;) | myFilter2&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#x27;msgFormat&#x27;, function (myMsg, arg2, arg3) &#123; // 字符串的 replace 方法：第一个参数，除了可写一个 字符串之外，还可以定义一个正则；第二个参数代表要替换为 xxx //将 myMsg 中的所有`单纯`字样，修改为`arg2 + arg3` return myMsg.replace(/单纯/g, arg2 + arg3) &#125;) //定义第二个全局过滤器 Vue.filter(&#x27;myFilter2&#x27;, function (myMsg) &#123; //在字符串 msg 的最后面加上【后缀】 return myMsg + &#x27;【后缀】&#x27; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#x27; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上方代码中，添加了多个过滤器，实现的思路是：将 msg 交给第一个过滤器来处理，然后将处理的结果交给第二个过滤器来处理 。 举例1：时间格式化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; time &#125;&#125; &lt;br /&gt; &#123;&#123; time | datefmt &#125;&#125; &lt;/div&gt; &lt;div id=&quot;app1&quot;&gt; &#123;&#123; time | datefmt &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义一个名称为 datafmt的全局过滤器 Vue.filter(&#x27;datefmt&#x27;, function (input) &#123; // 过滤器的逻辑：将input的值格式化成 yyyy-MM-dd 字符串输出 var res = &#x27;&#x27;; var year = input.getFullYear(); var month = input.getMonth() + 1; var day = input.getDate(); res = year + &#x27;-&#x27; + month + &#x27;-&#x27; + day; return res; &#125;); new Vue(&#123; el: &#x27;#app1&#x27;, data: &#123; time: new Date() &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; time: new Date() &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 运行效果： 举例2：时间格式化上面的举例1，时间格式化的过滤器，我们还有个更高端的写法：（字符串模板） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 2018-05-25T14:06:51.618Z &lt;br /&gt; &#123;&#123; &#x27;2018-05-25T14:06:51.618Z&#x27; | dateFormat &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.filter(&#x27;dateFormat&#x27;, function (dateStr, pattern = &quot;&quot;) &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + &#x27;-&#x27; + m + &#x27;-&#x27; + d if (pattern.toLowerCase() === &#x27;yyyy-mm-dd&#x27;) &#123; //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种 yyyy-mm-dd 的格式写 //这里用的是字符串模板 return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒 var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; time: new Date() &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 运行结果： 【荐】举例2的改进：（字符串的padStart方法使用） 上图中，我们可以看到，箭头处的时间有些问题，比如说，6要写成06更合适。为了实现这个功能，我们可以这样做： 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=&#39;&#39;) 或 String.prototype.padEnd(maxLength, fillString=&#39;&#39;)来填充字符串。 pad在英文中指的是补充。 实现举例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 2018-05-25T14:06:51.618Z &lt;br /&gt; &#123;&#123; &#x27;2018-05-25T14:06:51.618Z&#x27; | dateFormat &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.filter(&#x27;dateFormat&#x27;, function (dateStr, pattern) &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;) var d = dt.getDate().toString().padStart(2, &#x27;0&#x27;) if (pattern &amp;&amp; pattern.toLowerCase() === &#x27;yyyy-mm-dd&#x27;) &#123; //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种 yyyy-mm-dd 的格式写 //这里用的是字符串模板 return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒 var hh = dt.getHours().toString().padStart(2, &#x27;0&#x27;) var mm = dt.getMinutes().toString().padStart(2, &#x27;0&#x27;) var ss = dt.getSeconds().toString().padStart(2, &#x27;0&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; time: new Date() &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 运行效果如下： pattern参数的解释： 在做if (pattern &amp;&amp; pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;)这个判断时，逻辑是：先保证pattern参数传进来了，然后继续后面的判断。 我们不能写成：if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;)。因为，万一在调用的时候，不传递参数pattern，那么 if语句就相当于if (undefined.toLowerCase() === &#39;yyyy-mm-dd&#39;)，就会报错。 当然，ES6中有个新特性叫“默认参数”，我们就可以这样写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; 2018-05-25T14:06:51.618Z &lt;br /&gt; &#123;&#123; &#x27;2018-05-25T14:06:51.618Z&#x27; | dateFormat &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.filter(&#x27;dateFormat&#x27;, function (dateStr, pattern = &#x27;&#x27;) &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;) var d = dt.getDate().toString().padStart(2, &#x27;0&#x27;) if (pattern.toLowerCase() === &#x27;yyyy-mm-dd&#x27;) &#123; //如果调用过滤器的参数写的是 yyyy-mm-dd，那就按照这种 yyyy-mm-dd 的格式写 //这里用的是字符串模板 return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; //否则（比如说调用过滤器时不写参数），后面就补上 时-分-秒 var hh = dt.getHours().toString().padStart(2, &#x27;0&#x27;) var mm = dt.getMinutes().toString().padStart(2, &#x27;0&#x27;) var ss = dt.getSeconds().toString().padStart(2, &#x27;0&#x27;) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; time: new Date() &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 自定义私有过滤器私有过滤器：在某一个 vue 对象内部定义的过滤器称之为私有过滤器。这种过滤器只有在当前vue对象的el指定的监管区域有用。 举例：日期格式化 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; time &#125;&#125; &lt;br /&gt; &#123;&#123; time | datefmt &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; time: new Date() &#125;, //在某一个vue对象内部定义的过滤器称之为私有过滤器， //这种过滤器只有在当前vue对象el指定的监管的区域有用 filters: &#123; // input是自定义过滤器的默认参数，input的值永远都是取自于 | 左边的内容 datefmt: function (input) &#123; // 定义过滤器的内容：将input的值格式化成 yyyy-MM-dd 字符串输出 var res = &#x27;&#x27;; var year = input.getFullYear(); var month = input.getMonth() + 1; var day = input.getDate(); res = year + &#x27;-&#x27; + month + &#x27;-&#x27; + day; return res; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 上面的代码中，我们在vue实例中，通过filters关键字，在里面定义了一个局部过滤器datefmt。 运行结果： 第一行代码显示的是默认的date。第二行代码显示的是格式化之后的date，说明过滤器是起到了作用的。 总结过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器。 axiosaxios是在Vue中专门用来发送ajax请求的。 但是，axios并不依赖于Vue.js库，而是基于promise的。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-04.Vue的举例：列表功能","date":"2021-08-06T01:17:25.938Z","updated":"2021-07-28T07:34:11.375Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-04.Vue的举例：列表功能/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-04.Vue%E7%9A%84%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD/","excerpt":"","text":"列表功能举例步骤 1：列表功能完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .table &#123; width: 800px; margin: 20px auto; border-collapse: collapse; /*这一行，不能少：表格的两边框合并为一条*/ &#125; .table th &#123; background: #0094ff; color: white; font-size: 16px; border: 1px solid black; padding: 5px; &#125; .table tr td &#123; text-align: center; font-size: 16px; padding: 5px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123;id: 1, name: &#x27;奔驰&#x27;, ctime: new Date&#125;, &#123;id: 2, name: &#x27;大众&#x27;, ctime: new Date&#125;] &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 代码分析：数据是存放在data的list中的，将data中的数据通过v-for遍历给表格。 上方代码运行的效果： 步骤 2：无数据时，增加提示如果list中没有数据，那么表格中就会只显示表头&lt;th&gt;，这样显然不太好看。 为此，我们需要增加一个v-if判断：当数据为空时，显示提示。如下： 123&lt;tr v-show=&quot;list.length == 0&quot;&gt; &lt;td colspan=&quot;4&quot;&gt;列表无数据&lt;/td&gt;&lt;/tr&gt; 代码解释：colspan=&quot;4&quot;指的是让当前这个&lt;td&gt;横跨4个单元格的位置。如下： 步骤 3：item的添加具体实现步骤如下： （1）用户填写的数据单独存放在data属性里，并采用v-model进行双向绑定。 （2）用户把数据填好后，点击add按钮。此时需要增加一个点击事件的方法，将data中的数据放到list中（同时，清空文本框中的内容）。 （3）将数据展示出来。v-for有个特点：当list数组发生改变后，vue.js就会自动调用v-for重新将数据生成，这样的话，就实现了数据的自动刷新。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .table &#123; width: 800px; margin: 20px auto; border-collapse: collapse; /*这一行，不能少：表格的两边框合并为一条*/ &#125; .table th &#123; background: #0094ff; color: white; font-size: 16px; border: 1px solid black; padding: 5px; &#125; .table tr td &#123; text-align: center; font-size: 16px; padding: 5px; border: 1px solid black; &#125; .form &#123; width: 800px; margin: 20px auto; &#125; .form button &#123; margin-left: 10px; &#125; &lt;/style&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;form&quot;&gt; 编号：&lt;input type=&quot;text&quot; v-model=&quot;formData.id&quot;&gt; 名称：&lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot;&gt; &lt;button v-on:click=&quot;addData&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;table class=&quot;table&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;tr v-show=&quot;list.length == 0&quot;&gt; &lt;td colspan=&quot;4&quot;&gt;列表无数据&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123;id: 1, name: &#x27;奔驰&#x27;, ctime: new Date&#125;, &#123;id: 2, name: &#x27;大众&#x27;, ctime: new Date&#125;], //用户添加的数据 formData: &#123; id: 0, name: &quot;&quot; &#125; &#125;, methods: &#123; addData: function () &#123; //将数据追加到list中 var p = &#123;id: this.formData.id, name: this.formData.name, ctime: new Date()&#125;; this.list.push(p); //清空页面上的文本框中的数据 this.formData.id = 0; this.formData.name = &#x27;&#x27;; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 步骤 4：item的删除html部分： 12&lt;!--绑定delete事件，根据括号里的参数进行删除--&gt;&lt;td&gt;&lt;a href=&quot;#&quot; v-on:click=&quot;delData(item.id)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; js部分： 123456789101112131415delData: function (id) &#123; // 0 提醒用户是否要删除数据 if (!confirm(&#x27;是否要删除数据?&#x27;)) &#123; //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行 return; &#125; // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值（在数组中的索引值） var index = this.list.findIndex(function (item) &#123; return item.id == id &#125;); // 2.0 调用方法：list.splice(待删除的索引, 删除的元素个数) this.list.splice(index, 1);&#125; 代码解释：find()和findIndex()是ES6中为数组新增的函数。详细解释如下： 12345678// 根据id得到下标// 默认去遍历list集合，将集合中的每个元素传入到function的item里，var index = this.list.findIndex(function(item)&#123;//根据item中的id属性去匹配传进来的id//如果是则返回true ；否返回false,继续下面的一条数据的遍历，以此类推return item.id ==id; //如果返回true，那么findIndex方法会将这个item对应的index&#125;); 也就是说，我们是根据 item.id 找到这个 item 是属于list 数组中的哪个index索引。找到了index，就可以根据index来删除数组中的那个元素了。 当item被删除后，v-for会被自动调用，进而自动更新view。 完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .table &#123; width: 800px; margin: 20px auto; border-collapse: collapse; /*这一行，不能少：表格的两边框合并为一条*/ &#125; .table th &#123; background: #0094ff; color: white; font-size: 16px; border: 1px solid black; padding: 5px; &#125; .table tr td &#123; text-align: center; font-size: 16px; padding: 5px; border: 1px solid black; &#125; .form &#123; width: 800px; margin: 20px auto; &#125; .form button &#123; margin-left: 10px; &#125; &lt;/style&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;form&quot;&gt; 编号： &lt;input type=&quot;text&quot; v-model=&quot;formData.id&quot;&gt; 名称： &lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot;&gt; &lt;button v-on:click=&quot;addData&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;table class=&quot;table&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;tr v-show=&quot;list.length == 0&quot;&gt; &lt;td colspan=&quot;4&quot;&gt;列表无数据&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in list&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;!--绑定delete事件，根据括号里的参数进行删除--&gt; &lt;td&gt; &lt;a href=&quot;#&quot; v-on:click=&quot;delData(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123; id: 1, name: &#x27;奔驰&#x27;, ctime: new Date &#125;, &#123; id: 2, name: &#x27;大众&#x27;, ctime: new Date &#125;], //用户添加的数据 formData: &#123; id: 0, name: &quot;&quot; &#125; &#125;, methods: &#123; addData: function () &#123; //将数据追加到list中 var p = &#123; id: this.formData.id, name: this.formData.name, ctime: new Date() &#125;; this.list.push(p); //清空页面上的文本框中的数据 this.formData.id = 0; this.formData.name = &#x27;&#x27;; &#125;, //注意：方法之间用逗号隔开，这个逗号不要忘记了 delData: function (id) &#123; // 0 提醒用户是否要删除数据 if (!confirm(&#x27;是否要删除数据?&#x27;)) &#123; //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行 return; &#125; // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值 var index = this.list.findIndex(function (item) &#123; return item.id == id &#125;); // 2 调用方法：list.splice(待删除的索引, 删除的元素个数) this.list.splice(index, 1); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 步骤 5：按条件筛选item现在要求实现的效果是，在搜索框输入关键字 keywords，列表中仅显示匹配出来的内容。也就是说： 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的。 现在， 我们在使用v-for进行遍历显示的时候，不能再遍历全部的 list 了；我们要自定义一个 search 方法，同时，把keywords作为参数，传递给 search 方法。即v-for=&quot;item in search(keywords)&quot;。 在 search(keywords) 方法中，为了获取 list 数组中匹配的item，我们可以有两种方式实现。如下。 方式一：采用forEach + indexOf() 1234567891011search(keywords) &#123; // 根据关键字，进行数据的搜索，返回匹配的item //实现方式一：通过 indexOf() 进行匹配。 var newList = []; this.list.forEach(item =&gt; &#123; if (item.name.indexOf(keywords) != -1) &#123; //只要不等于 -1，就代表匹配到了 newList.push(item) &#125; &#125;) return newList&#125; 上方代码中， 我们要注意 indexOf(str) 的用法。举例如下： 123456789var str = &#x27;smyhvae&#x27;;console.log(str.indexOf(&#x27;s&#x27;)); //打印结果：0console.log(str.indexOf(&#x27;&#x27;)); //打印结果：0。（说明，即使去匹配空字符串，也是返回0）console.log(str.indexOf(&#x27;h&#x27;)); //打印结果：3console.log(str.indexOf(&#x27;x&#x27;)); //打印结果：-1 （说明，匹配不到任何字符串） 上方代码中，也就是说，如果参数为空字符串，那么，每个item都能匹配到。 方式二： filter + includes()方法 123456789101112search(keywords) &#123; // 根据关键字，进行数据的搜索，返回匹配的item var newList = this.list.filter(item =&gt; &#123; // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes(&#x27;要包含的字符串&#x27;) // 如果包含，则返回 true ，否则返回 false if (item.name.includes(keywords)) &#123; return item &#125; &#125;) return newList&#125; 注意：forEach some filter findIndex，这些都属于数组的新方法，都会对数组中的每一项，进行遍历，执行相关的操作。这里我们采用数组中的 filter 方法， 总的来说，方式二的写法更优雅，因为字符串的 includes()方法确实很实用。 完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .table &#123; width: 800px; margin: 20px auto; border-collapse: collapse;/*这一行，不能少：表格的两边框合并为一条*/ &#125; .table th &#123; background: #0094ff; color: white; font-size: 16px; border: 1px solid black; padding: 5px; &#125; .table tr td &#123; text-align: center; font-size: 16px; padding: 5px; border: 1px solid black; &#125; .form &#123; width: 800px; margin: 20px auto; &#125; .form button &#123; margin-left: 10px; &#125; &lt;/style&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;form&quot;&gt; 编号： &lt;input type=&quot;text&quot; v-model=&quot;formData.id&quot;&gt; 名称： &lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot;&gt; &lt;button v-on:click=&quot;addData&quot;&gt;添加&lt;/button&gt; 搜索： &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot;&gt; &lt;/div&gt; &lt;table class=&quot;table&quot;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;tr v-show=&quot;list.length == 0&quot;&gt; &lt;td colspan=&quot;4&quot;&gt;列表无数据&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in search(keywords)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;!--绑定delete事件，根据括号里的参数进行删除--&gt; &lt;td&gt; &lt;a href=&quot;#&quot; v-on:click=&quot;delData(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#123; id: 1, name: &#x27;奔驰&#x27;, ctime: new Date &#125;, &#123; id: 2, name: &#x27;大众&#x27;, ctime: new Date &#125;], //用户添加的数据 formData: &#123; id: &#x27;&#x27;, name: &quot;&quot; &#125;, keywords: &quot;&quot; &#125;, methods: &#123; addData: function () &#123; //将数据追加到list中 var p = &#123; id: this.formData.id, name: this.formData.name, ctime: new Date() &#125;; this.list.push(p); //清空页面上的文本框中的数据 this.formData.id = &#x27;&#x27;; this.formData.name = &#x27;&#x27;; &#125;, //注意：方法之间用逗号隔开，这个逗号不要忘记了 delData: function (id) &#123; // 0 提醒用户是否要删除数据 if (!confirm(&#x27;是否要删除数据?&#x27;)) &#123; //当用户点击的取消按钮的时候，应该阻断这个方法中的后面代码的继续执行 return; &#125; // 1 调用list.findIndex()方法根据传入的id获取到这个要删除数据的索引值 var index = this.list.findIndex(function (item) &#123; return item.id == id &#125;); // 2 调用方法：list.splice(待删除的索引, 删除的元素个数) this.list.splice(index, 1); &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索，返回匹配的item var newList = this.list.filter(item =&gt; &#123; // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes(&#x27;要包含的字符串&#x27;) // 如果包含，则返回 true ，否则返回 false if (item.name.includes(keywords)) &#123; return item &#125; &#125;) return newList &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 备注：在1.x 版本中可以通过filterBy指令来实现过滤，但是在2.x中已经被废弃了。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-03.Vue的系统指令(二)","date":"2021-08-06T01:17:25.936Z","updated":"2021-07-28T07:34:11.375Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-03.Vue的系统指令(二)/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-03.Vue%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4(%E4%BA%8C)/","excerpt":"","text":"前言本文主要内容： v-model v-for v-if v-show v-model：双向数据绑定（只能用于表单元素）之前的文章里，我们通过v-bind，给&lt;input&gt;标签绑定了data对象里的name属性。当data里的name的值发生改变时，&lt;input&gt;标签里的内容会自动更新。 可我现在要做的是：我在&lt;input&gt;标签里修改内容，要求data里的name的值自动更新。从而实现双向数据绑定。该怎么做呢？这就可以利用v-model这个属性。 区别： v-bind：只能实现数据的单向绑定，从 M 自动绑定到 V。 v-model：只有v-model才能实现双向数据绑定。注意，v-model 后面不需要跟冒号， 注意：v-model 只能运用在表单元素中。常见的表单元素包括：input(radio, text, address, email….) 、select、checkbox 、textarea。 代码举例如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;form action=&quot;#&quot;&gt; &lt;!-- 将 input 标签中的value值双向绑定到 Vue实例中的data。注意，v-model 后面不需要跟冒号 --&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; v-model=&quot;myAccount.username&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;pwd&quot; v-model=&quot;myAccount.userpwd&quot;&gt; &lt;input type=&quot;submit&quot; v-on:click=&quot;submit1&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, //上面的标签中采用v-model进行双向数据绑定，数据会自动更新到data里面来 data: &#123; name: &#x27;smyhvae&#x27;, myAccount: &#123;username: &#x27;&#x27;, userpwd: &#x27;&#x27;&#125; &#125;, //在methods里绑定各种方法，根据业务需要进行操作 methods: &#123; submit1: function () &#123; alert(this.myAccount.username + &quot; pwd=&quot; + this.myAccount.userpwd); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 此时，便可实现我们刚刚要求的双向数据绑定的效果。 v-model举例：实现简易计算器题目：现在两个输入框，用来做加减乘除，将运算的结果放在第三个输入框。 实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; @click=&quot;calc&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; n1: 0, n2: 0, result: 0, opt: &#x27;+&#x27; &#125;, methods: &#123; calc() &#123; // 计算器算数的方法 // 逻辑判断： switch (this.opt) &#123; case &#x27;+&#x27;: this.result = parseInt(this.n1) + parseInt(this.n2) break; case &#x27;-&#x27;: this.result = parseInt(this.n1) - parseInt(this.n2) break; case &#x27;*&#x27;: this.result = parseInt(this.n1) * parseInt(this.n2) break; case &#x27;/&#x27;: this.result = parseInt(this.n1) / parseInt(this.n2) break; &#125; //上面的逻辑判断，可能有点啰嗦，我们还可以采取下面的这种方式进行逻辑判断 // 注意：这是投机取巧的方式，正式开发中，尽量少用 // var codeStr = &#x27;parseInt(this.n1) &#x27; + this.opt + &#x27; parseInt(this.n2)&#x27; // this.result = eval(codeStr) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意上方代码中的注释，可以了解下eval()的用法。 Vue中通过属性绑定为元素设置class 类样式注意，是类样式。 引入我们先来看下面这段代码： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .my-red &#123; color: red; &#125; .my-thin &#123; /* 设置字体的粗细 */ font-weight: 200; &#125; .my-italic &#123; font-style: italic; &#125; .my-active &#123; /* 设置字符之间的间距 */ letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;my-red my-thin&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，我们直接通过正常的方式，给&lt;h1&gt;标签设置了两个 class 类的样式。代码抽取如下： 1&lt;h1 class=&quot;my-red my-thin&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt; 上面的效果，我们还可以用Vue来写。这就引入了本段要讲的方式。 方式一：数组方式一：直接传递一个数组。注意：这里的 class 需要使用 v-bind 做数据绑定。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .my-red &#123; color: red; &#125; .my-thin &#123; /* 设置字体的粗细 */ font-weight: 200; &#125; .my-italic &#123; font-style: italic; &#125; .my-active &#123; /* 设置字符之间的间距 */ letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 普通写法 --&gt; &lt;h1 class=&quot;my-red my-thin&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt; &lt;!-- vue的写法1：数组的形式 --&gt; &lt;h1 :class=&quot;[&#x27;my-red&#x27;, &#x27;my-thin&#x27;]&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码抽取如下： 12&lt;!-- vue的写法1：数组的形式 --&gt;&lt;h1 :class=&quot;[&#x27;my-red&#x27;, &#x27;my-thin&#x27;]&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; 上方代码中，注意，数组里写的是字符串；如果不加单引号，就不是字符串了，而是变量。 演示效果如下： 写法二：在数组中使用三元表达式12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue的写法2：在数组中使用三元表达式。注意格式不要写错--&gt; &lt;!-- 通过data中布尔值 flag 来判断：如果 flag 为 true，就给 h1 标签添加`my-active`样式；否则，就不设置样式。 --&gt; &lt;h1 :class=&quot;[flag?&#x27;my-active&#x27;:&#x27;&#x27;]&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag:true &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 上方代码的意思是，通过data中布尔值 flag 来判断：如果 flag 为 true，就给 h1 标签添加my-active样式；否则，就不设置样式。 注意，三元表达式的格式不要写错了。 写法三：在数组中使用 对象 来代替 三元表达式（提高代码的可读性）上面的写法二，可读性较差。于是有了写法三。 写法三：在数组中使用对象来代替三元表达式。 代码如下： 123456789101112131415&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue的写法3：在数组中使用对象来代替三元表达式。--&gt; &lt;h1 :class=&quot;[ &#123;&#x27;my-active&#x27;:flag&#125; ]&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 写法四：直接使用对象写法四：直接使用对象。代码如下： 123&lt;!-- vue的写法4：直接使用对象--&gt;&lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名。由于 对象的属性名可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt;&lt;h1 :class=&quot;&#123;style1:true, style2:false&#125;&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; 上方代码的意思是，给&lt;h1&gt;标签使用样式style1，不使用样式style2。注意： 1、既然class样式名是放在对象中的，这个样式名不能有中划线，比如说，写成:class=&quot;&#123;my-red:true, my-active:false&#125;，是会报错的。 2、我们也可以对象通过存放在 data 的变量中。也就是说，上方代码可以写成： 12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue的写法4：直接使用对象--&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名。由于 对象的属性名可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class=&quot;classObj&quot;&gt;我是smyhvae，生命壹号&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; classObj:&#123;style1:true, style2:false&#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; Vue中通过属性绑定为元素设置 style 行内样式注意，是行内样式（即内联样式）。 写法一写法一：直接在元素上通过 :style 的形式，书写样式对象。 例如： 1&lt;h1 :style=&quot;&#123;color: &#x27;red&#x27;, &#x27;font-size&#x27;: &#x27;20px&#x27;&#125;&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt; 写法二写法二：将样式对象，定义到 data 中，并直接引用到 :style 中。 也就是说，把写法一的代码改进一下。代码如下： 1234567891011121314&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;styleObj&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; styleObj: &#123; color: &#x27;red&#x27;, &#x27;font-size&#x27;: &#x27;20px&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 写法三写法二只用到了一组样式。如果想定义多组样式，可以用写法三。 写法三：在 :style 中通过数组，引用多个 data 上的样式对象。 代码如下： 123456789101112131415&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;[ styleObj1, styleObj2 ]&quot;&gt;我是生命壹号，smyhvae&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; styleObj1: &#123; color: &#x27;red&#x27;, &#x27;font-size&#x27;: &#x27;20px&#x27; &#125;, styleObj2: &#123; &#x27;font-style&#x27;: &#x27;italic&#x27; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; v-for：for循环的四种使用方式作用：根据数组中的元素遍历指定模板内容生成内容。 引入比如说，如果我想给一个ul中的多个li分别赋值1、2、3…。如果不用循环，就要挨个赋值： 12345678910111213141516171819&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;list[0]&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;list[1]&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;list[2]&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [1, 2, 3] &#125; &#125;);&lt;/script&gt; 效果： 为了实现上面的效果，如果我用v-for进行赋值，代码就简洁很多了： 123456789101112131415161718&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- 使用v-for对多个li进行遍历赋值 --&gt; &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [1, 2, 3] &#125; &#125;);&lt;/script&gt; 接下来，我们详细讲一下v-for的用法。需要声明的是，Vue 1.0的写法和Vue 2.0的写法是不一样的。本文全部采用Vue 2.0的写法。 方式一：普通数组的遍历针对下面这样的数组： 12345678&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; arr1: [2, 5, 3, 1, 1], &#125; &#125;);&lt;/script&gt; 将数组中的值赋给li： 1&lt;li v-for=&quot;item in arr1&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; 将数组中的值和index赋给li： 12&lt;!-- 括号里如果写两个参数：第一个参数代表值，第二个参数代表index 索引 --&gt;&lt;li v-for=&quot;(item,index) in arr1&quot;&gt;值：&#123;&#123;item&#125;&#125; --- 索引：&#123;&#123;index&#125;&#125;&lt;/li&gt; 效果如下： 方式二：对象数组的遍历123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- 对象数组的遍历。括号里如果写两个参数：第一个参数代表数组的单个item，第二个参数代表 index 索引--&gt; &lt;li v-for=&quot;(item, index) in dataList&quot;&gt;姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125; --- 索引：&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; //对象数组 dataList: [ &#123; name: &#x27;smyh&#x27;, age: &#x27;26&#x27; &#125;, &#123; name: &#x27;vae&#x27;, age: &#x27;32&#x27; &#125;, &#123; name: &#x27;xiaoming&#x27;, age: &#x27;20&#x27; &#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方式三：对象的遍历针对下面这样的对象： 123456789101112&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; obj1: &#123; name: &#x27;smyhvae&#x27;, age: &#x27;26&#x27;, gender: &#x27;男&#x27; &#125; &#125; &#125;);&lt;/script&gt; 将上面的obj1对象的数据赋值给li，写法如下： 1234567891011121314&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- 括号里如果写两个参数：则第一个参数代表value，第二个参数代表key --&gt; &lt;li v-for=&quot;(value,key) in obj1&quot;&gt;值：&#123;&#123;value&#125;&#125; --- 键：&#123;&#123;key&#125;&#125; &lt;/li&gt; &lt;h3&gt;---分隔线---&lt;/h3&gt; &lt;!-- 括号里如果写三个参数：则第一个参数代表value，第二个参数代表key，第三个参数代表index --&gt; &lt;li v-for=&quot;(value,key,index) in obj1&quot;&gt;值：&#123;&#123;value&#125;&#125; --- 键：&#123;&#123;key&#125;&#125; --- index：&#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 效果如下： 方式四：遍历数字in后面还可以直接放数字。举例如下： 12345&lt;ul&gt; &lt;!-- 对象数组的遍历 --&gt; &lt;!-- 注意：如果使用 v-for 遍历数字的话，前面的 myCount 值从 1 开始算起 --&gt; &lt;li v-for=&quot;myCount in 10&quot;&gt;这是第 &#123;&#123;myCount&#125;&#125;次循环&lt;/li&gt;&lt;/ul&gt; 效果如下： v-for中key的使用注意事项注意：在 Vue 2.2.0+ 版本里，当在组件中使用 v-for 时，key 属性是必须要加上的。 这样做是因为：每次 for 循环的时候，通过指定 key 来标示当前循环这一项的唯一身份。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 key的类型只能是：string/number，而且要通过 v-bind 来指定。 代码举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;smyh&#x27; &#125;, &#123; id: 2, name: &#x27;vae&#x27; &#125;, &#123; id: 3, name: &#x27;smyhvae&#x27; &#125;, &#123; id: 4, name: &#x27;xiaoming&#x27; &#125;, &#123; id: 5, name: &#x27;xiaohong&#x27; &#125; ] &#125;, methods: &#123; add() &#123; // 添加方法 this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-if：设置元素的显示和隐藏（添加/删除DOM元素）作用：根据表达式的值的真假条件，来决定是否渲染元素，如果为false则不渲染（达到隐藏元素的目的），如果为true则渲染。 在切换时，元素和它的数据绑定会被销毁并重建。 举例如下：（点击按钮时，切换和隐藏盒子） 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;toggle&quot;&gt;显示/隐藏&lt;/button&gt; &lt;div v-if=&quot;isShow&quot;&gt;我是盒子&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isShow: true &#125;, methods: &#123; toggle: function() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 效果如下： v-show：设置元素的显示和隐藏（在元素上添加/移除style=&quot;display:none&quot;属性）作用：根据表达式的真假条件，来切换元素的 display 属性。如果为false，则在元素上添加 display:none属性；否则移除display:none属性。 举例如下：（点击按钮时，切换和隐藏盒子） 我们直接把上一段代码中的v-if改成v-show就可以了： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;toggle&quot;&gt;显示/隐藏&lt;/button&gt; &lt;div v-show=&quot;isShow&quot;&gt;我是盒子&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isShow: true &#125;, methods: &#123; toggle: function() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 效果如下： v-if和v-show的区别v-if和v-show都能够实现对一个元素的隐藏和显示操作。 区别： v-if：每次都会重新添加/删除DOM元素 v-show：每次不会重新进行DOM的添加/删除操作，只是在这个元素上添加/移除style=&quot;display:none&quot;属性，表示节点的显示和隐藏。 优缺点： v-if：有较高的切换性能消耗。这个很好理解，毕竟每次都要进行dom的添加／删除操作。 v-show：有较高的初始渲染消耗。也就是说，即使一开始v-show=&quot;false&quot;，该节点也会被创建，只是隐藏起来了。而v-if=&quot;false&quot;的节点，根本就不会被创建。 总结： 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-02.v-on的事件修饰符","date":"2021-08-06T01:17:25.933Z","updated":"2021-07-28T07:34:11.375Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-02.v-on的事件修饰符/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-02.v-on%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"v-on的事件修饰符v-on的常见事件修饰符v-on 提供了很多事件修饰符来辅助实现一些功能。事件修饰符有如下： .stop 阻止冒泡。本质是调用 event.stopPropagation()。 .prevent 阻止默认事件（默认行为）。本质是调用 event.preventDefault()。 .capture 添加事件监听器时，使用捕获的方式（也就是说，事件采用捕获的方式，而不是采用冒泡的方式）。 .self 只有当事件在该元素本身（比如不是子元素）触发时，才会触发回调。 .once 事件只触发一次。 ``.{keyCode | keyAlias}` 只当事件是从侦听器绑定的元素本身触发时，才触发回调。 ``.native` 监听组件根元素的原生事件。 PS：一个事件，允许同时使用多个事件修饰符。 写法示范： 1234567891011121314151617181920 &lt;!-- click事件 --&gt;&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;doThat(&#x27;hello&#x27;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 阻止冒泡 --&gt;&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt; .stop的举例我们来看下面这个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .father &#123; height: 300px; width: 300px; background: pink; &#125; .child &#123; width: 200px; height: 200px; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;father&quot; @click=&quot;fatherClick&quot;&gt; &lt;div class=&quot;child&quot; @click=&quot;childClick&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; fatherClick: function () &#123; console.log(&#x27;father 被点击了&#x27;); &#125;, childClick: function () &#123; console.log(&#x27;child 被点击了&#x27;); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，存在冒泡的现象，父标签中包含了一个子标签。当点击子标签时，父标签也会被触发。打印顺序是： 12child 被点击了father 被点击了 那么问题来了，如果我不想让子标签的点击事件冒泡到父亲，该怎么做呢？办法是：给子标签加一个事件修饰符.stop，阻止冒泡。代码如下： 1&lt;div class=&quot;child&quot; @click.stop=&quot;childClick&quot;&gt; 阻止冒泡后，当点击子标签时，打印结果是： 1child 被点击了 PS：我发现一个有意思的现象。上方的这行代码中，如果把.stop改为:stop，造成的现象是，父标签被触发了，而子标签没有被触发。 .capture举例.capture：触发事件时，采用捕获的形式，而不是冒泡的形式。 还是采用上面的例子：当按钮点击时，如果想要采取捕获的方式，而不是冒泡的方式，办法是：可以直接在父标签上加事件修饰符.capture。代码如下： 1&lt;div class=&quot;father&quot; @click.capture=&quot;fatherClick&quot;&gt; 当点击子标签时，打印结果是： 12father 被点击了child 被点击了 .prevent的举例1比如说，超链接&lt;a&gt;默认有跳转行为，那我可以通过事件修饰符.prevent阻止这种跳转行为。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 通过 .prevent 阻止超链接的默认跳转行为 --&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;百度一下&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123; linkClick: function () &#123; console.log(&#x27;超链接被点击了&#x27;); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中： 如果去掉.prevent，点击按钮后，既会打印log，又会跳转到百度页面。 现在加上了.prevent，就只会打印loeg，不会跳转到百度页面。 .prevent的举例2现在有一个form表单： 123&lt;form action=&quot;http://www.baidu.com&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;表单提交&quot;&gt;&lt;/form&gt; 我们知道，上面这个表单因为type=&quot;submit&quot;，因此它是一个提交按钮，点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。这是表单的默认行为。 现在，我们可以用.prevent来阻止这种默认行为。修改为：点击按钮后，不提交到服务器，而是执行我们自己想要的事件（在submit方法中另行定义）。如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 阻止表单中submit的默认事件 --&gt; &lt;form @submit.prevent action=&quot;http://www.baidu.com&quot;&gt; &lt;!-- 执行自定义的click事件 --&gt; &lt;input type=&quot;submit&quot; @click=&quot;mySubmit&quot; value=&quot;表单提交&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; &#125;, methods: &#123; mySubmit: function() &#123; alert(&#x27;ok&#x27;); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 上方代码中，我们通过.prevent阻止了提交按钮的默认事件，点击按钮后，执行的是mySubmit()方法里的内容。这个方法名是可以随便起的，我们甚至可以起名为submit，反正默认的submit已经失效了。 .self举例 .self 只有当事件在该元素本身（比如不是子元素）触发时，才会触发回调。 我们知道，在事件触发机制中，当点击子标签时，父标签会通过冒泡的形式被触发（父标签本身并没有被点击）。可如果我给父标签的点击事件设置.self修饰符，达到的效果是：子标签的点击事件不会再冒泡到父标签了，只有点击符标签本身，父标签的事件才会被触发。代码如下： 1&lt;div class=&quot;father&quot; @click.self=&quot;fatherClick&quot;&gt; 疑问：既然.stop和.self都可以阻止冒泡，那二者有什么区别呢？区别在于：前者能够阻止整个冒泡行为，而后者只能阻止自己身上的冒泡行为。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/01-01.Vue的系统指令","date":"2021-08-06T01:17:25.930Z","updated":"2021-08-06T04:55:39.144Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/01-01.Vue的系统指令/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/01-01.Vue%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 本文主要内容 插值表达式{{}} - v-cloak - v-text - v-html - v-bind - v-on - 举例：文字滚动显示（跑马灯效果） - v-on的事件修饰符 ## Vue初体验 新建一个空的项目，引入vue.js文件。写如下代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--1、导入Vue的包--&gt; &lt;script src=&quot;vue2.5.15.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--这个div区域就是MVVM中的 View--&gt;&lt;div id=&quot;div1&quot;&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 2、创建一个Vue的实例 //new出来的对象就是MVVM中的 View Module（调度者） var myVue = new Vue(&#123; el: &#x27;#div1&#x27;, //当前vue对象将接管上面的div1区域 data: &#123;//data就是MVVM中的 module name: &#x27;smyhvae&#x27; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 显示效果： ![](http://img.smyhvae.com/20180313_0955.png) 如果我们在控制台输入`myVue.$data.name = 'haha'`，页面会**自动更新**name的值。意思是，当我们直接修改data数据，页面会自动更新，而不用去操作DOM。 下面来讲一下Vue的各种系统指令。 ## 插值表达式{{}} 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值。例如： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性（msg定义在data对象中）的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会自动更新。 {{}}`对JavaScript 表达式支持，例如： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; name == &#x27;smyhvae&#x27; ? &#x27;true&#x27; : &#x27;false&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; 但是有个限制就是，每个绑定都**只能包含单个表达式**，如下表达式无效： 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 代码举例： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span&gt;content:&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;smyhvae&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： ![](http://img.smyhvae.com/20180506_2240.png) ## v-cloak `v-cloak`：保持和元素实例的关联，直到结束编译后自动消失。 v-cloak指令和CSS 规则一起用的时候，能够**解决差值表达式闪烁的问题**（即：可以隐藏未编译的标签直到实例准备完毕）。 就拿上一段代码来举例，比如说，`{{name}}这个内容，在网速很慢的情况下，一开始会直接显示{{name}}这个内容，等网络加载完成了，才会显示smyhvae。那这个闪烁的问题该怎么解决呢？ 解决办法是：通过v-cloak隐藏{{name}}这个内容，当加载完毕后，再显示出来。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*2、在样式表里设置：只要是有 v-cloak 属性的标签，我都让它隐藏。 直到 Vue实例化完毕以后，v-cloak 会自动消失，那么对应的css样式就会失去作用，最终将span中的内容呈现给用户 */ [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 1、给 span 标签添加 v-cloak 属性 --&gt; &lt;span v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;smyhvae&#x27; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; v-textv-text可以将一个变量的值渲染到指定的元素中。例如： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--vue的版本：2.5.15--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#div1&#x27;, data: &#123; name: &#x27;hello smyhvae&#x27; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 结果： 差值表达式和 v-text 的区别12345&lt;!-- 差值表达式 --&gt;&lt;span&gt;content:&#123;&#123;name&#125;&#125;&lt;/span&gt;&lt;!-- v-text --&gt;&lt;span v-text=&quot;name&quot;&gt;/span&gt; 区别1： v-text 没有闪烁的问题，因为它是放在属性里的。 区别2 :插值表达式只会替换自己的这个占位符，并不会把整个元素的内容清空。v-text 会覆盖元素中原本的内容。 为了解释区别2，我们来用代码举例： 12345&lt;!-- 差值表达式 --&gt;&lt;p&gt;content:++++++&#123;&#123;name&#125;&#125;------&lt;/p&gt;&lt;!-- v-text --&gt;&lt;p v-text=&quot;name&quot;&gt;------++++++&lt;/p&gt; 上方代码的演示结果： 其实，第二行代码中，只要浏览器中还没有解析到v-text=&quot;name&quot;的时候，会显示------++++++；当解析到v-text=&quot;name&quot;的时候，name的值会直接替换------++++++。 v-htmlv-text是纯文本，而v-html会被解析成html元素。 注意：使用v-html渲染数据可能会非常危险，因为它很容易导致 XSS（跨站脚本） 攻击，使用的时候请谨慎，能够使用{{}}或者v-text实现的不要使用v-html。 代码举例： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;&lt;h1&gt;我是一个大大的h1标题&lt;/h1&gt;&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： v-bind：属性绑定机制v-bind：用于绑定属性。 比如说： 123&lt;img v-bind:src=&quot;imageSrc +&#x27;smyhvaeString&#x27;&quot;&gt;&lt;div v-bind:style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 上方代码中，给属性加了 v-bind 之后，属性值里的整体内容是表达式，属性值里的imageSrc和size是Vue实例里面的变量。 也就是说， v-bind的属性值里，可以写合法的 js 表达式。 上面两行代码也可以简写成： 123&lt;img :src=&quot;imageSrc&quot;&gt;&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 举例： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;!-- value里的值只是简单的字符串 --&gt; &lt;input type=&quot;text&quot; value=&quot;name&quot;&gt; &lt;!-- 加上 v-bind 之后，value里的值是 Vue 里的变量 --&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt; &lt;!-- 超链接后面的path是 Vue 里面的变量 --&gt; &lt;a v-bind=&quot;&#123;href:&#x27;http://www.baidu.com/&#x27;+path&#125;&quot;&gt;超链接&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#div1&#x27;, data: &#123; name: &#x27;smyhvae&#x27;, path: `2.html` &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 上面的代码中，我们给value这个属性绑定了值，此时这个值是一个变量。 效果： v-on：事件绑定机制v-on:click：点击事件12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--vue的版本：2.5.15--&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;div1&quot;&gt; &lt;!-- 给button节点绑定按钮的点击事件 --&gt; &#123;&#123;name&#125;&#125; &lt;button v-on:click=&quot;change&quot;&gt;改变name的值&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; //new出来的对象就是MVVM中的 View Module var myVue = new Vue(&#123; el: &#x27;#div1&#x27;, //当前vue对象将接管上面的div区域 data: &#123; //data就是MVVM中的 module name: &#x27;smyhvae&#x27; &#125;, //注意，下方这个 `methods` 是Vue中定义方法的关键字，不能改 //这个 methods 属性中定义了当前Vue实例所有可用的方法 methods: &#123; change: function() &#123; //上面的button按钮的点击事件 this.name += &#x27;1&#x27;; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 上方代码中，我们给button按钮绑定了点击事件。注意，这个button标签要写在div区域里（否则点击事件不生效），因为下方的View module接管的是div区域。 v-on的简写形式例如： 1&lt;button v-on:click=&quot;change&quot;&gt;改变name的值&lt;/button&gt; 可以简写成： 1&lt;button @click=&quot;change&quot;&gt;改变name的值&lt;/button&gt; v-on的常用事件v-on 提供了click 事件，也提供了一些其他的事件。 v-on:click v-on:keydown v-on:keyup v-on:mousedown v-on:mouseover v-on:submit …. 举例：文字滚动显示（跑马灯效果）我们利用上面几段所学的内容，做个跑马灯的小例子。要实现的效果是：类似于LED屏幕上，滚动显示的文字。 文字滚动显示的思路： （1）每次点击按钮后，拿到 msg 字符串，然后调用字符串的substring来进行字符串的截取操作，把第一个字符截取出来，放到最后一个位置即可。这就实现了滚动的效果。（2）为了实现文字自动连续滚动的效果，需要把步骤（1）中点击按钮的操作，放到定时器中去。 我们先来看一下 点击事件里的代码改怎么写。 步骤 1：每次点击按钮，字符串就滚动一次。代码如下： 12345678startMethod: function () &#123; // 获取 msg 的第一个字符 var start = this.msg.substring(0, 1); // 获取 后面的所有字符 var end = this.msg.substring(1); // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start;&#125; 步骤2：给上面的操作添加定时器。代码如下： 1234567891011121314startMethod: function () &#123; var _this = this; //添加定时器：点击按钮后，让字符串连续滚动 setInterval(function () &#123; // 获取 msg 的第一个字符 var start = _this.msg.substring(0, 1); // 获取 后面的所有字符 var end = _this.msg.substring(1); // 重新拼接得到新的字符串，并赋值给 this.msg // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去 _this.msg = end + start; console.log(_this.msg); &#125;, 400);&#125; 上面的代码中，我们发现，如果在定时器中直接使用this，这个this指向的是window。为了解决这个问题，我们是通过_this来解决了这个问题。 另外，我们还可以利用箭头函数来解决this指向的问题，因为箭头函数总的this指向，会继承外层函数的this指向。如下。 步骤2的改进版：用箭头函数来改进定时器，解决this指向的问题。代码如下： 12345678910111213startMethod: function () &#123; //添加定时器：点击按钮后，让字符串连续滚动 setInterval(() =&gt; &#123; // 获取 msg 的第一个字符 var start = this.msg.substring(0, 1); // 获取 后面的所有字符 var end = this.msg.substring(1); // 重新拼接得到新的字符串，并赋值给 this.msg // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去 this.msg = end + start; console.log(_this.msg); &#125;, 400);&#125; 步骤3：停止定时器。如下： 我们还需要加一个按钮，点击按钮后，停止文字滚动。也就是停止定时器。 提示：我们最好把定时器的id放在全局的位置（放到data里），这样的话，开启定时器的方法和停止定时器的方法，都可以同时访问到这个定时器。 代码如下： 123456789101112131415161718192021222324data: &#123; msg: &#x27;生命壹号，永不止步～～～&#x27;, intervalId: null&#125;,methods: &#123; startMethod: function () &#123; //添加定时器：点击按钮后，让字符串连续滚动 this.intervalId = setInterval(() =&gt; &#123; //【注意】这个定时器的this，一定不要忘记了 // 获取 msg 的第一个字符 var start = this.msg.substring(0, 1); // 获取 后面的所有字符 var end = this.msg.substring(1); // 重新拼接得到新的字符串，并赋值给 this.msg // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去 this.msg = end + start; console.log(_this.msg); &#125;, 400); &#125;, stopMethod: function () &#123; //停止定时器：点击按钮后，停止字符串的滚动 clearInterval(this.intervalId); &#125;&#125; 【重要】步骤4：一开始的时候，还需要判断是否已经存在定时器。如下： 步骤3中的代码，虽然做了停止定时器的操作，但是有个问题：在连续多次点击“启动定时器”按钮的情况下，此时再点击“停止定时器”的按钮，是没有反应的。因此，我们需要改进的地方是： 在开启定时器之前，先做一个判断：如果定时器不为 null，就不继续往下执行了（即不再开启新的定时器），防止开启了多个定时器。 停止定时器的时候，虽然定时器停止了，但定时器并不为 null。因此，最后我们还需要手动将定时器设置为null。这样，才能恢复到最初始的状态。 完整版代码： 针对上面的四个步骤，为了实现这个案例，完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;跑马灯走起&quot; @click=&quot;startMethod&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;跑马灯停止&quot; @click=&quot;stopMethod&quot;&gt; &lt;/div&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;生命壹号，永不止步～～～&#x27;, intervalId: null &#125;, methods: &#123; startMethod: function () &#123; //【重要】在开启定时器之前，先进行判断，避免出现多个定时器 //如果出现了多个定时器，后面的“停止定时器”操作是无效的 if (this.intervalId != null) return; //【注意】这个定时器的this，一定不要忘记了 //添加定时器：点击按钮后，让字符串连续滚动 this.intervalId = setInterval(() =&gt; &#123; // 获取 msg 的第一个字符 var start = this.msg.substring(0, 1); // 获取 后面的所有字符 var end = this.msg.substring(1); // 重新拼接得到新的字符串，并赋值给 this.msg // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去 this.msg = end + start; console.log(this.msg); &#125;, 400); &#125;, stopMethod: function () &#123; // 停止定时器：点击按钮后，停止字符串的滚动 clearInterval(this.intervalId); // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码的总结： 在Vue的实例中，如果想要获取data里的属性、methods里面的方法，都要通过this来访问。这里的this指向的是Vue的实例对象。 VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把最新的数据，从 data 上同步到页面中去。这样做 的好处是：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面；减少DOM操作。 在调用定时器 id 的时候，代码是this.intervalId，这个this一定不要漏掉了。","categories":[],"tags":[]},{"title":"","slug":"大前端/12-Vue基础/00-Vue的介绍和vue-cli","date":"2021-08-06T01:17:25.928Z","updated":"2021-07-28T07:34:11.374Z","comments":true,"path":"2021/08/06/大前端/12-Vue基础/00-Vue的介绍和vue-cli/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/12-Vue%E5%9F%BA%E7%A1%80/00-Vue%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8Cvue-cli/","excerpt":"","text":"MVVM模式 Model：负责数据存储 View：负责页面展示 View Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示 关于框架为什么要学习流行框架1、企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；企业中，使用框架，能够提高开发的效率。 提高开发效率的发展历程： 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念） 2、在Vue中，一个核心的概念就是：数据驱动，避免手动操作DOM元素。这样的话，可以让前端程序员可以更多的时间去关注数据的业务逻辑，而不是关心 DOM 是如何渲染的了。 框架和库的区别框架： 框架是一套完整的解决方案。 对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。但是优点也很明显：功能完善、提供了一整套的解决方案。 库（插件）： 只是提供某一个小功能。 对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 举例： 从Jquery 切换到 Zepto 从 EJS 切换到 art-template 前端的各种框架Vue.js、React、AngularJSAngularJS 提供更多的是一套解决方案，更像是一个生态。 Vue 和 React目前都是用了 Virtual Dom。 Vue 和 React 的相同点 利用虚拟DOM实现快速渲染 轻量级 响应式组件 支持服务器端渲染 易于集成路由工具、打包工具以及状态管理工具 PS：Vue 在国内很受欢迎；React 在国内和国外都很受欢迎，适合做大型网站。 什么是虚拟 DOM传统的web开发，是利用 jQuery操作DOM，这是非常耗资源的。 我们可以在 JS 的内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析，一次性插入到html里去。这就形成了虚拟 DOM。 Vue1.0没有虚拟DOM，Vue2.0改成了基于虚拟DOM。 前端框架回顾 Vue框架中，没有控制器。 Vue 框架发展历史 2013年底作为尤雨溪个人实验项目开始开发 2014年2月公开发布。 2014年11月发布0.11版本 2016年10月发布2.0版本。 相关网址 中文官网 vuejs官方论坛 GitHub地址：https://github.com/vuejs/vue Vue1.0 在线文档：http://v1-cn.vuejs.org/guide/ Vue2.x 在线文档：https://cn.vuejs.org/v2/guide/ Vue1下载地址：http://v1-cn.vuejs.org/js/vue.js Vue2下载地址：https://cdn.jsdelivr.net/npm/vue/ 上方截图的时间：2018-03-02。 介绍 Vue 本身并不是一个框架，Vue结合周边生态构成一个灵活的、渐进式的框架。 渐进式框架图： Vue框架的特点 模板渲染：基于 html 的模板语法，学习成本低。 响应式的更新机制：数据改变之后，视图会自动刷新。【重要】 渐进式框架 组件化/模块化 轻量：开启 gzip压缩后，可以达到 20kb 大小。（React 达到 35kb，AngularJS 达到60kb）。 Vue 的环境搭建 我们首先要安装好 NVM、Node.js环境，然后再来做下面的操作。 常见的插件 Webpack：代码模块化构建打包工具。 Gulp：基于流的自动化构建工具。 Grunt ：JS 世界的构建工具。 Babel：使用最新的 规范来编写 js。 Vue：构建数据驱动的Web界面的渐进式框架 Express：基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 以上这些包，都可以通过 NPM 这个包管理工具来安装。 引用 Vue.js 文件1、方式一：（CDN的方式进行引用） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 2、方式二：（下载 vue.js 文件） 去网站 https://cdn.jsdelivr.net/npm/vue/ 下载 vue.js 文件，直接放到工程文件里，然后引用。 3、方式三：（NPM的方式安装vue） 12# 最新稳定版$ npm install vue 如果网络不稳定，可以采用下面的方式安装： 1$ cnpm i vue --save 我们可以看到 vue.js 的安装目录： 此时在 src 中需要引入的路径是： 利用 vue-cli 新建一个空的项目Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。 官方代码参考1234567npm install -g @vue/clivue create my-appcd my-appnpm run serve 我们根据上方的参考代码，来看看“利用 vue-cli 新建一个空的项目”的步骤。 安装 vue-cli（命令行工具）安装命令如下： 12# 全局安装 vue-cli$ npm install -g @vue/cli 初始化一个 simple 项目（1）首先执行： 1vue create my-app 输入上方命令后，会弹出一个选项： 20190624_163626.png 如果是初学者，直接选default就行。之后会自动生成一个空的初始化项目，包含了项目目录、以及项目依赖的脚本。 这个空项目的工程文件如下：（请务必仔细研究这个项目的写法和目录结构） 2019-06-21-vue-my-app.zip 我们可以看到这个项目的结构： 20190624_160725.png src：项目源码 .babelrc：ES6编译插件的配置 index.html：单页面的入口 上方截图中，npm install 指的是下载各种依赖包，npm run dev指的是打开发包，npm run build指的是打生产包。 （2）本地运行项目： 123cd my-appnpm run serve 浏览器输入http://localhost:8080/，就可以让这个空的项目在本地跑起来： 20190624_160228.png 备注：我们在 GitHub上下载的任何Vue有关的项目，第一步都是要首先执行 npm install，安装依赖的 mode_modules，然后再运行。我们发给同事的工程文件，建议不要包含 node_modules。 构建一个 非 simple 项目（1）构建一个空的项目，首先执行： 1$ vue create vuedemo2 20190624_163726.png 上图中，选择 Manually select features，然后根据提示依次输入： 20190624_164305.png project name：要求小写。 description：默认即可。 vue-router：需要。 ESlint：语法检查，初学者可以暂时不需要。 单元测试：暂时也不需要。 e2e test：不需要。 选择 eslint 的配置： 20190624_1650.png 然后让这个空的项目就可以在浏览器上跑起来。 vue 项目结构分析 buid：打包配置的文件夹 config：webpack对应的配置 src：开发项目的源码 App.vue：入口组件。.vue文件都是组件。 main.js：项目入口文件。 static：存放静态资源 .babelrc：解析ES6的配置文件 .editorcofnig：编辑器的配置 .postcssrc.js：html添加前缀的配置 index.html：单页面的入口。通过 webpack打包后，会把 src 源码进行编译，插入到这个 html 里面来。 package.json：项目的基础配置，包含版本号、脚本命令、项目依赖库、开发依赖库、引擎等。 图片的base64编码默认是10k以下，建议都通过 base64编码。在配置文件webpack.base.conf.js中进行修改： 1234567&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;) &#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/06-ES6：字符串、数组、对象的扩展","date":"2021-08-06T01:17:25.922Z","updated":"2021-07-28T07:34:11.373Z","comments":true,"path":"2021/08/06/大前端/11-ES6/06-ES6：字符串、数组、对象的扩展/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/06-ES6%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"","text":"字符串的扩展ES6中的字符串扩展，用得少，而且逻辑相对简单。如下： includes(str)：判断是否包含指定的字符串 startsWith(str)：判断是否以指定字符串开头 endsWith(str)：判断是否以指定字符串结尾 repeat(count)：重复指定次数 举例如下： 123456789101112131415let str = &#x27;abcdefg&#x27;;console.log(str.includes(&#x27;a&#x27;));//trueconsole.log(str.includes(&#x27;h&#x27;));//false//startsWith(str) : 判断是否以指定字符串开头console.log(str.startsWith(&#x27;a&#x27;));//trueconsole.log(str.startsWith(&#x27;d&#x27;));//false//endsWith(str) : 判断是否以指定字符串结尾console.log(str.endsWith(&#x27;g&#x27;));//trueconsole.log(str.endsWith(&#x27;d&#x27;));//false//repeat(count) : 重复指定次数aconsole.log(str.repeat(5)); 打印结果： 数值的扩展 二进制与八进制数值表示法: 二进制用0b, 八进制用0o。 举例： 12console.log(0b1010);//10console.log(0o56);//46 Number.isFinite(i)：判断是否为有限大的数。比如Infinity这种无穷大的数，返回的就是false。 Number.isNaN(i)：判断是否为NaN。 Number.isInteger(i)：判断是否为整数。 Number.parseInt(str)：将字符串转换为对应的数值。 Math.trunc(i)：去除小数部分。 举例： 1234567891011121314151617181920//Number.isFinite(i) : 判断是否是有限大的数console.log(Number.isFinite(NaN)); //falseconsole.log(Number.isFinite(5)); //trueconsole.log(Number.isFinite(Infinity)); //false//Number.isNaN(i) : 判断是否是NaNconsole.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(5));//falsse//Number.isInteger(i) : 判断是否是整数console.log(Number.isInteger(5.23));//falseconsole.log(Number.isInteger(5.0));//trueconsole.log(Number.isInteger(5));//true//Number.parseInt(str) : 将字符串转换为对应的数值console.log(Number.parseInt(&#x27;123abc&#x27;));//123console.log(Number.parseInt(&#x27;a123abc&#x27;));//NaN// Math.trunc(i) : 直接去除小数部分console.log(Math.trunc(13.123));//13 数组的扩展 下面提到的数组的几个方法，更详细的内容，可以看《03-JavaScript基础/17-数组的其他方法.md》。 扩展1：Array.from()1Array.from(伪数组/可遍历的对象) 作用：将伪数组或可遍历对象转换为真数组。 扩展2：Array.of()1Array.of(value1, value2, value3) 作用：将一系列值转换成数组。 扩展3：find() 和 findIndex()方法1： 1find(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素。 方法2： 1findIndex(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素的index。 对象的扩展扩展11Object.is(v1, v2) 作用：判断两个数据是否完全相等。底层是通过字符串来判断的。 我们先来看下面这两行代码的打印结果： 12console.log(0 == -0);console.log(NaN == NaN); 打印结果： 12truefalse 上方代码中，第一行代码的打印结果为true，这个很好理解。第二行代码的打印结果为false，因为NaN和任何值都不相等。 但是，如果换成下面这种方式来比较： 12console.log(Object.is(0, -0));console.log(Object.is(NaN, NaN)); 打印结果却是： 12falsetrue 代码解释：还是刚刚说的那样，Object.is(v1, v2)比较的是字符串是否相等。 扩展2（重要）1Object.assign(目标对象, 源对象1, 源对象2...) 作用： 将源对象的属性复制到目标对象上。 其实可以理解成：将多个对象合并为一个新的对象。 举例： 123456let obj1 = &#123; name: &#x27;smyhvae&#x27;, age: 26 &#125;;let obj2 = &#123; city: &#x27;shenzhen&#x27; &#125;;let obj3 = &#123;&#125;;Object.assign(obj3, obj1, obj2);console.log(obj3); 打印结果： 上图显示，成功将obj1和obj2的属性复制给了obj3。 扩展3：__proto__属性举例： 12345678let obj1 = &#123;name:&#x27;smyhvae&#x27;&#125;;let obj2 = &#123;&#125;;obj2.__proto__ = obj1;console.log(obj1);console.log(obj2);console.log(obj2.name); 打印结果： 上方代码中，obj2本身是没有属性的，但是通过__proto__属性和obj1产生关联，于是就可以获得obj1里的属性。 1","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/05-ES6：promise、async等","date":"2021-08-06T01:17:25.920Z","updated":"2021-07-28T07:34:11.373Z","comments":true,"path":"2021/08/06/大前端/11-ES6/05-ES6：promise、async等/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/05-ES6%EF%BC%9Apromise%E3%80%81async%E7%AD%89/","excerpt":"","text":"前言文本主要内容： Promise（比较重要） Symbol async函数 Promise概述Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)。 ES6中的promise对象, 可以将异步操作以同步的流程表达出来，很好地解决了回调地狱的问题（避免了层层嵌套的回调函数）。在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发。 回调地狱的举例假设买菜、做饭、洗碗都是异步的。 现在的流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。这里面就涉及到了回调的嵌套。 ES6的Promise是一个构造函数, 用来生成promise实例。 promise对象的3个状态 初始化状态（等待状态）：pending 成功状态：fullfilled 失败状态：rejected 使用promise的基本步骤（1）创建promise对象 （2）调用promise的回调函数then() 代码格式如下： 123456789101112131415161718192021222324let promise = new Promise((resolve, reject) =&gt; &#123; //进来之后，状态为pending console.log(&#x27;111&#x27;); //这一行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) &#123; console.log(&#x27;333&#x27;); resolve();//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled &#125; else &#123; reject();//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected &#125;&#125;)console.log(&#x27;222&#x27;);//调用promise的then()promise.then(() =&gt; &#123; //如果promise的状态为fullfilled，则执行这里的代码 console.log(&#x27;成功了&#x27;); &#125; , () =&gt; &#123; //如果promise的状态为rejected，则执行这里的代码 console.log(&#x27;失败了&#x27;); &#125;) 代码解释： （1）当new Promise()执行之后，promise对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个function，function有两个参数：resolve和reject。如下： 如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled。 如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected （2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2： 如果promise的状态为fullfilled（意思是：如果请求成功），则执行function1里的内容 如果promise的状态为rejected（意思是，如果请求失败），则执行function2里的内容 另外，resolve()和reject()这两个方法，是可以给promise.then()传递参数的。如下： 123456789101112131415161718192021222324let promise = new Promise((resolve, reject) =&gt; &#123; //进来之后，状态为pending console.log(&#x27;111&#x27;); //这行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) &#123; console.log(&#x27;333&#x27;); resolve(&#x27;haha&#x27;);//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled &#125; else &#123; reject(&#x27;555&#x27;);//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected &#125;&#125;)console.log(&#x27;222&#x27;);//调用promise的then()promise.then((successMsg) =&gt; &#123; //如果promise的状态为fullfilled，则执行这里的代码 console.log(successMsg, &#x27;成功了&#x27;); &#125; , (errorMsg) =&gt; &#123; //如果promise的状态为rejected，则执行这里的代码 console.log(errorMsg, &#x27;失败了&#x27;); &#125;) ajax请求的举例（涉及到嵌套的回调）12345678910111213141516171819202122232425262728293031323334353637383940//定义一个请求news的方法function getNews(url) &#123; //创建一个promise对象 let promise = new Promise((resolve, reject) =&gt; &#123; //初始化promise状态为pending //启动异步任务 let request = new XMLHttpRequest(); request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; let news = request.response; resolve(news); &#125; else &#123; reject(&#x27;请求失败了。。。&#x27;); &#125; &#125; &#125;; request.responseType = &#x27;json&#x27;;//设置返回的数据类型 request.open(&quot;GET&quot;, url);//规定请求的方法，创建链接 request.send();//发送 &#125;) return promise;&#125;getNews(&#x27;http://localhost:3000/news?id=2&#x27;) .then((news) =&gt; &#123; console.log(news); document.write(JSON.stringify(news)); console.log(&#x27;http://localhost:3000&#x27; + news.commentsUrl); return getNews(&#x27;http://localhost:3000&#x27; + news.commentsUrl); &#125;, (error) =&gt; &#123; alert(error); &#125;) .then((comments) =&gt; &#123; console.log(comments); document.write(&#x27;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&#x27; + JSON.stringify(comments)); &#125;, (error) =&gt; &#123; alert(error); &#125;) 参考链接 当面试官问你Promise的时候，他究竟想听到什么？ Symbol概述背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。 概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 特点： Symbol属性对应的值是唯一的，解决命名冲突问题 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in、for of 遍历时不会遍历Symbol属性。 创建Symbol属性值Symbol是函数，但并不是构造函数。创建一个Symbol数据类型： 1234let mySymbol = Symbol();console.log(typeof mySymbol); //打印结果：symbolconsole.log(mySymbol); //打印结果：Symbol() 打印结果： 下面来讲一下Symbol的使用。 1、将Symbol作为对象的属性值1234567891011let mySymbol = Symbol();let obj = &#123; name: &#x27;smyhvae&#x27;, age: 26&#125;;//obj.mySymbol = &#x27;male&#x27;; //错误：不能用 . 这个符号给对象添加 Symbol 属性。obj[mySymbol] = &#x27;hello&#x27;; //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。console.log(obj); 上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用.这个符号，而是应该用属性选择器的方式。打印结果： 现在我们用for in尝试对上面的obj进行遍历： 123456789101112131415let mySymbol = Symbol();let obj = &#123; name: &#x27;smyhvae&#x27;, age: 26&#125;;obj[mySymbol] = &#x27;hello&#x27;;console.log(obj);//遍历objfor (let i in obj) &#123; console.log(i);&#125; 打印结果： 从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。 创建Symbol属性值时，传参作为标识如果我通过 Symbol()函数创建了两个值，这两个值是不一样的： 123456let mySymbol1 = Symbol();let mySymbol2 = Symbol();console.log(mySymbol1 == mySymbol2); //打印结果：falseconsole.log(mySymbol1); //打印结果：Symbol()console.log(mySymbol2); //打印结果：Symbol() 上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。 最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？ 既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为标识。比如： 12345678//在括号里加入参数，来标识不同的Symbollet mySymbol1 = Symbol(&#x27;one&#x27;);let mySymbol2 = Symbol(&#x27;two&#x27;);console.log(mySymbol1 == mySymbol2); //打印结果：falseconsole.log(mySymbol1); //打印结果：Symbol(one)console.log(mySymbol2); //打印结果：Symbol(two)。颜色为红色。console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。 打印结果： 定义常量Symbol 可以用来定义常量： 1const MY_NAME = Symbol(&#x27;my_name&#x27;); 内置的 Symbol 值除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。 Symbol.iterator属性 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 async函数（异步函数）概述 async 函数是在 ES2017 引入的。 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作。 本质： Generator 的语法糖。 async比之前的 Promise、Generator要好用一些。 语法： 1234async function foo() &#123; await 异步操作; await 异步操作；&#125; 我们在普通的函数前面加上 async 关键字，就成了 async 函数。 async、Promise、Generator的对比（async的特点）1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行。 2、async返回的总是Promise对象，可以用then方法进行下一步操作。 3、async取代Generator函数的星号*，await取代Generator的yield。 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用。","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/04-ES6：变量、函数扩展","date":"2021-08-06T01:17:25.918Z","updated":"2021-07-28T07:34:11.372Z","comments":true,"path":"2021/08/06/大前端/11-ES6/04-ES6：变量、函数扩展/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/04-ES6%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/","excerpt":"","text":"ES6 的变量声明ES6 中新增了 let 和 const 来定义变量： var：，ES5 和 ES6中，定义全局变量（是variable的简写）。 let：定义局部变量，替代 var。 const：定义常量（定义后，不可修改）。 var：全局变量看下面的代码： 12345&#123; var a = 1;&#125;console.log(a); //这里的 a，指的是 区块 里的 a 上方代码是可以输出结果的，输出结果为 1。因为 var 是全局声明的，所以，即使是在区块里声明，但仍然在全局起作用。 再来看下面这段代码： 123456var a = 1;&#123; var a = 2;&#125;console.log(a); //这里的 a，指的是 区块 里的 a 上方代码的输出结果为 2 ，因为 var 是全局声明的。 总结： 用 var 定义的全部变量，有时候会污染整个 js 的作用域。 let：局部变量123456var a = 2;&#123; let a = 3;&#125;console.log(a); 上方代码的输出结果为 2。用 let 声明的变量，只在局部（块级作用域内）起作用。 let是防止数据污染，我们来看下面这个例子： 用 var 声明变量：（可以打印结果，说明循环体外的变量 i 被污染了） 12345for (var i = 0; i &lt; 10; i++) &#123; console.log(&#x27;循环体中:&#x27; + i);&#125;console.log(&#x27;循环体外:&#x27; + i); 用let声明变量：（不能打印结果） 123456for (let i = 0; i &lt; 10; i++) &#123; console.log(&#x27;循环体中:&#x27; + i);&#125;console.log(&#x27;循环体外:&#x27; + i); 总结：我们要习惯用 let 声明，减少var声明带来的污染全局空间。 为了进一步说明 let 不会带来污染，需要说明的是：当我们定义了let a = 1时，如果我们在同一个作用域内继续定义let a = 2，是会报错的。 const：声明常量在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用 const 来定义。 举例： 12const name = &#x27;smyhvae&#x27;; //定义常量 变量的解构赋值ES6允许我们，通过数组或者对象的方式，对一组变量进行赋值，这被称为解构。 解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。 数组的解构赋值举例： 通常情况下，我们在为一组变量赋值时，一般是这样写： 1234let a = 0;let b = 1;let c = 2; 现在我们可以通过数组解构的方式进行赋值： 1let [a, b, c] = [1, 2, 3]; 二者的效果是一样的。 解构的默认值： 在解构赋值时，是允许使用默认值的。举例如下： 12345678910111213141516171819&#123; //一个变量时 let [foo = true] = []; console.log(foo); //输出结果：true&#125;&#123; //两个变量时 let [a, b] = [&#x27;生命壹号&#x27;] //a 赋值为：生命壹号。b没有赋值 console.log(a + &#x27;,&#x27; + b); //输出结果：生命壹号,undefined&#125;&#123; //两个变量时 let [a, b = &#x27;smyhvae&#x27;] = [&#x27;生命壹号&#x27;] //a 赋值为：生命壹号。b 采用默认值 smyhvae console.log(a + &#x27;,&#x27; + b); //输出结果：生命壹号,smyhvae&#125; undefined和null的区别： 如果我们在赋值时，采用的是 undefined或者null，那会有什么区别呢？ 1234567891011&#123; let [a, b = &#x27;smyhvae&#x27;] = [&#x27;生命壹号&#x27;, undefined]; //b 虽然被赋值为 undefined，但是 b 会采用默认值 console.log(a + &#x27;,&#x27; + b); //输出结果：生命壹号,smyhvae&#125;&#123; let [a, b = &#x27;smyhvae&#x27;] = [&#x27;生命壹号&#x27;, null]; //b 被赋值为 null console.log(a + &#x27;,&#x27; + b); //输出结果：生命壹号,null&#125; 上方代码分析： undefined：相当于什么都没有，此时 b 采用默认值。 null：相当于有值，但值为 null。 对象的解构赋值我们同样可以针对对象，进行结构赋值。 举例如下： 123let &#123; foo, bar &#125; = &#123; bar: &#x27;我是 bar 的值&#x27;, foo: &#x27;我是 foo 的值&#x27; &#125;;console.log(foo + &#x27;,&#x27; + bar); //输出结果：我是键 foo 的值,我是键 bar 的值 上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，是根据键来取值的。 圆括号的使用： 如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错： 1234let foo = &#x27;haha&#x27;;&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;;console.log(foo); 要解决报错，只要在解构的语句外边，加一个圆括号即可： 1234let foo = &#x27;haha&#x27;;(&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;);console.log(foo); //输出结果：smyhvae 字符串解构字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下： 12345678const [a, b, c, d] = &#x27;smyhvae&#x27;;console.log(a);console.log(b);console.log(c);console.log(d);console.log(typeof a); //输出结果：string 输出结果： 扩展运算符和 rest 运算符 扩展运算符的格式为... rest运算符的格式为...变量名 扩展运算符有了ES6，当我们在定义一个方法，但是不确定其参数的个数时，我们就可以用扩展运算符作为参数。 以前，我们在定义方法时，参数要确定个数，如下：（程序会报错） 12345678function fn(a, b, c) &#123; console.log(a); console.log(b); console.log(c); console.log(d);&#125;fn(1, 2, 3); 上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错： 现在，我们有了扩展运算符，就不用担心报错的问题了。代码可以这样写： 123456789function fn(...arg) &#123; //当不确定方法的参数时，可以使用扩展运算符 console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);&#125;fn(1, 2, 3); //方法中定义了四个参数，但只引用了三个参数，ES6 中并不会报错。 上方代码中注意，arg参数之后，不能再加别的参数，否则编译报错。 举例：数组赋值的问题 我们来分析一段代码：（将数组 arr1 赋值给 arr2） 123456789let arr1 = [&#x27;www&#x27;, &#x27;smyhvae&#x27;, &#x27;com&#x27;];let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址console.log(&#x27;arr1:&#x27; + arr1);console.log(&#x27;arr2:&#x27; + arr2);console.log(&#x27;---------------------&#x27;);arr2.push(&#x27;你懂得&#x27;); //往arr2 里添加一部分内容console.log(&#x27;arr1:&#x27; + arr1);console.log(&#x27;arr2:&#x27; + arr2); 运行结果： 上方代码中，我们往往 arr2 里添加了你懂的，却发现，arr1 里也有这个内容。原因是：let arr2 = arr1;其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。 如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做： 123456789let arr1 = [&#x27;www&#x27;, &#x27;smyhvae&#x27;, &#x27;com&#x27;];let arr2 = [...arr1]; //arr2 会重新开辟内存地址console.log(&#x27;arr1:&#x27; + arr1);console.log(&#x27;arr2:&#x27; + arr2);console.log(&#x27;---------------------&#x27;);arr2.push(&#x27;你懂得&#x27;); //往arr2 里添加一部分内容console.log(&#x27;arr1:&#x27; + arr1);console.log(&#x27;arr2:&#x27; + arr2); 运行结果： 我们明白了这个例子，就可以避免开发中的很多业务逻辑上的 bug。 rest 运算符rest 在英文中指的是剩余部分（不是指休息）。我们来举个例子，理解剩余部分的含义： 12345function fn(first, second, ...arg) &#123; console.log(arg.length);&#125;fn(0, 1, 2, 3, 4, 5, 6); //调用函数后，输出结果为 5 上方代码的输出结果为 5。 调用fn()时，里面有七个参数，而arg指的是剩下的部分（因为除去了first和second）。 从上方例子中可以看出，rest运算符适用于：知道前面的一部分参数的数量，但对于后面剩余的参数数量未知的情况。 for … of 循环ES6 中，如果我们要遍历一个数组，可以这样做： 12345let arr1 = [1, 2, 3, 4, 5];for (let value of arr1) &#123; console.log(value);&#125; 输出结果： for…of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。 注意，上面的数组中，for ... of获取的是数组里的值；for ... in获取的是index索引值。 Map对象的遍历for ... of既可以遍历数组，也可以遍历Map对象。 模板字符串我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接） 123var name = &#x27;smyhvae&#x27;;var age = &#x27;26&#x27;;console.log(&#x27;name:&#x27;+name+&#x27;,age:&#x27;+age); //传统写法 这种写法，比较繁琐，而且容易出错。 现在有了 ES6 语法，字符串拼接可以这样写： 1234567var name = &#x27;smyhvae&#x27;;var age = &#x27;26&#x27;;console.log(&#x27;name:&#x27;+name+&#x27;,age:&#x27;+age); //传统写法console.log(`name:$&#123;name&#125;,age:$&#123;age&#125;`); //ES6 写法 注意，上方代码中，倒数第二行用的是单引号，最后一行用的是反引号（在tab键的上方）。 参考链接： ES6的rest参数和扩展运算符 箭头函数需要说明的是，ES6中，函数新增了很多特性。例如： 参数默认值 扩展运算符 rest参数 箭头函数 this绑定 尾调用 这一段，我们来讲一下箭头函数。 定义和调用函数：（传统写法） 12345function fn1(a, b) &#123; return a + b;&#125;console.log(fn1(1, 2)); //输出结果：3 定义和调用函数：（ES6中的写法） 12345var fn2 = (a, b) =&gt; a + b;console.log(fn2(1, 2)); //输出结果：3 上方代码中，箭头后面的内容，就相当于 return 的内容（返回值）。 在箭头函数中，如果方法体内有两句话，那就需要在方法体外边加上{}括号。如下： 123456var fn2 = (a, b) =&gt; &#123; console.log(&#x27;haha&#x27;); return a + b;&#125;;console.log(fn2(1, 2)); //输出结果：3 从上面的箭头函数中，我们可以很清晰地找到函数名、参数名、方法体。 参数默认值当然，在 ES6 中定义方法时，我们还可以给方法里的参数加一个默认值（缺省值）： 方法被调用时，如果没有给参数赋值，那就是用默认值； 方法被调用时，如果给参数赋值了新的值，那就用新的值。 如下： 12345678var fn2 = (a, b = 5) =&gt; &#123; console.log(&#x27;haha&#x27;); return a + b;&#125;;console.log(fn2(1)); //第二个参数使用默认值 5。输出结果：6console.log(fn2(1, 8)); //输出结果：9 需要提醒的是：默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给b设置了默认值，那么就一定要给c设置默认值。 另外，我们来看下面这段代码： 12345let x = &#x27;smyh&#x27;;function fn(x, y = x) &#123; console.log(x, y);&#125;fn(&#x27;vae&#x27;); 注意第二行代码，我们给y赋值为x，这里的x是第一个参数，并不是第一行代码里定义的x。打印结果：vae vae。 如果我把第一个参数改一下，改成： 此时打印结果是：vae smyh。 this的指向ES5中，this指向的是函数被调用的对象；而ES6的箭头函数中，this指向的是函数被定义时。 所以说，箭头韩注重，一定要注意this的指向。 模块化模块化的意义： 比如说，当我需要用到jQuery库时，我会把jQuery.js文件引入到我自己代码的最前面；当我需要用到vue框架时，我会把vue.js文件引入到我自己代码的最前面。 可是，如果有20个这样的文件，就会产生20次http请求。这种做法的性能，肯定是不能接受的。 如果把20个文件直接写在一个文件里，肯定是不方便维护的。可如果写成20个文件，这20个文件又不好排序。这就是一个很矛盾的事情，于是，模块化就诞生了。 模块化历程：commonJS、AMD规范（RequireJS）、CMD规范（SeaJS）；import &amp; export export： 静态化：必须在顶部，不能使用条件语句，自动采用严格模式。（静态化有利于性能以及代码的稳定性） 更多 ES6 的语法，本文会陆续更新。 参考链接： 阮一峰 | ECMAScript 6 入门 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/03-ES6的介绍和环境配置","date":"2021-08-06T01:17:25.916Z","updated":"2021-07-28T07:34:11.372Z","comments":true,"path":"2021/08/06/大前端/11-ES6/03-ES6的介绍和环境配置/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/03-ES6%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。 PS：严格来说，ECMAScript 还包括其他很多语言的语言标准。 很多人在做业务选型的时候，会倾向于选jQuery。其实jQuery的语法是偏向于ES3的。而现在主流的框架 Vue.js 和React.js的语法，是用的ES6。 ES6中增加了很多功能上的不足。比如：常量、作用域、对象代理、类、继承等。这些在ES5中想实现，比较复杂，但是ES6对它们进行了封装。 ECMAScript 发展历史 1995年：ECMAScript 诞生。 1997年：ECMAScript 标准确立。 1999年：ES3 出现，与此同时，IE5 风靡一时。 2009年，ES5 出现，例如 foreach、Object.keys、Object.create 和 json 标准。 2015年6月，ES6正式发布。 ES6 的目标是：让 JS 语言可以编写复杂的大型应用程序，成为企业级开发语言。 ECMAScript 的各大版本 ES5 : 09年发布。 ES6：ECMAScript 2015年6月 ES7：ECMAScript 2016 ES8：ECMAScript 2017 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器。 流行的库基本都是基于 ES6 构建。 React 默认使用 ES6 标准开发。 ES6的环境配置掌握 ES6 之后，如果要考虑 ES5 的兼容性，可以这样做：写 ES6 语法的 js 代码，然后通过 Babel将 ES6 转换为 ES5。 但是，在这之前，我们需要配置一下相关的环境。 建立工程目录（1）先建立一个空的工程目录 ES6Demo，并在目录下建立两个文件夹 src和 dist： src：书写ES6代码，我们写的 js 程序都放在这里。 dist：利用 Babel 编译生成的 ES5 代码。我们在 HTML 页面需要引入 dist 里的 js 文件。 （2）在 src 里新建文件 index.html： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 我们引入 ES5 中的 js 文件，而不是引入 ES6 中的 js 文件。 --&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意，上方代码中，我们引入的是dist目录下的 js 文件。 然后我们新建文件 src/index.js： 12345let a = &#x27;smyhvae&#x27;;const b = &#x27;qianguyihao&#x27;;console.log(a);console.log(b); 这个文件是一个 ES6语法 的js文件，稍后，我们尝试把这个 ES6 语法的 js 文件转化为 ES5 的 js 文件。 PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。 全局安装 Babel-cli（1）初始化项目： 在安装Babel之前，需要先用 npm init 先初始化我们的项目。打开终端或者通过cmd打开命令行工具，进入项目目录，输入如下命令： 1npm init -y 上方代码中，-y 代表全部默认同意，就不用一次次按回车了（稍后再根据需要，在文件中手动修改）。命令执行完成后，会在项目的根目录下生成package.json文件： 123456789101112&#123; &quot;name&quot;: &quot;es6demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;smyhvae&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; PS：VS Code 里打开终端的快捷键是：Contol + ~。 （2）全局安装 Babel-cli： 在终端中输入以下命令： 1npm install -g babel-cli 如果安装比较慢的话，Mac 下可以使用cnpm进行安装 ，windows 下可以使用nrm切换到 taobao 的镜像。 （3）本地安装 babel-preset-es2015 和 babel-cli： 1npm install --save-dev babel-preset-es2015 babel-cli 安装完成后，会发现package.json文件，已经多了 devDependencies 选项： （4）新建.babelrc： 在根目录下新建文件.babelrc，输入如下内容： 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; （5）开始转换： 现在，我们应该可以将 ES6 的文件转化为 ES5 的文件了，命令如下：（此命令略显复杂） 1babel src/index.js -o dist/index.js 我们可以将上面这个命令进行简化一下。操作如下： 在文件 package.json 中修改键 scripts中的内容： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;babel src/index.js -o dist/index.js&quot;&#125;, 修改后的效果如下： 目前为止，环境配置好了。以后，我们执行如下命令，即可将src/index.js这个 ES6 文件转化为 dist/index.js这个 ES5 文件： 1npm run build 我们执行上面的命令之后，会发现， dist目录下会生成 ES5 的 js 文件： index.js： 12345678&#x27;use strict&#x27;;var a = &#x27;smyhvae&#x27;;var b = &#x27;qianguyihao&#x27;;console.log(a);console.log(b); 当我们打开网页后，就可以在浏览器的控制台，看到代码的输出结果。 本段内容的参考链接： 技术胖带你玩转ES6视频教程 (共18集)","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/02-ES5中的一些扩展","date":"2021-08-06T01:17:25.914Z","updated":"2021-07-28T07:34:11.372Z","comments":true,"path":"2021/08/06/大前端/11-ES6/02-ES5中的一些扩展/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/02-ES5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%A9%E5%B1%95/","excerpt":"","text":"JSON 对象1、js对象(数组) –&gt; json对象(数组)： 1JSON.stringify(obj/arr) 2、json对象(数组) –&gt; js对象(数组)： 1JSON.parse(json) 上面这两个方法是ES5中提供的。 我们要记住，我们通常说的“json字符串”，只有两种：json对象、json数组。 typeof json字符串的返回结果是string。 Object的扩展ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。 方法一1Object.create(prototype, [descriptors]) 作用: 以指定对象为原型，创建新的对象。同时，第二个参数可以为为新的对象添加新的属性，并对此属性进行描述。 举例1：（没有第二个参数时） 12345var obj1 = &#123;username: &#x27;smyhvae&#x27;, age: 26&#125;;var obj2 = &#123;address:&#x27;shenzhen&#x27;&#125;;obj2 = Object.create(obj1);console.log(obj2); 打印结果： 我们发现，obj1成为了obj2的原型。 举例2：（有第二个参数时） 第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新属性sex： 1234567891011121314var obj1 = &#123;username: &#x27;smyhvae&#x27;, age: 26&#125;;var obj2 = &#123;address: &#x27;shenzhen&#x27;&#125;;obj2 = Object.create(obj1, &#123; sex: &#123;//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉 value: &#x27;男&#x27;, //通过value关键字设置sex的属性值 writable: false, configurable: true, enumerable: true &#125;&#125;);console.log(obj2); 上方代码中，我们通过第5行的sex给obj2设置了一个新的属性sex，但是要通过value来设置属性值（第6行）。 设置完属性值后，这个属性值默认是不可修改的，要通过writable来设置。总而言是，这几个关键字的解释如下： value：设置属性值。 writable：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。 configurable：标识当前属性是否可以被删除。默认为false，不可删除。 enumerable：标识当前属性是否能用 for in 枚举。 默认为false，不可。 方法二 这个方法有点难理解。 1Object.defineProperties(object, descriptors) 作用：为指定对象定义扩展多个属性。 代码举例： 12345678910111213141516171819202122var obj2 = &#123; firstName : &#x27;smyh&#x27;, lastName : &#x27;vae&#x27;&#125;;Object.defineProperties(obj2, &#123; fullName : &#123; get : function () &#123; return this.firstName + &#x27;-&#x27; + this.lastName &#125;, set : function (data) &#123; //监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数 var names = data.split(&#x27;-&#x27;); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;);console.log(obj2.fullName);obj2.firstName = &#x27;tim&#x27;;obj2.lastName = &#x27;duncan&#x27;;console.log(obj2.fullName);obj2.fullName = &#x27;kobe-bryant&#x27;;console.log(obj2.fullName); get ：用来获取当前属性值的回调函数 set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 存取器属性：setter,getter一个用来存值，一个用来取值。 Object的扩展（二）obj对象本身就自带了两个方法。格式如下： 1234get 属性名()&#123;&#125; 用来得到当前属性值的回调函数set 属性名()&#123;&#125; 用来监视当前属性值变化的回调函数 举例如下： 123456789101112131415var obj = &#123; firstName : &#x27;kobe&#x27;, lastName : &#x27;bryant&#x27;, get fullName()&#123; return this.firstName + &#x27; &#x27; + this.lastName &#125;, set fullName(data)&#123; var names = data.split(&#x27; &#x27;); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj.fullName);obj.fullName = &#x27;curry stephen&#x27;;console.log(obj.fullName); 数组的扩展 下面讲的这几个方法，都是给数组的实例用的。 下面提到的数组的这五个方法，更详细的内容，可以看《03-JavaScript基础/15-数组的四个基本方法&amp;数组的遍历.md》、《03-JavaScript基础/17-数组的其他方法.md》。 方法1： 1Array.prototype.indexOf(value) 作用：获取 value 在数组中的第一个下标。 方法2： 1Array.prototype.lastIndexOf(value) 作用：获取 value 在数组中的最后一个下标。 方法3：遍历数组 1Array.prototype.forEach(function(item, index)&#123;&#125;) 方法4： 1Array.prototype.map(function(item, index)&#123;&#125;) 作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。 方法5： 1Array.prototype.filter(function(item, index)&#123;&#125;) 作用：遍历过滤出一个新的子数组，返回条件为true的值。 函数function的扩展：bind() ES5中新增了bind()函数来改变this的指向。 1Function.prototype.bind(obj) 作用：将函数内的this绑定为obj, 并将函数返回。 面试题: call()、apply()和bind()的区别： 都能改变this的指向 call()/apply()是立即调用函数 bind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。 PS：bind()传参的方式和call()一样。 分析： 为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。 bind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。","categories":[],"tags":[]},{"title":"","slug":"大前端/11-ES6/01-ES5中的严格模式","date":"2021-08-06T01:17:25.912Z","updated":"2021-07-28T07:34:11.371Z","comments":true,"path":"2021/08/06/大前端/11-ES6/01-ES5中的严格模式/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/11-ES6/01-ES5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ES的几个重要版本 ES5 : 09年发布。 ES6(ES2015) : 2015年发布，也称为ECMA2015。 ES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。 严格模式的理解概念理解：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：”严格模式”（strict mode）。 顾名思义，这种模式使得Javascript在更严格的语法条件下运行。 目的： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 针对整个脚本文件：将use strict放在脚本文件的第一行，则整个脚本文件将以严格模式运行。 针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。 PS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。 脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 创建eval作用域 对象不能有重名的属性 严格模式和普通模式的区别 下面列举几条严格模式的内容。 全局变量显式声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 禁止this关键字指向全局对象：12345var foo = function () &#123; console.log(this);&#125;foo(); 上方代码中，普通模式打印的是window。严格模式下打印的是undefined。 创设eval作用域禁止使用with语句因为with语句无法在编译时就确定，属性到底归属哪个对象。 构造函数必须通过new实例化对象构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。 比如说： 12345var Cat = function (name) &#123; this.name = name;&#125;Cat(&#x27;haha&#x27;); 上方代码中，如果在严格模式下，则会报错。 为了让代码更安全，禁止函数内部遍历调用栈严格模式下无法删除变量属性相关普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 严格模式下，对禁止扩展的对象添加新属性，会报错。 普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。 比如下面这样的代码： 1234var obj = &#123; username: &#x27;smyh&#x27;; username: &#x27;vae&#x27;&#125; 上面的代码，在严格模式下属于语法错误，因为有重名的属性。 函数必须声明在顶层将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 新增关键字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 总结至少要能答出四五条。 参考链接： 阮一峰 | Javascript 严格模式详解","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/WebSocket","date":"2021-08-06T01:17:25.908Z","updated":"2021-07-28T07:34:11.371Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/WebSocket/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/WebSocket/","excerpt":"","text":"WebSocket 的引入背景分析HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。 当用户在浏览器上进行操作时，可以请求服务器上的api；但是反过来却不可能：服务器端发生了一个事件，无法将这个事件的信息实时主动地通知客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。 那怎么去实时地知道服务器的状态呢？方法有两个： （1）轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 （2）长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。 WebSocket 协议最新的 HTML5协议，制定了 WebSocket 协议标准，允许客户端和服务器端以全双工的方式进行通信。 WebSocket 的原理非常简单：利用HTTP请求产生握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者转用TCP协议进行交流（QQ的协议）。 WebSocket协议需要浏览器和服务器都支持才可以使用： 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5 支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3 http 长连接和 websocket 的长连接区别HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 websocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。 keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。 Socket.IO 的引入Node.js上需要写一些程序，来处理TCP请求。 Node.js从诞生之日起，就支持 WebSocket 协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库 Socket.IO。 Socket.IO 是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持 WebSocket 协议的浏览器，提供了长轮询的透明模拟机制。 Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。 Socket.IO 的安装Socket.IO 的官网是：http://socket.io/ 安装方式： 1npm install socket.io","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/Node.js代码举例","date":"2021-08-06T01:17:25.906Z","updated":"2021-07-28T07:34:11.371Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/Node.js代码举例/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/Node.js%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/","excerpt":"","text":"在 Node.js 上建一个 http 服务器（1）新建一个文件 server01.js，然后在里面输入如下代码： 1234567891011const http = require(&#x27;http&#x27;); //引入 node.js里面的一个http包。因为引入之后，我们不会去修改它，所以用常量来表示// 创建一台服务器var server = http.createServer(function ()&#123; //当有人来访问这台服务器时，就会执行 function 回调函数 console.log(&#x27;有人来访问我了&#x27;);&#125;);server.listen(8080); //要让服务器设置为监听状态，端口设置为8080 注意看注释。 我们把上面这个 js 文件跑起来，然后在浏览器端输入http://localhost:8080/，每请求一次，服务器的控制台就会打印 有人来访问我了。 （2）write()函数和 end()函数： 将上面的代码修改如下： server02.js： 123456789101112131415const http = require(&#x27;http&#x27;);// 创建一台服务器var server = http.createServer(function (request, response) &#123; //当有人来访问这个服务器时，就会执行function 这个回调函数 console.log(&#x27;有人来访问我了&#x27;); response.write(&#x27;smyhvae&#x27;); //向浏览器输出内容 response.end(); //结束了，浏览器你走吧。&#125;);server.listen(8080); function 回调函数里可以设置两个参数：request 和 response。response.write()表示向浏览器输出一些内容。 将上面的 js 代码跑起来，产生的问题是，无论我们在浏览器端输入http://localhost:8080/1.html，还是输入http://localhost:8080/2.jpg，浏览器上显示的都是smyhvae。","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/ES6","date":"2021-08-06T01:17:25.903Z","updated":"2021-07-28T07:34:11.370Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/ES6/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/ES6/","excerpt":"","text":"前言ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。 发展历史20180303_1633.png 2015年6月，ES6正式发布。 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器 流行的库基本都是基于 ES6 构建。 React 默认使用 ES6 新源发开发。 ES6 的常用语法ES6语法概览 块级作用域、字符串 对象扩展、解构 类、模块化等。 作用域：let 和 const 用 let定义变量 ，替代 var 用const 定义常量（定义后，不可修改） 作用域和 {} 举例： 123let a1 = &#x27;haha&#x27;;const name = `smyhvae`; 模板字符串我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接） 123var name = &#x27;smyhvae&#x27;;var age = &#x27;26&#x27;;console.log(&#x27;name:&#x27;+name+&#x27;,age:&#x27;+age); //传统写法 这种写法，比较繁琐，而且容易出错。 现在有了 ES6 语法，字符串拼接可以这样写： 1234567var name = &#x27;smyhvae&#x27;;var age = &#x27;26&#x27;;console.log(&#x27;name:&#x27;+name+&#x27;,age:&#x27;+age); //传统写法console.log(`name:$&#123;name&#125;,age:$&#123;age&#125;`); //ES6 写法 注意，上方代码中，倒数第二行用的是单引号，最后一行用的是反引号（在tab键的上方）。 函数扩展ES6 中函数的用法： 参数默认值 箭头函数 展开运算符 定义和调用函数：（传统写法） 12345function fn1(name) &#123; console.log(name);&#125;fn1(&#x27;smyhvae&#x27;); 定义和调用函数：（ES6写法） 12345var fn2 = (name)=&gt;&#123; console.log(name);&#125;fn2(&#x27;smyhvae&#x27;); 上面两端代码，执行的结果是一样的。 当然，也可以给上面这个函数的参数加一个默认值： 123456var fn2 = (name=&#x27;enen&#x27;)=&gt;&#123; console.log(name);&#125;fn2(); //参数用默认值 enenfn2(&#x27;smyhvae&#x27;); 比如说，1秒后执行一段代码，可以用箭头函数： 123setTimeout(()=&gt;&#123; console.log(&#x27;something&#x27;);&#125;,1000); 如果函数体只有一条 return 语句，那么大括号可以省略： 123const myDouble = x=&gt;x*2;console.log(myDouble(5)); //打印结果为10 箭头函数的好处： 简写代码 保持 this 的作用域","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/CommonJS","date":"2021-08-06T01:17:25.901Z","updated":"2021-07-28T07:34:11.370Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/CommonJS/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/CommonJS/","excerpt":"","text":"全局对象global类似于客户端 JavaScript 运行环境中的 window。 process用于获取当前的 Node 进程信息，一般用于获取环境变量之类的信息。 consoleNode 中内置的 console 模块，提供操作控制台的输入输出功能，常见使用方式与客户端类似。 全局函数 setInterval(callback, millisecond) clearInterval(timer) setTimeout(callback, millisecond) clearTimeout(timer) Buffer：Class 用于操作二进制数据 以后介绍 Node 调试最简单的调试最方便也是最简单的调试：console.log() Node 原生的调试网址：https://nodejs.org/api/debugger.html 第三方模块提供的调试工具1234$ npm install node-inspector –g //方式一$ npm install devtool -g //方式二 开发工具的调试 Visual Studio Code WebStorm 模块化结构Node 实现 CommonJS 规范，所以可以使用模块化的方式组织代码结构。 Node 采用的模块化结构是按照 CommonJS 规范。 模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。 CommonJS 规范CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。 参考链接： http://wiki.commonjs.org/wiki/CommonJS 常用内置模块 path：处理文件路径。 fs：操作（CRUD）文件系统。 child_process：新建子进程。 util：提供一系列实用小工具。 http：提供 HTTP 服务器功能。 url：用于解析 URL。 querystring：解析 URL 中的查询字符串。 crypto：提供加密和解密功能。 总结：更多内容可以参考 api文档：https://nodejs.org/api/ 文件系统操作相关模块 fs：基础的文件操作 API path：提供和路径相关的操作 API readline：用于读取大文本文件，一行一行读 fs-extra（第三方）：https://www.npmjs.com/package/fs-extra","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/02-JavaScript模块化04：ES6","date":"2021-08-06T01:17:25.899Z","updated":"2021-07-28T07:34:11.370Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/02-JavaScript模块化04：ES6/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/02-JavaScript%E6%A8%A1%E5%9D%97%E5%8C%9604%EF%BC%9AES6/","excerpt":"","text":"ES6模块化的基本语法ES6模块化的说明依赖模块需要编译打包处理。原因如下： （1）有些浏览器不支持 ES6 的语法，写完 ES6 的代码后，需要通过Babel将 ES6 转化为 ES5。 （2）生成了ES5之后，里面仍然有require语法，而浏览器并不认识require这个关键字。此时，可以用 Browserify编译打包 js，进行再次转换。 推荐学习链接： http://es6.ruanyifeng.com/#docs/module 基本语法：导出模块： 1export 引入模块： 1import xxx from &#x27;路径&#x27; ES6模块化的使用举例（自定义模块）1、初始化项目（1）在工程文件中新建如下目录： 123456789js | src | module1.js | module2.js | module3.js | main.jsindex.html （2）在工程的根目录下，新建文件package.json，内容如下： 1234&#123; &quot;name&quot;: &quot;es6-babel-browserify&quot;, &quot;version&quot;: &quot;1.0.0&quot;&#125; 2、环境配置：安装babel 和 browserify等（1）安装babel 和 browserify： 12345npm install babel-cli -gnpm install babel-preset-es2015 --save-devnpm install browserify -g 安装 babel 的详细解释，可以参考本人的另外一篇文章：ES6的介绍和环境配置 （2）新建.babelrc： 在根目录下新建文件.babelrc，输入如下内容： 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; 3、编写代码（1）module1.js： 1234567891011//暴露模块：采用分别暴露的方式export function foo1() &#123; console.log(&#x27;我是 module1 中的 foo1&#x27;);&#125;export function foo2() &#123; console.log(&#x27;我是 module2 中的 foo2&#x27;);&#125;export let arr = [1, 2, 3, 4, 5]; （2）module2.js： 123456789101112//暴露模块：采用统一暴露的方式function fn1() &#123; console.log(&#x27;我是 module2 中的 fn1&#x27;);&#125;function fn2() &#123; console.log(&#x27;我是 module2 中的 fn2&#x27;);&#125;//统一暴露export &#123; fn1, fn2 &#125;; （3）module3.js： 1234567//暴露模块：采用默认暴露的方式。//默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据//语法格式：export default value;export default () =&gt; &#123; console.log(&#x27;我是 module3 中 default 方式暴露的函数&#x27;);&#125;; 这里，我们采取了一种新的暴露方式（默认暴露），在暴露时，加上了default这个关键字。代码里暴露了一个箭头函数，稍后，我们注意在main.js里是怎么引入module3.js的。 注意，我们只能写一次 default，也就是说，只能进行一次默认暴露。 （4）module4.js：（default方式暴露多个属性） 12345678910//暴露模块：采用默认暴露的方式。//默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据//语法格式：export default value;export default &#123; name: &#x27;我是 module4 中 default 方式暴露的属性 name&#x27;, foo() &#123; console.log(&#x27;我是 module4 中 default 方式暴露的函数 foo&#x27;); &#125;&#125; 这里，我们依旧采取了默认暴露的方式，只能写一次 default。代码里暴露了一个对象（对象里存放了一个属性、一个方法）。稍后，我们注意在main.js里是怎么引入module4.js的。 如果我想暴露多个属性、多个对象怎呢？很简单，把你想要暴露的所有内容，都放在default里，包成一个对象。你看module4.js就是如此， 同时暴露了多个属性&amp;方法。 （5）main.js： 这个是主模块。现在，我们来看一下，它如何引入上面的四个模块。 1234567891011121314151617181920//主模块。引入其他的模块import &#123; foo1, foo2 &#125; from &#x27;./module1&#x27;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module1 中的对象名一致。import &#123; fn1, fn2 &#125; from &#x27;./module2&#x27;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module2 中的对象名一致。import myModule3 from &#x27;./module3&#x27;; //module3 模块是采用 default 方式进行暴露的，myModule3 这个名字是我随便起的import myModule4 from &#x27;./module4&#x27;; //module4 模块是采用 default 方式进行暴露的，myModule4 这个名字是我随便起的//调用module1、module2中的内容foo1();foo2();fn1();fn2();//调用module3中的内容myModule3();//调用module4中的内容console.log(myModule4.name); //module4中的属性myModule4.foo(); //module4中的方法 我们可以看出：（具体请看注释，非常重要） module1和module2是采用常规暴露的形式，在引入它们时，模块名要一致。而且，要求用对象解构赋值的形式，而不是用 import myModule from ...这种形式（否则会报错 undefined）。 module2和module3是采用默认暴露的形式，在引入它们时，模块名随便起。 （6）index.html： 在这里引入main.js即可。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、编译转换如果我们不进行转换，而是直接在 index.html 中加载 js/src/main.js，是会报错的： 接下来，我们就进行转换。 （1）利用 babel 将 ES6 转换为 ES5： 1babel src -d build //build目录会自动生成 上方命令的意思是，将src目录下的所有ES6文件转化为ES5文件，并放在build目录下（build目录会被自动创建）。 转化成ES5之后，我们发现，如果直接在 index.html 中加载build目录下的ES5文件，也是会报错的，因为浏览器不认识main.js里的require关键字： 于是，我们还要进行一次转换。 （2）利用Browserify编译打包 build目录下的 ES5 文件： 1browserify build/main.js -o dist/main.js //dist目录需要手动创建 dist/main.js就是我们需要引入到 index.html 里的文件。 以后，我们每次修改完ES6的代码，就要执行上面的两个命令，重新生成新的js文件。 运行效果： 工程文件： 2018-04-13-ES6Demo.rar ES6模块化的使用举例（引入第三方模块）下载 jQuery 包： 1npm install jquery@1 //下载jQuery 1.X 的版本里最新的 在main.js 中引入上面的 jQuery： 1import $ from &#x27;jQuery&#x27;; 然后我们就可以通过$这个符号去写jQuery的代码了。","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/02-JavaScript模块化03：CMD","date":"2021-08-06T01:17:25.897Z","updated":"2021-07-28T07:34:11.369Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/02-JavaScript模块化03：CMD/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/02-JavaScript%E6%A8%A1%E5%9D%97%E5%8C%9603%EF%BC%9ACMD/","excerpt":"","text":"CMD的基本语法CMD的概念CMD（Common Module Definition）：同步模块定义。CMD专门用于浏览器端，模块的加载是同步的。模块在使用时才会加载执行。 CMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。 SeaJSSeaJS：一个基于CMD规范实现的模块化开发解决方案。 官网链接： http://seajs.org/ https://github.com/seajs/seajs 推荐学习链接： http://www.zhangxinxu.com/sp/seajs/ http://es6.ruanyifeng.com/#docs/module 暴露模块的方式 不管是定义没有依赖的模块，还是定义有依赖的模块，参数只有一个，那就是 function。 定义没有依赖的模块： 12345678define(function (require, exports, module) &#123; exports.xxx = value //暴露模块 module.exports = value&#125;) 参数只有一个，那就是 function。function 里有三个参数： 定义有依赖的模块： 123456789101112131415//定义有依赖的模块define(function (require, exports, module) &#123; //引入依赖的模块(同步的方式) var module2 = require(&#x27;./module2&#x27;) //引入依赖的模块(异步的方式) require.async(&#x27;./module3&#x27;, function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 上面的代码可以看到，在引入依赖的模块时，有两种引入的方式：同步和异步。 引入模块的方式12345678define(function (require) &#123; var m1 = require(&#x27;./module1&#x27;) var m4 = require(&#x27;./module4&#x27;) m1.show() m4.show()&#125;) SeaJS的使用举例（自定义模块）1、创建项目结构在工程文件中新建如下目录： 12345678910js | libs | sea.js | modules | module1.js | module2.js | module3.js | module4.js | main.js //主模块index.html 2、下载SeaJS，并导入 官网: https://seajs.github.io/seajs/docs/#downloads GitHub：https://github.com/seajs/seajs 在官网下载sea.js文件，然后将其拷贝到项目的js/libs/目录中。这样的话，就导入成功了。 3、自定义模块（1）module1.js： 12345678910//定义没有依赖的模块define(function (require, exports, module) &#123; let name = &#x27;我是 module1 中的内容&#x27;; function foo1() &#123; return name; &#125; //暴露模块 module.exports = &#123; foo1 &#125;; //暴露出去的是 foo1这个函数对象&#125;); （2）module2.js： 12345678910//定义没有依赖的模块define(function (require, exports, module) &#123; let name = &#x27;我是 module2 中的内容&#x27;; function foo2() &#123; console.log(name); &#125; //暴露模块 module.exports = foo2; //可以理解成：exports就是 foo2 这个函数&#125;); （3）module3.js: 12345678910//定义没有依赖的模块define(function (require,exports,module) &#123; let data = &#x27;我是 module3 中的内容&#x27;; function foo3() &#123; console.log(data); &#125; //暴露模块 exports.module3 = &#123; foo3 &#125;; //可以理解成：给 export 对象暴露了 module3 这个属性，这个属性里有foo3 这个函数。&#125;); （4）module4.js： 这个模块依赖了 module2 和 module3。 12345678910111213141516171819//定义有依赖的模块define(function (require, exports, module) &#123; let name = &#x27;我是 module4 中的内容&#x27;; //同步的方式引入 module2 let myModule2 = require(&#x27;./module2&#x27;); myModule2(); //异步的方式引入 module3 require.async(&#x27;./module3&#x27;, function (myModule3) &#123; myModule3.module3.foo3(); &#125;); function foo4() &#123; console.log(name); &#125; exports.foo4 = foo4;&#125;) （5）main.js： module1.js没有依赖其他的模块，它是独立的 module4.js依赖了module2和module3。 因此，让main.js依赖module1.js和module4就够了。 main.js： 12345678910111213//主模块（主模块不需要导出）define(function (require) &#123; //导入 module1 let module1 = require(&#x27;./module1&#x27;); console.log(module1.foo1()); //执行foo1函数后，将返回值打印 //导入 module4 let module4 = require(&#x27;./module4&#x27;); module4.foo4();&#125;); （6）index.html： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入 sea.js库 --&gt; &lt;script src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 引入主模块 seajs.use(&#x27;./js/modules/main.js&#x27;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果：","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/02-JavaScript模块化02：AMD","date":"2021-08-06T01:17:25.895Z","updated":"2021-07-28T07:34:11.368Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/02-JavaScript模块化02：AMD/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/02-JavaScript%E6%A8%A1%E5%9D%97%E5%8C%9602%EF%BC%9AAMD/","excerpt":"","text":"AMD的基本语法AMD的概念AMD（Asynchronous Module Definition）：异步模块定义。AMD专门用于浏览器端，模块的加载是异步的。 AMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。 RequireJS：一个基于AMD规范实现的模块化开发解决方案。 暴露模块的方式定义没有依赖的模块：（参数只有一个 function） 12345define(function () &#123; return 模块&#125;) 定义有依赖的模块：（参数有两个：模块名、function） 123456//定义有依赖的模块：第一个参数为数组define([&#x27;module1&#x27;, &#x27;module2&#x27;], function (m1, m2) &#123; return 模块&#125;) 代码解释： 第一个参数必须是数组，里面存放的是，需要依赖的其他的模块。 第二个参数是function，里面带了形参 m1 和 m2，分别代表了 module1 和 module2。这个形参的作用是，前面依赖的模块一旦声明了，就可以一一对应地注入到 function中去，从而在 function 内部使用依赖的模块。这种方式称之为显式声明依赖注入。 引入模块的方式在主模块中引入其他的模块： 123456//在主模块中引入其他的模块require([&#x27;module1&#x27;, &#x27;module2&#x27;], function (m1, m2) &#123; 使用m1 / m2&#125;) RequireJS：是AMD的实现 http://www.requirejs.org/ http://www.ruanyifeng.com/blog/2012/11/require_js.html RequireJS的使用举例（自定义模块）1、创建项目结构在工程文件中新建如下目录： 123456789js | libs | modules | alerter.js | dataService.js | main.jsindex.html 所有的代码写完之后，项目结构如下： 2、下载require.js，并导入 官网: http://requirejs.org/docs/download.html GitHub：https://github.com/requirejs/requirejs 在官网下载require.js文件： 然后将require.js文件拷贝到项目的js/libs/目录中。 这样的话，就导入成功了。 3、自定义模块（1）dataService.js： 12345678910//定义没有依赖的模块define(function () &#123; let name = &#x27;我是 dataService.js中的内容&#x27;; function getName() &#123; return name; &#125; //暴露模块 return &#123; getName &#125;;&#125;); 这模块没有依赖。 （2）alerter.js： 123456789101112//定义有依赖的模块define([&#x27;myDataService&#x27;], function (dataService) &#123; let msg = &#x27;我是 aleter.js中的内容&#x27;; function showMsg() &#123; console.log(dataService.getName()); //调用了 myDataService 模块中的内容 console.log(msg); &#125; //暴露模块 return &#123; showMsg &#125;;&#125;); 这个模块，依赖了myDataService这个模块，模块名是我自己起的。稍后，我们会在main.js中做映射，将myDataService这个名字和dataService.js文件关联起来。 （3）main.js： 这个是主模块。 1234567891011requirejs.config(&#123; //baseUrl: &#x27;js/&#x27;, //基本路径 paths: &#123; //配置路径 myDataService: &#x27;./modules/dataService&#x27;, myAlerter: &#x27;./modules/alerter&#x27; &#125;&#125;);requirejs([&#x27;myAlerter&#x27;], function (alerter) &#123; alerter.showMsg();&#125;)(); 这个模块，依赖了myAlerter这个模块，模块名是我自己起的。并且，我们在文件的上方做了映射，将myAlerter这个名字和alerter.js文件关联了起来。 我们来讲一下最上方的几行代码（即requirejs.config里的内容）的意思： 我们可以看到，文件（3）依赖了文件（2），文件（2）依赖了文件（1）。 paths里做的就是映射：将键myDataService和文件dataService.js进行关联，将键myAlerter和文件alerter.js进行关联。 另外，再讲一下注释里的baseUrl的用法：如果没有这个注释，那么paths里的路径，是从当前这个文件（main.js）的角度出发的；如果加了一行baseUrl，表明它是 paths 里所有路径的最开头的部分，baseUrl的路径是从项目的根目录的角度出发的。 （4）index.html： 这个是入口文件。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 先通过 src 引入 require.js 文件，然后通过 data-main 引入主模块（main.js） --&gt; &lt;script data-main=&quot;js/main.js&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意，上面的代码中，我们直接通过src属性引入requre.js 文件，一旦这个文件发挥作用了，会去找data-main属性里的指向，它正好指向的是主模块。 有了上面这种引入的方式，我们就不用再老土地引入多个&lt;script&gt;标签了。 运行 index.html，打印结果如下： 项目源码：2018-04-11-RequireJSDemo","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/02-JavaScript模块化01：CommonJS","date":"2021-08-06T01:17:25.893Z","updated":"2021-07-28T07:34:11.367Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/02-JavaScript模块化01：CommonJS/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/02-JavaScript%E6%A8%A1%E5%9D%97%E5%8C%9601%EF%BC%9ACommonJS/","excerpt":"","text":"前言网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题： 文件依赖 全局污染、命名冲突 程序模块化包括： 日期模块 数学计算模块 日志模块 登陆认证模块 报表展示模块等。 所有这些模块共同组成了程序软件系统。 一次编写，多次使用，才是提高效率的核心。 模块化的理解什么是模块化概念：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。 模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。 最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。 模块化的好处 避免命名冲突，减少命名空间污染 降低耦合性；更好地分离、按需加载 高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。 高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。 部署方便 模块化规范模块化规范的引入假设我们引入模块化，首先可能会想到的思路是：在一个文件中引入多个js文件。如下： 1234567&lt;body&gt; &lt;script src=&quot;zepto.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;fastClick.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;util/login.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;util/base.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;util/city.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 但是这样做会带来很多问题： 请求过多：引入十个js文件，就有十次http请求。 依赖模糊：不同的js文件可能会相互依赖，如果改其中的一个文件，另外一个文件可能会报错。 以上两点，最终导致：难以维护。 于是，这就引入了模块化规范。 模块化的概念解读模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。 那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。 模块化规范服务器端规范： CommonJS规范：是 Node.js 使用的模块化规范。 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。 浏览器端规范： AMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。 12345- 异步加载模块；- 依赖前置、提前执行：require([`foo`,`bar`],function(foo,bar)&#123;&#125;); //也就是说把所有的包都 require 成功，再继续执行代码。- define 定义模块：define([`require`,`foo`],function()&#123;return&#125;); **CMD规范**：是 SeaJS 在推广过程中对模块化定义的规范化产出。淘宝团队开发。 123456同步加载模块；依赖就近，延迟执行：require(./a) 直接引入。或者Require.async 异步引入。 //依赖就近：执行到这一部分的时候，再去加载对应的文件。define 定义模块， export 导出：define(function(require, export, module)&#123;&#125;); PS：面试时，经常会问AMD 和 CMD 的区别。 另外，还有ES6规范。 这篇文章，我们来讲一下CommonJS。 CommonJS 的基本语法CommonJS 的介绍CommonJS：是 Node.js 使用的模块化规范。 也就是说，Node.js 就是基于 CommonJS 这种模块化规范来编写的。 在 CommonJS 中，每个文件都可以当作一个模块： 在服务器端：模块的加载是运行时同步加载的。 在浏览器端: 模块需要提前编译打包处理。首先，既然同步的，很容易引起阻塞；其次，浏览器不认识require语法，因此，需要提前编译打包。 暴露模块的方式方式一： 1module.exports = value 这个 value 可以是任意的数据类型。 方式二： 1exports.xxx = value 问题: 暴露的模块到底是谁？ 答案：暴露的本质是exports对象。【重要】 比如，方式二可以理解成是，给 exports 对象添加属性。 PS：暴露的关键词是exports，不是export。 引入模块的方式1require(xxx) 解释： 下载的第三方模块：xxx直接为模块名（包名）。 自定义模块：xxx为模块文件路径 CommonJS 在服务器端的实现举例1、初始化项目在工程文件中新建如下目录和文件： 123456modules | module1.js | module2.js | module3.jsapp.js 然后在根目录下新建如下命令： 1npm init 然后根据提示，依次输入如下内容： 包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。 版本：可以用默认的版本 1.0.0，也可以自己修改包名。 其他的参数，一路回车即可。效果如下： 于是，根目录下会自动生成package.json这个文件。点进去看一下： 123456789101112&#123; &quot;name&quot;: &quot;commonjs_node&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;app.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;smyhvae&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 2、导入第三方包uniq这个第三方包的作用是保证唯一性（我们拿它来举例）。我们在当前工程目录下，输入如下命令进行安装： 1npm install uniq 安装成功后，根目录下会自动生成相应的文件： 需要说明的是，我的node版本是 v8.10.0（v8以上），对应的 npm 版本是 v5.6.0，版本比较高，因此，当我输入完npm install uniq之后，package.json中就会自动添加uniq包的依赖： 如果有些童鞋的npm版本较低，就需要手动去添加依赖；另一种方式是，可以使用npm install uniq --save命令，这个多出来的--save就可以自动添加依赖。 我们去官网看一下uniq的用法： 123456let uniq = require(&#x27;uniq&#x27;);let arr = [1, 1, 2, 2, 3, 5];uniq(arr);console.log(arr); //输出结果：[ 1, 2, 3, 5 ] 可以看出，这个包可以起到数组去重的作用。 3、自定义模块（1）module1.js： 123456789101112//暴露方式一：module.exports = value//暴露一个对象出去module.exports = &#123; name: &#x27;我是 module1&#x27;, foo()&#123; console.log(this.name); &#125;&#125;//我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js： 123456//暴露方式一：module.exports = value//暴露一个函数出去module.exports = function()&#123; console.log(&#x27;我是 module2&#x27;);&#125; 注意，此时暴露出去的 exports 对象 等价于整个函数。 （3）module3.js： 1234567891011121314//暴露方式二：exports.xxx = value//可以往 export 对象中不断地添加属性，进行暴露exports.foo1 = function()&#123; console.log(&#x27;module3 中的 foo1 方法&#x27;);&#125;exports.foo2 = function()&#123; console.log(&#x27;module3 中的 foo2 方法&#x27;);&#125;exports.arr = [1,1,2,2,3,5,11]; （4）app.js：（将其他模块汇集到主模块） 1234567891011121314151617181920//将其他模块汇集到主模块let uniq = require(&#x27;uniq&#x27;); //引入时，第三方模块要放在自定义模块的上面let module1 = require(&#x27;./modules/module1&#x27;);let module2 = require(&#x27;./modules/module2&#x27;);let module3 = require(&#x27;./modules/module3&#x27;);//调用module1对象的方法module1.foo();//调用module2的函数module2(); //注意，在定义时，module2对象等价于整个函数function。所以，module2()的意思是，直接调用了函数。//调用module3中的属性module3.foo1();module3.foo2();uniq(module3.arr); //将module3中的数组进行去重操作console.log(module3.arr); //打印数组去重后的结果 这样的话，我们的代码就写完了。 我们在命令行中输入node app.js，就可以把代码跑起来了。打印结果如下： 123456我是 module1我是 module2module3 中的 foo1 方法module3 中的 foo2 方法[ 1, 11, 2, 3, 5 ] CommonJS 基于浏览器端的实现举例1、初始化项目在工程文件中新建如下目录和文件： 12345678js dist //打包生成文件的目录 src //源码所在的目录 | module1.js | module2.js | module3.js | app.js //应用主源文件index.html //因为CommonJS是基于浏览器端，js文件要跑在浏览器的页面上，所以要有这个html页面 然后在根目录下新建如下命令： 1npm init 然后根据提示，依次输入如下内容： 包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。 版本：可以用默认的版本 1.0.0，也可以自己修改包名。 其他的参数，一路回车即可。 于是，根目录下会自动生成package.json这个文件。点进去看一下： 12345678910111213&#123; &quot;name&quot;: &quot;commonjs_browser&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 2、下载第三方包：Browserify这里需要用到Browserify这个工具进行编译打包。Browserify 称为 CommonJS 的浏览器端的打包工具。 输入如下命令进行安装：（两个命令都要输入） 12npm install browserify -g //全局npm install browserify --save-dev //局部。 上面的代码中，-dev表示开发依赖。这里解释一下相关概念： 开发依赖：当前这个包，只在开发环境下使用。 运行依赖：当前这个包，是在生产环境下使用。 3、自定义模块 &amp; 代码运行（1）module1.js： 123456789101112//暴露方式一：module.exports = value//暴露一个对象出去module.exports = &#123; name: &#x27;我是 module1&#x27;, foo()&#123; console.log(this.name); &#125;&#125;//我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js： 123456//暴露方式一：module.exports = value//暴露一个函数出去module.exports = function()&#123; console.log(&#x27;我是 module2&#x27;);&#125; 注意，此时暴露出去的 exports 对象 等价于整个函数。 （3）module3.js： 1234567891011//暴露方式二：exports.xxx = value//可以往export对象中不断地添加属性，进行暴露exports.foo1 = function()&#123; console.log(&#x27;module3 中的 foo1 方法&#x27;);&#125;exports.foo2 = function()&#123; console.log(&#x27;module3 中的 foo2 方法&#x27;);&#125; （4）app.js：（将其他模块汇集到主模块） 12345678let module1 = require(&#x27;./module1&#x27;); // ./ 指的是当前路径let module2 = require(&#x27;./module2&#x27;);let module3 = require(&#x27;./module3&#x27;);module1.foo();module2();module3.foo1();module3.foo2(); 引入的路径解释： ./是相对路径，指的是当前路径（app.js的当前路径是src） 到此，我们的主要代码就写完了。 但是，如果我们直接在index.html中，像下面这样写，是不行的：（因为浏览器不认识 require 关键字） 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./js/src/app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 为了能够让index.html引入app.js，我们需要输入如下命令： 打包处理js: 1browserify js/src/app.js -o js/dist/bundle.js 然后在index.html中引入打包后的文件： 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt; othersSeaJS 的介绍SeaJS：一个基于CMD规范实现的模块化开发解决方案。 作者：Alibaba 玉伯。 官网：http://seajs.org/ GitHub：https://github.com/seajs/seajs 现在官网变成了：https://seajs.github.io/seajs/docs/ 特性： 简单友好的模块定义规范。 自然直观的代码组织方式。 RequireJS（AMD）、SeaJS（CDM）、CommonJS、ES6 的对比1、RequireJS 和 AMD： 异步模块定义，特点是依赖前置。 2、SeaJS 和 CMD： 同步模块定义。 123456789// 所有模块都通过 define 来定义define(funtion(require, exports, module) &#123; //通过 require 引入依赖 var $ require(`jquery`); var Spinning = require(`./spinning`);&#125;) 3、CommonJS： 以上三个都是 ES5里面的规范。 4、ES6： ES6的特性：export/import","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/01-Node.js入门","date":"2021-08-06T01:17:25.891Z","updated":"2021-07-28T07:34:11.366Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/01-Node.js入门/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/01-Node.js%E5%85%A5%E9%97%A8/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 Node.js的介绍引擎引擎的特性： JS的内核即引擎。因为引擎有以下特性： （1）转化的作用： 汽油柴油等等-&gt;动能 模板+数据—&gt;页面 js引擎：js 代码—&gt;机器码\\字节码 （2）移植性。 有哪些引擎： 备注：Node是用V8引擎去解析 js，此时，我们不用去考虑浏览器的兼容性问题。 什么是 Node.js1、官方解释： Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js使用了一个事件驱动、非阻塞式I/O的模型（ Node.js的特性），使其轻量级又高效。 Node.js 的包管理器 npm 是全球最大的开源库生态系统。 如上图所示： Node 内部采用 Google Chrome 的 V8 引擎，作为 JavaScript 语言解释器； 通过自行开发的 libuv 库，调用操作系统资源。 2、非官方解释： Node.js：是 JavaScript 语言在服务器端的运行环境（平台）。 3、运行环境（平台）的含义： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机。 其次，Node 提供大量工具库，使得 JavaScript 语言能与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 总结： Node.js 是一个 JavaScript 的运行环境（平台），不是一门语言，也不是 JavaScript 的框架。 与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在 Chrome 的 V8 引擎上。 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS。），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js没有web容器。 Node 的历史 2008年左右，随着 AJAX 的逐渐普及，Web 开发逐渐走向复杂化，系统化； 2009年2月，Ryan Dahl 想要创建一个轻量级，适应现代 Web 开发的平台； 2009年5月，Ryan Dahl 在 GitHub 中开源了最初版本，同年11月，JSConf 就安排了 Node 讲座； 2010年底，Joyent 公司资助，Ryan Dahl 也加入了该公司，专门负责 Node 的开发； 2011年7月，在微软的支持下登陆 Windows 平台。PS：node 的生产环境基本是在 Linux 下。 据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。 注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。 国内外的应用情况以下几个项目都用到了 Node： https://github.com/nodejs/node-v0.x-archive/wiki/Projects,-Applications,-and-Companies-Using-Node https://nodejs.org/en/foundation/members/ https://github.com/NetEase/pomelo 还有以下几个网站： LinkedIn移动版From RoR to Node.js, base on Joyent Paypal From Java to Node.js Twitter的队列：收集需要保存的Tweets，传给负责写入的进程 知乎的推送 网易、阿里、各种创业团队等 Node.js的主要应用领域 RESTFul API 实时通信：如消息推送等 高并发 I/O阻塞 知名度较高的Node.js开源项目 express：Node.js中最有名的web服务器框架。 PM2：node 本来是单进程的，PM2可以实现和管理多进程。 jade：非常优秀的模板引擎，不仅限于 js 语言。 CoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。 Atom：文本编辑器。 socket.io：实时通信框架。 mocha：功能强大的 node.js 测试框架。 Node.js的特点单线程Node.js 的环境配置Node.js 安装包（不推荐）去 Node.js 的官网下载安装包： 我们也可以在https://nodejs.org/en/download/releases/上下载历史版本。 注意，我们以一定要用偶数版（V4、V6等)，不要用奇数版（比如V5），因为奇数版不稳定。 我们并不推荐直接采用 Node.js.msi 安装包进行安装，不方便 node 的更新，原因如下： 以前版本安装的很多全局的工具包需要重新安装； 无法回滚到之前的版本； 无法在多个版本之间切换（很多时候我们要使用特定版本）。 因此，我们暂时先不用安装 Node.js，稍后用 NVM 的方式来安装 Node.js。 通过 NVM 安装Node.js（推荐）NVM：node.js version manager，用来管理 node 的版本。安装的步骤如下。 （1）我们去官网下载 NVM 的安装包： 下载下来后，直接解压到 D:\\web目录下： （2）在上面的目录中，新建一个settings.txt文件，里面的内容填充如下： 1234root: D:\\web\\nvmpath: D:\\web\\nodejsarch: 64proxy 上方内容的解释： root 配置为：当前 nvm.exe 所在的目录 path 配置为：node 快捷方式所在的目录 arch 配置为：当前操作系统的位数（32/64） proxy 不用配置 （3）配置环境变量： NVM_HOME = D:\\web\\nvm（当前 nvm.exe 所在目录） NVM_SYMLINK = D:\\web\\nodejs （node 快捷方式所在的目录） PATH += ;%NVM_HOME%;%NVM_SYMLINK% 配置成功后，重启资源管理器。 验证：(在 cmd 中输入命令) （1）输入nvm命令查看环境变量是否配置成功： （2）输入 nvm ls，查看已安装的所有 node 版本。 （3）输入 nvm -v，查看 已安装的 nvm 版本。 （4）输入 node -v，查看正在使用的 node 版本。 参考链接：安装npm，nvm，node 如果 node 安装失败，可以参考上面这个链接。 NVM 的常用命令查看当前使用的 nvm 版本： 123nvm -vnvm --version 查看本地安装的所有的 node 版本： 1nvm list|ls 安装指定版本的node： 1nvm install 版本号 [arch] 比如：nvm install 8.10.0。 卸载指定版本node： 1nvm uninstall 版本号 切换使用指定版本的node： 1nvm use 版本号 [arch] Node 的常用命令查看 node 的版本： 1$ node -v 执行脚本字符串： 1$ node -e &#x27;console.log(&quot;Hello World&quot;)&#x27; 运行脚本文件： 12345$ node index.js$ node path/index.js$ node path/index 查看帮助： 12$ node --help 进入 REPL 环境： 1$ node REPL 的全称：Read、Eval、 Print、Loop。类似于浏览器的控制台。 如果要退出 REPL 环境，可以输入.exit 或 process.exit() 。 在 VS Code 里，我们可以在菜单栏选择“帮助-&gt;切换开发人员工具”，打开console控制台。 包和 NPM什么是包由于 Node 是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念：与核心模块类似，就是将一些预先设计好的功能或者说 API 封装到一个文件夹，提供给开发者使用。 Node 本身并没有太多的功能性 API，所以市面上涌现出大量的第三方人员开发出来的 Package。 包的加载机制如果 Node中自带的包和第三方的包名冲突了，该怎么处理呢？原则是： 先在系统核心（优先级最高）的模块中找； 然后到当前项目中 node_modules 目录中找。 比如说： 1requiere(`fs`) 那加载的肯定是系统的包。所以，我们尽量不要创建一些和现有的包重名的包。 NPM的概念 包的生态圈一旦繁荣起来，就必须有工具去来管理这些包。NPM 应运而生。 NPM：Node Package Manager。官方链接： https://www.npmjs.com/ 随着时间的发展，NPM 出现了两层概念： 一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区。 另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。 NPM 的安装（不需要单独安装）NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM： NVM、Node、NPM 安装之后，目录分布如下： 输入 npm -v，查看 npm 的版本： 如果上方命令无效，可能是之前的 node 并没有完全安装成功。解决办法：https://segmentfault.com/a/1190000011114680 另外，Node 附带的 NPM 可能不是最新版本，可以用下面的命令，更新到最新版本： 1$ npm install npm -g 配置 NPM 的全局目录（暂略）NPM 默认安装到当前正在使用 Node 版本所在目录下。我们建议重新配置 NPM 的全局目录。 输入npm config ls，查看： NPM的常用命令 npm init –yes 项目的初始化。执行完成后，会生成package.json文件。 npm install [package] 只在当前工程下安装 package。 npm install -g [package] 在全局环境下安装 package。 npm run [script] NRM的安装(Win 和 Mac 通用)由于 NPM 的资源都在国外，有时候会被墙，导致无法下载或者很慢。此时可以用到NRM。 NRM：Node Registry Manager。作用是：切换和管理包的镜像源。 项目地址：https://www.npmjs.com/package/nrm GitHub地址： https://github.com/Pana/nrm 安装 NRM： 1npm install -g nrm NRM 的常用命令： 123nrm ls //显示全部的镜像nrm use taobao // 使用淘宝的镜像 效果入下： 推荐的国内加速镜像淘宝：https://npm.taobao.org/ 安装cnpm 项目地址：https://npm.taobao.org/ 安装cnpm替换npm（npm由于源服务器在国外，下载node包速度较慢，cnpm使用国内镜像）： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 如果我们需要通过 cnpm 去安装一个包时，举例如下： 1cnpm i vue 解释： i 指的就是 install。 Node 的使用我们可以输入node命令，然后在里面写 js 的代码，也可以 通过 node 运行 js 文件。比如，编写好一个 js文件01.js，然后在命令行输入： 1node 01.js 就可以执行 js 程序。 Mac 下的环境安装Mac 下安装 NVM（1）打开 终端.app，输入： 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 安装成功的界面： 完成后，nvm就被安装在了~/.nvm下。 如果发现安装失败： 原因：Xcode 软件进行过更新。 解决办法：打开 Xcode 软件，同意相关内容即可。 （2）配置环境变量： 打开文件： 1open ～／.bash_profile 在最后一行输入： 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 如果你发现文件中已经存在了上面这行代码，就不用往里面加了。 最后，重启终端软件，输入nvm试试。 PS：NVM 现在已经不支持 Homebrew 的方式来安装了。 参考链接：https://www.jianshu.com/p/a3f8778bc0a1 Mac 下安装 Node（通过nvm安装）和Windows下一样，也是执行如下命令： 1nvm install 8.10.0 网速有点慢，要稍等。 输入 node -v，查看当前使用的 node 版本。 安装好 Node 之后，npm 也会自动安装的，输入 npm -v，查看 npm 的版本。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/10-Node.js和模块化/00-事件驱动和非阻塞机制","date":"2021-08-06T01:17:25.888Z","updated":"2021-07-28T07:34:11.366Z","comments":true,"path":"2021/08/06/大前端/10-Node.js和模块化/00-事件驱动和非阻塞机制/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/10-Node.js%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/00-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6/","excerpt":"","text":"异步编程异步操作 Node 采用 Chrome V8 引擎处理 JavaScript 脚本。V8 最大特点就是单线程运行，一次只能运行一个任务。 Node 大量采用异步操作（asynchronous operation），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。 提高代码的响应能力。 异步IO也叫非阻塞IO。例如读文件，传统的语言，基本都是读取完毕才能进行下一步操作。非阻塞就是Node的callback，不会影响下一步操作，等到文件读取完毕，回调函数自动被执行，而不是在等待。 异步操作回调由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方。 Node 中的操作方式就是以异步回调的方式解决无状态的问题。 回调函数的设计：错误优先异步操作中，无法通过 try catch 捕获异常。 这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。 统一约定： 回调函数的第一个参数默认接收错误信息，第二个参数才是真正的回调数据（便于外界获取调用的错误情况）： 1234foo1(&#x27;赵小黑&#x27;, 19, function(error, data) &#123; if(error) throw error; console.log(data);&#125;); 异步回调的问题相比较于传统的代码： 异步事件驱动的代码 不容易阅读 不容易调试 不容易维护 另外还有个问题是回调黑洞：（回调黑洞） 123456789101112do1(function() &#123; do2(function() &#123; do3(function() &#123; do4(function() &#123; do5(function() &#123; do6() &#125;); &#125;); &#125;); &#125;);&#125;); 进程和线程进程（进行中的程序） 每一个 正在运行 的应用程序都称之为进程。 每一个应用程序运行都至少有一个进程。 进程是用来给应用程序提供一个运行的环境。 进程是操作系统为应用程序分配资源的一个单位。 线程 用来执行应用程序中的代码 在一个进程内部，可以有很多的线程 在一个线程内部，同时只可以干一件事 传统的开发方式大部分都是 I/O 阻塞的，所以需要多线程来更好的利用硬件资源。 线程并不是越多越好。 多线程的弊端缺点一： - 创建线程耗费。 - 线程数量有限。 - CPU 在不同线程之间转换，有个上下文转换，这个转换非常耗时。 所谓的多线程其实都是假的，对于单核CPU而言，它们无非是在抢占 CPU 资源。线程和线程之间需要切换和调度，这是很耗费资源的。 缺点二： 线程之间共享某些数据，同步某个状态都很麻烦。 就算 CPU 是多核的，现在的问题是，线程与线程之间如果要共享数据，该怎么办？比如 A 线程要访问 B 线程的变量。 事件驱动和非阻塞机制参考链接：https://www.kancloud.cn/revin/nodejs/176211 总结： Node 中将所有的阻塞操作交给了内部线程池实现。 Node 主线程本身，主要就是不断的往返调度。 平台实现差异由于 Windows 和 *nix 平台（其他平台）的差异，Node 提供了 libuv 作为抽象封装层，保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。 如下图所示：","categories":[],"tags":[]},{"title":"","slug":"大前端/09-Ajax/05-模板引擎","date":"2021-08-06T01:17:25.883Z","updated":"2021-07-28T07:34:11.364Z","comments":true,"path":"2021/08/06/大前端/09-Ajax/05-模板引擎/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/09-Ajax/05-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","excerpt":"","text":"模版引擎引入我们在使用ajax请求数据时，返回的如果是一个 JSON 格式的字符串，我们需要将其包装到对应的HTML代码中，再添加到页面上，才能看到效果。那么这个包装得过程有没有简单的方法呢? 假设在 js 中有如下数据： 12345var obj = &#123; name:&quot;fox&quot;, age:18, skill:&quot;卖萌&quot;&#125;; 希望包装为: 12345&lt;ul&gt; &lt;li&gt;姓名:fox&lt;/li&gt; &lt;li&gt;年龄:18&lt;/li&gt; &lt;li&gt;爱好:卖萌&lt;/li&gt;&lt;/ul&gt; 我们可以通过模板插件来实现。 模版插件的原理我们定义一段文本作为模板,读取文本,使用特殊的符号&lt;%= 属性名 %&gt;,通过正则表达式找到这些特殊的符号进行替换,是不是就实现了这样的效果呢? 常见的模板引擎 BaiduTemplate(百度开发) ArtTemplate(腾讯开发)：GitHub地址、文档地址。 velocity.js(淘宝开发) Handlebars ArtTemplate标准语法： 123&#123;&#123;if user&#125;&#125; &lt;h2&gt;&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;&#123;&#123;/if&#125;&#125; 渲染模板： 123456var data = &#123; title: `标签`, list: [`文艺`, `博客`, `摄影`]&#125;;var html = template(`test`, data);document.getElementById(`content`).innerHTML = html; 举例： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;js/template-native-debug.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery-2.2.0.js&quot;&gt;&lt;/script&gt; &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;h3&gt;&lt;%= className %&gt;&lt;/h3&gt; &lt;ul&gt; &lt;% for(var i = 0; i&lt; students.length;i++) &#123; %&gt; &lt;li&gt;&lt;%= i+1 %&gt;. &lt;%= students[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/script&gt; &lt;script&gt; var data = &#123; className:&quot;前端1期&quot;, students:[&quot;张飞&quot;,&quot;刘备&quot;,&quot;诸葛亮&quot;,&quot;甄姬&quot;,&quot;小乔&quot;,&quot;汪汪&quot;] &#125;; $(function ()&#123; var html = template(&quot;tpl&quot;,data); $(&quot;#demo&quot;).html(html); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果：","categories":[],"tags":[]},{"title":"","slug":"大前端/09-Ajax/04-同源和跨域","date":"2021-08-06T01:17:25.881Z","updated":"2021-07-28T07:34:11.363Z","comments":true,"path":"2021/08/06/大前端/09-Ajax/04-同源和跨域/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/09-Ajax/04-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源和跨域同源同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 跨域问题的解决方案从我自己的网站访问别人网站的内容，就叫跨域。 出于安全性考虑，浏览器不允许ajax跨域获取数据。 iframe：处于安全性考虑，浏览器的开发厂商已经禁止了这种方式。 JSONP：script 标签的 src 属性传递数据。 JSONPJSONP(JSON with Padding)：带补丁的 json，本质是利用了 &lt;script src=&quot;&quot;&gt;&lt;/script&gt;标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。 我们知道， html标签的 src 属性是支持跨域的： 1&lt;img src=&quot;http://img.smyhvae.com/2016040101.jpg&quot; alt=&quot;&quot;&gt; jsonp 就是利用这个特性实现的跨域，但用的是 script 标签。如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --&gt;&lt;script type=&quot;text/javascript&quot; src=&#x27;http://192.168.141.137/2018-02-28/myData.php&#x27;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方那一行的代码，意思是：刷新A服务器上的index页面后，会去请求 B 服务器上的 myData.php 这个页面。而且请求的方式是 get 请求。 但是 B 服务器上的页面不是你想请求就可以请求的，大家一起配合才可以。 具体实现步骤： 需要首先声明的是，jsonp 只能通过 GET 方式进行请求。 （1）A客户端的代码： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 定义 eatFood()方法 function fn(data) &#123; console.log(&#x27;我被调用了哦&#x27;); console.log(data); &#125;&lt;/script&gt;&lt;!-- 使用 script标签 发送了 get请求 去到了一个 php页面 --&gt;&lt;script type=&quot;text/javascript&quot; src=&#x27;http://192.168.141.137/01.php?callback1=fn&#x27;&gt;&lt;/script&gt; 我们来分析上方代码中的最后一行的那个url：A 客户端请求的是 B服务器上的 01.php页面。url里有个callback1=fn，意思是：callback1是A和B 之间的约定，约定后，将执行方法 fn。 其实，fn方法已经在最后一行代码中执行了。只不过，fn方法里的data数据，是从 B 服务器中获取的。 （2）B服务器端的代码： 1234567&lt;?php $mycallBack = $_GET[&#x27;callback1&#x27;]; $arr = array(&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;zhaoliu&quot;); echo $mycallBack.`(`.json_encode($arr).`)`; //字符串拼接?&gt; 代码解释： 第一行的callback1 是A和B之间的约定，二者必须一致。 echo语句中输出的内容，即使要返回给A客户端的内容，此内容会保存在 A 客户端的fn方法的data里。 data[0]指的是 zhangsan。 json_encode指的是，将php对象转化为 json。 刷新A页面，输出结果为： 1mycallBack([&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;zhaoliu&quot;]) jQuery 中的 JSONP我们知道，jQuery 中发送 Ajax 请求，格式是： 12345678910111213141516$(&quot;#btn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;./data.php?callback1=fn&quot;, dataType:&quot;jsonp&quot;, type:&quot;get&quot;, //jsonp:&quot;callback1&quot;, //传递给B服务器的回调函数的名字（默认为 callback） //jsonCallBack:&quot;fn&quot; //自定义的函数名称。默认为 jQuery 自动生成的随机函数名 success:function(data)&#123; alert(data); //$(&quot;#showInfo&quot;).html(data); &#125;, error:function(e)&#123; console.log(e); &#125; &#125;);&#125;); 那如果数据是 JSONP，上方代码则改为： 1234567891011121314$(&quot;#btn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;./data.php?fn&quot;, dataType:&quot;text&quot;, type:&quot;get&quot;, success:function(data)&#123; alert(data); //$(&quot;#showInfo&quot;).html(data); &#125;, error:function(e)&#123; console.log(e); &#125; &#125;);&#125;); 参考链接参考链接：https://www.cnblogs.com/2050/p/3191744.html","categories":[],"tags":[]},{"title":"","slug":"大前端/09-Ajax/03-函数封装：Ajax发送http请求（get&post）","date":"2021-08-06T01:17:25.879Z","updated":"2021-07-28T07:34:11.363Z","comments":true,"path":"2021/08/06/大前端/09-Ajax/03-函数封装：Ajax发送http请求（get&post）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/09-Ajax/03-%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%EF%BC%9AAjax%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%EF%BC%88get&post%EF%BC%89/","excerpt":"","text":"函数封装ajax_tool.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// 方法：ajax get 五部曲function ajax_get(url,data) &#123; // 异步对象 var ajax = new XMLHttpRequest(); // url 方法 // 如果是get发送数据 发送的格式为 xxx.php?name=jack&amp;age=18 // 所以 这里 需要拼接 url if (data) &#123; // 如果有值 需要拼接字符串 // 拼接为xxx.php?name=jack&amp;age=18 url+=&#x27;?&#x27;; url+=data; &#125;else&#123; &#125; ajax.open(&#x27;get&#x27;,url); // 发送 ajax.send(); // 注册事件 ajax.onreadystatechange = function () &#123; // 在事件中 获取数据 并修改界面显示 if (ajax.readyState==4&amp;&amp; ajax.status==200) &#123; console.log(ajax.responseText); &#125; &#125;&#125;// 方法：ajax_post五部曲function ajax_post(url,data) &#123; // 异步对象 var ajax = new XMLHttpRequest(); // url 方法 ajax.open(&#x27;post&#x27;,url); // 设置 请求报文 ajax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); // 发送 if (data) &#123; // 如果 有值 post请求 是在 send中 发送给服务器 ajax.send(data); &#125;else&#123; ajax.send(); &#125; // 注册事件 ajax.onreadystatechange = function () &#123; // 在事件中 获取数据 并修改界面显示 if (ajax.readyState==4&amp;&amp;ajax.status==200) &#123; console.log(ajax.responseText); &#125; &#125;&#125;// 方法：将 get 跟post 封装到一起/* 参数1:url 参数2:数据 参数3:请求的方法 参数4:数据成功获取以后，调用的方法*/function ajax_tool(url,data,method,success) &#123; // 异步对象 var ajax = new XMLHttpRequest(); // get 跟post 需要分别写不同的代码 if (method==&#x27;get&#x27;) &#123; // get请求 if (data) &#123; // 如果有值 url+=&#x27;?&#x27;; url+=data; &#125;else&#123; &#125; // 设置 方法 以及 url ajax.open(method,url); // send即可 ajax.send(); &#125;else&#123; // post请求 // post请求 url 是不需要改变 ajax.open(method,url); // 需要设置请求报文 ajax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); // 判断data send发送数据 if (data) &#123; // 如果有值 从send发送 ajax.send(data); &#125;else&#123; // 木有值 直接发送即可 ajax.send(); &#125; &#125; // 注册事件 ajax.onreadystatechange = function () &#123; // 在事件中 获取数据 并修改界面显示 if (ajax.readyState==4&amp;&amp;ajax.status==200) &#123; // console.log(ajax.responseText); // 将 数据 让 外面可以使用 // return ajax.responseText; // 当 onreadystatechange 调用时 说明 数据回来了 // ajax.responseText; // 数据成功获取以后，执行方法success()。 //我们把获取的数据作为 success()的参数，意思是： //success方法是外面的，数据是里面给的。那数据就变相地传递到了外面去【重要】 success(ajax.responseText); &#125; &#125;&#125; 函数调用（get方法）test_get.html: 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;测试get&quot; id=&#x27;ajax_get&#x27;&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 导入 封装的js --&gt;&lt;script type=&quot;text/javascript&quot; src=&#x27;ajax_tool.js&#x27;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.querySelector(&#x27;#ajax_get&#x27;).onclick = function () &#123; // 直接使用 封装的 工具函数即可 /* 参数1:url 参数2:数据 参数3:请求的方法 参数4：请求成功后，调用的方法 */ var backData = ajax_tool(&#x27;test_get.php&#x27;,&#x27;name=smyhvae&amp;skill=code&#x27;,&#x27;get&#x27;,function(data)&#123; console.log(data); &#125;); // 测试 console.log(backData); &#125;&lt;/script&gt; test_get.php： 1234&lt;?php // 获取get提交的数据 echo $_GET[&#x27;skill&#x27;]; ?&gt; 函数调用（post方法）test_post.html： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;测试post&quot; id=&#x27;ajax_post&#x27;&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 导入 封装的js --&gt;&lt;script type=&quot;text/javascript&quot; src=&#x27;ajax_tool.js&#x27;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.querySelector(&#x27;#ajax_post&#x27;).onclick = function () &#123; // 直接使用 封装的 工具函数即可 /* 参数1:url 参数2:数据 参数3:请求的方法 参数4:数据获取成功调用的方法 */ var backData = ajax_tool(&#x27;02.test_post.php&#x27;,&#x27;friend=好丽友&#x27;,&#x27;post&#x27;,function(data)&#123; console.log(data); &#125;); // 测试 console.log(backData); // 怎么样 处理数据 全部写在 匿名函数中 ajax_tool(&#x27;02.test_post.php&#x27;,&#x27;friend=好丽友&#x27;,&#x27;post&#x27;,function(data)&#123; console.log(data); // 修改页面的显示呢? &#125;); &#125;&lt;/script&gt; test_post.php： 12345&lt;?php echo $_POST[&#x27;friend&#x27;]; ?&gt; 工程文件： 2018-02-28-Ajax请求封装.rar","categories":[],"tags":[]},{"title":"","slug":"大前端/09-Ajax/02-Ajax入门和发送http请求","date":"2021-08-06T01:17:25.876Z","updated":"2021-07-28T07:34:11.363Z","comments":true,"path":"2021/08/06/大前端/09-Ajax/02-Ajax入门和发送http请求/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/09-Ajax/02-Ajax%E5%85%A5%E9%97%A8%E5%92%8C%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 同步和异步同步和异步的概念 同步：必须等待前面的任务完成，才能继续后面的任务。 异步：不受当前任务的影响。 拿排队举例： 同步：在银行排队时，只有等到你了，才能够去处理业务。 异步：在排队的时候，可以玩手机。 异步更新网站我们在访问一个普通的网站时，当浏览器加载完HTML、CSS、JS以后，网站的内容就固定了。如果想让网站内容发生更改，就必须刷新页面才能够看到更新的内容。 可如果用到异步更新，情况就大为改观了。比如，我们在访问新浪微博时，看到一大半了，点击底部的加载更多，会自动帮我们加载更多的微博，同时页面并没有刷新。 试想一下，如果没有异步刷新的话，每次点击“加载更多”，网页都要刷新，体验就太不好了。 web前端里的异步更新，就要用到 Ajax。 AjaxAjax 的概念在浏览器中，我们可以在不刷新页面的情况下，通过ajax的方式去获取一些新的内容。 Ajax：Asynchronous Javascript And XML（异步 JavaScript 和 XML）。它并不是凭空出现的新技术，而是对于现有技术的结合。Ajax 的核心是 js 对象：XMLHttpRequest。 发送 Ajax 请求的五个步骤 其实也就是 使用 XMLHttpRequest 对象的五个步骤。 我们先回忆一下，一个完整的HTTP请求需要的是： 请求的网址、请求方法get/post。 提交请求的内容数据、请求主体等。 接收响应回来的内容。 发送 Ajax 请求的五个步骤： （1）创建异步对象。即 XMLHttpRequest 对象。 （2）使用open方法设置请求的参数。open(method, url, async)。参数解释：请求的方法、请求的url、是否异步。 （3）发送请求。 （4）注册事件。 注册onreadystatechange事件，状态改变时就会调用。 如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 （5）获取返回的数据。 Ajax 请求：get 请求举例（1）index.html： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送get_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 绑定点击事件 document.querySelector(&#x27;#btnAjax&#x27;).onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var ajaxObj = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 ajaxObj.open(&#x27;get&#x27;, &#x27;02-ajax.php&#x27;); // （3）发送请求 ajaxObj.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 ajaxObj.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log(&#x27;数据返回成功&#x27;); // 数据是保存在 异步对象的 属性中 console.log(ajaxObj.responseText); // 修改页面的显示 document.querySelector(&#x27;h1&#x27;).innerHTML = ajaxObj.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; （2）02-ajax.php： 123&lt;?php echo &#x27;smyhvae&#x27;; ?&gt; 效果如下： Ajax 请求：post 请求举例index.html： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;发送put_ajax请求&quot; id=&#x27;btnAjax&#x27;&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open(&#x27;post&#x27;, &#x27;02.post.php&#x27;); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); // 将数据通过send方法传递 xhr.send(&#x27;name=fox&amp;age=18&#x27;); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest 对象详解我们在上一段讲解了使用 XMLHttpRequest 对象的五个步骤。本段，我们讲一下注意事项。 发送请求发送请求的方法： 1open(method, url, async); 参数解释： method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） 另外还有个方法：（仅用于 POST 请求） 1send(string); POST请求时注意如果想让 像form 表单提交数据那样使用POST请求，就需要使用 XMLHttpRequest 对象的 setRequestHeader()方法 来添加 HTTP 头。然后在 send() 方法中添加想要发送的数据： 12345xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.php&quot;, true);xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;name=smyhvae&amp;age=27&quot;); onreadystatechange 事件注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。 readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status： 200: “OK”。 404: 未找到页面。 在 onreadystatechange 事件中，当 readyState 等于 4，且状态码为200时，表示响应已就绪。 服务器响应的内容 responseText：获得字符串形式的响应数据。 responseXML：获得 XML 形式的响应数据。 如果响应的是普通字符串，就使用responseText；如果响应的是XML，使用responseXML。 Ajax 传输 XMLXML 语法XML（Extensible Markup Language）：可扩展标记语言。详细语法可以查看：#。 1、XML声明： 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 第一行的声明，指定了XML版本(1.0)以及使用的编码。 2、自定义标签： XML中没有默认的标签，所有的标签都是我们自己已定义的。例如： 12&lt;fox&gt;&lt;/fox&gt;&lt;name&gt;&lt;/name&gt; XML中没有单标签，都是双标签。 3、根节点： XML中必须要有一个根节点，所有的子节点都放置在根节点下。例如： 123&lt;root1&gt; &lt;name&gt;&lt;/name&gt;&lt;/root1&gt; XML 解析因为 XML 就是标签，所以我们可以直接用解析Dom元素的方法解析 XML。 解析过程： （1）html 部分：（包含 xml ） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;person id=&#x27;personXML&#x27;&gt; &lt;name&gt;fox&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;skill&gt;小花花&lt;/skill&gt; &lt;/person&gt;&lt;/body&gt;&lt;/html&gt; （2）解析 xml： 1234567&lt;script type=&quot;text/javascript&quot;&gt; var xmlObj = document.getElementById(&quot;personXML&quot;); var name = xmlObj.getElementsByTagName(&#x27;name&#x27;)[0].innerHTML; console.log(name);&lt;/script&gt; ajax 请求解析xml（举例）（1）get_xml.php：（里面包含了xml文件） 12345678&lt;?php // 设置 返回的为 xml header(&#x27;content-type:text/xml; charset= utf-8&#x27;); // 读取xml文件 并返回 echo file_get_contents(&#x27;info/star.xml&#x27;); ?&gt; 上方代码解释： php 自带了 读取 xml 文件的方法。 在 php 中，如果要使用xml传输数据，则需要使用header()设置返回的内容为xml。 （2）get_xml.html：（Ajax 请求，获取并解析xml） 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;获取XMl数据&quot; id=&#x27;getXML&#x27;&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.querySelector(&#x27;#getXML&#x27;).onclick = function () &#123; var ajax = new XMLHttpRequest(); ajax.open(&#x27;get&#x27;,&#x27;get_XMl.php&#x27;); ajax.send(); ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status==200) &#123; // 如果 返回的是 xml文件 console.log(ajax.responseText); // 异步 对象中 有另外一个属性 用来专门获取 xml // xml对象 在浏览器段 就是一个 document对象 // 解析时 可以直接使用 querySelector 或者 getElementById等等 document对象 有的语法 console.log(ajax.responseXML); console.log(ajax.responseXML.querySelector(&#x27;kuzi&#x27;).innerHTML); // 下面这个 页面文档对象 如果要获取某个标签 console.log(window.document); &#125; &#125; &#125;&lt;/script&gt; Ajax 传输 JSONJSON 的语法JSON(JavaScript Object Notation)：是ECMAScript的子集。作用是进行数据的交换。语法更为简洁，网络传输、机器解析都更为迅速。 语法规则： 数据在键值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 数据类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 示例： 12345678910111213141516171819// 对象&#123; &quot;name&quot;:&quot;fox&quot;, &quot;age&quot;:&quot;18&quot;, &quot;sex&quot;:&quot;true&quot;, &quot;car&quot;:null&#125;// 数组[ &#123; &quot;name&quot;:&quot;小小胡&quot;, &quot;age&quot;:&quot;1&quot; &#125;, &#123; &quot;name&quot;:&quot;小二胡&quot;, &quot;age&quot;:&quot;2&quot; &#125;] JavaScript中：json 字符串 &lt;–&gt; js 对象基本上，所有的语言都有将 json 字符串转化为该语言对象的语法。 比如在 js中： JSON.parse()：将JSON字符串转化为 js 对象。例如： 12// 将 JSON 字符串格式化为 js 对象var jsObj = JSON.parse(ajax.responseText); JSON.stringify()：将 JS 对象转化为JSON字符串。例如： 12345678910var Obj = &#123; name: &quot;fox&quot;, age: 18, skill: &quot;撩妹&quot;&#125;;console.log(Obj);// 将 js 对象格式化为 JSON 字符串var jsonStr = JSON.stringify(Obj); PHP中：json 字符串 &lt;–&gt; js 对象 **json_decode()**方法：将json字符串转化为变量。 **json_encode()**方法：将变量转化为json字符串。 代码举例： 12345678910111213&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); // json字符串 $jsonStr = &#x27;&#123;&quot;name&quot;:&quot;itcast&quot;,&quot;age&quot;:54,&quot;skill&quot;:&quot;歌神&quot;&#125;&#x27;; // 字符串转化为 php对象 print_r(json_decode($jsonStr)); echo &quot;&lt;br&gt;&quot;; // php数组 $arrayName = array(&#x27;name&#x27; =&gt;&#x27;littleFox&#x27; ,&#x27;age&#x27; =&gt; 13 ); // php对象 转化为 json字符串 print_r(json_encode($arrayName)); ?&gt; 输出结果： 123stdClass Object ( [name] =&gt; itcast [age] =&gt; 54 [skill] =&gt; 歌神 )&#123;&quot;name&quot;:&quot;littleFox&quot;,&quot;age&quot;:13&#125; ajax 请求解析 json（举例）（1）Person.json: 12345&#123; &quot;name&quot;:&quot;小强&quot;, &quot;skill&quot;:&quot;砍树&quot;, &quot;friend&quot;:&quot;老板&quot;&#125; （2）myJson.php： 123456&lt;?php // 读取json文件 并返回即可 echo file_get_contents(&#x27;info/Person.json&#x27;); ?&gt; （3）getJson.html： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;获取 json 数据&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取json&quot; id=&#x27;btnJson&#x27;&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 获取的是一个 如果要获取多个 // document.querySelectorAll(selector) document.querySelector(&quot;#btnJson&quot;).onclick = function () &#123; var ajax = new XMLHttpRequest(); ajax.open(&#x27;get&#x27;,&#x27;myJson.php&#x27;); ajax.send(); ajax.onreadystatechange = function () &#123; if (ajax.readyState==4&amp;&amp;ajax.status==200) &#123; // json 字符串 是字符串 所以我们可以 通过 responseText获取 console.log(ajax.responseText); // 转化为 js对象 var jsObj = JSON.parse(ajax.responseText); console.log(jsObj); // 拼接ul s var str = &#x27;&#x27;; str+=&#x27;&lt;ul&gt;&#x27;; str+=&#x27;&lt;li&gt;&#x27;+jsObj.name+&#x27;&lt;/li&gt;&#x27;; str+=&#x27;&lt;li&gt;&#x27;+jsObj.skill+&#x27;&lt;/li&gt;&#x27;; str+=&#x27;&lt;li&gt;&#x27;+jsObj.friend+&#x27;&lt;/li&gt;&#x27;; str+=&#x27;&lt;/ul&gt;&#x27;; // 设置到界面上 document.body.innerHTML = str; &#125; &#125; &#125;&lt;/script&gt; 演示效果： jQuery 中的 AjaxJQuery作为最受欢迎的js框架之一，常见的Ajax已经帮助我们封装好了，只需要调用即可。更为详细的api文档可以查阅：w3cSchool_JQueryAjax 格式举例： 12345678$.ajax(&#123; url:&#x27;01.php&#x27;,//请求地址 data:&#x27;name=fox&amp;age=18&#x27;,//发送的数据 type:&#x27;GET&#x27;,//请求的方式 success:function (argument) &#123;&#125;,// 请求成功执行的方法 beforeSend:function (argument) &#123;&#125;,// 在发送请求之前调用,可以做一些验证之类的处理 error:function (argument) &#123;console.log(argument);&#125;,//请求失败调用 &#125;) 代码举例： （1）index.html 1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery-ajax&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt;&lt;div id=&quot;showInfo&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#btn&quot;).click(function()&#123; $.ajax(&#123; url:&quot;data.php&quot;, dataType:&quot;text&quot;, type:&quot;get&quot;, success:function(data)&#123; alert(data); //$(&quot;#showInfo&quot;).html(data); &#125;, error:function(e)&#123; console.log(e); &#125; &#125;); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; （2）data.php： 12345678&lt;?php$text = &#x27;hello world&#x27;;echo $text; ?&gt; 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/09-Ajax/01-服务器分类及PHP入门","date":"2021-08-06T01:17:25.874Z","updated":"2021-07-28T07:34:11.362Z","comments":true,"path":"2021/08/06/大前端/09-Ajax/01-服务器分类及PHP入门/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/09-Ajax/01-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%B1%BB%E5%8F%8APHP%E5%85%A5%E9%97%A8/","excerpt":"","text":"C/S架构和B/S架构C/S架构是Client/Server这两个单词的首字母，指的是客户端，服务器。 优点: 性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可。 界面酷炫:客户端可以使用更多系统提供的效果,做出更为炫目的效果。 缺点: 更新软件：如果有新的功能，就要推出新的版本。 不同设备访问：如果使用其他的电脑，没有安装客户端的话就无法登陆软件。 B/S架构是Browser/Server的这两个单词的首字母。指的是浏览器、服务器，是WEB兴起之后的一种架构。 现在所有的网站都是B/S架构，较为常见的例子有百度、知乎、网易云音乐Web等等，只需要通过浏览器即可使用. 优点： 更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容，对用户而言只需要刷新浏览器即可。 多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用。 缺点: 性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小。 浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一。移动设备兼容性较好，ie6已经越来越少人用了。 服务器分类项目开发时，有三套环境： Development 开发环境 Test 测试环境 Production 生产环境 程序员平时干活儿用开发环境；开发完成后，部署到测试环境；测试完成后，产品上线，部署到生产环境。 三套环境意味着三个服务器。 服务器类型按类型分： 文件服务器 数据库服务器 邮件服务器 Web 服务器等 按软件分： Apache 服务器 Nginx 服务器 IIS 服务器 Tomcat 服务器 Node 服务器等 按操作系统分： Linux服务器 Windows服务器等 服务器软件提供了某种服务的计算器，我们称之为服务器。那么这些赋予计算器各种服务功能的软件主要有哪一些呢？ 常见的服务器软件有： 文件服务器：Server-U、FileZilla、VsFTP等； 数据库服务器：Oracle、MySQL、PostgreSQL、MSSQL等； 邮件服务器：Postfix、Sendmail等； HTTP 服务器：Apache（免费、开源）、Nginx、IIS（微软的.net服务器）、Tomcat（java编程的服务器）、NodeJS 等。 使用 WampServer 搭建 HTTP服务集成环境的分类 AMP：Apache + Mysql + PHP。 WAMP：windows + Apache + Mysql + PHP。 XAMPP：WAMP 是针对windows的，而 XAMPP 可以安装在Linux、Windows、MacOS、Solaris这些操作系统上面。 在windows平台下，如果想要一步到位安装好这些软件，可是使用软件 WampServer。 WampServer 的安装去 WampServer 的官网下载软件。 安装完成后进行安装。 测试访问打开浏览器输入 127.0.0.1 查看显示的内容，如果是第一次安装，默认显示的应该是如下图片： 127.0.0.1 是回送地址，指本地机，一般用来测试使用，如果想要让其他电脑也能够访问，需要进行如下配置： （1）关闭防火墙： （2）修改httpd.conf文件： 因为 Apache 的配置默认不允许外部访问，我们需要修改配置。 打开文件c:\\wamp\\bin\\apache\\Apache2.2.21\\conf\\httpd.conf，通过搜索功能找到onlineoffline tag - don&#39;t remove这句话，在第234行的 Allow from 127.0.0.1的下面，加一行：Allow from all。 然后将第192行的Deny from all改为Allow from all。 保存，然后重启 wamp 即可。 配置网站根目录网站的根目录默认是在D:\\wamp\\www。如果想修改这个根目录，可以这样改： 打开 Apache的配置文件 D:\\wamp\\bin\\apache\\Apache2.2.21\\conf\\http.conf，如果是初次安装，找到178行的DocumentRoot &quot;d:/wamp/www/&quot;，以及205行的&lt;Directory &quot;d:/wamp/www/&quot;&gt;，改这两个位置的路径即可。我们可以通过搜索关键字documentRoot来定位。 静态网站和动态网站静态网站： 访问的是实实在在保存在服务器上的文件。静态资源包括：html页面、css文件、js文件、图片等。 当内容、图片、界面需要更新时，直接修改.html文件。 动态网站： 当用户访问网站时，根据某些逻辑,动态生成对应的HTML、CSS、JS代码给用户（这也就是web服务器开发的本质）。 通过某种手段，当有新的消息时，自动的完成网站的更新。 总结： 由于静态网站在维护的局限性，所以产生了动态网站。 实现动态网站的技术：php/jsp/.net/python等。 动态网站的原理：浏览器请求动态网站的页面（比如*.php），php拼接数据并动态生成html页面，然后将新生成的页面返回给浏览器 php 之所以被称为最好的语言，是因为：基本上，我们能够想到的功能，它都帮助我们封装成了方法。十分方便。 PHP的常见语法PHP代码执行方式： 在服务器端执行，然后返回给用户结果。如果直接使用浏览器打开，就会解析为文本。 意思是说，需要浏览器通过 http请求，才能够执行php页面。 这里只列举常用的PHP语法，更为详细的语法教程可以查阅 api 文档。 第一段 php 代码将 WampServer 跑起来，在D:\\wamp\\www下新建一个1.php文件，代码如下： 1.php： 123&lt;?php echo &quot;hello smyhvae&quot;;?&gt; 在浏览器中输入http://127.0.0.1/2018-02-28/1.php，效果如下： 代码的编写位置： 上方代码中，注意php语言的格式，第一行和第三行的格式中，没有空格。代码的编写位置在&lt;?php 代码写在这里?&gt;。 注释php 注释的写法跟 js 一致。 123456&lt;?php //这是单行注释 /* 这是多行注释 */?&gt; 变量 变量以$符号开头，其后是变量的名称。大小写敏感。 变量名称必须以字母或下划线开头。 举例： 12$a1;$_abc; 数据类型PHP支持的数据类型包括： 字符串 整数 浮点数 布尔 数组 对象 NULLL 定义字符串时需要注意： 单引号`` ：内部的内容只是作为字符串。 双引号”” ：如果内部是PHP的变量,那么会将该变量的值解析。如果内部是html代码，也会解析成html。 说白了，单引号里的内容，一定是字符串。双引号里的内容，可能会进行解析。 1echo &quot;&lt;input type=`button` value=`smyhvae`&gt;&quot;; 上面这个语句，就被会解析成按钮。 1234567891011121314151617181920212223242526// 字符串$str = &#x27;123&#x27;;// 字符串拼接$str2 = &#x27;123&#x27;.&#x27;哈哈哈&#x27;;// 整数$numA = 1; //正数$numB = -2;//负数// 浮点数$x = 1.1;// 布尔$a = true;$b = false;// 普通数组：数组中可以放 数字、字符串、布尔值等，不限制类型。$arr1 = array(&#x27;123&#x27;, 123);echo $arr1[0];// 关系型数组：类似于json格式$arr2 = $array(`name`=&gt;`smyhvae`, `age`=&gt;`26`);echo $arr2[`name`]; //获取时，通过 key 来获取 上方代码中注意，php 中字符串拼接的方式是 .。要注意哦。 运算符PHP 中的运算符跟 JavaScript 中的基本一致，用法也基本一致。 算数运算符：+、-、/、*、% 赋值运算符：x = y、x += y,x -= y等。 举例： 12345678910&lt;?php $x = 10; $y = 6; echo ($x + $y); // 输出 16 echo ($x - $y); // 输出 4 echo ($x * $y); // 输出 60 echo ($x / $y); // 输出 1.6666666666667 echo ($x % $y); // 输出 4?&gt; 函数的定义语法格式： 1234function functionName() &#123; //这里写代码&#125; （1）有参数、无返回值的函数： 12345function sayName($name)&#123; echo $name.&#x27;你好哦&#x27;;&#125;// 调用sayName(&#x27;smyhvae&#x27;); （2）有参数、参数有默认值的函数： 123456function sayFood($food=&#x27;西兰花&#x27;)&#123; echo $food.&#x27;好吃&#x27;;&#125;// 调用sayFood(&#x27;西葫芦&#x27;);// 如果传入参数,就使用传入的参数sayFood();// 如果不传入参数,直接使用默认值 （3）有参数、有返回值的函数： 1234function sum($a,$b)&#123; return $a+$b&#125;sum(1,2);// 返回值为1+2 = 3 类和对象PHP中允许使用对象这种自定义的数据类型。必须先声明，实例化之后才能够使用。 定义最基础的类： 1234567891011class Fox&#123; public $name = &#x27;itcast&#x27;; public $age = 10;&#125;$fox = new $fox;// 对象属性取值$name = $fox-&gt;name;// 对象属性赋值$fox-&gt;name = &#x27;小狐狸&#x27;; 带构造函数的类： 1234567891011121314151617class fox&#123; // 私有属性,外部无法访问 var $name = &#x27;小狐狸&#x27;; // 定义方法 用来获取属性 function Name()&#123; return $this-&gt;name; &#125; // 构造函数,可以传入参数 function fox($name)&#123; $this-&gt;name = $name &#125;&#125; // 定义了构造函数 需要使用构造函数初始化对象 $fox = new fox(&#x27;小狐狸&#x27;); // 调用对象方法,获取对象名 $foxName = $fox-&gt;Name(); 内容输出 echo：输出字符串。 print_r()：输出复杂数据类型。比如数组、对象。 var_dump()：输出详细信息。 1234567891011121314151617$arr =array(1,2,&#x27;123&#x27;);echo&#x27;123&#x27;;//结果：123print_r($arr);//结果：Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 123 )var_dump($arr);/* 结果：array 0 =&gt; int 1 1 =&gt; int 2 2 =&gt; string &#x27;123&#x27; (length=3)*/ 循环语句这里只列举了foreach、for循环。 for 循环： 1234for ($x=0; $x&lt;=10; $x++) &#123; echo &quot;数字是：$x &lt;br&gt;&quot;;&#125; foreach 循环： 12345$colors = array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;);foreach ($colors as $value) &#123; echo &quot;$value &lt;br&gt;&quot;;&#125; 上方代码中，参数一：循环的对象。参数二：将对象的值挨个取出，直到最后。 如果循环的是对象，输出的是对象的属性的值。 输出结果： 1234redgreenblueyellow php中的header()函数浏览器访问http服务器，接收到响应时，会根据响应报文头的内容进行一些具体的操作。在php中，我们可以根据 header 来设置这些内容。 header()函数的作用：用来向客户端(浏览器)发送报头。直接写在php代码的第一行就行。 下面列举几个常见的 header函数。 （1）设置编码格式： 1header(&#x27;content-type:text/html; charset= utf-8&#x27;); 例如： 1234&lt;?php header(&#x27;content-type:text/html; charset= utf-8&#x27;); echo &quot;我的第一段 PHP 脚本&quot;;?&gt; （2）设置页面跳转： 1header(&#x27;location:http://www.baidu.com&#x27;); 设置页面刷新的间隔： 1header(&#x27;refresh:3; url=http://www.xiaomi.com&#x27;); php中的 get 请求和 post 请求get 请求可以通过$_GET对象来获取。 举例：下面是一个简单的表单代码，通过 get 请求将数据提交到01.php。 （1）index.html: 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 通过 get 请求，将表单提交到 php 页面中 --&gt;&lt;form action=&quot;01.php&quot; method=&quot;get&quot;&gt; &lt;label for=&quot;&quot;&gt;姓名： &lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;label for=&quot;&quot;&gt;邮箱： &lt;input type=&quot;text&quot; name=&quot;userEmail&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （2）01.php： 1234567&lt;?php header(&#x27;content-type:text/html; charset= utf-8&#x27;); echo &quot;&lt;h1&gt;php 的get 请求演示&lt;/h1&gt;&quot;; echo &#x27;用户名：&#x27;.$_GET[&#x27;userName&#x27;]; echo &#x27;&lt;br/&gt;&#x27;; echo &#x27;邮箱：&#x27;.$_GET[&#x27;userEmail&#x27;]; ?&gt; 上方代码可以看出，$_GET是关系型数组，可以通过 **$_GET[key]**获取值。这里的 key 是 form 标签中表单元素的 name 属性的值。 效果： post 请求可以通过$_POST对象来获取。 举例：下面是一个简单的表单代码，通过 post 请求将数据提交到02.php。 （1）index.html： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 通过 post 请求，将表单提交到 php 页面中 --&gt;&lt;form action=&quot;02.php&quot; method=&quot;post&quot; &gt; &lt;label for=&quot;&quot;&gt;姓名： &lt;input type=&quot;text&quot; name= &quot;userName&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;label for=&quot;&quot;&gt;邮箱： &lt;input type=&quot;text&quot; name= &quot;userEmail&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （2）02.php： 1234567&lt;?php header(&#x27;content-type:text/html; charset= utf-8&#x27;); echo &quot;&lt;h1&gt;php 的 post 请求演示&lt;/h1&gt;&quot;; echo &#x27;用户名：&#x27;.$_POST[&#x27;userName&#x27;]; echo &#x27;&lt;br/&gt;&#x27;; echo &#x27;邮箱：&#x27;.$_POST[&#x27;userEmail&#x27;]; ?&gt; 上方代码可以看出，$_POST是关系型数组，可以通过 **$_POST[key]**获取值。这里的 key 是 form 标签中表单元素的 name 属性的值。 效果演示： 实际开发中，可能不会单独写一个php文件，常见的做法是：在 html 文件中嵌入 php 的代码。 比如说，原本 html 中有个 li 标签是存放用户名的： 1&lt;li&gt;smyhvae&lt;/li&gt; 嵌入 php后，用户名就变成了动态获取的： 123&lt;li&gt;&lt;?php echo $_POST[`userName`] ?&gt;&lt;/li&gt; php 中文件相关的操作文件上传 $_FILES上传文件时，需要在html代码中进行如下设置： （1）在html表单中，设置enctype=&quot;multipart/form-data&quot;。该值是必须的。 （2）只能用 post 方式获取。 代码如下： （1）index.html: 1234567&lt;form action=&quot;03-fileUpdate.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;&quot;&gt;照片: &lt;input type=&quot;file&quot; name = &quot;picture&quot; multiple=&quot;&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt; （2）在 php 文件中打印 file 的具体内容： 1234&lt;?php sleep(5);// 让服务器休息一会 print_r($_FILES); //打印 file 的具体内容?&gt; 演示效果： 上方现象可以看出： 点击提交后，服务器没有立即出现反应,而是休息了一会sleep(5)。 在wamp/tmp目录下面出现了一个.tmp文件。 .tmp文件一会就被自动删除了。 服务器返回的内容中有文件的名字[name] =&gt; computer.png，以及上传文件保存的位置D:\\wamp\\tmp\\php3D70.tmp。服务器返回的内容如下： 1Array ( [upFile] =&gt; Array ( [name] =&gt; yangyang.jpg [type] =&gt; image/jpeg [tmp_name] =&gt; D:\\wamp\\tmp\\phpCC56.tmp [error] =&gt; 0 [size] =&gt; 18145 ) ) 文件保存我们尝试一下，把上面的例子中的临时目录下面的文件保存起来。这里需要用到 php 里的 move_uploaded_file()函数。# 格式如下： 1move_uploaded_file($_FILES[&#x27;photo&#x27;][&#x27;tmp_name&#x27;], &#x27;./images/test.jpg&#x27;); 参数解释：参数一：移动的文件。参数二：目标路径。 （1）index.html：（这部分的代码保持不变） 123456&lt;form action=&quot;03.fileUpdate.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;&quot;&gt;照片: &lt;input type=&quot;file&quot; name = &quot;picture&quot; multiple=&quot;&quot;&gt;&lt;/label&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt; &lt;/form&gt; （2）PHP代码： 暂略。 WampServer 中修改上传文件的大小（1）打开 WampServer的文件php.ini： （2）修改php.ini中的如下内容： 设置文件最大上传限制：（值的大小可以根据需求修改） 123file_uploads = On; 是否允许上传文件 On/Off 默认是Onupload_max_filesize = 32M; 设置 上传文件的最大限制post_max_size = 32M; 设置 通过Post提交的最多数据 考虑网络传输快慢：这里修改一些参数： 123max_execution_time = 30000 ; 脚本最长的执行时间 单位为秒max_input_time = 600 ; 接收提交的数据的时间限制 单位为秒memory_limit = 1024M ; 最大的内存消耗 HTTP 协议请求客户端发出的请求，主要由三个组成部分：请求行、请求头、请求主体。如下图所示： 20180228_1505.jpg 1、请求行： 请求方法：GET or POST 请求URL HTTP协议版本 2、请求头： 常见的请求头如下： 12345678910111213141516171819202122232425262728User-Agent：浏览器的具体类型 如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0Accept：浏览器支持哪些数据类型 如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;Accept-Charset：浏览器采用的是哪种编码 如：Accept-Charset: ISO-8859-1Accept-Encoding：浏览器支持解码的数据压缩格式 如：Accept-Encoding: gzip, deflateAccept-Language：浏览器的语言环境 如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:www.baidu.comConnection：表示是否需要持久连接。属性值可以是Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-AliveContent-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=&#x27;gb2312&#x27;Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzipContent-Language：WEB服务器告诉浏览器自己响应的对象的语言。Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: http://www.baidu.com/ 3、请求体： 指的是提交给服务器的数据。 需要注意的是，如果是往服务器提交数据，需要在请求头中设置Content-Type: application/x-www-form-urlencoded(在ajax中需要手动设置)。 响应响应报文是服务器返回给客户端的。组成部分有响应行、响应头、响应主体。 1、状态行： HTTP响应行：主要是设置响应状态等信息。 2、响应头： Cookie、缓存等信息就是在响应头的属性中设置的。 常见的响应头如下： 123456789101112131415161718192021222324252627Cache-Control响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。下面，的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。Cache-Control: max-age=3600ETag一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;Location我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：Location: http://www.google.com.hkSet-Cookie服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 3、HTTP响应体： 如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。 抓包工具常见的抓包工具有：Fiddler、Charles。 1 1 1 1","categories":[],"tags":[]},{"title":"","slug":"大前端/08-移动web开发/03-Less详解","date":"2021-08-06T01:17:25.870Z","updated":"2021-07-28T07:34:11.362Z","comments":true,"path":"2021/08/06/大前端/08-移动web开发/03-Less详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/08-%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/03-Less%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 CSS 预处理器为什么要有 CSS 预处理器CSS基本上是设计师的工具，不是程序员的工具。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难以组织和维护。 很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“CSS预处器（CSS Preprocessor）”。 什么是 CSS 预处理器 是 CSS 语言的超集，比CSS更丰满。 CSS 预处理器定义了一种新的语言，其基本思想是：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。 通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS预处理器技术已经非常成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。 到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。 less 的介绍less 是一款比较流行的预处理 CSS，支持变量、混合、函数、嵌套、循环等特点。 官网 中文网（less 文档） Bootstrap网站的 less 文档 推荐文章：http://www.w3cplus.com/css/less less 的语法注释less 的注释可以有两种。 第一种注释：模板注释 1// 模板注释 这里的注释转换成CSS后将会删除 因为 less 要转换为 css才能在浏览器中使用。转换成 css 之后，这种注释会被删除（毕竟 css 不识别这种注释）。 第二种注释：CSS 注释语法 12/* CSS 注释语法 转换为CSS后让然保留 */ 总结：如果在less中写注释，我们推荐写第一种注释。除非是类似于版权等内容，就采用第二种注释。 定义变量我们可以把重复使用或经常修改的值定义为变量，在需要使用的地方引用这个变量即可。这样可以避免很多重复的工作量。 （1）在less文件中，定义一个变量的格式： 123@变量名: 变量值; //格式@bgColor: #f5f5f5; //格式举例 （2）同时，在 less 文件中引用这个变量。 最终，less文件的完整版代码如下： main.less： 1234567// 定义变量@bgColor: #f5f5f5;// 引用变量body&#123; background-color: @bgColor;&#125; 我们将上面的less文件编译为 css 文件后（下一段讲less文件的编译），自动生成的代码如下： main.css： 123body&#123; background-color: #f5f5f5;&#125; 使用嵌套在 css 中经常会用到子代选择器，效果可能是这样的： 123456789101112131415.container &#123; width: 1024px;&#125;.container &gt; .row &#123; height: 100%;&#125;.container &gt; .row a &#123; color: #f40;&#125;.container &gt; .row a:hover &#123; color: #f50;&#125; 上面的代码嵌套了很多层，写起来很繁琐。可如果用 less 的嵌套语法来写这段代码，就比较简洁。 嵌套的举例如下： main.less: 123456789101112131415161718192021222324.container &#123; width: @containerWidth; &gt; .row &#123; height: 100%; a &#123; color: #f40; &amp;:hover &#123; color: #f50; &#125; &#125; &#125; div &#123; width: 100px; .hello &#123; background-color: #00f; &#125; &#125;&#125; 将上面的less文件编译为 css 文件后，自动生成的代码如下： main.css 1234567891011121314151617181920212223.container &#123; width: 1024px;&#125;.container &gt; .row &#123; height: 100%;&#125;.container &gt; .row a &#123; color: #f40;&#125;.container &gt; .row a:hover &#123; color: #f50;&#125;.container div &#123; width: 100px;&#125;.container div .hello &#123; background-color: #00f;&#125; MixinMixin 的作用是把重复的代码放到一个类当中，每次只要引用类名，就可以引用到里面的代码了，非常方便。 （1）在 less 文件中定义一个类：（将重复的代码放到自定义的类中） 123456/* 定义一个类 */.roundedCorners(@radius: 5px) &#123; -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius;&#125; 上方代码中，第一行里面，括号里的内容是参数：这个参数是缺省值。 （2）在 less 文件中引用上面这个类： 123456#header &#123; .roundedCorners;&#125;#footer &#123; .roundedCorners(10px);&#125; 上方代码中，header 中的引用没有带参数，表示参数为缺省值； footer 中的引用带了参数，那就用这个参数。 Import在开发阶段，我们可以将不同的样式放到多个文件中，最后通过@import 的方式合并。意思就是，当出现多个 less 文件时，怎么引用它们。 这个很好理解， css 文件可以有很多个，less文件也可以有很多个。 （1）定义一个被引用的less文件，名为_button1.less： _button1.less: 1234.btn&#123; line-height: 100px; color: @btnColor;&#125; PS1：被引用的less文件，我们习惯在前面加下划线，表示它是部分文件。 PS2：_button1.less里可以引用main.css里的自定义变量。 （2）在 main.css 中引用上面的 _button1.less：（代码的第二行） main.css： 1234567@btnColor: red;@import url(`_button1.less:&#x27;); //这里的路径写的是相对路径body&#123; width: 1024px;&#125; 将 上面的main.less 编译为 main.css之后，自动生成的代码如下： 12345678.btn &#123; line-height: 100px; color: red;&#125;body &#123; width: 1024px;&#125; 内置函数less 里有一些内置的函数，这里讲一下 lighten 和 darken 这两个内置函数。 main.less: 12345body &#123; background-color: lighten(#000, 10%); // 让黑色变亮 10% color: darken(#fff, 10%); // 让白色变暗 10%&#125; 将 上面的 main.less 编译为 main.css 之后，自动生成的代码如下： main.css： 12345body &#123; background-color: #1a1a1a; color: #e6e6e6;&#125; 如果还有什么不懂的，可以看 api 文档，在上面的第二段附上了链接。 在 index.html中直接引用 less.js 做法一：写完 less文件后，将其编译为 css 文件，然后在代码中引用css文件。 做法二：在代码中直接用引用 less 文件。 产品上线后，当然是使用做法一，因为做法二会多出编译的时间。 平时开发或演示demo的时候可以用做法二。 这一段，我们讲一下做法二，其实是浏览器在本地在线地把 less 文件转换为 css 文件。 （1）在 less 官网下载 less.js 文件： 把下载好的文件放在工程文件的lib文件夹里： （2）在 index.html 中引入 less.js 和我们自己写的 main.less。位置如下： copy 红框那部分的代码如下： 1&lt;link rel=&quot;stylesheet/less&quot; href=&quot;../main.less&quot;&gt; 我们可以在打开的网页中，通过控制台看到效果： 注意，我们要在服务器中打开 html 文件，否则，看不到效果。 这里也告诉了我们： 不提倡将 less 引入页面，因为 less 需要编译，因此你就需要再引入一个less.js, 多了一个HTTP 请求，同时当浏览器禁用了 js 你的样式就不起作用了，less 编译应该在服务端或使用 grunt 自动编译。 工程文件：（工程文件中，我引用的less.js版本是 2.5.3） 2018-02-27-LessDemo.rar 参考链接： 知乎 | less文件如何引入页面 less 的编译less 的编译指的是将写好的 less 文件 生成为 css 文件。 less 的编译，依赖于 NodeJS 环境。因此，我们需要先安装 NodeJS。 1、安装 Node.js去 Node.js的官网下载安装包： 一路 next 进行安装。 安装完成后，配置环境变量： 在 path 变量中追加安装路径：;C:\\Program Files\\nodejs。重启资源管理器，即可生效。 PS：我发现，我安装的 node.js v8.9.4 版本，已经自动添加了环境变量。 在 cmd 命令行，输入node.exe -v，可以查看 node.js 的版本。 2、安装 less 的编译环境将 npm.zip 解压，将解压后的文件拷贝到路径C:\\Users\\smyhvae\\AppData\\Roaming\\npm下： 然后重启资源管理器（或者重启电脑）。在 cmd 中输入 lessc，如果能看到下面的效果，说明 less编译环境安装成功： 如果你用的是 linux 系统，可以输入下面的命令安装： 1npm install -g less 3、将 less 文件编译为 css 文件在 less 所在的路径下，输入 lessc xxx.less，即可编译成功。或者，如果输入 lessc xxx.less &gt; ..\\xx.css，表示输出到指定路径。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/08-移动web开发/02-Bootstrap使用","date":"2021-08-06T01:17:25.868Z","updated":"2021-07-28T07:34:11.361Z","comments":true,"path":"2021/08/06/大前端/08-移动web开发/02-Bootstrap使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/08-%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/02-Bootstrap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"大前端/08-移动web开发/01-Bootstrap入门","date":"2021-08-06T01:17:25.866Z","updated":"2021-07-28T07:34:11.361Z","comments":true,"path":"2021/08/06/大前端/08-移动web开发/01-Bootstrap入门/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/08-%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/01-Bootstrap%E5%85%A5%E9%97%A8/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 Bootstrap 介绍Bootstrap 是非常流行的前端框架。特点是：灵活简洁、代码优雅、美观大方。它是由Twitter的两名工程师 Mark Otto 和 Jacob Thornton 在2011年开发的。 简单来说，Bootstrap 让 Web 开发更简单、更快捷。使用 Bootstrap 框架并不代表我们再开发时不用自己写 CSS 样式，而是不用写绝大多数常见的样式。 PS：Amaze UI 这个框架其实跟 Bootstrap 很像。 官网网站 官方网站：https://getbootstrap.com/ 中文网站：http://www.bootcss.com/ V3版本： V4版本： 列举几个用 Bootstrap 做的网站： Bootstrap 优站精选 https://mobirise.com/ http://snappa.io/ Bootstrap 版本目前市面上使用的最多的是 3.x.x 版本。各个版本的介绍： 2.3.2版本： 2013年之后，停止维护； 支持更广泛的浏览器 代码不够简洁， 功能不够多。 3.x.x 版本： 目前最新的稳定版本。 不支持 IE7 和早期的 Firefox 支持 IE8，单效果不好。 2015年8月发布 4.0.0-alpha 的内部测试版。 版本号的普及： alpha 版：内部测试版。α 是希腊字母的第一个，表示最早的版本，bug很多。主要是给开发和测试人员找 bug 用的。 beta 版：公开测试版。 主要是给“部落”用户和忠实用户测试用的。bug依然很多，但比 Alpha 版要稳定。这个阶段的版本还会不断增加新功能，如果你是发烧友，可以下载这个版本。 rc 版：候选版本（Release Candidate）。该版本不再增加新的功能。类似于最终发行版之前的预览版（发行的候选版本）。此版本的发布，预示着最终发行版即将到来。作为普通用户，如果很着急，也可以下载 rc 版。 stable 版：稳定版。在开源软件中，都有 stable版本，这个是开源软件的最终发行版，用户可以放心大胆地使用。 Bootstrap 库的下载 这里我们以 Bootstrap V3.3.7 为例。 进入中文官网，下载 用于生产环境的 Bootstrap，如下图所示： 下载之后，解压 bootstrap-3.3.7-dist ，有三个文件夹： 将其拷贝到工程文件的lib文件夹下即可。 PS：dist表示编译之后的文件，这在库文件中是很常见的。 因为 bootstrap.js依赖jQuery，所以要先引用jquery.js 然后引用bootstrap.js。 Bootstrap 基础模板的介绍Bootstrap官网提供了基本模板，如下图所示： 其完整版代码 copy 如下： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot;&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn&#x27;t work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap&#x27;s JavaScript plugins) --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们需要对上面的代码进行解释。 （1）Compatible： 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; 解释：设置浏览器的兼容模式版本。表示如果在IE浏览器下则使用最新的标准，渲染当前文档。 （2）viewport 视口： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; 解释：声明当前网页在移动端浏览器中展示的相关设置。我们在做移动 web 开发时，就用上面这行代码设置 viewport。 视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示。 需要注意的是： 目前大多数手机浏览器的视口（承载页面的容器）宽度都是980； 此属性为移动端页面视口设置，上方代码设置的值，表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1）。 属性解释： width:设置viewport的宽度。 initial-scale：初始化缩放比例。 minimum-scale:最小缩放比例。 maximum-scale:最大缩放比例。 user-scalable:是否允许用户手动缩放（值可以写成yes/no，也可以写成1/0） PS：如果设置了不允许用户缩放，那么最小缩放和最大缩放就没有意义了。二者是矛盾的。 （3）条件注释： 1234&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 条件注释的作用：当判断条件满足时，就会执行注释中的HTML代码，不满足时会当做注释忽略掉。 上方代码的条件注释中，引入了两个脚本： html5shiv：让浏览器可以识别 HTML5 的新标签。如header、footer、section等。 respond.js：让低版本浏览器可以使用 CSS3 的媒体查询。 另外，我们还需要引入下面这个库： jQuery：Bootstrap框架中的所有 JS 组件都依赖于 jQuery 实现。 我们可以把上面这三个库文件拷贝到 lib 文件夹中（注意引用的路径要写正确）。 使用 Bootstrap 搭建项目1、工程文件的目录结构12345678├─ Demo ·························· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 2、下载并引入 Bootstrap 库文件见上一段的讲解。引入之后，另外还需要引入 html5shiv、respond、jQuery 这三个库文件。 3、字符集、Viewport设置、浏览器兼容模式我们将 Bootstrap 的基础模板代码 copy到项目的index.html中，这其中就包括最前面的三个meta标签： 1234&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt;&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; 4、favicon（站点图标）1&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt; 5、引入相应的第三方文件12345678910 &lt;!-- 引入 Bootstrap 的核心样式文件（必须） --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot;&gt; &lt;!-- 引入我们自己写的 css 样式文件--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/my.css&quot;&gt;...&lt;script src=&quot;lib/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/my.js&quot;&gt;&lt;/script&gt; 注意，先引入第三方的文件，再引入我们自己写的文件。 6、默认字体在我们默认的样式表中将默认字体设置为： 12345678body&#123; font-family: &quot;Helvetica Neue&quot;, Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; 7、完成页面空结构 先划分好页面中的大容器，然后在具体看每一个容器中单独的情况。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;!--建议：第三方引用的css库放在上面，我们自己写的文件，都放在下面--&gt; &lt;!-- 引入 Bootstrap 的核心样式文件（必须） --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap/css/bootstrap.css&quot;&gt; &lt;!-- 引入我们自己写的 css 样式文件--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;lib/html5shiv/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;lib/respond/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 头部区域 --&gt;&lt;header id=&quot;header&quot;&gt;&lt;/header&gt;&lt;!-- /头部区域 --&gt;&lt;!-- 广告轮播 --&gt;&lt;section id=&quot;main_ad&quot;&gt;&lt;/section&gt;&lt;!-- /广告轮播 --&gt;&lt;!-- 特色介绍 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- /特色介绍 --&gt;&lt;!-- 立即预约 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- /立即预约 --&gt;&lt;!-- 产品推荐 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- /产品推荐 --&gt;&lt;!-- 新闻列表 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- /新闻列表 --&gt;&lt;!-- 合作伙伴 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- /合作伙伴 --&gt;&lt;!-- 脚注区域 --&gt;&lt;footer&gt;&lt;/footer&gt;&lt;!-- /脚注区域 --&gt;&lt;script src=&quot;lib/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS 样式全局 CSS 样式在官网有介绍： 如果需要哪个样式，直接根据文档的指引，在相应的元素里加指定的类名即可。 我们选部分重要的来讲一下。 布局容器：container 类截图如下： 作用：用于定义一个固定宽度且居中的版心。只不过，这个版心的宽度具有响应式的效果。 也就是说，在 Bootstrap 中，我们一般用 .container 类来表示版心。 格式举例： 12345678&lt;div class=&quot;topbar&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 此处的代码会显示在一个固定宽度且居中的容器中 该容器的宽度会跟随屏幕的变化而变化 --&gt; &lt;/div&gt;&lt;/div&gt; 这个 container 类我们自己其实也可以写，通过媒体查询即可实现。 栅格参数栅格系统最主要的操作是：利用 css 的响应式去做一套行列布局的预置样式。 栅格参数如下： 我们尤其要记住各个屏幕的尺寸和类前缀。 组件一个按钮称之为样式；两个按钮在一起，就可以称之为组件。 组件在官网有介绍： 我们现在需要关注的不是组件怎么用，而是里面有哪些组件，避免重复造轮子：别人已经做得很好了，不需要我们再重复。 JS 组件JS 组件在官网有介绍： 这里面包含了很多带交互的组件。比如轮播图： 博主提供的下载链接空结构的工程文件的下载地址：(lib文件夹里包含了Bootstrap相关的各种库和中文文档) 2018-02-25-BootstrapDemo及文档.rar 还是那句话：如果需要哪个样式，直接根据文档的指引，在相应的元素里加指定的类名即可。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/CSS3的常见边框汇总","date":"2021-08-06T01:17:25.861Z","updated":"2021-07-28T07:34:11.361Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/CSS3的常见边框汇总/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/CSS3%E7%9A%84%E5%B8%B8%E8%A7%81%E8%BE%B9%E6%A1%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"CSS3 常见边框汇总123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3 边框&lt;/title&gt; &lt;style&gt; body, ul, li, dl, dt, dd, h1, h2, h3, h4, h5 &#123; margin: 0; padding: 0; &#125; body &#123; background-color: #F7F7F7; &#125; .wrapper &#123; width: 1000px; margin: 0 auto; padding: 20px; box-sizing: border-box; &#125; header &#123; padding: 20px 0; margin-bottom: 20px; text-align: center; &#125; header h3 &#123; line-height: 1; font-weight: normal; font-size: 28px; &#125; .main &#123; /*overflow: hidden;*/ &#125; .main:after &#123; content: &#x27;&#x27;; clear: both; display: block; &#125; .main .item &#123; width: 210px; height: 210px; margin: 0 30px 30px 0; display: flex; position: relative; background-color: #FFF; float: left; box-shadow: 2px 2px 5px #CCC; &#125; .main .item:after &#123; content: attr(data-brief); display: block; width: 100%; height: 100%; text-align: center; line-height: 210px; position: absolute; top: 0; left: 0; color: #FFF; font-family: &#x27;微软雅黑&#x27;; font-size: 18px; background-color: rgba(170, 170, 170, 0); z-index: -1; transition: all 0.3s ease-in; &#125; .main .item:hover:after &#123; background-color: rgba(170, 170, 170, 0.6); z-index: 100; &#125; .main .item:nth-child(4n) &#123; margin-right: 0; &#125; /*.main .item:nth-last-child(-n+5) &#123; margin-bottom: 0; &#125;*/ /* 以上是骨架样式 */ /* 1、2、3、4 顺时针 */ .border-radius &#123; width: 180px; height: 180px; margin: auto; border: 1px solid red; /*border-radius: 50% 30% 20%;*/ &#125; .square &#123; border-radius: 0; &#125; /*拱形*/ .item:nth-child(1) .border-radius &#123; border-radius: 90px; &#125; /*拱形*/ .item:nth-child(2) .border-radius &#123; border-radius: 90px 90px 0 0; &#125; /*半圆*/ .item:nth-child(3) .border-radius &#123; height: 90px; border-radius: 90px 90px 0 0; &#125; /*左上角*/ .item:nth-child(4) .border-radius &#123; /*height: 90px;*/ border-radius: 90px 0 0 0; &#125; /*四分之一圆*/ .item:nth-child(5) .border-radius &#123; width: 90px; height: 90px; border-radius: 90px 0 0 0; &#125; /*横着的椭圆*/ .item:nth-child(6) .border-radius &#123; height: 90px; /*border-radius: 50%;*/ border-radius: 90px 90px 90px 90px / 45px 45px 45px 45px; /*border-radius: 45px / 90px;*/ &#125; /*竖着的椭圆*/ .item:nth-child(7) .border-radius &#123; width: 90px; border-radius: 45px 45px 45px 45px / 90px 90px 90px 90px; &#125; /*半个横着的椭圆*/ .item:nth-child(8) .border-radius &#123; height: 45px; border-radius: 90px 90px 0 0 / 45px 45px 0 0; &#125; /*半个竖着的椭圆*/ .item:nth-child(9) .border-radius &#123; width: 45px; border-radius: 45px 0 0 45px / 90px 0 0 90px; &#125; /*四分之一竖着的椭圆*/ .item:nth-child(10) .border-radius &#123; width: 45px; height: 90px; border-radius: 45px 0 0 0 / 90px 0 0 0; &#125; /*饼环*/ .item:nth-child(11) .border-radius &#123; width: 40px; height: 40px; border: 70px solid red; border-radius: 90px; &#125; /*圆饼*/ .item:nth-child(12) .border-radius &#123; width: 40px; height: 40px; border: 70px solid red; border-radius: 60px; &#125; /*左上角圆饼*/ .item:nth-child(13) .border-radius &#123; width: 60px; height: 60px; border: 60px solid red; border-radius: 90px 0 0 0; &#125; /*对角圆饼*/ .item:nth-child(14) .border-radius &#123; width: 60px; height: 60px; border: 60px solid red; border-radius: 90px 0 90px 0; &#125; /*四边不同色*/ .item:nth-child(15) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red green yellow blue; &#125; /*右透明色*/ .item:nth-child(16) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red green yellow blue; border-right-color: transparent; &#125; /*圆右透明色*/ .item:nth-child(17) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: red; border-right-color: transparent; border-radius: 90px; &#125; /*圆右红透明色*/ .item:nth-child(18) .border-radius &#123; width: 0px; height: 0px; border-width: 90px; border-style: solid; border-color: transparent; border-right-color: red; border-radius: 90px; &#125; /*阴阳图前世*/ .item:nth-child(19) .border-radius &#123; width: 180px; height: 0px; border-top-width: 90px; border-bottom-width: 90px; border-style: solid; border-top-color: red; border-bottom-color: green; /*border-right-color: red;*/ border-radius: 90px; &#125; /*阴阳图前世2*/ .item:nth-child(20) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-style: solid; border-bottom-color: green; background-color: red; /*border-right-color: red;*/ border-radius: 90px; &#125; /*阴阳图今生*/ .item:nth-child(21) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-style: solid; border-bottom-color: green; background-color: red; border-radius: 90px; position: relative; &#125; .item:nth-child(21) .border-radius::after, .item:nth-child(21) .border-radius::before &#123; content: &#x27;&#x27;; position: absolute; top: 50%; width: 20px; height: 20px; /*margin: -10px 0 0 0;*/ border-width: 35px; border-style: solid; border-radius: 45px; &#125; /*左阴阳*/ .item:nth-child(21) .border-radius::after &#123; background-color: red; border-color: green; &#125; /*右阴阳*/ .item:nth-child(21) .border-radius::before &#123; background-color: green; border-color: red; right: 0; &#125; /*右阴阳*/ .item:nth-child(22) .border-radius &#123; width: 180px; height: 90px; border-bottom-width: 90px; border-bottom-color: green; border-bottom-style: solid; background-color: red; border-radius: 90px; position: relative; &#125; .item:nth-child(22) .border-radius::after, .item:nth-child(22) .border-radius::before &#123; content: &#x27;&#x27;; position: absolute; top: 50%; width: 20px; height: 20px; border-width: 35px; border-style: solid; border-radius: 45px; &#125; .item:nth-child(22) .border-radius::before &#123; border-color: green; background-color: red; &#125; .item:nth-child(22) .border-radius::after &#123; right: 0; border-color: red; background-color: green; &#125; /*消息框*/ .item:nth-child(23) .border-radius &#123; width: 160px; height: 80px; background-color: red; border-radius: 6px; position: relative; &#125; .item:nth-child(23) .border-radius::after &#123; content: &#x27;&#x27;; width: 0; height: 0; border-width: 10px; border-style: solid; border-color: transparent; border-right-color: red; position: absolute; top: 16px; left: -20px; &#125; /*奇怪的图形*/ .item:nth-child(24) .border-radius &#123; width: 40px; height: 40px; border-width: 45px 0 45px 70px; border-style: solid; border-radius: 0 0 60px 0; border-color: red; &#125; /*奇怪的图形2*/ .item:nth-child(25) .border-radius &#123; width: 100px; height: 40px; border-width: 45px 20px 45px 70px; border-style: solid; border-radius: 60px; border-color: red; &#125; /*QQ对话*/ .item:nth-child(26) .border-radius &#123; width: 160px; height: 80px; background-color: red; border-radius: 6px; position: relative; &#125; .item:nth-child(26) .border-radius::after &#123; content: &#x27;&#x27;; position: absolute; top: 0; right: -20px; width: 30px; height: 30px; border-width: 0 0 30px 30px; border-style: solid; border-bottom-color: red; border-left-color: transparent; border-radius: 0 0 60px 0; &#125; /*圆角的百分比设置 */ .item:nth-child(27) .border-radius &#123; width: 180px; /*height: 180px;*/ height: 90px; border-radius: 50%; border-radius: 90px/45px; /*百分比是按横竖两个对应的方向的长度进行计算*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;header&gt; &lt;h3&gt;CSS3 边框圆角&lt;/h3&gt; &lt;/header&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;item&quot; data-brief=&quot;整圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;拱形&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;半圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;左上角&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;四分之一圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;横着的椭圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;竖着的椭圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;半个横着的椭圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;半个竖着的椭圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;四分之一竖着的椭圆&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;饼环&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;圆饼&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;左上角圆饼&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;对角圆饼&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;四边不同色&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;右透明色&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;圆右透明色&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;圆右红透明色&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;阴阳图前世&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;阴阳图前世2&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;阴阳图今生&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;阴阳图今生2&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;消息框&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;奇怪的图形&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;奇怪的图形2&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;QQ对话&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot; data-brief=&quot;圆角百分比&quot;&gt; &lt;div class=&quot;border-radius&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 爱心123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .heart &#123; width: 200px; height: 300px; /*border: 1px solid #000;*/ margin: 100px auto; position: relative; &#125; .heart::before, .heart::after &#123; content: &quot;左一半&quot;; width: 100%; height: 100%; position: absolute; background-color: red; left: 0; top: 0; border-radius: 100px 100px 0 0; transform: rotate(-45deg); text-align: center; line-height: 100px; color: yellow; font-size: 30px; font-family: &quot;MIcrosoft Yahei&quot;; &#125; .heart::after &#123; content: &quot;右一半&quot;; left: 71px; transform: rotate(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;heart&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 它其实是下面这两个盒子叠起来的： 改变 .heart::after 的 left值，即可叠起来。","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/10-HTML5详解（三）","date":"2021-08-06T01:17:25.859Z","updated":"2021-07-28T07:34:11.360Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/10-HTML5详解（三）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/10-HTML5%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"Web 存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。 H5 中有两种存储的方式1、**window.sessionStorage 会话存储：** 保存在内存中。 生命周期为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。 在同一个窗口下数据可以共享。 2、**window.localStorage 本地存储**： 有可能保存在浏览器内存里，有可能在硬盘里。 永久生效，除非手动删除（比如清理垃圾的时候）。 可以多窗口共享。 Web 存储的特性（1）设置、读取方便。 （2）容量较大，sessionStorage 约5M、localStorage 约20M。 （3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。 常见 API设置存储内容： 1setItem(key, value); PS：可以新增一个 item，也可以更新一个 item。 读取存储内容： 1getItem(key); 根据键，删除存储内容： 1removeItem(key); 清空所有存储内容： 1clear(); 根据索引值来获取存储内容： 1key(n); sessionStorage 的 API 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot;/&gt;&lt;button&gt;sesssionStorage存储&lt;/button&gt;&lt;button&gt;sesssionStorage获取&lt;/button&gt;&lt;button&gt;sesssionStorage更新&lt;/button&gt;&lt;button&gt;sesssionStorage删除&lt;/button&gt;&lt;button&gt;sesssionStorage清除&lt;/button&gt;&lt;script&gt; //在h5中提供两种web存储方式 // sessionStorage session（会话，会议） 5M 当窗口关闭是数据销毁 内存 // localStorage 20M 永久生效 ，除非手动删除 清理垃圾 硬盘上 var txt = document.querySelector(&#x27;input&#x27;); var btns = document.querySelectorAll(&#x27;button&#x27;); // sessionStorage存储数据 btns[0].onclick = function () &#123; window.sessionStorage.setItem(&#x27;userName&#x27;, txt.value); window.sessionStorage.setItem(&#x27;pwd&#x27;, &#x27;123456&#x27;); window.sessionStorage.setItem(&#x27;age&#x27;, 18); &#125; // sessionStorage获取数据 btns[1].onclick = function () &#123; txt.value = window.sessionStorage.getItem(&#x27;userName&#x27;); &#125; // sessionStorage更新数据 btns[2].onclick = function () &#123; window.sessionStorage.setItem(&#x27;userName&#x27;, txt.value); &#125; // sessionStorage删除数据 btns[3].onclick = function () &#123; window.sessionStorage.removeItem(&#x27;userName&#x27;); &#125; // sessionStorage清空数据 btns[4].onclick = function () &#123; window.sessionStorage.clear(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 如上图所示，我们可以在 Storage 选项卡中查看 Session Storage 和Local Storage。 localStorage 的 API 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot;/&gt;&lt;button&gt;localStorage存储&lt;/button&gt;&lt;button&gt;localStorage获取&lt;/button&gt;&lt;button&gt;localStorage更新&lt;/button&gt;&lt;button&gt;localStorage删除&lt;/button&gt;&lt;button&gt;localStorage清除&lt;/button&gt;&lt;script&gt; /* * localStorage * 数据存在硬盘上 * 永久生效 * 20M * */ var txt = document.querySelector(&#x27;input&#x27;); var btns = document.querySelectorAll(&#x27;button&#x27;); // localStorage存储数据 btns[0].onclick = function () &#123; window.localStorage.setItem(&#x27;userName&#x27;, txt.value); &#125; // localStorage存储数据 btns[1].onclick = function () &#123; txt.value = window.localStorage.getItem(&#x27;userName&#x27;); &#125; // localStorage删除数据 btns[3].onclick = function () &#123; window.localStorage.removeItem(&#x27;userName&#x27;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例：记住用户名和密码代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=&quot;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; class=&quot;userName&quot;/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=&quot;&quot;&gt; 密 码：&lt;input type=&quot;text&quot; class=&quot;pwd&quot;/&gt;&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;label for=&quot;&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check&quot; id=&quot;&quot;/&gt;记住密码&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;&lt;button&gt;登录&lt;/button&gt;&lt;script&gt; var userName = document.querySelector(&#x27;.userName&#x27;); var pwd = document.querySelector(&#x27;.pwd&#x27;); var chk = document.querySelector(&#x27;.check&#x27;); var btn = document.querySelector(&#x27;button&#x27;); // 当点击登录的时候 如果勾选“记住密码”，就存储密码；否则就清除密码 btn.onclick = function () &#123; if (chk.checked) &#123;// 记住数据 window.localStorage.setItem(&#x27;userName&#x27;, userName.value); window.localStorage.setItem(&#x27;pwd&#x27;, pwd.value); &#125; else &#123;// 清除数据 window.localStorage.removeItem(&#x27;userName&#x27;); window.localStorage.removeItem(&#x27;pwd&#x27;); &#125; &#125; // 下次登录时，如果记录的有数据，就直接填充 window.onload = function () &#123; userName.value = window.localStorage.getItem(&#x27;userName&#x27;); pwd.value = window.localStorage.getItem(&#x27;pwd&#x27;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 网络状态我们可以通过 window.onLine 来检测用户当前的网络状况，返回一个布尔值。另外： window.online：用户网络连接时被调用。 window.offline：用户网络断开时被调用（拔掉网线或者禁用以太网）。 网络状态监听的代码举例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.addEventListener(&#x27;online&#x27;, function () &#123; alert(&#x27;网络连接建立！&#x27;); &#125;); window.addEventListener(&#x27;offline&#x27;, function () &#123; alert(&#x27;网络连接断开！&#x27;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 应用缓存HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 cache manifest 缓存清单文件。 优势1、可配置需要缓存的资源； 2、网络无连接应用仍可用； 3、本地读取缓存资源，提升访问速度，增强用户体验； 4、减少请求，缓解服务器负担。 cache manifest 缓存清单文件缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。推荐使用 .appcache作为后缀名，另外还要添加MIME类型。 缓存清单文件里的内容怎样写： （1）顶行写CACHE MANIFEST。 （2）CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等。 （3）NETWORK: 换行 指定需要在线访问的资源，可使用通配符（也就是：不需要缓存的、必须在网络下面才能访问的资源）。 （4）FALLBACK: 换行 当被缓存的文件找不到时的备用资源（当访问不到某个资源时，自动由另外一个资源替换）。 格式举例1： 格式举例2： 123456789101112131415161718CACHE MANIFEST#要缓存的文件CACHE: images/img1.jpg images/img2.jpg#指定必须联网才能访问的文件NETWORK: images/img3.jpg images/img4.jpg#当前页面无法访问是回退的页面FALLBACK: 404.html 缓存清单文件怎么用： （1）例如我们创建一个名为 demo.appcache的文件。例如： demo.appcache： 123456CACHE MANIFEST# 注释以#开头#下面是要缓存的文件CACHE: http://img.smyhvae.com/2016040101.jpg （2）在需要应用缓存在页面的根元素(html)里，添加属性manifest=”demo.appcache”。路径要保证正确。例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;01.appcache&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040101.jpg&quot; alt=&quot;&quot;/&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/09-HTML5详解（二）","date":"2021-08-06T01:17:25.857Z","updated":"2021-07-28T07:34:11.360Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/09-HTML5详解（二）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/09-HTML5%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"本文主要内容 拖拽 历史 地理位置 全屏 拖拽 如上图所示，我们可以拖拽博客园网站里的图片和超链接。 在HTML5的规范中，我们可以通过为元素增加 draggable=&quot;true&quot; 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。 1、拖拽元素页面中设置了 draggable=&quot;true&quot; 属性的元素。 举例如下： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.min.css&quot;&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--给 box1 增加拖拽的属性--&gt; &lt;div class=&quot;box1&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，我们给 box1 增加了draggable=&quot;true&quot; 属性之后，发现 box1 是可以拖拽的。但是拖拽之后要做什么事情呢？这就涉及到事件监听。 拖拽元素的事件监听：（应用于拖拽元素） ondragstart当拖拽开始时调用 ondragleave 当鼠标离开拖拽元素时调用 ondragend 当拖拽结束时调用 ondrag 整个拖拽过程都会调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector(&#x27;.box&#x27;); // 绑定拖拽事件 // 拖拽开始 box.ondragstart = function () &#123; console.log(&#x27;拖拽开始.&#x27;); &#125; // 拖拽离开：鼠标拖拽时离开被拖拽的元素是触发 box.ondragleave = function () &#123; console.log(&#x27;拖拽离开..&#x27;); &#125; // 拖拽结束 box.ondragend = function () &#123; console.log(&#x27;拖拽结束...&#x27;); console.log(&quot;---------------&quot;); &#125; box.ondrag = function () &#123; console.log(&#x27;拖拽&#x27;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 打印结果： 2、目标元素比如说，你想把元素A拖拽到元素B里，那么元素B就是目标元素。 页面中任何一个元素都可以成为目标元素。 目标元素的事件监听：（应用于目标元素） ondragenter 当拖拽元素进入时调用 ondragover 当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态） ondrop 当在目标元素上松开鼠标时调用 ondragleave 当鼠标离开目标元素时调用 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 100px; height: 100px; border: 1px solid #000; background-color: green; &#125; .two &#123; position: relative; width: 200px; height: 200px; left: 300px; top: 100px; border: 1px solid #000; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;one&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;&lt;script&gt; var two = document.querySelector(&#x27;.two&#x27;); //目标元素的拖拽事件 // 当被拖拽元素进入是触发 two.ondragenter = function () &#123; console.log(&quot;来了.&quot;); &#125; // 当被拖拽元素离开时触发 two.ondragleave = function () &#123; console.log(&quot;走了..&quot;); &#125; // 当拖拽元素在 目标元素上时，连续触发 two.ondragover = function (e) &#123; //阻止拖拽事件的默认行为 e.preventDefault(); //【重要】一定要加这一行代码，否则，后面的方法 ondrop() 无法触发。 console.log(&quot;over...&quot;); &#125; // 当在目标元素上松开鼠标是触发 two.ondrop = function () &#123; console.log(&quot;松开鼠标了....&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果演示： 注意，上方代码中，我们加了event.preventDefault()这个方法。如果没有这个方法，后面ondrop()方法无法触发。如下图所示： 如上图所示，连光标的形状都提示我们，无法在目标元素里继续操作了。 总结：如果想让拖拽元素在目标元素里做点事情，就必须要在 ondragover() 里加event.preventDefault()这一行代码。 案例：拖拽练习 完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 400px; height: 400px; border: 1px solid #000; &#125; .one &gt; div, .two &gt; div &#123; width: 98px; height: 98px; border: 1px solid #000; border-radius: 50%; background-color: red; float: left; text-align: center; line-height: 98px; &#125; .two &#123; width: 400px; height: 400px; border: 1px solid #000; position: absolute; left: 600px; top: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;one&quot;&gt; &lt;div draggable=&quot;true&quot;&gt;1&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;2&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;3&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;4&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;5&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;6&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;7&lt;/div&gt; &lt;div draggable=&quot;true&quot;&gt;8&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;&lt;script&gt; var boxs = document.querySelectorAll(&#x27;.one div&#x27;); // 临时的盒子 用于存放当前拖拽的元素 var two = document.querySelector(&#x27;.two&#x27;); var temp = null; // 给8个小盒子分别绑定拖拽事件 for (var i = 0; i &lt; boxs.length; i++) &#123; boxs[i].ondragstart = function () &#123;// 保持当前拖拽的元素 temp = this; console.log(temp); &#125; boxs[i].ondragend = function () &#123;// 当拖拽结束 ，清空temp temp = null; console.log(temp); &#125; &#125; // 目标元素的拖拽事件 two.ondragover = function (e) &#123;// 阻止拖拽的默认行为 e.preventDefault(); &#125; // 当在目标元素上松开鼠标是触发 two.ondrop = function () &#123;// 将拖拽的元素追加到 two里面来 this.appendChild(temp); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 历史界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。 在HTML5中可以通过 window.history 操作访问历史状态，让一个页面可以有多个历史状态 window.history对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState; //放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态) 地理定位在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS (Location Base Service)。 获取地理信息的方式1、IP地址2、三维坐标：（1）GPS（Global Positioning System，全球定位系统）。 目前世界上在用或在建的第2代全球卫星导航系统（GNSS）有： 1.美国 Global Positioning System （全球定位系统） 简称GPS； 2.苏联/俄罗斯 GLOBAL NAVIGATION SATELLITE SYSTEM （全球卫星导航系统）简称GLONASS（格洛纳斯）； 3.欧盟（欧洲是不准确的说法，包括中国在内的诸多国家也参与其中）Galileo satellite navigation system（伽利略卫星导航系统） 简称GALILEO（伽利略）； 4.中国 BeiDou(COMPASS) Navigation Satellite System（北斗卫星导航系统）简称 BDS ； 5.日本 Quasi-Zenith Satellite System （准天顶卫星系统） 简称QZSS ； 6.印度 India Regional Navigation Satellite System（印度区域卫星导航系统）简称IRNSS。 以上6个系统中国都能使用。 （2）Wi-Fi定位：仅限于室内。 （3）手机信号定位：通过运营商的信号塔定位。 3、用户自定义数据：对不同获取方式的优缺点进行了比较，浏览器会自动以最优方式去获取用户地理信息： 隐私HTML5 Geolocation(地理位置定位) 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。 API详解 navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息 navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息 1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标） position.coords.latitude纬度 position.coords.longitude经度 2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。 3、可选参数 options 对象可以调整位置信息数据收集方式 地理位置的 api 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /*navigator 导航*/ //geolocation: 地理定位// window.navigator.geolocation// 兼容处理 if(navigator.geolocation)&#123;// 如果支持，获取用户地理信息// successCallback 当获取用户位置成功的回调函数// errorCallback 当获取用户位置失败的回调函数 navigator.geolocation.getCurrentPosition(successCallback,errorCallback); &#125;else&#123; console.log(&#x27;sorry,你的浏览器不支持地理定位&#x27;); &#125; // 获取地理位置成功的回调函数 function successCallback(position)&#123;// 获取用户当前的经纬度// coords坐标// 纬度latitude var wd=position.coords.latitude;// 经度longitude var jd=position.coords.longitude; console.log(&quot;获取用户位置成功！&quot;); console.log(wd+&#x27;----------------&#x27;+jd);// 40.05867366972477----------------116.33668634275229// 谷歌地图：40.0601398850,116.3434224706// 百度地图：40.0658210000,116.3500430000// 腾讯高德：40.0601486487,116.3434373643 &#125; // 获取地理位置失败的回调函数 function errorCallback(error)&#123; console.log(error); console.log(&#x27;获取用户位置失败！&#x27;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 百度地图api举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;普通地图&amp;全景图&lt;/title&gt;&lt;script async src=&quot;http://c.cnzz.com/core.php&quot;&gt;&lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=NsGTBiDpgGQpI7KDmYNAPGuHWGjCh1zk&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; body, html&#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:&quot;微软雅黑&quot;;&#125; #panorama &#123;height: 100%;overflow: hidden;&#125; &lt;/style&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;http://202.102.100.100/35ff706fd57d11c141cdefcd58d6562b.js&quot; charset=&quot;gb2312&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; hQGHuMEAyLn(&#x27;[id=&quot;bb9c190068b8405587e5006f905e790c&quot;]&#x27;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;panorama&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //全景图展示 // 谷歌获取的经纬度 40.05867366972477----------------116.33668634275229 // 谷歌地图：40.0601398850,116.3434224706 // 百度地图：40.0658210000,116.3500430000 // 腾讯高德：40.0601486487,116.3434373643// var jd=116.336686;// var wd=40.058673; var jd=116.350043; var wd=40.065821; var panorama = new BMap.Panorama(&#x27;panorama&#x27;); panorama.setPosition(new BMap.Point(jd, wd)); //根据经纬度坐标展示全景图 panorama.setPov(&#123;heading: -40, pitch: 6&#125;); panorama.addEventListener(&#x27;position_changed&#x27;, function(e)&#123; //全景图位置改变后，普通地图中心点也随之改变 var pos = panorama.getPosition(); map.setCenter(new BMap.Point(pos.lng, pos.lat)); marker.setPosition(pos); &#125;);// //普通地图展示// var mapOption = &#123;// mapType: BMAP_NORMAL_MAP,// maxZoom: 18,// drawMargin:0,// enableFulltimeSpotClick: true,// enableHighResolution:true// &#125;// var map = new BMap.Map(&quot;normal_map&quot;, mapOption);// var testpoint = new BMap.Point(jd, wd);// map.centerAndZoom(testpoint, 18);// var marker=new BMap.Marker(testpoint);// marker.enableDragging();// map.addOverlay(marker);// marker.addEventListener(&#x27;dragend&#x27;,function(e)&#123;// panorama.setPosition(e.point); //拖动marker后，全景图位置也随着改变// panorama.setPov(&#123;heading: -40, pitch: 6&#125;);&#125;// );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全屏 HTML5规范允许用户自定义网页上任一元素全屏显示。 开启/关闭全屏显示方法如下：（注意 screen 是小写） 123requestFullscreen() //让元素开启全屏显示cancleFullscreen() //让元素关闭全屏显示 为考虑兼容性问题，不同的浏览器需要在此基础之上，添加私有前缀，比如：（注意 screen 是大写） 12345webkitRequestFullScreen webkitCancleFullScreenmozRequestFullScreenmozCancleFullScreen 检测当前是否处于全屏状态方法如下： 1document.fullScreen 不同浏览器需要加私有前缀，比如： 123document.webkitIsFullScreendocument.mozFullScreen 全屏的伪类 :full-screen .box {} :-webkit-full-screen {} :moz-full-screen {} 比如说，当元素处于全屏状态时，改变它的样式。这时就可以用到伪类。 代码举例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 250px; height: 250px; background-color: green; margin: 100px auto; border-radius: 50%; &#125; /*全屏伪类：当元素处于全屏时，改变元素的背景色*/ .box:-webkit-full-screen &#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector(&#x27;.box&#x27;); document.querySelector(&#x27;.box&#x27;).onclick = function () &#123; // box.requestFullscreen(); //直接这样写是没有效果的 // 开启全屏显示的兼容写法 if (box.requestFullscreen) &#123; //如果支持全屏，那就让元素全屏 box.requestFullscreen(); &#125; else if (box.webkitRequestFullScreen) &#123; box.webkitRequestFullScreen(); &#125; else if (box.mozRequestFullScreen) &#123; box.mozRequestFullScreen(); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/08-HTML5举例：简单的视频播放器","date":"2021-08-06T01:17:25.854Z","updated":"2021-07-28T07:34:11.360Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/08-HTML5举例：简单的视频播放器/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/08-HTML5%E4%B8%BE%E4%BE%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"我们采用 Bootstrap 网站的图标字体，作为播放器的按钮图标。 index.html的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入字体图标的文件--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.min.css&quot;/&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; /*多媒体标题*/ figcaption&#123; text-align: center; line-height: 150px; font-family: &quot;Microsoft Yahei&quot;; font-size:24px; &#125; /* 播放器*/ .palyer&#123; width: 720px; height: 360px; margin:10px auto; border: 1px solid #000; background: url(images/loading.gif) center no-repeat #000; background-size:auto 100%; position: relative; border-radius: 20px; &#125; .palyer video&#123; height:100%; display: block; margin:0 auto; /*display: none;*/ &#125; /* 控制条*/ .controls&#123; width: 700px; height:40px; background-color: rgba(255, 255, 0, 0.3); position: absolute; bottom:10px; left:10px; border-radius: 10px; &#125; /*开关*/ .switch&#123; position: absolute; width: 20px; height: 20px; left:10px; top:10px; text-align: center; line-height: 20px; color:yellow; &#125; /*进度条*/ .progress&#123; width: 432px; height: 10px; position: absolute; background-color: rgba(255,255,255,0.4); left:40px; top:15px; border-radius: 4px; overflow: hidden; &#125; /* 当前进度*/ .curr-progress&#123; width: 50%; height: 10px; background-color: #fff; &#125; /* 时间模块*/ .time&#123; width: 120px; height: 20px; text-align: center; line-height: 20px; color:#fff; position: absolute; left:510px; top:10px; font-size:12px; &#125; /*全屏*/ .extend&#123; position: absolute; width: 20px; height: 20px; right:20px; top:10px; text-align: center; line-height: 20px; color:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 多媒体--&gt; &lt;figure&gt; &lt;!-- 多媒体标题--&gt; &lt;figcaption&gt;视频案例&lt;/figcaption&gt; &lt;div class=&quot;palyer&quot;&gt; &lt;video src=&quot;video/fun.mp4&quot;&gt;&lt;/video&gt; &lt;!-- 控制条--&gt; &lt;div class=&quot;controls&quot;&gt; &lt;!-- 播放暂停--&gt; &lt;a href=&quot;#&quot; class=&quot;switch icon-play&quot;&gt;&lt;/a&gt; &lt;div class=&quot;progress&quot;&gt; &lt;!-- 当前进度--&gt; &lt;div class=&quot;curr-progress&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 时间--&gt; &lt;div class=&quot;time&quot;&gt; &lt;span class=&quot;curr-time&quot;&gt;00:00:00&lt;/span&gt;/&lt;span class=&quot;total-time&quot;&gt;00:00:00&lt;/span&gt; &lt;/div&gt; &lt;!-- 全屏--&gt; &lt;a href=&quot;#&quot; class=&quot;extend icon-resize-full&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/figure&gt; &lt;script&gt; // 思路： /* * 1、点击按钮 实现播放暂停并且切换图标 * 2、算出视频的总时显示出出来 * 3、当视频播放的时候，进度条同步，当前时间同步 * 4、点击实现全屏 */// 获取需要的标签 var video=document.querySelector(&#x27;video&#x27;);// 播放按钮 var playBtn=document.querySelector(&#x27;.switch&#x27;);// 当前进度条 var currProgress=document.querySelector(&#x27;.curr-progress&#x27;);// 当前时间 var currTime=document.querySelector(&#x27;.curr-time&#x27;);// 总时间 var totalTime=document.querySelector(&#x27;.total-time&#x27;);// 全屏 var extend=document.querySelector(&#x27;.extend&#x27;); var tTime=0;// 1、点击按钮 实现播放暂停并且切换图标 playBtn.onclick=function()&#123;// 如果视频播放 就暂停，如果暂停 就播放 if(video.paused)&#123;// 播放 video.play(); //切换图标 this.classList.remove(&#x27;icon-play&#x27;); this.classList.add(&#x27;icon-pause&#x27;); &#125;else&#123;// 暂停 video.pause();// 切换图标 this.classList.remove(&#x27;icon-pause&#x27;); this.classList.add(&#x27;icon-play&#x27;);&#125; &#125;// 2、算出视频的总时显示出出来// 当时加载完成后的事件，视频能播放的时候 video.oncanplay=function()&#123;// 获取视频总时长 tTime=video.duration; console.log(tTime);// 将总秒数 转换成 时分秒的格式：00：00:00// 小时 var h=Math.floor(tTime/3600);// 分钟 var m=Math.floor(tTime%3600/60);// 秒 var s=Math.floor(tTime%60);// console.log(h);// console.log(m);// console.log(s);// 把数据格式转成 00:00：00 h=h&gt;=10?h:&quot;0&quot;+h; m=m&gt;=10?m:&quot;0&quot;+m; s=s&gt;=10?s:&quot;0&quot;+s; console.log(h); console.log(m); console.log(s);// 显示出来 totalTime.innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s; &#125;// * 3、当视频播放的时候，进度条同步，当前时间同步// 当时当前时间更新的时候触发 video.ontimeupdate=function()&#123;// 获取视频当前播放的时间// console.log(video.currentTime);// 当前播放时间 var cTime=video.currentTime;// 把格式转成00:00:00 var h=Math.floor(cTime/3600);// 分钟 var m=Math.floor(cTime%3600/60);// 秒 var s=Math.floor(cTime%60);// 把数据格式转成 00:00：00 h=h&gt;=10?h:&quot;0&quot;+h; m=m&gt;=10?m:&quot;0&quot;+m; s=s&gt;=10?s:&quot;0&quot;+s;// 显示出当前时间 currTime.innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s;// 改变进度条的宽度： 当前时间/总时间 var value=cTime/tTime; currProgress.style.width=value*100+&quot;%&quot;; &#125;// 全屏 extend.onclick=function()&#123;// 全屏的h5代码 video.webkitRequestFullScreen(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 工程文件： 2018-02-23-H5多媒体播放器.rar","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/07-CSS3属性详解：Web字体","date":"2021-08-06T01:17:25.852Z","updated":"2021-07-28T07:34:11.359Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/07-CSS3属性详解：Web字体/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/07-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%9AWeb%E5%AD%97%E4%BD%93/","excerpt":"","text":"前言开发人员可以为自已的网页指定特殊的字体（将指定字体提前下载到站点中），无需考虑用户电脑上是否安装了此特殊字体。从此，把特殊字体处理成图片的方式便成为了过去。 支持程度比较好，甚至 IE 低版本的浏览器也能支持。 字体的常见格式 不同浏览器所支持的字体格式是不一样的，我们有必要了解一下字体格式的知识。 TureTpe格式：(.ttf).ttf 字体是Windows和Mac的最常见的字体，是一种RAW格式。 支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+。 OpenType格式：(.otf).otf 字体被认为是一种原始的字体格式，其内置在TureType的基础上。 支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+。 Web Open Font Format格式：(.woff)woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离。 支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+。 Embedded Open Type格式：(.eot).eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+。 SVG格式：(.svg).svg字体是基于SVG字体渲染的一种格式。 支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+。 总结： 了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体。通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式之间的区别。 下载字体的网站推荐： http://www.zhaozi.cn/ http://www.youziku.com/ WebFont 的使用步骤打开网站http://iconfont.cn/webfont#!/webfont/index，如下： 上图中，比如我想要「思源黑体-粗」这个字体，那我就点击红框中的「本地下载」。 下载完成后是一个压缩包，压缩包链接：http://download.csdn.net/download/smyhvae/10253561 解压后如下： 上图中， 我们把箭头处的html文件打开，里面告诉了我们 webfont 的使用步骤： （1）第一步：使用font-face声明字体 1234567@font-face &#123;font-family: &#x27;webfont&#x27;; src: url(&#x27;webfont.eot&#x27;); /* IE9*/ src: url(&#x27;webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;webfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&#x27;webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */&#125; （2）第二步：定义使用webfont的样式 123456.web-font&#123; font-family:&quot;webfont&quot; !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; （3）第三步：为文字加上对应的样式 1&lt;i class=&quot;web-font&quot;&gt;这一分钟，你和我在一起，因为你，我会记得那一分钟。从现在开始，我们就是一分钟的朋友。这是事实，你改变不了，因为已经完成了。&lt;/i&gt; 举例： 我们按照上图中的步骤来，引入这个字体。完整版代码如下： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p&#123; font-size:30px; &#125; /* 如果要在网页中使用web字体（用户电脑上没有这种字体）*/ /* 第一步：声明字体*/ /* 告诉浏览器 去哪找这个字体*/ @font-face &#123;font-family: &#x27;my-web-font&#x27;; src: url(&#x27;font/webfont.eot&#x27;); /* IE9*/ src: url(&#x27;font/webfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;font/webfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;font/webfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&#x27;font/webfont.svg#webfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */ &#125; /* 第二步：定义一个类名，谁加这类名，就会使用 webfont 字体*/ .webfont&#123; font-family: &#x27;my-web-font&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 第三步：引用 webfont 字体 --&gt; &lt;p class=&quot;webfont&quot;&gt;生命壹号，永不止步&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： （1）my-web-font这个名字是随便起的，只要保证第一步和第二步中的名字一样就行。 （2）因为我把字体文件单独放在了font文件夹中，所以在src中引用字体资源时，写的路径是 font/... 工程文件： 2018-02-20-WebFont举例.zip 字体图标（阿里的 iconfont 网站举例）我们其实可以把图片制作成字体。常见的做法是：把网页中一些小的图标，借助工具生成一个字体包，然后就可以像使用文字一样使用图标了。这样做的优点是： 将所有图标打包成字体库，减少请求； 具有矢量性，可保证清晰度； 使用灵活，便于维护。 也就是说，我们可以把这些图标当作字体来看待，凡是字体拥有的属性（字体大小、颜色等），均适用于图标。 使用步骤如下：（和上一段的使用步骤是一样的） 打开网站http://iconfont.cn/，找到想要的图标，加入购物车。然后下载下来： 压缩包下载之后，解压，打开里面的demo.html，里面告诉了我们怎样引用这些图标。 举例1：（图标字体引用） 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*申明字体*/ @font-face &#123;font-family: &#x27;iconfont&#x27;; src: url(&#x27;font/iconfont.eot&#x27;); /* IE9*/ src: url(&#x27;font/iconfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;font/iconfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;font/iconfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&#x27;font/iconfont.svg#iconfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */ &#125; .iconfont&#123; font-family: iconfont; &#125; p&#123; width: 200px; border: 1px solid #000; line-height: 60px; font-size:30px; margin:100px auto; text-align: center; &#125; p span&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 【重要】编码代表图标 --&gt; &lt;p&gt;&lt;span class=&quot;iconfont&quot;&gt;&amp;#xe628;&lt;/span&gt;扫码付款&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例2：（伪元素的方式使用图标字体） 如果想要在文字的前面加图标字体，我们更习惯采用伪元素的方式进行添加。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*申明字体*/ @font-face &#123;font-family: &#x27;iconfont&#x27;; src: url(&#x27;font/iconfont.eot&#x27;); /* IE9*/ src: url(&#x27;font/iconfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;font/iconfont.woff&#x27;) format(&#x27;woff&#x27;), /* chrome、firefox */ url(&#x27;font/iconfont.ttf&#x27;) format(&#x27;truetype&#x27;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&#x27;font/iconfont.svg#iconfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */ &#125; p&#123; width: 200px; border: 1px solid #000; line-height: 60px; font-size:30px; margin:100px auto; text-align: center; position: relative; &#125; .icon::before&#123; /*&amp;#xe628;*/ content:&quot;\\e628&quot;; /*position: absolute;*/ /*left:10px;*/ /*top:0px;*/ font-family: iconfont; color:red; &#125; span&#123; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;icon&quot;&gt;扫码付款&lt;/p&gt; &lt;span class=&quot;icon&quot; &gt;我是span&lt;/span&gt; &lt;div class=&quot;icon&quot;&gt;divvvvvvvvvvv&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 工程文件： 2018-02-20-图标字体demo.zip 其他相相关网站介绍 Font Awesome 使用介绍：http://fontawesome.dashgame.com/ 定制自已的字体图标库： http://iconfont.cn/ https://icomoon.io/ SVG素材： http://www.iconsvg.com/ 360浏览器网站案例暂略。 这里涉及到：jQuery fullPage 全屏滚动插件。 中文网址:http://www.dowebok.com 相关说明:http://www.dowebok.com/77.html 使用 Bootstrap 网站的图标字体打开如下网站：http://www.bootcss.com/p/font-awesome/。 如上图所示，下载字体后，进行解压： 使用步骤如下： （1）如图只是想要字体的话，可以把css和font这两个文件夹拷贝到项目里。 （2）在html文档中的 标签里，引入 font-awesome.min.css 文件： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.min.css&quot;&gt; （3）想在哪个标签里用这个图标，直接在这个标签里加className就行（className都在网站上列出来了）。 完整版代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.min.css&quot;&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;icon-play&quot;&gt;播放&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/06-CSS3属性详解：flex布局","date":"2021-08-06T01:17:25.850Z","updated":"2021-07-28T07:34:11.359Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/06-CSS3属性详解：flex布局/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/06-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%9Aflex%E5%B8%83%E5%B1%80/","excerpt":"","text":"多列布局类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。用得不多。 格式举例： 123456789101112131415161718192021.wrapper&#123; /* 分成几列 */ -webkit-column-count: 3; /* 每列之间，用分割线隔开 */ -webkit-column-rule: 1px dashed red; /* 设置列之间的间距 */ -webkit-column-gap: 60px; /* 设置每一列的宽度 */ /* -webkit-column-width: 400px; */ /*-webkit- -moz- -ms- -o-*/&#125;h4&#123; /* 设置跨列：让h4这标题位于整个文flex-wrap本的标题，而不是处在某一列之中*/ -webkit-column-span: all; text-align: center;&#125; 备注：上面这几个属性涉及到兼容性问题，需要加私有前缀。 flex：伸缩布局CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强。其强大的伸缩性，在响应式开中可以发挥极大的作用。 如上图所示，有几个概念需要了解一下： 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向，从左向右。 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。 PS：主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 设置伸缩布局的步骤（1）指定一个盒子为伸缩布局： 1display: flex; （2）设置 flex-direction 属性来调整此盒的子元素的布局方式。默认的方向是水平方向。 （3）可互换主侧轴，也可改变主侧轴的方向。 各属性详解1、flex-direction属性：设置主轴方向。 flex-direction: row; 设置主轴方向，默认是水平方向。属性值可以是： row 水平方向（默认值） reverse-row 反转 column 垂直方向 reverse-column 反转列 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style: none; &#125; body&#123; background-color: #eee; font-family: &quot;Microsoft Yahei&quot;; font-size:22px; &#125; h3&#123; font-weight: normal; &#125; section&#123; width: 1000px; margin:40px auto; &#125; ul&#123; background-color: #fff; border: 1px solid #ccc; &#125; ul li&#123; width: 200px; height: 200px; background-color: pink; margin:10px; &#125; section:nth-child(1) ul&#123; overflow: hidden; /* 清除浮动 */ &#125; section:nth-child(1) ul li&#123; float: left; &#125; /* 设置伸缩盒子*/ section:nth-child(2) ul&#123; display: flex; &#125; section:nth-child(3) ul&#123; /* 设置伸缩布局*/ display: flex; /* 设置主轴方向*/ flex-direction: row; &#125; section:nth-child(4) ul&#123; /* 设置伸缩布局*/ display: flex; /* 设置主轴方向 :水平翻转*/ flex-direction: row-reverse; &#125; section:nth-child(5) ul&#123; /* 设置伸缩布局*/ display: flex; /* 设置主轴方向 :垂直*/ flex-direction: column; &#125; section:nth-child(6) ul&#123; /* 设置伸缩布局*/ display: flex; /* 设置主轴方向 :垂直*/ flex-direction: column-reverse; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;h3&gt;传统布局&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;伸缩布局 display:flex&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴方向 flex-direction:row&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴方向 flex-direction:row-reverse&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴方向 flex-direction:column&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴方向 flex-direction:column-reverse&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 2、justify-content：设置子元素在主轴上的对齐方式。 justify-content: flex-start; 设置子元素在主轴上的对齐方式。属性值可以是： flex-start 从主轴的起点对齐（默认值） flex-end 从主轴的终点对齐 center 居中对齐 space-around 在父盒子里平分 space-between 两端对齐 平分 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style:none;&#125; body&#123; background-color: #eee; font-family: &quot;Microsoft Yahei&quot;; &#125; section&#123; width: 1000px; margin:50px auto; &#125; section h3&#123; font-size:22px; font-weight: normal; &#125; ul&#123; border: 1px solid #999; background-color: #fff; display: flex; &#125; ul li&#123; width: 200px; height: 200px; background: pink; margin:10px; &#125; section:nth-child(1) ul&#123; /* 主轴对齐方式：从主轴开始的方向对齐*/ justify-content: flex-start; &#125; section:nth-child(2) ul&#123; /* 主轴对齐方式：从主轴结束的方向对齐*/ justify-content: flex-end; &#125; section:nth-child(3) ul&#123; /* 主轴对齐方式：居中对齐*/ justify-content: center; &#125; section:nth-child(4) ul&#123; /* 主轴对齐方式：在父盒子中平分*/ justify-content: space-around; &#125; section:nth-child(5) ul&#123; /* 主轴对齐方式：两端对齐 平分*/ justify-content: space-between; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;h3&gt;主轴的对齐方式：justify-content:flex-start&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴的对齐方式：justify-content:flex-end&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴的对齐方式：justify-content:center&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴的对齐方式：justify-content:space-round&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;section&gt; &lt;h3&gt;主轴的对齐方式：justify-content:space-bettwen&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 3、align-items：设置子元素在侧轴上的对齐方式。 align-items:flex-start; 设置子元素在侧轴上的对齐方式。属性值可以是： flex-start 从侧轴开始的方向对齐 flex-end 从侧轴结束的方向对齐 baseline 基线 默认同flex-start center 中间对齐 stretch 拉伸 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style:none; &#125; body&#123; background-color: #eee; font-family: &quot;Microsoft Yahei&quot;; &#125; section&#123; width: 1000px; margin:50px auto; &#125; section h3&#123; font-size:22px; font-weight: normal; &#125; ul&#123; border: 1px solid #999; background-color: #fff; display: flex; height:500px; &#125; ul li&#123; width: 200px; height: 200px; background: pink; margin:10px; &#125; section:nth-child(1) ul&#123; /* 侧轴对齐方式 ：从侧轴开始的方向对齐*/ align-items:flex-start; &#125; section:nth-child(2) ul&#123; /* 侧轴对齐方式 ：从侧轴结束的方向对齐*/ align-items:flex-end; &#125; section:nth-child(3) ul&#123; /* 侧轴对齐方式 ：居中*/ align-items:center; &#125; section:nth-child(4) ul&#123; /* 侧轴对齐方式 ：基线 默认同flex-start*/ align-items:baseline; &#125; section:nth-child(5) ul&#123; /* 侧轴对齐方式 ：拉伸*/ align-items:stretch; &#125; section:nth-child(5) ul li&#123; height:auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt; &lt;h3&gt;侧轴的对齐方式:align-items ：flex-start&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;section&gt; &lt;h3&gt;侧轴的对齐方式：align-items:flex-end&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;section&gt; &lt;h3&gt;侧轴的对齐方式：align-items:center&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;section&gt; &lt;h3&gt;侧轴的对齐方式：align-itmes:baseline&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;section&gt; &lt;h3&gt;侧轴的对齐方式：align-itmes: stretch&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 4、flex属性：设置子盒子的权重 代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; list-style:none; &#125; body&#123; background-color: #eee; font-family: &quot;Microsoft Yahei&quot;; &#125; section&#123; width: 1000px; margin:50px auto; &#125; section h3&#123; font-size:22px; font-weight: normal; &#125; ul&#123; border: 1px solid #999; background-color: #fff; display: flex; &#125; ul li&#123; width: 200px; height: 200px; background: pink; margin:10px; &#125; section:nth-child(1) ul li:nth-child(1)&#123; flex:1; &#125; section:nth-child(1) ul li:nth-child(2)&#123; flex:1; &#125; section:nth-child(1) ul li:nth-child(3)&#123; flex:8; &#125; section:nth-child(2) ul li:nth-child(1)&#123; &#125; section:nth-child(2) ul li:nth-child(2)&#123; flex:1; &#125; section:nth-child(2) ul li:nth-child(3)&#123; flex:4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt; &lt;h3&gt;伸缩比例:flex&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;section&gt; &lt;h3&gt;伸缩比例:flex&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/05-CSS3属性详解：动画详解","date":"2021-08-06T01:17:25.847Z","updated":"2021-07-28T07:34:11.359Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/05-CSS3属性详解：动画详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/05-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言本文主要内容： 过渡：transition 2D 转换 transform 3D 转换 transform 动画：animation 过渡：transitiontransition的中文含义是过渡。过渡是CSS3中具有颠覆性的一个特征，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。 补间动画：自动完成从起始状态到终止状态的的过渡。不用管中间的状态。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片。 参考链接：补间动画基础 transition 包括以下属性： transition-property: all; 如果希望所有的属性都发生过渡，就使用all。 transition-duration: 1s; 过渡的持续时间。 transition-timing-function: linear; 运动曲线。属性值可以是： linear 线性 ease 减速 ease-in 加速 ease-out 减速 ease-in-out 先加速后减速 transition-delay: 1s; 过渡延迟。多长时间后再执行这个过渡动画。 上面的四个属性也可以写成综合属性： 123transition: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;transition: all 3s linear 0s; 其中，transition-property这个属性是尤其需要注意的，不同的属性值有不同的现象。我们来示范一下。 如果设置 transition-property: width，意思是只让盒子的宽度在变化时进行过渡。效果如下： 如果设置 transition-property: all，意思是让盒子的所有属性（包括宽度、背景色等）在变化时都进行过渡。效果如下： 案例：小米商品详情代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 过渡&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #eeeeee; &#125; .content &#123; width: 800px; height: 320px; padding-left: 20px; margin: 80px auto; &#125; .item &#123; width: 230px; height: 300px; text-align: center; margin-right: 20px; background-color: #FFF; float: left; position: relative; top: 0; overflow: hidden; /* 让溢出的内容隐藏起来。意思是让下方的橙色方形先躲起来 */ transition: all .5s; /* 从最初到鼠标悬停时的过渡 */ &#125; .item img &#123; margin-top: 30px; &#125; .item .desc &#123; position: absolute; left: 0; bottom: -80px; width: 100%; height: 80px; background-color: #ff6700; transition: all .5s; &#125; /* 鼠标悬停时，让 item 整体往上移动5px，且加一点阴影 */ .item:hover &#123; top: -5px; box-shadow: 0 0 15px #AAA; &#125; /* 鼠标悬停时，让下方的橙色方形现身 */ .item:hover .desc &#123; bottom: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;./images/1.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;./images/2.png&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;desc&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;./images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;span class=&quot;desc&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 动画效果录制的比较差，但真实体验还是可以的。 工程文件： 2018-02-08-小米商品详情过渡 2D 转换转换是 CSS3 中具有颠覆性的一个特征，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式。 转换再配合过渡和动画，可以取代大量早期只能靠 Flash 才可以实现的效果。 在 CSS3 当中，通过 transform 转换来实现 2D 转换或者 3D 转换。 2D转换包括：缩放、移动、旋转。 我们依次来讲解。 1、缩放：scale格式： 123transform: scale(x, y);transform: scale(2, 0.5); 参数解释： x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。 取值：大于1表示放大，小于1表示缩小。不能为百分比。 格式举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 1000px; margin: 100px auto; &#125; .box div &#123; width: 300px; height: 150px; background-color: pink; float: left; margin-right: 15px; color: white; text-align: center; font: 400 30px/150px “宋体”; &#125; .box .box2 &#123; background-color: green; transition: all 1s; &#125; .box .box2:hover &#123; /*width: 500px;*/ /*height: 400px;*/ background-color: yellowgreen; /* transform: css3中用于做变换的属性 scale(x,y)：缩放 */ transform: scale(2, 0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 上图可以看到，给 box1 设置 2D 转换，并不会把兄弟元素挤走。 2、位移：translate格式： 123transform: translate(水平位移, 垂直位移);transform: translate(-50%, -50%); 参数解释： 参数为百分比，相对于自身移动。 正值：向右和向下。 负值：向左和向上。如果只写一个值，则表示水平移动。 格式举例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 1000px; margin: 100px auto; &#125; .box &gt; div &#123; width: 300px; height: 150px; border: 1px solid #000; background-color: red; float: left; margin-right: 30px; &#125; div:nth-child(2) &#123; background-color: pink; transition: all 1s; &#125; /* translate:(水平位移，垂直位移)*/ div:nth-child(2):hover &#123; transform: translate(-50%, -50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 上图中，因为我在操作的时候，鼠标悬停后，立即进行了略微的移动，所以产生了两次动画。正确的效果应该是下面这样的： 应用：让绝对定位中的盒子在父亲里居中 我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div &#123; width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半&#125; 如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。 现在，我们还可以利用偏移 translate 来做，这也是比较推荐的写法： 123456789div &#123; width: 600px; height: 60px; background-color: red; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; transform: translate(-50%); 然后，利用translate，往左走自己宽度的一半【推荐写法】&#125; 3、旋转：rotate格式： 123transform: rotate(角度);transform: rotate(45deg); 参数解释：正值 顺时针；负值：逆时针。 举例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background-color: red; margin: 50px auto; color: #fff; font-size: 50px; transition: all 2s; /* 过渡：让盒子在进行 transform 转换的时候，有个过渡期 */ &#125; /* rotate（角度）旋转 */ .box:hover &#123; transform: rotate(-405deg); /* 鼠标悬停时，让盒子进行旋转 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;1&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 注意，上方代码中，我们给盒子设置了 transform 中的 rotate 旋转，但同时还要给盒子设置 transition 过渡。如果没有这行过渡的代码，旋转会直接一步到位，效果如下：（不是我们期望的效果） 案例1：小火箭 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; html,body&#123; height:100%; &#125; body&#123; background-color: #DE8910; &#125; .rocket&#123; position: absolute; left:100px; top:600px; height: 120px; transform:translate(-200px ,200px) rotate(45deg); transition:all 1s ease-in; &#125; body:hover .rocket&#123; transform:translate(500px,-500px) rotate(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img class=&quot;rocket&quot; src=&quot;images/rocket.png&quot; alt=&quot;&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们将 transform 的两个小属性合并起来写了。 小火箭图片的url：http://img.smyhvae.com/20180208-rocket.png 案例2：扑克牌 rotate 旋转时，默认是以盒子的正中心为坐标原点的。如果想改变旋转的坐标原点，可以用transform-origin属性。格式如下： 12345transform-origin: 水平坐标 垂直坐标;transform-origin: 50px 50px;transform-origin: center bottom; //旋转时，以盒子底部的中心为坐标原点 我们来看一下 rotate 结合 transform-origin 的用法举例。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; /*background-color: #eee;*/ &#125; .box &#123; width: 300px; height: 440px; margin: 100px auto; position: relative; &#125; img &#123; width: 100%; transition: all 1.5s; position: absolute; /* 既然扑克牌是叠在一起的，那就都用绝对定位 */ left: 0; top: 0; transform-origin: center bottom; /*旋转时，以盒子底部的中心为坐标原点*/ box-shadow: 0 0 3px 0 #666; &#125; .box:hover img:nth-child(6) &#123; transform: rotate(-10deg); &#125; .box:hover img:nth-child(5) &#123; transform: rotate(-20deg); &#125; .box:hover img:nth-child(4) &#123; transform: rotate(-30deg); &#125; .box:hover img:nth-child(3) &#123; transform: rotate(-40deg); &#125; .box:hover img:nth-child(2) &#123; transform: rotate(-50deg); &#125; .box:hover img:nth-child(1) &#123; transform: rotate(-60deg); &#125; .box:hover img:nth-child(8) &#123; transform: rotate(10deg); &#125; .box:hover img:nth-child(9) &#123; transform: rotate(20deg); &#125; .box:hover img:nth-child(10) &#123; transform: rotate(30deg); &#125; .box:hover img:nth-child(11) &#123; transform: rotate(40deg); &#125; .box:hover img:nth-child(12) &#123; transform: rotate(50deg); &#125; .box:hover img:nth-child(13) &#123; transform: rotate(60deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt; &lt;img src=&quot;images/pk2.png&quot;/&gt; &lt;img src=&quot;images/pk1.png&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 4、倾斜暂略。 3D 转换1、旋转：rotateX、rotateY、rotateZ3D坐标系（左手坐标系） 如上图所示，伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。拇指、食指和中指分别代表X、Y、Z轴的正方向，这样我们就建立了一个左手坐标系。 浏览器的这个平面，是X轴、Y轴；垂直于浏览器的平面，是Z轴。 旋转的方向：（左手法则） 左手握住旋转轴，竖起拇指指向旋转轴的正方向，正向就是其余手指卷曲的方向。 从上面这句话，我们也能看出：所有的3d旋转，对着正方向去看，都是顺时针旋转。 格式： 123456transform: rotateX(360deg); //绕 X 轴旋转360度transform: rotateY(360deg); //绕 Y 轴旋转360度transform: rotateZ(360deg); //绕 Z 轴旋转360度 格式举例： （1）rotateX 举例： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .rotateX &#123; width: 300px; height: 226px; margin: 200px auto; /* 透视 :加给变换的父盒子*/ /* 设置的是用户的眼睛距离 平面的距离*/ /* 透视效果只是视觉上的呈现，并不是正真的3d*/ perspective: 110px; &#125; img &#123; /* 过渡*/ transition: transform 2s; &#125; /* 所有的3d旋转，对着正方向去看，都是顺时针旋转*/ .rotateX:hover img &#123; transform: rotateX(360deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;rotateX&quot;&gt; &lt;img src=&quot;images/x.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 上方代码中，我们最好加个透视的属性，方能看到3D的效果；没有这个属性的话，图片旋转的时候，像是压瘪了一样。 而且，透视的是要加给图片的父元素 div，方能生效。我们在后面会讲解透视属性。 （2）rotateY 举例： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .rotateY &#123; width: 237px; height: 300px; margin: 100px auto; /* 透视 */ perspective: 150px; &#125; img &#123; transition: all 2s; /* 过渡 */ &#125; .rotateY:hover img &#123; transform: rotateY(360deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;rotateY&quot;&gt; &lt;img src=&quot;images/y.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： （3）rotateZ 举例： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .rotateZ &#123; width: 330px; height: 227px; margin: 100px auto; /* 透视*/ perspective: 200px; &#125; img &#123; transition: all 1s; &#125; .rotateZ:hover img &#123; transform: rotateZ(360deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;rotateZ&quot;&gt; &lt;img src=&quot;images/z.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 案例：百度钱包 现在有下面这张图片素材： 要求做成下面这种效果： 上面这张图片素材其实用的是精灵图。实现的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; background-color: cornflowerblue; &#125; .box &#123; width: 300px; height: 300px; /*border: 1px solid #000;*/ margin: 50px auto; position: relative; &#125; .box &gt; div &#123; width: 100%; height: 100%; position: absolute; /*border: 1px solid #000;*/ border-radius: 50%; transition: all 2s; backface-visibility: hidden; &#125; .box1 &#123; background: url(images/bg.png) left 0 no-repeat; /*默认显示图片的左半边*/ &#125; .box2 &#123; background: url(images/bg.png) right 0 no-repeat; transform: rotateY(180deg); /*让图片的右半边默认时，旋转180度，就可以暂时隐藏起来*/ &#125; .box:hover .box1 &#123; transform: rotateY(180deg); /*让图片的左半边转消失*/ &#125; .box:hover .box2 &#123; transform: rotateY(0deg); /*让图片的左半边转出现*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、移动：translateX、translateY、translateZ格式： 123456transform: translateX(100px); //沿着 X 轴移动transform: translateY(360px); //沿着 Y 轴移动transform: translateZ(360px); //沿着 Z 轴移动 格式举例： （1）translateX 举例： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background: green; transition: all 1s; &#125; .box:hover &#123; transform: translateX(100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： （2）translateY 举例： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background: green; transition: all 1s; &#125; .box:hover &#123; transform: translateY(100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： （3）translateZ 举例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; /* 给box的父元素加透视效果*/ perspective: 1000px; &#125; .box &#123; width: 250px; height: 250px; background: green; transition: all 1s; margin: 200px auto &#125; .box:hover &#123; /* translateZ必须配合透视来使用*/ transform: translateZ(400px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 上方代码中，如果不加透视属性，是看不到translateZ的效果的。 3、透视：perspective电脑显示屏是一个 2D 平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。但仅仅只是视觉呈现出3d 效果，并不是正真的3d。 格式有两种写法： 作为一个属性，设置给父元素，作用于所有3D转换的子元素 作为 transform 属性的一个值，做用于元素自身。 4、3D呈现（transform-style）3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。属性值可以如下： 1234transform-style: preserve-3d; //让 子盒子 位于三维空间里transform-style: flat; //让子盒子位于此元素所在的平面内（子盒子被扁平化） 案例：立方体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 250px; height: 250px; border: 1px dashed red; margin: 100px auto; position: relative; border-radius: 50%; /* 让子盒子保持3d效果*/ transform-style: preserve-3d; /*transform:rotateX(30deg) rotateY(-30deg);*/ animation: gun 8s linear infinite; &#125; .box &gt; div &#123; width: 100%; height: 100%; position: absolute; text-align: center; line-height: 250px; font-size: 60px; color: #daa520; &#125; .left &#123; background-color: rgba(255, 0, 0, 0.3); /* 变换中心*/ transform-origin: left; /* 变换*/ transform: rotateY(90deg) translateX(-125px); &#125; .right &#123; background: rgba(0, 0, 255, 0.3); transform-origin: right; /* 变换*/ transform: rotateY(90deg) translateX(125px); &#125; .forward &#123; background: rgba(255, 255, 0, 0.3); transform: translateZ(125px); &#125; .back &#123; background: rgba(0, 255, 255, 0.3); transform: translateZ(-125px); &#125; .up &#123; background: rgba(255, 0, 255, 0.3); transform: rotateX(90deg) translateZ(125px); &#125; .down &#123; background: rgba(99, 66, 33, 0.3); transform: rotateX(-90deg) translateZ(125px); &#125; @keyframes gun &#123; 0% &#123; transform: rotateX(0deg) rotateY(0deg); &#125; 100% &#123; transform: rotateX(360deg) rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;up&quot;&gt;上&lt;/div&gt; &lt;div class=&quot;down&quot;&gt;下&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt; &lt;div class=&quot;forward&quot;&gt;前&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;后&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画动画是CSS3中具有颠覆性的特征，可通过设置多个节点 来精确控制一个或一组动画，常用来实现复杂的动画效果。 1、定义动画的步骤（1）通过@keyframes定义动画； （2）将这段动画通过百分比，分割成多个节点；然后各节点中分别定义各属性； （3）在指定元素里，通过 animation 属性调用动画。 之前,我们在 js 中定义一个函数的时候，是先定义，再调用： 12345js 定义函数： function fun()&#123; 函数体 &#125; 调用： fun(); 同样，我们在 CSS3 中定义动画的时候，也是先定义，再调用： 12345678定义动画： @keyframes 动画名&#123; from&#123; 初始状态 &#125; to&#123; 结束状态 &#125; &#125; 调用： animation: 动画名称 持续时间； 其中，animation属性的格式如下： 12345animation: 定义的动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。(infinite 表示无限次)animation: move1 1s alternate linear 3;animation: move2 4s; 定义动画的格式举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; margin: 100px; background-color: red; /* 调用动画*/ /* animation: 动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。infinite 表示无限次*/ /*animation: move 1s alternate linear 3;*/ animation: move2 4s; &#125; /* 方式一：定义一组动画*/ @keyframes move1 &#123; from &#123; transform: translateX(0px) rotate(0deg); &#125; to &#123; transform: translateX(500px) rotate(555deg); &#125; &#125; /* 方式二：定义多组动画*/ @keyframes move2 &#123; 0% &#123; transform: translateX(0px) translateY(0px); background-color: red; border-radius: 0; &#125; 25% &#123; transform: translateX(500px) translateY(0px); &#125; /*动画执行到 50% 的时候，背景色变成绿色，形状变成圆形*/ 50% &#123; /* 虽然两个方向都有translate，但其实只是Y轴上移动了200px。 因为X轴的500px是相对最开始的原点来说的。可以理解成此时的 translateX 是保存了之前的位移 */ transform: translateX(500px) translateY(200px); background-color: green; border-radius: 50%; &#125; 75% &#123; transform: translateX(0px) translateY(200px); &#125; /*动画执行到 100% 的时候，背景色还原为红色，形状还原为正方形*/ 100% &#123; /*坐标归零，表示回到原点。*/ transform: translateX(0px) translateY(0px); background-color: red; border-radius: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意好好看代码中的注释。 效果如下： 2、动画属性我们刚刚在调用动画时，animation属性的格式如下： animation属性的格式如下： 12345animation: 定义的动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。(infinite 表示无限次)animation: move1 1s alternate linear 3;animation: move2 4s; 可以看出，这里的 animation 是综合属性，接下来，我们把这个综合属性拆分看看。 （1）动画名称： 1animation-name: move; （2）执行一次动画的持续时间： 1animation-duration: 4s; 备注：上面两个属性，是必选项，且顺序固定。 （3）动画的执行次数： 1animation-iteration-count: 1; //iteration的含义表示迭代 属性值infinite表示无数次。 （3）动画的方向： 1animation-direction: alternate; 属性值：normal 正常，alternate 反向。 （4）动画延迟执行： 1animation-delay: 1s; （5）设置动画结束时，盒子的状态： 1animation-fill-mode: forwards; 属性值： forwards：保持动画结束后的状态（默认）， backwards：动画结束后回到最初的状态。 （6）运动曲线： 1animation-timing-function: ease-in; 属性值可以是：linear ease-in-out steps()等。 注意，如果把属性值写成** steps()，则表示动画不是连续执行**，而是间断地分成几步执行。我们接下来专门讲一下属性值 steps()。 steps()的效果我们还是拿上面的例子来举例，如果在调用动画时，我们写成： 1animation: move2 4s steps(2); 效果如下： 有了属性值 steps()，我们就可以作出很多不连续地动画效果。比如时钟；再比如，通过多张静态的鱼，作出一张游动的鱼。 step()举例：时钟的简易模型 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 3px; height: 200px; background-color: #000; margin: 100px auto; transform-origin: center bottom; /* 旋转的中心点是底部 */ animation: myClock 60s steps(60) infinite; &#125; @keyframes myClock &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码，我们通过一个黑色的长条div，旋转360度，耗时60s，分成60步完成。即可实现。 效果如下： 动画举例：摆动的鱼现在，我们要做下面这种效果： PS：图片的url是http://img.smyhvae.com/20180209_1245.gif，图片较大，如无法观看，可在浏览器中单独打开。 为了作出上面这种效果，要分成两步。 （1）第一步：让鱼在原地摆动 鱼在原地摆动并不是一张 gif动图，她其实是由很多张静态图间隔地播放，一秒钟播放完毕，就可以了： 上面这张大图的尺寸是：宽 509 px、高 2160 px。 我们可以理解成，每一帧的尺寸是：宽 509 px、高 270 px。270 * 8 = 2160。让上面这张大图，在一秒内从 0px 的位置往上移动2160px，分成8步来移动。就可以实现了。 代码是： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .shark &#123; width: 509px; height: 270px; /*盒子的宽高是一帧的宽高*/ border: 1px solid #000; margin: 100px auto; background: url(images/shark.png) left top; /* 让图片一开始位于 0 px的位置 */ animation: sharkRun 1s steps(8) infinite; /* 一秒之内，从顶部移动到底部，分八帧， */ &#125; @keyframes sharkRun &#123; 0% &#123; &#125; /* 270 * 8 = 2160 */ 100% &#123; background-position: left -2160px; /* 动画结束时，让图片位于最底部 */ &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;sharkBox&quot;&gt; &lt;div class=&quot;shark&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 我们不妨把上面的动画的持续时间从1s改成 8s，就可以看到动画的慢镜头： 这下，你应该恍然大悟了。 （2）第二步：让鱼所在的盒子向前移动。 实现的原理也很简单，我们在上一步中已经让shark这个盒子实现了原地摇摆，现在，让 shark 所在的父盒子 sharkBox向前移动，即可。完整版代码是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .shark &#123; width: 509px; height: 270px; /* 盒子的宽高是一帧的宽高 */ border: 1px solid #000; margin: 100px auto; background: url(images/shark.png) left top; /* 让图片一开始位于 0 px的位置 */ animation: sharkRun 1s steps(8) infinite; /* 一秒之内，从顶部移动到底部，分八帧 */ &#125; /* 鱼所在的父盒子 */ .sharkBox &#123; width: 509px; height: 270px; animation: sharkBoxRun 20s linear infinite; &#125; @keyframes sharkRun &#123; 0% &#123; &#125; /* 270 * 8 = 2160 */ 100% &#123; background-position: left -2160px; /* 动画结束时，让图片位于最底部 */ &#125; &#125; @keyframes sharkBoxRun &#123; 0% &#123; transform: translateX(-600px); &#125; 100% &#123; transform: translateX(3000px); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;sharkBox&quot;&gt; &lt;div class=&quot;shark&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 大功告成。 工程文件如下： 2018-02-09-fishes.rar 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/04-CSS3属性详解（一）","date":"2021-08-06T01:17:25.845Z","updated":"2021-07-28T07:34:11.358Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/04-CSS3属性详解（一）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/04-CSS3%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言我们在上一篇文章中学习了CSS3的选择器，本文来学一下CSS3的一些属性。 本文主要内容： 颜色 文本 盒模型中的 box-sizing 属性 处理兼容性问题：私有前缀 边框 背景属性 渐变 颜色CSS3中，有一种新的表示颜色的方式：RGBA或者HSLA。 RGBA、HSLA可应用于所有使用颜色的地方。 RGBA 举例： 123background-color: rgba(0, 0, 255, 0.3);border: 30px solid rgba(0, 255, 0, 0.3); 解释： RGBA 即：Red、Green、Blue、Alpha R、G、B 的取值范围是：0~255 HSLA 举例： 1background-color: hsla(240,50%,50%,0.4); 解释： H 色调，取值范围 0~360。0或360表示红色、120表示绿色、240表示蓝色。 S 饱和度，取值范围 0%~100%。值越大，越鲜艳。 L 亮度，取值范围 0%~100%。亮度最大时为白色，最小时为黑色。 A 透明度，取值范围 0~1。 如果不知道 H 的值该设置多少，我们不妨来看一下色盘： 推荐链接：配色宝典 关于设置透明度的其他方式： （1）opacity: 0.3; 会将整个盒子及子盒子设置透明度。也就是说，当盒子设置半透明的时候，会影响里面的子盒子。 （2）background: transparent; 可以单独设置透明度，但设置的是完全透明（不可调节透明度）。 文本text-shadow：设置文本的阴影格式举例： 1text-shadow: 20px 27px 22px pink; 参数解释：水平位移 垂直位移 模糊程度 阴影颜色。 效果举例： 举例：凹凸文字效果text-shadow 可以设置多个阴影，每个阴影之间使用逗号隔开。我们来看个例子。 代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; background-color: #666; &#125; div &#123; font-size: 100px; text-align: center; font-weight: bold; font-family: &quot;Microsoft Yahei&quot;; color: #666; &#125; /* text-shadow 可以设置多个阴影，每个阴影之间使用逗号隔开*/ .tu &#123; text-shadow: -1px -1px 1px #fff, 1px 1px 1px #000; &#125; .ao &#123; text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;ao&quot;&gt;生命壹号&lt;/div&gt;&lt;div class=&quot;tu&quot;&gt;生命壹号&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，实现凹凸文字效果的方式比较简单，给左上角放白色的阴影，右下角放黑色的阴影，就达到了凹下去的效果。 盒模型中的 box-sizing 属性我们在**之前的文章**中专门讲过盒子模型。 CSS3 对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。 这就需要用到 box-sizing属性。它的属性值可以是：content-box、border-box。解释如下。 外加模式：（css的默认方式） 1box-sizing: content-box; 解释：此时设置的 width 和 height 是内容区域的宽高。盒子的实际宽度 = 设置的 width + padding + border。此时改变 padding 和 border 的大小，也不会改变内容的宽高，而是盒子的总宽高发生变化。 内减模式：【需要注意】 1box-sizing: border-box; 解释：此时设置的 width 和 height 是盒子的总宽高。盒子的实际宽度 = 设置的 width。此时改变 padding 和 border 的大小，会改变内容的宽高，盒子的总宽高不变。 处理兼容性问题：私有前缀通过网址http://caniuse.com/ 可以查询CSS3各特性的支持程度。 处理兼容性问题的常见方法：为属性添加私有前缀。 如此方法不能解决，应尽量避免使用，无需刻意去处理CSS3的兼容性问题。 私有前缀的举例： 比如说，我想给指定的div设置下面这样一个属性： 1background: linear-gradient(left, green, yellow); 上面这个属性的作用是：添加从左到右的线性渐变，颜色从绿色变为黄色。 如果直接这样写属性，是看不到效果的： 此时，我们可以为浏览器添加不同的私有前缀，属性就可以生效了。 格式如下： 1234-webkit-: 谷歌 苹果-moz-:火狐-ms-：IE-o-：欧朋 格式举例如下： 12345background: -webkit-linear-gradient(left, green, yellow);background: -moz-linear-gradient(left, green, yellow);background: -ms-linear-gradient(left, green, yellow);background: -o-linear-gradient(left, green, yellow);background: linear-gradient(left, green, yellow); 效果如下： 边框边框的属性很多，其中边框圆角和边框阴影这两个属性，应用十分广泛，兼容性也相对较好，且符合渐进增强的原则，需要重点熟悉。 边框圆角：border-radius 属性边框的每个圆角，本质上是一个圆，圆有水平半径和垂直半径：如果二者相等，就是圆；如果二者不等， 就是椭圆。 单个属性的写法： 12345678border-top-left-radius: 60px 120px; //参数解释：水平半径 垂直半径border-top-right-radius: 60px 120px;border-bottom-left-radius: 60px 120px;border-bottom-right-radius: 60px 120px; 复合写法： 12345border-radius: 60px/120px; //参数：水平半径/垂直半径border-radius: 20px 60px 100px 140px; //从左上开始，顺时针赋值。如果当前角没有值，取对角的值border-radius: 20px 60px; 最简洁的写法：（四个角的半径都相同时） 1border-radius: 60px; 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent &#123; width: 400px; &#125; .box &#123; width: 100px; height: 100px; float: left; border: 1px solid rgb(144, 12, 63); margin: 20px; text-align: center; line-height: 100px; color: #fff; font-size: 50px; background-color: rgb(255, 141, 26); &#125; /*画圆形的方式一*/ .box:nth-child(1) &#123; border-radius: 50px; &#125; /*画圆形的方式二*/ .box:nth-child(2) &#123; border-radius: 50%; &#125; .box:nth-child(3) &#123; border-radius: 100px 0 0 0; &#125; .box:nth-child(4) &#123; border-radius: 100px/50px; &#125; .box:nth-child(5) &#123; border-radius: 10%; &#125; .box:nth-child(6) &#123; border-radius: 0 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;6&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 边框阴影：box-shadow 属性格式举例： 123box-shadow: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色box-shadow: 15px 21px 48px -2px #666; 参数解释： 水平偏移：正值向右 负值向左。 垂直偏移：正值向下 负值向上。 模糊程度：不能为负值。 效果如下： 另外，后面还可以再加一个inset属性，表示内阴影。如果不写，则默认表示外阴影。例如： 1box-shadow:3px 3px 3px 3px #666 inset; 效果如下： 20180207_2028.png 注意：设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。 我们还可以设置多重边框阴影，实现更好的效果，增强立体感。 边框图片边框图片有以下属性： 1234567891011121314/* 边框图片的路径*/border-image-source: url(&quot;images/border.png&quot;);/* 图片边框的裁剪*/border-image-slice: 27;/*图片边框的宽度*/border-image-width: 27px;/*边框图片的平铺*//* repeat :正常平铺 但是可能会显示不完整*//*round: 平铺 但是保证 图片完整*//*stretch: 拉伸显示*/border-image-repeat: stretch; 我们也可以写成一个综合属性： 1border-image: url(&quot;images/border.png&quot;) 27/20px round; 这个属性要好好理解，我们假设拿下面这张图来作为边框图片： 这张图片将会被“切割”成九宫格形式，然后进行平铺。四个角位置、形状保持不变，中心位置和水平垂直向两个方向平铺： 再具体一点： 常见的边框图片汇总1 背景属性背景属性在 CSS3 中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。 背景尺寸：background-size属性background-size属性：设置背景图片的尺寸。 格式举例： 12345678910111213/* 宽、高的具体数值 */background-size: 500px 500px;/* 宽高的百分比 */background-size: 50% 50%; // 如果两个属性值相同，可以简写成：background-size: 50%;background-size: 100% auto; //这个属性可以自己试验一下。/* cover：会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。 */background-size: cover;/* contain：会自动调整缩放比例，保证图片始终完整显示在背景区域。 */background-size: contain; 这里我们对属性值 cover 和 contain进行再次强调： cover：会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。也就是说，保证背景图片完全覆盖盒子，但不能保证完整显示。 contain：会自动调整缩放比例，保证图片始终完整显示在背景区域。也就是说，保证背景图片最大化地在盒子里，等比例显示，但不保证能铺满盒子。 背景原点：background-origin 属性background-origin 属性：控制背景从什么地方开始显示。 格式举例： 12345678910/* 从 padding-box 内边距开始显示背景图 */background-origin: padding-box; //默认值/* 从 border-box 边框开始显示背景图 */background-origin: border-box;/* 从 content-box 内容区域开始显示背景图 */background-origin: content-box; 如果属性值设置成了border-box，那边框部分也会显示图片哦。 如下图所示： 背景裁剪：background-clip属性格式举例： background-clip: content-box; 超出的部分，将裁剪掉。属性值可以是： border-box 超出 border-box 的部分，将裁剪掉 padding-box 超出 padding-box 的部分，将裁剪掉 content-box 超出 content-box 的部分，将裁剪掉 假设现在有这样的属性设置： 123background-origin: border-box;background-clip: content-box; 上方代码的意思是，背景图片从边框部分开始加载，但是呢，超出内容区域的部分将被裁减掉。 同时设置多个背景我们可以给一个盒子同时设置多个背景，用以逗号隔开即可。可用于自适应局。 代码举例： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; height: 416px; border: 1px solid #000; margin: 100px auto; /* 给盒子加多个背景，按照背景语法格式书写，多个背景使用逗号隔开 */ background: url(images/bg1.png) no-repeat left top, url(images/bg2.png) no-repeat right top, url(images/bg3.png) no-repeat right bottom, url(images/bg4.png) no-repeat left bottom, url(images/bg5.png) no-repeat center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 上方代码中，我们其实给盒子设置了五张小图，拼成的一张大图。当改变浏览器窗口大小时，可以自适应布局。 渐变渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。 渐变分为： 线性渐变：沿着某条直线朝一个方向产生渐变效果。 径向渐变：从一个中心点开始沿着四周产生渐变效果。 重复渐变。 见下图： 注意，渐变属于背景图片属性background-image的属性值。我们依次来看一下。 线性渐变格式： 1234background-image: linear-gradient(方向, 起始颜色, 终止颜色);background-image: linear-gradient(to right, yellow, green); 参数解释： 方向可以是：to left、to right、to top、to bottom、角度30deg（指的是顺时针方向30°）。 格式举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 500px; height: 100px; margin: 10px auto; border: 1px solid #000; &#125; /* 语法： linear-gradient(方向，起始颜色，终止颜色); 方向：to left to right to top to bottom 角度 30deg 起始颜色 终止颜色 */ div:nth-child(1) &#123; background-image: linear-gradient(to right, yellow, green); &#125; /* 不写方向，表示默认的方向是：从上往下 */ div:nth-child(2) &#123; background-image: linear-gradient(yellow, green); &#125; /* 方向可以指定角度 */ div:nth-child(3) &#123; width: 100px; height: 100px; background-image: linear-gradient(135deg, yellow, green); &#125; /* 0%的位置开始出现黄色，40%的位置开始出现红色的过度。70%的位置开始出现绿色的过度，100%的位置开始出现蓝色 */ div:nth-child(4) &#123; background-image: linear-gradient(to right, yellow 0%, red 40%, green 70%, blue 100%); &#125; /* 颜色之间，出现突变 */ div:nth-child(5) &#123; background-image: linear-gradient(45deg, yellow 0%, yellow 25%, blue 25%, blue 50%, red 50%, red 75%, green 75%, green 100% ); &#125; div:nth-child(6) &#123; background-image: linear-gradient(to right, #000 0%, #000 25%, #fff 25%, #fff 50%, #000 50%, #000 75%, #fff 75%, #fff 100% ); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例：按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3 渐变&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; padding: 0; background-color: #f8fcd4; &#125; .nav &#123; width: 800px; text-align: center; padding-top: 50px; margin: 0 auto; &#125; /*设置按钮基本样式*/ .nav a &#123; display: inline-block; width: 100px; height: 30px; text-align: center; line-height: 30px; font-size: 14px; color: #fff; text-decoration: none; border: 1px solid #e59500; background-color: #FFB700; background-image: linear-gradient( to bottom, #FFB700 0%, #FF8C00 100% ); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航1&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航2&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航3&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航4&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航5&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;导航6&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 径向渐变格式： 1234background-image: radial-gradient(辐射的半径大小, 中心的位置, 起始颜色, 终止颜色);background-image: radial-gradient(100px at center,yellow ,green); 解释：围绕中心点做渐变，半径是150px，从黄色到绿色做渐变。 中心点的位置可以是：at left right center bottom top。如果以像素为单位，则中心点参照的是盒子的左上角。 当然，还有其他的各种参数。格式举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 250px; height: 250px; border: 1px solid #000; margin: 20px; float: left; &#125; /* 径向渐变： radial-gradient（辐射的半径大小, 中心的位置，起始颜色，终止颜色）; 中心点位置：at left right center bottom top */ /*辐射半径为100px，中心点在中间*/ div:nth-child(1) &#123; background-image: radial-gradient(100px at center, yellow, green); &#125; /*中心点在左上角*/ div:nth-child(3) &#123; background-image: radial-gradient(at left top, yellow, green); &#125; div:nth-child(2) &#123; background-image: radial-gradient(at 50px 50px, yellow, green); &#125; /*设置不同的颜色渐变*/ div:nth-child(4) &#123; background-image: radial-gradient(100px at center, yellow 0%, green 30%, blue 60%, red 100%); &#125; /*如果辐射半径的宽高不同，那就是椭圆*/ div:nth-child(5) &#123; background-image: radial-gradient(100px 50px at center, yellow, green); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例：利用径向渐变和边框圆角的属性，生成按钮。代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3 渐变&lt;/title&gt; &lt;style&gt; div:nth-child(1) &#123; width: 200px; height: 200px; margin: 40px auto; border-radius: 100px; background-color: yellowgreen; &#125; div:nth-child(2) &#123; width: 200px; height: 200px; margin: 40px auto; border-radius: 100px; background-color: yellowgreen; background-image: radial-gradient( 200px at 100px 100px, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.5) ); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，给第二个div设置的透明度是从0到0.5。如果设置的透明度是从0到0，则样式无变化，和第一个div一样。如果设置的透明度是从1到1，则盒子是全黑的。 CSS3的更多属性，且听下文继续。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/03-CSS3选择器详解","date":"2021-08-06T01:17:25.842Z","updated":"2021-07-28T07:34:11.358Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/03-CSS3选择器详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/03-CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 CSS3介绍CSS3在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 CSS3的现状 浏览器支持程度不够好，有些需要添加私有前缀 移动端支持优于PC端 不断改进中 应用相对广泛 应对的策略：渐进增强 （1）坚持渐进增强的原则：让低版本浏览器能正常访问页面，高版本的浏览器用户体验更好。【重要】 比如说，同样是一个头像，可能在低版本的浏览器中，头像方的；在高版本的浏览器中，头像是圆的。 （2）考虑用户群体。 （3）遵照产品的方案。 参考链接： 渐进增强 VS 优雅降级 | 简书 渐进增强和优雅降级之间的不同（面试题目） 浏览器的版本问题由于CSS3普遍存在兼容性问题，为了避免因兼容性带来的干扰，浏览器的建议版本为： Chrome浏览器 version 46+ Firefox浏览器 firefox 42+ 如何使用手册CSS参考手册的网址：http://css.doyoe.com/ CSS参考手册的下载链接：http://download.csdn.net/download/smyhvae/10243974 在查看CSS参考手册时，需要注意以下符号： 比如说，&#123;1,4&#125;表示可以设置一至四个参数。 下面讲CSS3的基础知识。本文讲一下 CSS3 选择器的内容。 CSS3 选择器我们之前学过 CSS 的选择器，比如： 1234567891011121314151617181920div 标签选择器.box 类名选择器#box id选择器div p 后代选择器div.box 交集选择器div,p,span 并集选择器div&gt;p 子代选择器* : 通配符div+p: 选中div后面相邻的第一个pdiv~p: 选中的div后面所有的p CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与 jQuery 中所提供的绝大部分选择器兼容。 属性选择器属性选择器的标志性符号是 []。 匹配含义： 1^：开头 $：结尾 *：包含 格式： E[title] 选中页面的E元素，并且E存在 title 属性即可。 E[title=&quot;abc&quot;]选中页面的E元素，并且E需要带有title属性，且属性值完全等于abc。 E[attr~=val] 选择具有 att 属性且属性值为：用空格分隔的字词列表，其中一个等于 val 的E元素。 E[attr|=val] 表示要么是一个单独的属性值，要么这个属性值是以“-”分隔的。 E[title^=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 开头。 E[title$=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 结尾。 E[title*=&quot;abc&quot;] 选中页面的E元素，并且E需要带有 title 属性,属性值任意位置包含abc。 比如说，我们用属性选择器去匹配标签的className，是非常方便的。 这里我们用class属性来举例。代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;选择器 - 属性&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; font-family: &#x27;微软雅黑&#x27;; background-color: #F7F7F7; &#125; .wrapper &#123; width: 1024px; margin: 0 auto; &#125; .wrapper &gt; section &#123; min-height: 300px; margin-bottom: 30px; box-shadow: 1px 1px 4px #DDD; background-color: #FFF; &#125; .wrapper &gt; header &#123; text-align: center; line-height: 1; padding: 20px; margin-bottom: 10px; font-size: 30px; &#125; .wrapper section &gt; header &#123; line-height: 1; padding: 10px; font-size: 22px; color: #333; background-color: #EEE; &#125; .wrapper .wrap-box &#123; padding: 20px; &#125; form &#123; width: 300px; height: 300px; margin: 0 auto; &#125; form input[type=&quot;text&quot;] &#123; width: 200px; height: 30px; &#125; form input[type=&quot;password&quot;] &#123; width: 200px; height: 30px; &#125; .attr1 &#123; &#125; .download &#123; &#125; .attr1 a[href=&quot;./a.rmvb&quot;] &#123; color: red; &#125; .attr1 a[href=&quot;./b.rmvb&quot;] &#123; color: pink; &#125; /* E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的*/ .attr2 a[class~=&quot;download&quot;] &#123; color: red; &#125; /* E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以&quot;-&quot;分隔的*/ .attr3 a[class|=&quot;download&quot;] &#123; color: red; &#125; /* E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置 */ .attr4 a[class*=&quot;download&quot;] &#123; color: red; &#125; /* E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置 */ .attr5 a[class^=&quot;download&quot;] &#123; color: red; &#125; /* E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置 */ .attr6 a[class$=&quot;download&quot;] &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;header&gt;CSS3-属性选择器&lt;/header&gt; &lt;section&gt; &lt;header&gt;简介&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;form action=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt; 姓名: &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;li&gt; 密码: &lt;input type=&quot;password&quot;&gt; &lt;/li&gt; &lt;li&gt; 性别: &lt;input type=&quot;radio&quot;&gt;男 &lt;input type=&quot;radio&quot;&gt; 女 &lt;/li&gt; &lt;li&gt; 兴趣: &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;写代码 &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr1&quot;&gt; &lt;header&gt;E[attr]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download download-movie&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;download download-movie&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;download download-music&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr2&quot;&gt; &lt;header&gt;E[attr~=attr]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download download-movie&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;download download-movie&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;download download-music&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr3&quot;&gt; &lt;header&gt;E[attr|=attr]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;download-movie&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;download-music&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr4&quot;&gt; &lt;header&gt;E[attr*=val]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;moviedownload&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;downloadmusic&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr5&quot;&gt; &lt;header&gt;E[attr^=val]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;moviedownload&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;downloadmusic&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;attr6&quot;&gt; &lt;header&gt;E[attr$=val]&lt;/header&gt; &lt;div class=&quot;wrap-box&quot;&gt; &lt;a href=&quot;./a.rmvb&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./b.rmvb&quot; class=&quot;moviedownload&quot;&gt;下载&lt;/a&gt; &lt;a href=&quot;./a.mp3&quot; class=&quot;downloadmusic&quot;&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最后来张表格： 结构伪类选择器伪类选择器的标志性符号是 :。 CSS中有一些伪类选择器，比如:link、:active、:visited、:hover，这些是动态伪类选择器。 CSS3又新增了其它的伪类选择器。这一小段，我们来学习CSS3中的结构伪类选择器：即通过结构来进行筛选。 1、格式：（第一部分） E:first-child 匹配父元素的第一个子元素E。 E:last-child 匹配父元素的最后一个子元素E。 E:nth-child(n) 匹配父元素的第n个子元素E。注意，盒子的编号是从1开始算起，不是从0开始算起。 E:nth-child(odd) 匹配奇数 E:nth-child(even) 匹配偶数 E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。 理解： （1）这里我们要好好理解父元素的含义，它指的是：以 E 元素的父元素为参考。 （2）注意：以上选择器中所选到的元素的类型，必须是指定的类型E，如果选不中，则无效。这个要好好理解，具体可以看CSS参考手册中的E:nth-child(n)的示例。我们可以理解成：先根据选择器找到选中的全部位置，如果发现某个位置不是类型E，则该位置失效。 （3）另外，E:nth-child(n)这个属性也很有意思。比如，针对下面这样一组标签： 123456789101112&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt;&lt;/ul&gt; 上方代码中： 如果选择器写成li:nth-child(2)，则表示第2个 li。 如果选择器写成li:nth-child(n)，则表示所有的li。因为此时的 n 表示 0,1,2,3,4,5,6,7,8…..（当n小于1时无效，因为n = 0 也是不会选中的） 如果选择器写成li:nth-child(2n)，则表示所有的第偶数个 li。 如果选择器写成li:nth-child(2n+1)，则表示所有的第奇数个 li。 如果选择器写成li:nth-child(-n+5)，则表示前5个 li。 如果选择器写成li:nth-last-child(-n+5)，则表示最后5个 li。 如果选择器写成li:nth-child(7n)，则表示选中7的倍数。。 上面列举的选择器中，我们只要记住： n 表示 0,1,2,3,4,5,6,7,8…..就很容易明白了。 2、格式：（第二部分） E:first-of-type 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 既然上面这几个选择器带有type，我们可以这样理解：先在同级里找到所有的E类型，然后根据 n 进行匹配。 3、格式：（第三部分） E:empty 匹配没有任何子节点（包括空格等text节点）的元素E。 E:target 匹配相关URL指向的E元素。要配合锚点使用。 举例： 我们可以把多个伪类选择器结合起来使用，比如： 如果想把上图中，第一行的前三个 span 标红，我们可以这样使用结构伪类选择器： 123dt:first-child span:nth-of-type(-n+3) &#123; color: red;&#125; 最后来张表格： 伪元素选择器伪元素选择器的标志性符号是 ::。 1、格式：（第一部分） E::before 设置在 元素E 前面（依据对象树的逻辑结构）的内容，配合content属性一起使用。 E::after 设置在 元素E 后面（依据对象树的逻辑结构）的内容，配合content属性一起使用。 E:after、E:before 在旧版本里是伪类，在 CSS3 这个新版本里是伪元素。新版本里，E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待，这样做的目的是用来做兼容处理。 举例： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /*::before 和::after 是通过 css 模拟出的html标签的效果*/ span::before&#123; content:&quot;smyhvae&quot;; color:red; background-color: pink; width: 50px; height: 50px; display: inline-block; &#125; span::after&#123; content:&quot;永不止步&quot;; color:yellowgreen; &#125; /*给原本的span标签设置一个默认的属性*/ span&#123; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;span&gt;生命壹号&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图可以看出： 通过伪元素选择器，就可以添加出类似于span标签的效果（记得要结合 content 属性使用）。 通过这两个属性添加的伪元素，是行内元素，需要转换成块元素才能设置宽高。 2、格式：（第二部分） E::first-letter 设置元素 E 里面的第一个字符的样式。 E::first-line 设置元素 E 里面的第一行的样式。 E::selection 设置元素 E 里面被鼠标选中的区域的样式（一般设置颜色和背景色）。 E::first-letter 的举例： E::first-line的举例： 最后来张表格： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/01-HTML5详解","date":"2021-08-06T01:17:25.840Z","updated":"2021-07-28T07:34:11.357Z","comments":true,"path":"2021/08/06/大前端/07-HTML5和CSS3/01-HTML5详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/01-HTML5%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 HTML5的介绍Web 技术发展时间线 1991 HTML 1994 HTML2 1996 CSS1 + JavaScript 1997 HTML4 1998 CSS2 2000 XHTML1（严格的html） 2002 Tableless Web Design（表格布局） 2005 AJAX 2009 HTML5 2014 HTML5 Finalized 2002年的表格布局逐渐被淘汰，是因为：表格是用来承载数据的，并不是用来划分网页结构的。 2009年就已经推出了HTML5的草案，但直到2014年才有定稿，是因为有移动端的推动。 H5草案的前身是叫：Web Application，最早是由WHATWG这个组织在2004年提出的。 2007年被 W3C 组织接纳，并在 2008-01-22 发布 HTML5 的第一个草案。 什么是 HTML5HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。 HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。 HTML5的广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。 HTML5不等于 HTML next version。HTML5 包含： HTML的升级版、CSS的升级版、JavaScript API的升级版。 总结：HTML5是新一代开发 Web 富客户端应用程序整体解决方案。包括：HTML5，CSS3，Javascript API在内的一套技术组合。 富客户端：具有很强的交互性和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。 PS： 单纯地从技术的角度讲，兼容性问题只会让开发者徒增烦恼。 如果网页端的程序能做到PC客户端的体验，就会对后者构成威胁。 HTML5 的应用场景列举几个HTML5 的应用场景： （1）极具表现力的网页：内容简约而不简单。 （2）网页应用程序： 代替PC端的软件：iCloud、百度脑图、Office 365等。 APP端的网页：淘宝、京东、美团等。 微信端：公众号、小程序等。 （3）混合式本地应用。 （4）简单的游戏。 HTML5 新增的内容 语义化的标签语义化的作用语义标签对于我们并不陌生，如&lt;p&gt;表示一个段落、&lt;ul&gt;表示一个无序列表。标签语义化的作用： 能够便于开发者阅读和写出更优雅的代码。 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。 更好地搜索引擎优化。 总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。 H5在语义上的改进在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。 我们常见的 css+div 布局是： 以后我们可以这样写： 传统的做法中，我们通过增加类名如class=&quot;header&quot;、class=&quot;footer&quot;，使HTML页面具有语义性，但是不具有通用性。 HTML5 则是通过新增语义标签的形式来解决这个问题，例如&lt;header&gt;&lt;/header&gt;、&lt;footer&gt;&lt;/footer&gt;等，这样就可以使其具有通用性。 传统网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;div class=&quot;header&quot;&gt; &lt;ul class=&quot;nav&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&lt;!-- 主体部分 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;!-- 文章 --&gt; &lt;div class=&quot;article&quot;&gt;&lt;/div&gt; &lt;!-- 侧边栏 --&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; H5 的经典网页布局： 1234567891011121314151617&lt;!-- 头部 --&gt;&lt;header&gt; &lt;ul class=&quot;nav&quot;&gt;&lt;/ul&gt;&lt;/header&gt;&lt;!-- 主体部分 --&gt;&lt;div class=&quot;main&quot;&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/div&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt; H5中常用的新语义标签 &lt;nav&gt; 表示导航 &lt;header&gt; 表示页眉 &lt;footer&gt; 表示页脚 &lt;section&gt; 表示区块 &lt;article&gt; 表示文章。如文章、评论、帖子、博客 &lt;aside&gt; 表示侧边栏 如文章的侧栏 &lt;figure&gt; 表示媒介内容分组。 &lt;mark&gt; 表示标记 (用得少) &lt;progress&gt; 表示进度 (用得少) &lt;time&gt; 表示日期 本质上新语义标签与&lt;div&gt;、&lt;span&gt;没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成&lt;div class=&quot;nav&quot;&gt; 相当于&lt;nav&gt;。 PS：单标签不用写关闭符号。 新语义标签的兼容性处理IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入html5shiv.js文件。 引入时，需要做if判断，具体代码如下： 12345&lt;!-- 条件注释 只有ie能够识别--&gt;&lt;!--[if lte ie 8]&gt; &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 上方代码是条件注释：虽然是注释，但是IE浏览器可以识别出来。解释一下： l：less 更小 t：than 比 e：equal等于 g：great 更大 PS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。 在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。 但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement(‘tagName’)创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。 当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。 H5中的表单传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。 H5中新增的表单类型 email 只能输入email格式。自动带有验证功能。 tel 手机号码。 url 只能输入url格式。 number 只能输入数字。 search 搜索框 range 滑动条 color 拾色器 time 时间 date 日期。 --datetime 时间日期 month 月份 week 星期 上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;&gt; &lt;title&gt;表单类型&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; form &#123; max-width: 500px; width: 100%; margin: 32px auto 0; font-size: 16px; &#125; label &#123; display: block; margin: 10px 0; &#125; input &#123; width: 100%; height: 25px; margin-top: 2px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;表单类型&lt;/legend&gt; &lt;label for=&quot;&quot;&gt; email: &lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; color: &lt;input type=&quot;color&quot; name=&quot;color&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; url: &lt;input type=&quot;url&quot; name=&#x27;url&#x27;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; number: &lt;input type=&quot;number&quot; step=&quot;3&quot; name=&quot;number&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; range: &lt;input type=&quot;range&quot; name=&quot;range&quot; value=&quot;100&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; search: &lt;input type=&quot;search&quot; name=&quot;search&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; tel: &lt;input type=&quot;tel&quot; name=&quot;tel&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; time: &lt;input type=&quot;time&quot; name=&quot;time&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; date: &lt;input type=&quot;date&quot; name=&quot;date&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; datetime: &lt;input type=&quot;datetime&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; week: &lt;input type=&quot;week&quot; name=&quot;month&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; month: &lt;input type=&quot;month&quot; name=&quot;month&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; datetime-local: &lt;input type=&quot;datetime-local&quot; name=&quot;datetime-local&quot;&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： &lt;fieldset&gt; 标签将表单里的内容进行打包，代表一组；而&lt;legend&gt; 标签的则是 fieldset 里的元素定义标题。 表单元素（标签）这里讲两个表单元素。 1、&lt;datalist&gt; 数据列表： 123456&lt;input type=&quot;text&quot; list=&quot;myData&quot;&gt;&lt;datalist id=&quot;myData&quot;&gt; &lt;option&gt;本科&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;option&gt;不明&lt;/option&gt;&lt;/datalist&gt; 上方代码中，input里的list属性和 datalist 进行了绑定。 效果： 上图可以看出，数据列表可以自动提示。 2、&lt;keygen&gt;元素： keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 3、&lt;meter&gt;元素：度量器 low：低于该值后警告 high：高于该值后警告 value：当前值 max：最大值 min：最小值。 举例： 1&lt;meter value=&quot;81&quot; min=&quot;0&quot; max=&quot;100&quot; low=&quot;60&quot; high=&quot;80&quot;/&gt; 表单属性 placeholder 占位符（提示文字） autofocus 自动获取焦点 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off) form 指定表单项属于哪个form，处理复杂表单时会需要 novalidate 关闭默认的验证功能（只能加给form） required 表示必填项 pattern 自定义正则，验证表单。例如 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; form &#123; width: 100%; /* 最大宽度*/ max-width: 640px; /* 最小宽度*/ min-width: 320px; margin: 0 auto; font-family: &quot;Microsoft Yahei&quot;; font-size: 20px; &#125; input &#123; display: block; width: 100%; height: 30px; margin: 10px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;表单属性&lt;/legend&gt; &lt;label for=&quot;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; placeholder=&quot;例如：smyhvae&quot; autofocus name=&quot;userName&quot; autocomplete=&quot;on&quot; required/&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; 电话：&lt;input type=&quot;tel&quot; pattern=&quot;1\\d&#123;10&#125;&quot;/&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; multiple的表单: &lt;input type=&quot;file&quot; multiple&gt; &lt;/label&gt; &lt;!-- 上传文件--&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; multiple/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 表单事件 oninput()：用户输入内容时触发，可用于输入字数统计。 oninvalid()：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; form &#123; width: 100%; /* 最大宽度*/ max-width: 400px; /* 最小宽度*/ min-width: 200px; margin: 0 auto; font-family: &quot;Microsoft Yahei&quot;; font-size: 20px; &#125; input &#123; display: block; width: 100%; height: 30px; margin: 10px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;表单事件&lt;/legend&gt; &lt;label for=&quot;&quot;&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;txt1&quot;/&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt; 输入的次数统计：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;txt2&quot;/&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;script&gt; var txt1 = document.getElementById(&#x27;txt1&#x27;); var txt2 = document.getElementById(&#x27;txt2&#x27;); var num = 0; txt1.oninput = function () &#123; //用户输入时触发 num++; //用户每输入一次，num自动加 1 //将统计数显示在txt2中 txt2.value = num; &#125; txt1.oninvalid = function () &#123; //验证不通过时触发 this.setCustomValidity(&#x27;亲，请输入正确哦&#x27;); //设置验证不通过时的提示文字 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 多媒体在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。 H5里面提供了视频和音频的标签。 音频HTML5通过&lt;audio&gt;标签来解决音频播放的问题。 使用举例： 1&lt;audio src=&quot;music/yinyue.mp3&quot; autoplay controls&gt; &lt;/audio&gt; 效果如下： 我们可以通过附加属性，来更友好地控制音频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 处理兼容性问题： 由于版权等原因，不同的浏览器可支持播放的格式是不一样的： 为了做到多浏览器支持，可以采取以下兼容性写法： 1234567&lt;!--推荐的兼容写法：--&gt;&lt;audio controls loop&gt; &lt;source src=&quot;music/yinyue.mp3&quot;/&gt; &lt;source src=&quot;music/yinyue.ogg&quot;/&gt; &lt;source src=&quot;music/yinyue.wav&quot;/&gt; 抱歉，你的浏览器暂不支持此音频格式&lt;/audio&gt; 代码解释：如果识别不出音频格式，就弹出那句“抱歉”。 视频HTML5通过&lt;video&gt;标签来解决视频播放的问题。 使用举例： 1&lt;video src=&quot;video/movie.mp4&quot; controls autoplay&gt;&lt;/video&gt; 我们可以通过附加属性，来更友好地控制视频的播放，如： autoplay 自动播放。写成autoplay 或者 autoplay = &quot;&quot;，都可以。 controls 控制条。（建议把这个选项写上，不然都看不到控件在哪里） loop 循环播放。 preload 预加载 同时设置 autoplay 时，此属性将失效。 width：设置播放窗口宽度。 height：设置播放窗口的高度。 由于版权等原因，不同的浏览器可支持播放的格式是不一样的： 兼容性写法： 12345678&lt;!--&lt;video src=&quot;video/movie.mp4&quot; controls autoplay &gt;&lt;/video&gt;--&gt;&lt;!-- 行内块 display:inline-block --&gt;&lt;video controls autoplay&gt; &lt;source src=&quot;video/movie.mp4&quot;/&gt; &lt;source src=&quot;video/movie.ogg&quot;/&gt; &lt;source src=&quot;video/movie.webm&quot;/&gt; 抱歉，不支持此视频&lt;/video&gt; DOM 操作获取元素 document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。 document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。 类名操作 Node.classList.add(“class”) 添加class Node.classList.remove(“class”) 移除class Node.classList.toggle(“class”) 切换class，有则移除，无则添加 Node.classList.contains(“class”) 检测是否存在class 自定义属性js 里可以通过 box1.index=100; box1.title 来自定义属性和获取属性。 H5可以直接在标签里添加自定义属性，但必须以 data- 开头。 举例： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 给标签添加自定义属性 必须以data-开头 --&gt;&lt;div class=&quot;box&quot; title=&quot;盒子&quot; data-my-name=&quot;smyhvae&quot; data-content=&quot;我是一个div&quot;&gt;div&lt;/div&gt;&lt;script&gt; var box = document.querySelector(&#x27;.box&#x27;); //自定义的属性 需要通过 dateset[]方式来获取 console.log(box.dataset[&quot;content&quot;]); //打印结果：我是一个div console.log(box.dataset[&quot;myName&quot;]); //打印结果：smyhvae //设置自定义属性的值 var num = 100; num.index = 10; box.index = 100; box.dataset[&quot;content&quot;] = &quot;aaaa&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例：鼠标点击时，tab栏切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Tab 标签&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #F7F7F7; &#125; .tabs &#123; width: 400px; margin: 30px auto; background-color: #FFF; border: 1px solid #C0DCC0; box-sizing: border-box; &#125; .tabs nav &#123; height: 40px; text-align: center; line-height: 40px; overflow: hidden; background-color: #C0DCC0; display: flex; &#125; nav a &#123; display: block; width: 100px; border-right: 1px solid #FFF; color: #000; text-decoration: none; &#125; nav a:last-child &#123; border-right: 0 none; &#125; nav a.active &#123; background-color: #9BAF9B; &#125; .cont &#123; overflow: hidden; display: none; &#125; .cont ol &#123; line-height: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;tabs&quot;&gt; &lt;nav&gt; &lt;a href=&quot;javascript:;&quot; data-cont=&quot;local&quot;&gt;国内新闻&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; data-cont=&quot;global&quot;&gt;国际新闻&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; data-cont=&quot;sports&quot;&gt;体育新闻&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; data-cont=&quot;funny&quot;&gt;娱乐新闻&lt;/a&gt; &lt;/nav&gt; &lt;section class=&quot;cont&quot; id=&quot;local&quot;&gt; &lt;ol&gt; &lt;li&gt;国内新闻1&lt;/li&gt; &lt;li&gt;国内新闻2&lt;/li&gt; &lt;li&gt;国内新闻3&lt;/li&gt; &lt;li&gt;国内新闻4&lt;/li&gt; &lt;li&gt;国内新闻5&lt;/li&gt; &lt;li&gt;国内新闻6&lt;/li&gt; &lt;li&gt;国内新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=&quot;cont&quot; id=&quot;global&quot;&gt; &lt;ol&gt; &lt;li&gt;国内新闻1&lt;/li&gt; &lt;li&gt;国际新闻2&lt;/li&gt; &lt;li&gt;国际新闻3&lt;/li&gt; &lt;li&gt;国际新闻4&lt;/li&gt; &lt;li&gt;国际新闻5&lt;/li&gt; &lt;li&gt;国际新闻6&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=&quot;cont&quot; id=&quot;sports&quot;&gt; &lt;ol&gt; &lt;li&gt;体育新闻1&lt;/li&gt; &lt;li&gt;体育新闻2&lt;/li&gt; &lt;li&gt;体育新闻3&lt;/li&gt; &lt;li&gt;体育新闻4&lt;/li&gt; &lt;li&gt;体育新闻5&lt;/li&gt; &lt;li&gt;体育新闻6&lt;/li&gt; &lt;li&gt;体育新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt; &lt;section class=&quot;cont&quot; id=&quot;funny&quot;&gt; &lt;ol&gt; &lt;li&gt;娱乐新闻1&lt;/li&gt; &lt;li&gt;娱乐新闻2&lt;/li&gt; &lt;li&gt;娱乐新闻3&lt;/li&gt; &lt;li&gt;娱乐新闻4&lt;/li&gt; &lt;li&gt;娱乐新闻5&lt;/li&gt; &lt;li&gt;娱乐新闻6&lt;/li&gt; &lt;li&gt;娱乐新闻7&lt;/li&gt; &lt;/ol&gt; &lt;/section&gt;&lt;/div&gt;&lt;script&gt; // 目标： 默认显示一个 当前的样式 // 点击导航，实现切换 // key 表示的当前显示的是第几个 (function (key) &#123;// 获取所有的导航 var navs = document.querySelectorAll(&#x27;nav a&#x27;);// 遍历 给导航 绑定事件，并且添加当前样式 for (var i = 0; i &lt; navs.length; i++) &#123;// 如果是用户指定的当前样式 if (key == i) &#123; navs[i].classList.add(&#x27;active&#x27;);// 拿到要显示内容section的id var secId = navs[i].dataset[&#x27;cont&#x27;];// 获取对应的section标签 document.querySelector(&#x27;#&#x27; + secId).style.display = &#x27;block&#x27;; &#125;// 给每一个导航绑定点击事件 navs[i].onclick = function () &#123; // 排他 // 之前有active样式的清除, 之前显示的section 隐藏 var currentNav = document.querySelector(&#x27;.active&#x27;);// 获取对应的内容区域 ，让其隐藏 var currentId = currentNav.dataset[&#x27;cont&#x27;];// 去掉导航的active 样式 currentNav.classList.remove(&#x27;active&#x27;);// 对应的内容区域 document.querySelector(&#x27;#&#x27; + currentId).style.display = &#x27;none&#x27;; // 突出显示自己 导航添加样式 对应的section 显示// 给自己添加active样式 this.classList.add(&#x27;active&#x27;);// 对应的section模块显示出来 var myId = this.dataset[&#x27;cont&#x27;]; document.querySelector(&#x27;#&#x27; + myId).style.display = &#x27;block&#x27;; &#125; &#125; &#125;)(0);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/06-jQuery/11-Zepto入门","date":"2021-08-06T01:17:25.836Z","updated":"2021-07-28T07:34:11.357Z","comments":true,"path":"2021/08/06/大前端/06-jQuery/11-Zepto入门/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/06-jQuery/11-Zepto%E5%85%A5%E9%97%A8/","excerpt":"","text":"Zepto 的介绍什么是 Zeptozepto是轻量级的JavaScript库，专门为移动端定制的框架。 与jquery有着类似的API，俗称：会jquery就会用zepto zepto的特点 针对移动端 轻量级，压缩版本只有8kb左右 响应，执行快 语法、API大部分同jquery一样，学习难度低，上手快。 目前API完善的框架中体积最小的一个 相关网址 官网：http://zeptojs.com/ GitHub：https://github.com/madrobby/zepto Zepto 与 jQuery 的前世今生相同点 都是优秀的js函数库 语法、API大部分都一样（zepto是按照jquery的思路来设计的） Zepto 相当于 jQuery 的子集 同jQuery一样，都是以$符号为核心函数。 不同点Zepto 的初体验（1）Zepto 库的下载： 我们去官网下载 Zepto的开发版本zepto.js： 官网里，还有这样一张图： 上图的意思是： 最前面打钩的那五个api，已经包含在zepto.js 文件里了； 后面没有打钩的那些api，如果需要用它们，必须单独下载响应的文件。 比如说，移动端的 touch 事件是很常见的，我们可以将touch.js这个文件下载，稍后用。 （2）代码演示： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #btn &#123; width: 200px; height: 200px; background: pink; margin: 10px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;btn&quot;&gt;我是 div&lt;/div&gt; &lt;script src=&quot;libs/zepto1.2.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;libs/touch.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&#x27;#btn&#x27;).on(&#x27;touchstart&#x27;, function () &#123; alert(&#x27;hello world&#x27;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码实现的效果是，当手在div上滑动时，就会弹出 alert窗。可以看出，这里面代码的写法和 jQuery 是一致的。 注意，我们要将浏览器切换到手机模式，才能看到touchstart事件的效果；否则，在浏览器上点来点去，是没有反应的。 Zepto 和 jQuery 相同的 api 意思是，jQuery 和 Zepto 有哪些共同点。 jQuery 的主要特性下面来讲一下 jQuery 的主要特性（jQuery 的核心函数$、jQuery 对象），它们对 Zepto 来说，同样适用。 1、jQuery 的核心函数$: 作为函数使用（参数）： function html字符串 DOM code 选择器字符串 作为对象调用(方法)： $.ajax() $.get() $.post() $.isArray() $.each() $.isFunction() $.trim() 2、jQuery 对象： 概念：jquery核心函数$()调用返回的对象就是jquery对象的数组（可能有只有一个）。 使用列举： addClass() removeClass() show() find() 代码举例1、$.each()方法举例：（遍历数组） 12345678910&lt;script src=&quot;libs/zepto-1.2.0.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;libs/zepto-1.2.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var arr = [2, 4, 6, 8]; $.each(arr, function (index, item) &#123; console.log(index, item); &#125;);&lt;/script&gt; 打印结果： 2、append()举例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 200px; height: 200px; background: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;script src=&quot;libs/zepto-1.2.0.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;libs/touch.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;.box1&#x27;).on(&#x27;touchstart&#x27;, function () &#123; $(&#x27;.box1&#x27;).append(&#x27;&lt;p&gt;我是新添加的元素&lt;/p&gt;&#x27;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码实现的效果是：每次，当手在box1上滑动时，会在 box1 中新添加一个元素。 4、find()方法举例： 1234$(&#x27;.box1&#x27;).on(&#x27;touchstart&#x27;, function () &#123; console.log(&#x27;touch&#x27;); $(this).find(&#x27;p&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;);&#125;); 代码解释：找到 box1 中的 p 标签， 给 p 标签设置背景色。 注意，代码里的$(this).find()相当于this.find，只不过this没有find方法，而$有find方法。 5、show()方法举例： 123$(`.box1`).on(&#x27;touchstart&#x27;, function () &#123; $(&#x27;.box2&#x27;).show();&#125;); 假设 box2 一开始是隐藏的，事件中，让 box2 显示出来。","categories":[],"tags":[]},{"title":"","slug":"大前端/06-jQuery/04-jQuery的事件机制和其他知识","date":"2021-08-06T01:17:25.834Z","updated":"2021-07-28T07:34:11.356Z","comments":true,"path":"2021/08/06/大前端/06-jQuery/04-jQuery的事件机制和其他知识/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/06-jQuery/04-jQuery%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/","excerpt":"","text":"jQuery 设置宽度和高度宽度操作： 12$(selector).height(); //不带参数表示获取高度$(selector).height(200); //带参数表示设置高度 宽度操作： 12$(selector).width(); //不带参数表示获取宽度$(selector).width(200); //带参数表示设置高宽度 问题：jQuery的css()获取高度，和jQuery的height获取高度，二者的区别？ 答案： 123$(&quot;div&quot;).css(); //返回的是string类型，例如：30px$(&quot;div&quot;).height(); //返回得失number类型，例如：30。常用于数学计算。 如上方代码所示，$(&quot;div&quot;).height();返回的是number类型，常用于数学计算。 jQuery 的坐标操作offset()方法12$(selector).offset();$(selector).offset(&#123;left:100, top: 150&#125;); 作用：获取或设置元素相对于 document 文档的位置。参数解释： 无参数：表示获取。返回值为：{left:num, top:num}。返回值是相对于document的位置。 有参数：表示设置。参数建议使用 number 数值类型。 注意：设置offset后，如果元素没有定位(默认值：static)，则被修改为relative。 position()方法1$(selector).position(); 作用：获取相对于其最近的带有定位的父元素的位置。返回值为对象：&#123;left:num, top:num&#125;。 注意：只能获取，不能设置。 scrollTop()方法12scrollTop();$(selector).scrollTop(100); 作用：获取或者设置元素被卷去的头部的距离。参数解释： 无参数：表示获取偏移。 有参数：表示设置偏移，参数为数值类型。 scrollLeft()方法12scrollLeft();$(selector).scrollLeft(100); 作用：获取或者设置元素水平方向滚动的位置。参数解释： 无参数：表示获取偏移。 有参数：表示设置偏移，参数为数值类型。 代码示范： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; height: 5000px; &#125; .box1 &#123; width: 300px; height: 300px; position: relative; margin: 10px; overflow: auto; background-color: pink; &#125; .box2 &#123; width: 200px; height: 400px; position: absolute; top: 50px; left: 50px; background-color: yellow; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //距离页面最顶端或者最左侧的距离和有没有定位没有关系 $(&quot;button&quot;).eq(0).click(function () &#123; alert($(&quot;.box2&quot;).offset().top); &#125;) //距离页面最顶端或者最左侧的距离和有没有定位没有关系 $(&quot;button&quot;).eq(1).click(function () &#123; $(&quot;.box2&quot;).offset(&#123;&quot;left&quot;: 1000, &quot;top&quot;: 1000&#125;); &#125;) //距离父系盒子中带有定位的盒子的距离(获取的就是定位值，和margin/padding无关) $(&quot;button&quot;).eq(2).click(function () &#123; alert($(&quot;.box2&quot;).position().top); &#125;) //距离父系盒子中带有定位的盒子的距离(获取的就是定位值，和margin/padding无关) $(&quot;button&quot;).eq(3).click(function () &#123; $(&quot;.box2&quot;).position().top = &quot;100px&quot;; &#125;) //获取被选取的头部 $(&quot;button&quot;).eq(4).click(function () &#123; alert($(window).scrollTop()); &#125;) //获取被选取的头部 $(&quot;button&quot;).eq(5).click(function () &#123; $(window).scrollTop(100); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;offset().top获取&lt;/button&gt;&lt;button&gt;offset().top设置&lt;/button&gt;&lt;button&gt;position().top获取&lt;/button&gt;&lt;button&gt;position().top设置&lt;/button&gt;&lt;button&gt;scrollTop()&lt;/button&gt;&lt;button&gt;scrollTop()&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery的事件机制常见的事件绑定 click(handler) 单击事件。 blur(handler) 失去焦点事件。 mouseenter(handler) 鼠标进入事件。 mouseleave(handler) 鼠标离开事件。 dbclick(handler) 双击事件。 change(handler) 改变事件，如：文本框值改变，下拉列表值改变等。 focus(handler) 获得焦点事件。 keydown(handler) 键盘按下事件。 参考链接：http://www.w3school.com.cn/jquery/jquery_ref_events.asp on方式绑定事件最早采用的是 bind、delegate等方式绑定的。jQuery 1.7版本后，jQuery用on统一了所有的事件处理的方法，此方法兼容zepto(移动端类似于jQuery的一个库)。 格式举例： 1234$(document).on(&quot;click mouseenter&quot;, &quot;.box&quot;, &#123;&quot;name&quot;: 111&#125;, function (event) &#123; console.log(event.data); //event.data获取的就是第三个参数这个json。 console.log(event.data.name); //event.data.name获取的是name的值。&#125;); 参数解释： 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）。上方代码绑定的是单击事件和鼠标进入事件。 第二个参数：selector, 执行事件的后代元素。 第三个参数：data，传递给事件处理函数的数据，事件触发的时候通过event.data来使用（也就是说，可以通过event拿到data） 第四个参数：handler，事件处理函数。 简单点的写法： 123$(document).on(&quot;click&quot;,&quot;.box&quot;, function () &#123; alert(1);&#125;); off方式解绑事件12345$(selector).off(); // 解绑匹配元素的所有事件$(selector).off(&quot;click&quot;); // 解绑匹配元素的所有click事件$(selector).off( &quot;click&quot;, &quot;**&quot; ); // 解绑所有代理的click事件，元素本身的事件不会被解绑 jQuery的事件对象event.data 传递给事件处理程序的额外数据 event.currentTarget 等同于this，当前DOM对象 event.pageX 鼠标相对于文档左部边缘的位置 event.target 触发事件源，不一定===this event.stopPropagation()； 阻止事件冒泡 event.preventDefault(); 阻止默认行为 event.type 事件类型：click，dbclick… event.which 鼠标的按键类型：左1 中2 右3 event.keyCode 键盘按键代码 代码演示： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(document).on(&quot;click&quot;, &#123;&#125;, function (event) &#123; console.log(event.data); console.log(event.currentTarget); console.log(event.target); console.log(event.pageX); console.log(event.type); console.log(event.which); console.log(event.keyCode); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们通过event参数，获取了点击事件的各种event里的属性。 单击网页后，打印结果为： 举例：键盘上对的按键按下时，变色 这个时候就要用到event参数，因为要获取event.keyCode，才能知道按下的是键盘上的哪个按键。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .wrap &#123; width: 400px; height: 400px; margin: 100px auto 0; &#125; .wrap h1 &#123; text-align: center; &#125; .wrap div &#123; width: 400px; height: 300px; background: pink; font-size: 30px; text-align: center; line-height: 300px; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：在页面上，按键.是哪个颜色的首写字母div就改变为该颜色，然后span内容赋值。 //步骤： //1.给document绑定keyup事件 //2.获取值，根据此值，给div和span上色和内容 var div = $(&quot;#bgChange&quot;); var span = $(&quot;#keyCodeSpan&quot;); //绑定事件 $(document).keyup(function (e) &#123; //键盘弹出时，触发事件 //调用方法 setColor(e.keyCode); &#125;); function setColor(keyCode) &#123; //alert(e.keyCode); //2.获取值，根据此值，给div和span上色和内容 switch (keyCode) &#123; case 80: //修改内容pink setEle(&quot;pink&quot;, keyCode); break; case 66: //修改内容blue setEle(&quot;blue&quot;, keyCode); break; case 79: //修改内容orange setEle(&quot;orange&quot;, keyCode); break; case 82: //修改内容red setEle(&quot;red&quot;, keyCode); break; case 89: //修改内容yellow setEle(&quot;yellow&quot;, keyCode); break; default : alert(&quot;系统没有设置该颜色！&quot;); &#125; function setEle(a, b) &#123; div.css(&quot;background-color&quot;, a); span.text(b); &#125; &#125; //1.给document绑定keyup事件// $(document).keyup(function (e) &#123;// //alert(e.keyCode);// //2.获取值，根据此值，给div和span上色和内容// switch (e.keyCode)&#123;// case 80:// //修改内容pink// div.css(&quot;background-color&quot;,&quot;pink&quot;);// span.text(e.keyCode);// break;// case 66:// //修改内容blue// div.css(&quot;background-color&quot;,&quot;blue&quot;);// span.text(e.keyCode);// break;// case 79:// //修改内容orange// div.css(&quot;background-color&quot;,&quot;orange&quot;);// span.text(e.keyCode);// break;// case 82:// //修改内容red// div.css(&quot;background-color&quot;,&quot;red&quot;);// span.text(e.keyCode);// break;// case 89:// //修改内容yellow// div.css(&quot;background-color&quot;,&quot;yellow&quot;);// span.text(e.keyCode);// break;// default :// alert(&quot;系统没有设置该颜色！&quot;);// &#125;// &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;h1&gt;按键改变颜色&lt;/h1&gt; &lt;div id=&quot;bgChange&quot;&gt; keyCode为： &lt;span id=&quot;keyCodeSpan&quot;&gt;80&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery 的两大特点（1）链式编程：比如.show()和.html()可以连写成.show().html()。 链式编程原理：return this。 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。 1end(); // 结束当前链最近的一次过滤操作，并且返回匹配元素之前的状态。 （2）隐式迭代：隐式 对应的是 显式。隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。 举例：五角星评分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;五角星评分案例&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .comment &#123; font-size: 40px; color: #ff3100; &#125; .comment li &#123; float: left; cursor: pointer; &#125; ul &#123; list-style: none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var star_none = &#x27;☆&#x27;; // 空心五角星 var star_sel = &#x27;★&#x27;; // 实心五角星 //需求1：鼠标放悬停时，当前的li和之前所有的li内容全部变为实心五角星，移开变为空心。 $(&quot;.comment li&quot;).on(&quot;mouseenter&quot;, function () &#123; //当前五角星，和之前的所有五角星，全部是实心的，其他的为空心 //写法一：分两次写// $(this).text(star_sel).prevAll(&quot;li&quot;).text(star_sel);// $(this).nextAll(&quot;li&quot;).text(star_none); //写法二：一次性写完，但要用到end()，否则会出问题。【重要】 $(this).text(star_sel).prevAll(&quot;li&quot;).text(star_sel).end().nextAll(&quot;li&quot;).text(star_none); &#125;); $(&quot;.comment li&quot;).on(&quot;mouseleave&quot;, function () &#123; //bug：如果没有点击过li，那么会出现无法清除的现象，处理办法就是先判断，看看是否有current类 if ($(&quot;li.current&quot;).length === 0) &#123; $(&quot;.comment li&quot;).text(star_none); &#125; else &#123; //当鼠标移开的时候，谁有current类名，那么当前和之前所有的li前部是实心五角星，后面的所有li都是空心 $(&quot;li.current&quot;).text(star_sel).prevAll(&quot;li&quot;).text(star_sel).end().nextAll(&quot;li&quot;).text(star_none); &#125; &#125;); //需求2：鼠标点击那个li，当你前li和之前所有的li都变成实心五角星，其他变为空心。 $(&quot;.comment li&quot;).on(&quot;click&quot;, function () &#123; //点击哪个li给他加一个类名。清空其他所有的li的类名 $(this).attr(&quot;class&quot;, &quot;current&quot;).siblings(&quot;li&quot;).removeAttr(&quot;class&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;comment&quot;&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt; &lt;li&gt;☆&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，注意end的用法，很巧妙。 实现效果： each的用法大部分情况下是不需要使用each方法的，因为jQuery的隐式迭代特性。 但是，如果要对每个元素做不同的处理，这时候就用到了each方法。 格式如下： 1$(selector).each(function(index,element)&#123;&#125;); 参数解释： 参数一：表示当前元素在所有匹配元素中的索引号 参数二：参数二表示当前元素（是js 中的DOM对象，而不是jQuery对象） 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; li &#123; width: 100px; height: 100px; margin: 20px; float: left; list-style: none; text-align: center; font: 50px/100px &quot;simsun&quot;; color: white; background-color: black; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; //设置每个不一样的盒子透明度逐渐递增 $(&quot;ul li&quot;).each(function (index, element) &#123; $(element).css(&quot;opacity&quot;, (index + 1) / 10); console.log(index+&quot;---&quot;+element.tagName); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li class=&quot;aaa1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;aaa2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;aaa3&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;aaa4&quot;&gt;4&lt;/li&gt; &lt;li class=&quot;aaa5&quot;&gt;5&lt;/li&gt; &lt;li class=&quot;aaa6&quot;&gt;6&lt;/li&gt; &lt;li class=&quot;aaa7&quot;&gt;7&lt;/li&gt; &lt;li class=&quot;aaa8&quot;&gt;8&lt;/li&gt; &lt;li class=&quot;aaa9&quot;&gt;9&lt;/li&gt; &lt;li class=&quot;aaa10&quot;&gt;10&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 多库共存多库共存指的是：jQuery占用了 $ 和 jQuery 这两个变量。当在同一个页面中引用了 jQuery 库以及其他的库（或者其他版本的jQuery库），恰好其他的库中也用到了 $ 或者jQuery变量.那么，要保证每个库都能正常使用，就产生了多库共存的问题。 温馨提示：我们可以通过以下方式获取 jQuery 库的版本号。 1console.log($.fn.jquery); //打印 jQuery 库的版本号 办法一：让 jQuery 放弃对 $ 的使用权： 1$.noConflict(); 效果如下： 上图中，代码中同时包含了两个版本的库。1.11.1版本放弃了对 $ 的使用权，交给了1.8.2版本；但是1.11.1版本并没有放弃对 jQuery关键字的使用权。 办法二：同时放弃放弃两个符号的使用权，并定义一个新的使用权（如果有三个库时，可以这样用） 1$.noConflict(true); //返回值是新的关键字 效果如下： jQuery 的插件机制jQuery 库，虽然功能强大，但也不是面面俱到。jQuery 是通过插件的方式，来扩展它的功能： 当你需要某个插件的时候，你可以“安装”到jQuery上面，然后使用。 当你不再需要这个插件，那你就可以从jQuery上“卸载”它。 插件之改变颜色jQuery的自定义动画方法animate()，在执行动画时，是不支持设置背景色这个属性的。这个时候可以借助jQuery.color.js这个插件。 举例： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: blue; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.color.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //点击按钮，改变盒子的宽度和背景色 $(&quot;button&quot;).on(&quot;click&quot;, function () &#123; $(&quot;div&quot;).animate(&#123;&quot;width&quot;: 200, &quot;background-color&quot;: &quot;red&quot;&#125;, 2000, function () &#123; alert(&quot;动画结束&quot;); &#125;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;变色&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 上方代码中，因为加入了一行插件：（注意顺序是放在jQuery插件之后） 1&lt;script src=&quot;jquery.color.js&quot;&gt;&lt;/script&gt; 否则的话，在动画执行的过程中，是无法设置背景色的。 插件之懒加载懒加载：当打开一个网页时，只有当我看到某个部分，再加载那个部分；而不是一下子全部加载完毕。这样可以优化打开的速度。 比如说，我可以设置一张图片为懒加载，于是，这张图片会等我宠幸到它的时候，它再打开。 代码举例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; height: 3000px; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;!--懒加载的使用。第一步：导包(必须在jquery库的下方）--&gt; &lt;script src=&quot;jquery.lazyload.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //第二步骤：调用懒加载的方法实现功能。参数的不同，功能也不同。 $(&quot;img.lazy&quot;).lazyload(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;!--需要实现将图片设置为懒加载模式--&gt;&lt;img class=&quot;lazy&quot; data-original=&quot;images/01.jpg&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/06-jQuery/03-jQuery操作DOM","date":"2021-08-06T01:17:25.832Z","updated":"2021-07-28T07:34:11.356Z","comments":true,"path":"2021/08/06/大前端/06-jQuery/03-jQuery操作DOM/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/06-jQuery/03-jQuery%E6%93%8D%E4%BD%9CDOM/","excerpt":"","text":"文本主要内容 样式和类操作 节点操作 样式操作和类操作作用：设置或获取元素的样式属性值。 样式操作1、设置样式： 123456789 //设置单个样式： css(属性，值); $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;red&quot;); //设置多个样式： css(json);$(&quot;div&quot;).css(&#123;&quot;width&quot;:100,&quot;height&quot;:100,&quot;background-color&quot;:&quot;pink&quot;&#125;); 2、获取样式： 123//获取样式：css(属性);//获取的时候如果有很多个，那么获取jquery对象中的第一个alert($(&quot;div&quot;).css(&quot;width&quot;)); 举例如下： 类操作（className）1、添加类样式： 1$(selector).addClass(&quot;liItem&quot;); //为指定元素添加类className 注意：此处类名不带点，所有类操作的方法类名都不带点。 2、移除类样式： 12$(selector).removeClass(&quot;liItem&quot;); //为指定元素移除类 className$(selector).removeClass(); //不指定参数，表示移除被选中元素的所有类 3、判断有没有类样式： 1$(selector).hasClass(&quot;liItem&quot;); //判断指定元素是否包含类 className 此时，会返回true或false。jquery对象中，只要有一个带有指定类名的就是true，所有都不带才是false。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; &#125; .current &#123; background-color: red; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;).eq(0).click(function () &#123; //添加类 $(&quot;div&quot;).addClass(&quot;current&quot;); //判断类 alert($(&quot;div&quot;).hasClass(&quot;current&quot;)); &#125;); $(&quot;button&quot;).eq(1).click(function () &#123; //删除类 $(&quot;div&quot;).removeClass(&quot;current&quot;); //判断类 alert($(&quot;div&quot;).hasClass(&quot;current&quot;)); &#125;); //alert($(&quot;div&quot;).hasClass(&quot;current&quot;));//jquery对象中只要有一个带有类名的就是true，所有都不带才是false。 &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加&lt;/button&gt;&lt;button&gt;删除&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;current&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、切换类样式： 1$(selector).toggleClass(“liItem”); //为指定元素切换类 className，该元素有类则移除，没有指定类则添加。 解释：为指定元素切换类 className，该元素有类则移除，没有指定类则添加。 如果采用采用正常的思路实现上面这句话，代码是： 1234567if($(&quot;div&quot;).hasClass(&quot;current&quot;))&#123; //如果有类名，那么删除 $(&quot;div&quot;).removeClass(&quot;current&quot;)&#125;else&#123; //如果没有类名，那么添加 $(&quot;div&quot;).addClass(&quot;current&quot;)&#125; 现在有了toggleClass()方法，一行代码即可实现。 举例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: green; &#125; .current &#123; background-color: red; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;).click(function () &#123; //需求：点击按钮 ，切换背景 //切换类（toggleCLass） $(&quot;div&quot;).toggleClass(&quot;current&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;切换背景&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 样式操作和类操作的比较 操作的样式非常少，那么可以通过.css()实现。 操作的样式很多，建议通过使用类 class 的方式来操作。 如果考虑以后维护方便（把CSS从js中分离出来）的话，推荐使用类的方式来操作。 举例：addClass+removeClass 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrapper &#123; width: 1000px; height: 475px; margin: 0 auto; margin-top: 100px; &#125; .tab &#123; border: 1px solid #ddd; border-bottom: 0; height: 36px; width: 320px; &#125; .tab li &#123; position: relative; float: left; width: 80px; height: 34px; line-height: 34px; text-align: center; cursor: pointer; border-top: 4px solid #fff; &#125; .tab span &#123; position: absolute; right: 0; top: 10px; background: #ddd; width: 1px; height: 14px; overflow: hidden; &#125; .products &#123; width: 1002px; border: 1px solid #ddd; height: 476px; &#125; .products .main &#123; float: left; display: none; &#125; .products .main.selected &#123; display: block; &#125; .tab li.active &#123; border-color: red; border-bottom: 0; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(window).ready(function () &#123; //需求:鼠标放到那个li上，让该li添加active类，下面的对应的.main的div添加selected $(&quot;.tab&gt;li&quot;).mouseenter(function () &#123; //不用判断，当前的li添加active类，其他的删除active类 $(this).addClass(&quot;active&quot;).siblings(&quot;li&quot;).removeClass(&quot;active&quot;); //对应索引值的div添加selected类，其他的删除selected类 //【重要】根据tab的索引值获取下方图片div的索引值 $(&quot;.products&gt;div&quot;).eq($(this).index()).addClass(&quot;selected&quot;).siblings(&quot;div&quot;).removeClass(&quot;selected&quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;tab&quot;&gt; &lt;li class=&quot;tab-item active&quot;&gt;国际大牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;国妆名牌&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;清洁用品&lt;span&gt;◆&lt;/span&gt;&lt;/li&gt; &lt;li class=&quot;tab-item&quot;&gt;男士精品&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;products&quot;&gt; &lt;div class=&quot;main selected&quot;&gt; &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/guojidapai.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/guozhuangmingpin.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/qingjieyongpin.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;a href=&quot;###&quot;&gt;&lt;img src=&quot;images/nanshijingpin.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们注意，tab栏和下方图片栏的index值，一一对应，这里用得很巧妙。 效果： jQuery 的节点操作动态创建元素原生 js 有三种动态创建元素的方式。这里我们学一下 jQuery 动态创建元素。注意，创建的是 jQuery 对象。 方式一： 1var $spanNode1 = $(&quot;&lt;span&gt;我是一个span元素&lt;/span&gt;&quot;); // 返回的是 jQuery对象 此方法类似于 原生 js 中的document.createElement(&quot;标签名&quot;); 方式二：（推荐） 1var node = $(&quot;#box&quot;).html(&quot;&lt;li&gt;我是li&lt;/li&gt;&quot;); 此方法类似于 原生 js 中的innerHTML。 举例： 12345//方式一： $(&quot;标签&quot;) :类比于js中的document.createElement(&quot;li&quot;);console.log($(&quot;&lt;li class=&#x27;aaa&#x27;&gt;我是li标签&lt;/li&gt;&quot;));//方式二： $(&quot;ul&quot;).html(&quot;&quot;); :类比innerHTML属性。因为此属性，识别标签。$(&quot;ul&quot;).html(&quot;&lt;li&gt;我是html方法穿件出来的li标签&lt;/li&gt;&quot;) 添加元素jQuery 添加元素的方法非常多，最重要的方法是append()。格式如下： 123456// 方式一：在$(selector)中追加$node$(selector).append($node); //参数是 jQuery对象// 方式二：在$(selector)中追加div元素，$(selector).append(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;); //参数是 htmlString 作用：在被选元素内部的最后一个子元素（或内容）后面插入内容（存在或者创建出来的元素都可以）。 通俗的解释：在盒子里的最末尾添加元素。 如果是页面中存在的元素，那调用append()后，会把这个元素放到相应的目标元素里面去；但是，原来的这个元素，就不存在了。 如果是给多个目标追加元素，那么方法的内部会复制多份这个元素，然后追加到多个目标里面去。 举例： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(document).ready(function () &#123; $(&quot;button&quot;).click(function () &#123; //创建一个新的jquery对象li var jqNewLi = $(&quot;&lt;li&gt;我是jquery创建出来的li。用的是append方法添加&lt;/li&gt;&quot;); //append(); 在盒子里的最末尾添加与严肃 $(&quot;ul&quot;).append(jqNewLi); //把新创建的 li 塞进已知的 ul 中 //jqNewLi.appendTo($(&quot;ul&quot;)); //方式二：把新创建的li塞进ul中。作用同上 &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加li&lt;/button&gt;&lt;ul&gt; &lt;li&gt;我是土著li&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 其他的添加元素的方法： 方法2： 1$(selector).appendTo(node); 作用：同append()，只不过是反着写的。 方法3： 1$(selector).prepend(node); 作用：在元素的第一个子元素前面追加内容或节点。 方法4： 1$(selector).after(node); 作用：在被选元素之后，作为兄弟元素插入内容或节点。 方法5： 1$(selector).before(node); 作用：在被选元素之前，作为兄弟元素插入内容或节点。 清空元素方式一：没有参数 12$(selector).empty();$(selector).html(&quot;&quot;); 解释：清空指定元素的所有子元素（光杆司令）。 方式二： // 1$(selector).remove(); 解释：“自杀” 。把自己以及所有的内部元素从文档中删除掉。 复制元素格式： 1复制的新元素 = $(selector).clone(); 解释：复制$(selector)这个元素。是深层复制。 总结推荐使用 html(&quot;&lt;span&gt;&lt;/span&gt;&quot;) 方法来创建元素或者 html(&quot;&quot;) 清空元素。 案例：选择水果完整版代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; select &#123; width: 170px; height: 240px; font-size: 18px; background-color: #a4ff34; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //步骤： //1.将左侧的子标签全部移动到右侧。 $(&quot;button&quot;).eq(0).click(function () &#123; //右侧标签.append(左侧标签); $(&quot;#sel2&quot;).append($(&quot;#sel1 option&quot;)); &#125;); //2.将右侧的子标签全部移动到左侧。 $(&quot;button&quot;).eq(1).click(function () &#123; //左侧标签.append(右侧标签); $(&quot;#sel1&quot;).append($(&quot;#sel2 option&quot;)); &#125;); //第二步：获取子元素的时候要注意，获取的必须是，被选中的元素。 //技术点：怎么获取被选中的子元素呢？？？答案：option:selected; //1.将左侧被选中的子标签移动到右侧 $(&quot;button&quot;).eq(2).click(function () &#123; //右侧标签.append(左侧标签); $(&quot;#sel2&quot;).append($(&quot;#sel1 option:selected&quot;)); &#125;); //2.将右侧被选中的子标签移动到左侧 $(&quot;button&quot;).eq(3).click(function () &#123; //右侧标签.append(左侧标签); $(&quot;#sel1&quot;).append($(&quot;#sel2 option:selected&quot;)); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;select id=&quot;sel1&quot; size=&quot;10&quot; multiple&gt; &lt;option value=&quot;0&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;鸭梨&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;葡萄&lt;/option&gt;&lt;/select&gt;&lt;button&gt;&gt;&gt;&gt;&lt;/button&gt;&lt;button&gt;&lt;&lt;&lt;&lt;/button&gt;&lt;button&gt;&gt;&lt;/button&gt;&lt;button&gt;&lt;&lt;/button&gt;&lt;select id=&quot;sel2&quot; size=&quot;10&quot; multiple&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 效果： 案例：动态添加表格项代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff; &#125; td &#123; font: 14px &quot;微软雅黑&quot;; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 模拟从后台拿到的数据 var data = [&#123; name: &quot;博客园&quot;, url: &quot;http://www.cnblogs.com/smyhvae/&quot;, type: &quot;程序员的精神家园&quot; &#125;, &#123; name: &quot;简书&quot;, url: &quot;https://www.jianshu.com/u/4d2e6b4bf117&quot;, type: &quot;写作平台&quot; &#125;, &#123; name: &quot;百度&quot;, url: &quot;https://www.baidu.com/&quot;, type: &quot;你就知道&quot; &#125;]; //需求:点击按钮，然后生成tr里面生成三个td.数组元素个数个tr。然后放入tbody中 //步骤： //1.绑定事件 //2.利用for循环,把数组中的所有数据组合成一个字符串。 //3.把生成的字符串设置为html内容添加进tbody中。 //1.绑定事件 $(&quot;input&quot;).click(function () &#123; //写入到click事件中，每次点击以后把之前的str清空【重要】 var str = &quot;&quot;; //2.利用for循环,把数组中的所有数据组合成一个字符串。 for(var i=0;i&lt;data.length;i++)&#123; //如何生成3组？？？// str += &quot;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&quot;; //data[i] = 数组中的每一个json //data[i].name = 数组中的每一个json的name属性值 str += &quot;&lt;tr&gt;&lt;td&gt;&quot;+data[i].name+&quot;&lt;/td&gt;&lt;td&gt;&quot;+data[i].url+&quot;&lt;/td&gt;&lt;td&gt;&quot;+data[i].type+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; //3.把生成的字符串设置为html内容添加进tbody中。 $(&quot;#j_tbData&quot;).html(str); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;获取数据&quot; id=&quot;j_btnGetData&quot;/&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;说明&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tbData&quot;&gt; &lt;!--&lt;tr&gt;--&gt; &lt;!--&lt;td&gt;1&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;2&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;3&lt;/td&gt;--&gt; &lt;!--&lt;/tr&gt;--&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 代码解释：每次生成字符串str之前，记得先把之前的str清空，不然每次点击按钮，都会继续添加表格项。 将上一个案例进一步提升：点击按钮，添加数据暂略。 jQuery 设置和获取属性jQuery 无法直接操作节点的属性和src等，我们需要借助attr()方法。下面介绍。 属性操作（1）设置属性： 1$(selector).attr(&quot;title&quot;, &quot;生命壹号&quot;); 参数解释：第一个参数表示：要设置的属性名称。第二个参数表示：该属性名称对应的值。 （2）获取属性： 1$(selector).attr(&quot;title&quot;); 参数为：要获取的属性的名称，返回指定属性对应的值。 总结：两个参数是给属性赋值，单个参数是获取属性值。 （3）移除属性： 1$(selector).removeAttr(&quot;title&quot;); 参数为：要移除的属性的名称。 （4）form表单中的 prop()方法： 针对checked、selected、disabled属性，要使用 prop()方法，而不是其他的方法。 prop方法通常用来影响DOM元素的动态状态，而不是改变的HTML属性。例如：input和button的disabled特性，以及checkbox的checked特性。 总结：细节可以参考：http://api.jquery.com/prop/。 以上四项的代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .aaa &#123; border: 1px solid red; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //获取元素，绑定属性 var jqinp = $(&quot;input&quot;).eq(0); var jqinp2 = $(&quot;input:checkbox&quot;); var jqbtn = $(&quot;button&quot;); jqbtn.click(function () &#123; //是绑定到jquery的衣服上，而不是标签上。所以没达到效果// jqinp.title = 111;// console.log(jqinp.title); //绑定到标签上 jqinp.attr(&quot;title&quot;, 111); console.log(jqinp.attr(&quot;title&quot;)); jqinp.attr(&quot;aaa&quot;, 111); console.log(jqinp.attr(&quot;aaa&quot;)); //两个参数是给属性赋值，单个参数是获取属性值。 jqinp.attr(&quot;class&quot;, &quot;aaa&quot;); console.log(jqinp.attr(&quot;class&quot;)); jqinp.removeAttr(&quot;class&quot;); console.log(jqinp.attr(&quot;class&quot;)); //form中的特殊属性，用prop jqinp2.prop(&quot;checked&quot;, true);// jqinp2.attr(&quot;checked&quot;,true);//一次性的。鼠标多点击几次，就失效了。 &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;绑定&lt;/button&gt;&lt;input type=&quot;text&quot;/&gt;&lt;input type=&quot;checkbox&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 效果： 案例：表格案例全选反选 完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .wrap &#123; width: 300px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff; &#125; td &#123; font: 14px &quot;微软雅黑&quot;; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求1：点击上面的多选按钮，下面的所有多选按钮都和上面的一致 //需求2：点击下面的多选按钮，判断下面的所有多选按钮都是否全部被选定只有全部被选定上面的才被选定 //需求1：点击上面的多选按钮，下面的所有多选按钮都和上面的一致 //步骤：绑定事件，直接让下面的所有按钮和上面的按钮属性值一模一样 $(&quot;#j_cbAll&quot;).click(function () &#123; //直接让下面的所有按钮和上面的按钮属性值一模一样 $(&quot;#j_tb input:checkbox&quot;).prop(&quot;checked&quot;, $(this).prop(&quot;checked&quot;)); &#125;); //需求2：点击下面的多选按钮，判断下面的所有多选按钮都是否全部被选定只有全部被选定上面的才被选定 //需求2：点击下面的多选按钮，判断下面的所有多选按钮都是否全部被选定只有全部被选定上面的才被选定 $(&quot;#j_tb input:checkbox&quot;).click(function () &#123; //判断，只有所有都背选定，上面的才被选定 //技术点：带有checked属性的标签和checkbox个数一样多的时候 if ($(&quot;#j_tb input:checkbox&quot;).length === $(&quot;#j_tb input:checked&quot;).length) &#123; //只有所有的都有checked属性，上面的才被选定 $(&quot;#j_cbAll&quot;).prop(&quot;checked&quot;, true); &#125; else &#123; $(&quot;#j_cbAll&quot;).prop(&quot;checked&quot;, false); &#125; &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;j_cbAll&quot;/&gt; &lt;/th&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;所属团队&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;j_tb&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;JavaScript&lt;/td&gt; &lt;td&gt;千古壹号&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;css&lt;/td&gt; &lt;td&gt;千古壹号&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;html&lt;/td&gt; &lt;td&gt;千古壹号&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot;/&gt; &lt;/td&gt; &lt;td&gt;jQuery&lt;/td&gt; &lt;td&gt;千古壹号&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; val()方法和 text()方法1$(selector).val(); 作用：设置或返回 form 表单元素的value值，例如：input、select、textarea 的值。 1$(selector).text(); 作用：设置或获取匹配元素的文本内容。不带参数表示，会把所有匹配到的元素内容拼接为一个字符串，不同于其他获取操作。 1$(selector).text(&quot;我是内容&quot;); 作用：设置的内容包含html标签，那么text()方法会把他们当作纯文本内容输出。 总结： text() 不识别标签。 html() 识别标签。 举例： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(document).ready(function () &#123; //val(); 获取标签中的value属性的值。带有参数是赋值(类比js中的value属性) console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;我是value()赋值的input内容&quot;); console.log($(&quot;input&quot;).val()); console.log(&quot;-----------------&quot;); //text(); 获取双闭合标签中的文本值。（不识别标签）(类比js中的innerText) console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;&lt;li&gt;我是text()赋值的&lt;/li&gt;&quot;) console.log($(&quot;div&quot;).text()); console.log(&quot;-----------------&quot;); //html(); 获取双闭合标签中的文本值。（识别标签）(类比js中的innerHTML) console.log($(&quot;div&quot;).html()); $(&quot;div&quot;).html(&quot;&lt;li&gt;我是html()赋值的&lt;/li&gt;&quot;); console.log($(&quot;div&quot;).html()); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; value=&quot;我是input中已存在的 value内容&quot;/&gt;&lt;div&gt; &lt;li&gt;你好&lt;/li&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 打印结果：","categories":[],"tags":[]},{"title":"","slug":"大前端/06-jQuery/02-jQuery动画详解","date":"2021-08-06T01:17:25.830Z","updated":"2021-07-28T07:34:11.355Z","comments":true,"path":"2021/08/06/大前端/06-jQuery/02-jQuery动画详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/06-jQuery/02-jQuery%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言jQuery提供的一组网页中常见的动画效果，这些动画是标准的、有规律的效果；同时还提供给我们了自定义动画的功能。 显示动画方式一： 1$(&quot;div&quot;).show(); 解释：无参数，表示让指定的元素直接显示出来。其实这个方法的底层就是通过display: block;实现的。 方式二： 1$(&quot;div&quot;).show(2000); 解释：通过控制元素的宽高、透明度、display属性，逐渐显示，2秒后显示完毕。 效果如下： 方式三： 1$(&quot;div&quot;).show(&quot;slow&quot;); 参数可以是： slow 慢：600ms normal 正常：400ms fast 快：200ms 解释：和方式二类似，也是通过控制元素的宽高、透明度、display属性，逐渐显示。 方式四： 1234//show(毫秒值，回调函数;$(&quot;div&quot;).show(5000,function () &#123; alert(&quot;动画执行完毕！&quot;);&#125;); 解释：动画执行完后，立即执行回调函数。 总结： 上面的四种方式几乎一致：参数可以有两个，第一个是动画的执行时长，第二个是动画结束后执行的回调函数。 隐藏动画方式参照上面的show()方法的方式。如下： 1234567$(selector).hide();$(selector).hide(1000);$(selector).hide(&quot;slow&quot;);$(selector).hide(1000, function()&#123;&#125;); 显示和隐藏的来回切换： 显示和隐藏的来回切换采用的是toggle()方法：就是先执行show()，再执行hide()。 同样是四种方式： 12$(selector).toggle(); 滑入和滑出1、滑入动画效果：（类似于生活中的卷帘门） 1$(selector).slideDown(speed, 回调函数); 解释：下拉动画，显示元素。 注意：省略参数或者传入不合法的字符串，那么则使用默认值：400毫秒（同样适用于fadeIn/slideDown/slideUp） 2 滑出动画效果： 1$(selector).slideUp(speed, 回调函数); 解释：上拉动画，隐藏元素。 3、滑入滑出切换动画效果： 1$(selector).slideToggle(speed, 回调函数); 参数解释同show()方法。 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 300px; height: 300px; display: none; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //点击按钮后产生动画 $(&quot;button:eq(0)&quot;).click(function () &#123; //滑入动画： slideDown(毫秒值，回调函数[显示完毕执行什么]); $(&quot;div&quot;).slideDown(2000, function () &#123; alert(&quot;动画执行完毕！&quot;); &#125;); &#125;) //滑出动画 $(&quot;button:eq(1)&quot;).click(function () &#123; //滑出动画：slideUp(毫秒值，回调函数[显示完毕后执行什么]); $(&quot;div&quot;).slideUp(2000, function () &#123; alert(&quot;动画执行完毕！&quot;); &#125;); &#125;) $(&quot;button:eq(2)&quot;).click(function () &#123; //滑入滑出切换（同样有四种用法） $(&quot;div&quot;).slideToggle(1000); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;滑入&lt;/button&gt;&lt;button&gt;滑出&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 淡入淡出动画1、淡入动画效果： 1$(selector).fadeIn(speed, callback); 作用：让元素以淡淡的进入视线的方式展示出来。 2、淡出动画效果： 1$(selector).fadeOut(1000); 作用：让元素以渐渐消失的方式隐藏起来 3、淡入淡出切换动画效果： 1$(selector).fadeToggle(&#x27;fast&#x27;, callback); 作用：通过改变透明度，切换匹配元素的显示或隐藏状态。 参数的含义同show()方法。 代码举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 300px; height: 300px; display: none; /*opacity: 1;*/ background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //点击按钮后产生动画 $(&quot;button:eq(0)&quot;).click(function () &#123;// //淡入动画用法1: fadeIn(); 不加参数 $(&quot;div&quot;).fadeIn();// //淡入动画用法2: fadeIn(2000); 毫秒值// $(&quot;div&quot;).fadeIn(2000);// //通过控制 透明度和display //淡入动画用法3: fadeIn(字符串); slow慢：600ms normal正常:400ms fast快：200ms// $(&quot;div&quot;).fadeIn(&quot;slow&quot;);// $(&quot;div&quot;).fadeIn(&quot;fast&quot;);// $(&quot;div&quot;).fadeIn(&quot;normal&quot;); //淡入动画用法4: fadeIn(毫秒值，回调函数[显示完毕执行什么]);// $(&quot;div&quot;).fadeIn(5000,function () &#123;// alert(&quot;动画执行完毕！&quot;);// &#125;); &#125;) //滑出动画 $(&quot;button:eq(1)&quot;).click(function () &#123;// //滑出动画用法1: fadeOut(); 不加参数// $(&quot;div&quot;).fadeOut();// //滑出动画用法2: fadeOut(2000); 毫秒值// $(&quot;div&quot;).fadeOut(2000); //通过这个方法实现的：display: none;// //通过控制 透明度和display //滑出动画用法3: fadeOut(字符串); slow慢：600ms normal正常:400ms fast快：200ms// $(&quot;div&quot;).fadeOut(&quot;slow&quot;);// $(&quot;div&quot;).fadeOut(&quot;fast&quot;);// $(&quot;div&quot;).fadeOut(&quot;normal&quot;); //滑出动画用法1: fadeOut(毫秒值，回调函数[显示完毕执行什么]);// $(&quot;div&quot;).fadeOut(2000,function () &#123;// alert(&quot;动画执行完毕！&quot;);// &#125;); &#125;) $(&quot;button:eq(2)&quot;).click(function () &#123; //滑入滑出切换 //同样有四种用法 $(&quot;div&quot;).fadeToggle(1000); &#125;) $(&quot;button:eq(3)&quot;).click(function () &#123; //改透明度 //同样有四种用法 $(&quot;div&quot;).fadeTo(1000, 0.5, function () &#123; alert(1); &#125;); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;淡入&lt;/button&gt;&lt;button&gt;淡出&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;button&gt;改透明度为0.5&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 自定义动画1$(selector).animate(&#123;params&#125;, speed, callback); 作用：执行一组CSS属性的自定义动画。 第一个参数表示：要执行动画的CSS属性（必选） 第二个参数表示：执行动画时长（可选） 第三个参数表示：动画执行完后，立即执行的回调函数（可选） 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; position: absolute; left: 20px; top: 30px; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; $(&quot;button&quot;).click(function () &#123; var json = &#123;&quot;width&quot;: 500, &quot;height&quot;: 500, &quot;left&quot;: 300, &quot;top&quot;: 300, &quot;border-radius&quot;: 100&#125;; var json2 = &#123; &quot;width&quot;: 100, &quot;height&quot;: 100, &quot;left&quot;: 100, &quot;top&quot;: 100, &quot;border-radius&quot;: 100, &quot;background-color&quot;: &quot;red&quot; &#125;; //自定义动画 $(&quot;div&quot;).animate(json, 1000, function () &#123; $(&quot;div&quot;).animate(json2, 1000, function () &#123; alert(&quot;动画执行完毕！&quot;); &#125;); &#125;); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;自定义动画&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 停止动画1$(selector).stop(true, false); 里面的两个参数，有不同的含义。 第一个参数： true：后续动画不执行。 false：后续动画会执行。 第二个参数： true：立即执行完成当前动画。 false：立即停止当前动画。 PS：参数如果都不写，默认两个都是false。实际工作中，直接写stop()用的多。 效果演示： 当第二个参数为true时，效果如下： 当第二个参数为false时，效果如下： 这个后续动画我们要好好理解，来看个例子。 案例：鼠标悬停时，弹出下拉菜单（下拉时带动画） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-color: pink; &#125; .wrap li &#123; background-color: green; &#125; .wrap &gt; ul &gt; li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function () &#123; //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。 var jqli = $(&quot;.wrap&gt;ul&gt;li&quot;); //绑定事件 jqli.mouseenter(function () &#123; $(this).children(&quot;ul&quot;).stop().slideDown(1000); &#125;); //绑定事件(移开隐藏) jqli.mouseleave(function () &#123; $(this).children(&quot;ul&quot;).stop().slideUp(1000); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上方代码中，关键的地方在于，用了stop函数，再执行动画前，先停掉之前的动画。 如果去掉stop()函数，效果如下：（不是我们期望的效果） stop方法的总结当调用stop()方法后，队列里面的下一个动画将会立即开始。但是，如果参数clearQueue被设置为true，那么队列面剩余的动画就被删除了，并且永远也不会执行。 如果参数jumpToEnd被设置为true，那么当前动画会停止，但是参与动画的每一个CSS属性将被立即设置为它们的目标值。比如：slideUp()方法，那么元素会立即隐藏掉。如果存在回调函数，那么回调函数也会立即执行。 注意：如果元素动画还没有执行完，此时调用stop()方法，那么动画将会停止。并且动画没有执行完成，那么回调函数也不会被执行。 举例：右下角的弹出广告代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .ad &#123; position: fixed; right: 0; bottom: 0; width: 230px; height: 120px; background-image: url(images/ad.jpg); display: none; &#125; .ad span &#123; position: absolute; right: 0; top: 0; width: 40px; height: 18px; background-image: url(images/h.jpg); cursor: pointer; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：然广告ad部分，先滑入，在滑出，在淡入。然后绑定事件，点击span弹出 //步骤： $(&quot;.ad&quot;).slideDown(1000).slideUp(1000).fadeIn(1000).children(&quot;span&quot;).click(function () &#123; $(this).parent().fadeOut(1000); &#125;); //第二种写法// $(&quot;.ad&quot;).slideDown(1000, function () &#123;// $(&quot;.ad&quot;).slideUp(1000, function () &#123;// $(&quot;.ad&quot;).fadeIn(1000, function () &#123;// $(&quot;.ad&quot;).children(&quot;span&quot;).click(function () &#123;// $(this).parent().fadeOut(1000, function () &#123;// alert(&quot;执行完毕！&quot;);// &#125;);// &#125;);// &#125;);// &#125;);// &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;ani&quot;&gt;我是内容&lt;/div&gt;&lt;div class=&quot;ad&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/06-jQuery/01-jQuery的介绍和选择器","date":"2021-08-06T01:17:25.827Z","updated":"2021-07-28T07:34:11.355Z","comments":true,"path":"2021/08/06/大前端/06-jQuery/01-jQuery的介绍和选择器/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/06-jQuery/01-jQuery%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 jQuery 的介绍引入 jQuery 的原因在用 js 写代码时，会遇到一些问题： window.onload 事件有事件覆盖的问题，因此只能写一个事件。 代码容错性差。 浏览器兼容性问题。 书写很繁琐，代码量多。 代码很乱，各个页面到处都是。 动画效果很难实现。 如下图所示： jQuery的出现，可以解决以上问题。 什么是 jQueryjQuery 是 js 的一个库，封装了我们开发过程中常用的一些功能，方便我们调用，提高开发效率。 js库是把我们常用的功能放到一个单独的文件中，我们用的时候，直接引用到页面里即可。 以下是jQuery的相关信息： 官网：http://jquery.com/ 官网API文档：http://api.jquery.com/ 中文汉化API文档：http://www.css88.com/jqapi-1.9/ 学习jQuery，主要是学什么初期，主要学习如何使用jQuery操作DOM，其实就是学习jQuery封装好的那些API。 这些API的共同特点是：几乎全都是方法。所以，在使用jQuery的API时，都是方法调用，也就是说要加小括号()，小括号里面是相应的参数，参数不同，功能不同。 jQuery初体验现在用原生 js 来写下面这一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; background-color: pink; margin: 10px; display: none; &#125; &lt;/style&gt; &lt;script&gt; //原生js window.onload = function () &#123; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var divArr = document.getElementsByTagName(&quot;div&quot;); btn.onclick = function () &#123; for (var i = 0; i &lt; divArr.length; i++) &#123; divArr[i].style.display = &quot;block&quot;; divArr[i].innerHTML = &quot;生命壹号&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示五个div盒子和设置内容&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果用 jQuery 来写，保持其他的代码不变，&lt;script&gt;部分的代码修改为：（需要提前引入 ） 123456789101112131415161718&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //jquery版 $(document).ready(function () &#123; //获取元素 var jQbtn = $(&quot;button&quot;);//根据标签名获取元素 var jQdiv = $(&quot;div&quot;);//根据标签名获取元素 //绑定事件 jQbtn.click(function () &#123; jQdiv.show(1000);//显示盒子。 jQdiv.html(&quot;tomorrow！&quot;);//设置内容 //上面的两行可以写成链式编程：jQdiv.show(3000).html(1111); &#125;);//事件是通过方法绑定的。 &#125;);&lt;/script&gt; jQuery 的两大特点（1）链式编程：比如.show()和.html()可以连写成.show().html()。 链式编程原理：return this。 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。 （2）隐式迭代：隐式 对应的是 显式。隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。 jQuery 的使用使用 jQuery 的基本步骤（1）引包 （2）入口函数 （3）功能实现代码（事件处理） 如下图所示： 主要，导包的代码一定要放在js代码的最上面。 jQuery 的版本jQuery 有两个大版本： 1.x版本：最新版为 v1.11.3。 2.x版本：最新版为 v2.1.4（不再支持IE6、7、8）。 3.x版本。 PS：开发版本一般用1.10以上。 我们以 v1.11.1版本为例，下载下来后发现，里面有两个文件： 它们的区别是： 第一个是未压缩版，第二个是压缩版。 平时开发过程中，可以使用任意一个版本；但是，项目上线的时候，推荐使用压缩版。 jQuery 的入口函数和 $ 符号入口函数（重要）原生 js 的入口函数指的是：window.onload = function() &#123;&#125;; 如下： 12345 //原生 js 的入口函数。页面上所有内容加载完毕，才执行。 //不仅要等文本加载完毕，而且要等图片也要加载完毕，才执行函数。window.onload = function () &#123; alert(1);&#125; 而 jQuery的入口函数，有以下几种写法： 写法一： 1234//1.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(document).ready(function () &#123; alert(1);&#125;) 写法二：（写法一的简洁版） 1234//2.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(function () &#123; alert(1);&#125;); 写法三： 1234//3.文档加载完毕，图片也加载完毕的时候，在执行这个函数。$(window).ready(function () &#123; alert(1);&#125;) jQuery入口函数与js入口函数的区别： 区别一：书写个数不同： Js 的入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery 的入口函数，可以出现任意多次，并不存在事件覆盖问题。 区别二：执行时机不同： Js的入口函数是在所有的文件资源加载完成后，才执行。这些文件资源包括：页面文档、外部的js文件、外部的css文件、图片等。 jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 文档加载的顺序：从上往下，边解析边执行。 jQuery的$符号jQuery 使用 $ 符号原因：书写简洁、相对于其他字符与众不同、容易被记住。 jQuery占用了我们两个变量：$ 和 jQuery。当我们在代码中打印它们俩的时候： 123456789&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log($); console.log(jQuery); console.log($===jQuery);&lt;/script&gt; 打印结果如下： 从打印结果可以看出，$ 代表的就是 jQuery。 那怎么理解jQuery里面的 $ 符号呢？ $ 实际上表示的是一个函数名 如下： 12345678910$(); // 调用上面我们自定义的函数$$(document）.ready(function()&#123;&#125;); // 调用入口函数$(function()&#123;&#125;); // 调用入口函数$(“#btnShow”) // 获取id属性为btnShow的元素$(“div”) // 获取所有的div标签元素 如上方所示，jQuery 里面的 $ 函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象。 jQuery这个js库，除了 $ 之外，还提供了另外一个函数：jQuery。jQuery函数跟 $ 函数的关系：jQuery === $。 js中的DOM对象 和 jQuery对象 比较（重点，难点）二者的区别通过 jQuery 获取的元素是一个数组，数组中包含着原生JS中的DOM对象。举例： 针对下面这样一个div结构： 12345&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 通过原生 js 获取这些元素节点的方式是： 123var myBox = document.getElementById(&quot;box&quot;); //通过 id 获取单个元素var boxArr = document.getElementsByClassName(&quot;box&quot;); //通过 class 获取的是数组var divArr = document.getElementsByTagName(&quot;div&quot;); //通过标签获取的是数组 通过 jQuery 获取这些元素节点的方式是：（获取的都是数组） 1234//获取的是数组，里面包含着原生 JS 中的DOM对象。var jqBox1 = $(&quot;#box&quot;);var jqBox2 = $(&quot;.box&quot;);var jqBox3 = $(&quot;div&quot;); 我们打印出来看看： 上图显示，由于JQuery 自带了 css()方法，我们还可以直接在代码中给 div 设置 css 属性。 总结：jQuery 就是把 DOM 对象重新包装了一下，让其具有了 jQuery 方法。 二者的相互转换1、 DOM 对象 转为 jQuery对象： 1$(js对象); 举例：（拿上一段的代码举例） 1234//转换。jqBox1 = $(myBox);jqBox2 = $(boxArr);jqBox3 = $(divArr); DOM 对象转换成了 jquery 对象之后，上面的功能可以直接调用。 2、jQuery对象 转为 DOM 对象： 123jquery对象[index]; //方式1（推荐）jquery对象.get(index); //方式2 jQuery对象转换成了 DOM 对象之后，可以直接调用 DOM 提供的一些功能。如： 123//jquery对象转换成 DOM 对象之后jqBox3[0].style.backgroundColor = &quot;black&quot;;jqBox3.get(4).style.backgroundColor = &quot;pink&quot;; 总结：如果想要用哪种方式设置属性或方法，必须转换成该类型。 举例：隔行变色代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(function () &#123; var jqLi = $(&quot;li&quot;); for (var i = 0; i &lt; jqLi.length; i++) &#123; if (i % 2 === 0) &#123; //jquery对象，转换成了js对象 jqLi[i].style.backgroundColor = &quot;pink&quot;; &#125; else &#123; jqLi[i].style.backgroundColor = &quot;yellow&quot;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： jQuery 选择器我们以前在CSS中学习的选择器有： 今天来学习一下jQuery 选择器。 jQuery选择器是jQuery强大的体现，它提供了一组方法，让我们更加方便的获取到页面中的元素。 1、jQuery 的基本选择器 解释如下： 举例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(document).ready(function () &#123; //三种方式获取jquery对象 var jqBox1 = $(&quot;#box&quot;); var jqBox2 = $(&quot;.box&quot;); var jqBox3 = $(&quot;div&quot;); //操作标签选择器 jqBox3.css(&quot;width&quot;, 100); jqBox3.css(&quot;height&quot;, 100); jqBox3.css(&quot;margin&quot;, 10); jqBox3.css(&quot;background&quot;, &quot;pink&quot;); //操作类选择器(隐式迭代，不用一个一个设置) jqBox2.css(&quot;background&quot;, &quot;red&quot;); //操作id选择器 jqBox1.css(&quot;background&quot;, &quot;yellow&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 2、层级选择器 解释如下： 举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //获取ul中的li设置为粉色 //后代：儿孙重孙曾孙玄孙.... var jqLi = $(&quot;ul li&quot;); jqLi.css(&quot;margin&quot;, 5); jqLi.css(&quot;background&quot;, &quot;pink&quot;); //子代：亲儿子 var jqOtherLi = $(&quot;ul&gt;li&quot;); jqOtherLi.css(&quot;background&quot;, &quot;red&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;ol&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 3、基本过滤选择器 解释： 举例： 1234567891011121314151617181920212223242526&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function () &#123; // :odd $(&quot;li:odd&quot;).css(&quot;background&quot;, &quot;red&quot;); // :even $(&quot;li:even&quot;).css(&quot;background&quot;, &quot;green&quot;); // :eq(index) $(&quot;ul li:eq(3)&quot;).css(&quot;font-size&quot;, &quot;30px&quot;); //设置第四个li的字体 // :lt(index) $(&quot;li:lt(6)&quot;).css(&quot;font-size&quot;, &quot;30px&quot;); // :gt(index) $(&quot;.ulList1 li:gt(7)&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); // :first $(&quot;.ulList li:first&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); // :last $(&quot;li:last&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); &#125;);&lt;/script&gt; 4、属性选择器 5、筛选选择器 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; var jqul = $(&quot;ul&quot;); //find(selector); 从jquery对象的后代中查找 //必须制定参数，如果不指定获取不到元素。length === 0 jqul.find(&quot;li&quot;).css(&quot;background&quot;, &quot;pink&quot;); console.log(jqul.find()); //chidlren(selector); 从jquery对象的子代中查找 //不写参数代表获取所有子元素。 jqul.children(&quot;li&quot;).css(&quot;background&quot;, &quot;green&quot;); //eq(索引值); 从jquery对象的子代中查找该索引值的元素 //要写该数组中的第几个。 jqul.children().eq(0).css(&quot;background&quot;, &quot;red&quot;); //next(); 该元素的下一个兄弟元素 jqul.children().eq(0).next().css(&quot;background&quot;, &quot;yellow&quot;); //siblings(selector); 该元素的所有兄弟元素 jqul.children().eq(0).next().siblings().css(&quot;border&quot;, &quot;1px solid blue&quot;); //parent(); 该元素的父元素（和定位没有关系） console.log(jqul.children().eq(0).parent()); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li class=&quot;box&quot;&gt;生命壹号，永不止步&lt;/li&gt; &lt;span&gt;生命壹号，永不止步&lt;/span&gt; &lt;li class=&quot;box&quot;&gt;生命壹号，永不止步&lt;/li&gt; &lt;i&gt;生命壹号，永不止步&lt;/i&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;a id=&quot;box&quot; href=&quot;#&quot;&gt;生命壹号，永不止步&lt;/a&gt; &lt;ol&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 举例举例1：鼠标悬停时，弹出下拉菜单【重要】完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-color: pink; &#125; .wrap li &#123; background-color: yellowgreen; &#125; .wrap &gt; ul &gt; li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function () &#123; //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。 var jqli = $(&quot;.wrap&gt;ul&gt;li&quot;); //绑定事件 jqli.mouseenter(function () &#123; //这个位置用到了this. // console.log(this); //打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】 //让this中的ul显示出来。// 原生 js 的做法是：this.children[1].style.display = &quot;block&quot;; //把js的dom对象包装为jquery对象，然后用jquery方法操作 $(this).children(&quot;ul&quot;).show(); &#125;); //绑定事件：鼠标移开时，隐藏下拉菜单 jqli.mouseleave(function () &#123; $(this).children(&quot;ul&quot;).hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们可以看到，用 jQuery来操作，是非常方便的。 实现效果如下： this的用法： 上方代码中，核心的一行代码是： 123$(this).children(&quot;ul&quot;).show();$(this).children(&quot;ul&quot;).hide(); 如果我把这行代码中的this直接写成 DOM对象： 123jqli.children(&quot;ul&quot;).show();jqli.children(&quot;ul&quot;).hide(); 产生的结果是：（不是我们期望的结果） 两张图的对比，可以看出this的作用：谁正在调用函数，this就指的是谁。 举例2：鼠标悬停时变色完整版代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求；隔行变色；鼠标悬停时，还要变色。 var jqli1 = $(&quot;li:odd&quot;); var jqli2 = $(&quot;li:even&quot;); jqli1.css(&quot;background&quot;, &quot;#cccccc&quot;); jqli2.css(&quot;background&quot;, &quot;white&quot;); //鼠标悬停时变色 var color = &quot;&quot;; $(&quot;li&quot;).mouseenter(function () &#123; color = $(this).css(&quot;background&quot;); //先把之前的颜色保存下来，鼠标离开时还原 $(this).css(&quot;background&quot;, &quot;green&quot;); &#125;); //鼠标离开时，恢复为原来的颜色 $(&quot;li&quot;).mouseleave(function () &#123; $(this).css(&quot;background&quot;, color); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例3：突出显示要求：鼠标悬停时，突出显示这个li，让其他的li都半透明。 用 jQuery的选择起来实现，会发现非常方便。 完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; body &#123; background: #000; &#125; .wrap &#123; margin: 100px auto 0; width: 630px; height: 394px; padding: 10px 0 0 10px; background: #000; overflow: hidden; border: 1px solid #fff; &#125; .wrap li &#123; float: left; margin: 0 10px 10px 0; &#125; .wrap img &#123; display: block; border: 0; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(window).ready(function () &#123; //需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1 $(&quot;.wrap&quot;).find(&quot;li&quot;).mouseenter(function () &#123; //链式编程 $(this).css(&quot;opacity&quot;, 1).siblings(&quot;li&quot;).css(&quot;opacity&quot;, 0.4); &#125;); //离开wrap的时候所有的li的全部opacity值为1； $(&quot;.wrap&quot;).mouseleave(function () &#123; $(this).children().children(&quot;li&quot;).css(&quot;opacity&quot;, 1);// $(&quot;.wrap li&quot;).css(&quot;opacity&quot;,1); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/06.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 注意这里的css布局里，每一个图片都用一个li来存放。设置li的父亲的宽度之后，然后将li设置为浮动，即可自适应地排列成两排。 工程文件： 2018-02-05-突出显示.rar 举例4：手风琴效果完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123;padding: 0;margin: 0;&#125; ul &#123; list-style-type: none;&#125; .parentWrap &#123; width: 200px; text-align:center; &#125; .menuGroup &#123; border:1px solid #999; background-color:#e0ecff; &#125; .groupTitle &#123; display:block; height:20px; line-height:20px; font-size: 16px; border-bottom:1px solid #ccc; cursor:pointer; &#125; .menuGroup &gt; div &#123; height: 200px; background-color:#fff; display:none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。 $(&quot;.parentWrap span&quot;).click(function () &#123;// $(this).next().show();// //让其他的隐藏// //点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。// $(this).parent(&quot;li&quot;).siblings(&quot;li&quot;).children(&quot;div&quot;).hide(); //连式编程 $(this).next().show().parent(&quot;li&quot;).siblings(&quot;li&quot;).find(&quot;div&quot;).hide(); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;parentWrap&quot;&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题1&lt;/span&gt; &lt;div&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题2&lt;/span&gt; &lt;div&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题3&lt;/span&gt; &lt;div&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题4&lt;/span&gt; &lt;div&gt;我是弹出来的div4&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 注意这里的 选择器的用法：parent、next 举例5：淘宝精品服饰广告完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; font-size: 12px; &#125; ul &#123; list-style: none; &#125; a &#123; text-decoration: none; &#125; .wrapper &#123; width: 298px; height: 248px; margin: 100px auto 0; border: 1px solid pink; overflow: hidden; &#125; #left, #center, #right &#123; float: left; &#125; #left li, #right li &#123; background: url(images/lili.jpg) repeat-x; &#125; #left li a, #right li a &#123; display: block; width: 48px; height: 27px; border-bottom: 1px solid pink; line-height: 27px; text-align: center; color: black; &#125; #left li a:hover, #right li a:hover &#123; background-image: url(images/abg.gif); &#125; #center &#123; border-left: 1px solid pink; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; //需求：鼠标放入两侧的li中，让中间的ul中对应索引值的li显示出来，其他的隐藏。（右侧的li要+9） //左侧先绑。获取绑mouseenter $(&quot;#left li&quot;).mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(&quot;#center li&quot;).eq($(this).index()).show().siblings(&quot;li&quot;).hide(); &#125;); //右侧 $(&quot;#right li&quot;).mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(&quot;#center li:eq(&quot; + ($(this).index() + 9) + &quot;)&quot;).show().siblings(&quot;li&quot;).hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;ul id=&quot;left&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;雪地靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;冬裙&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;呢大衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;羽绒服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;center&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/雪地靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/冬裙.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/呢大衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/羽绒服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/牛仔裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/登山鞋.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮带.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/围巾.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登山鞋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮带&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;围巾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男靴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果： 工程文件： 2018-02-05-淘宝精品服饰广告.rar 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：JavaScript特效/04-JS的小知识","date":"2021-08-06T01:17:25.823Z","updated":"2021-07-28T07:34:11.354Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：JavaScript特效/04-JS的小知识/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9AJavaScript%E7%89%B9%E6%95%88/04-JS%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"方法的注释方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 比如： 123456789/** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getFirstNode(ele)&#123; var node = ele.firstElementChild || ele.firstChild; return node;&#125; 断点调试（1）先让程序运行一遍。 （2）f12，弹出代码调试工具 （3）打断点： 然后刷新页面。 （4）一步步调试，每点击一次，执行一步： （5）监视变量： 当然，也可以添加变量或者表达式到监视窗口。操作如下： 上图中，选择变量或表达式，然后右键add to watch. 然后监视窗口：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：JavaScript特效/03-client家族(可视区)","date":"2021-08-06T01:17:25.821Z","updated":"2021-07-28T07:34:11.354Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：JavaScript特效/03-client家族(可视区)/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9AJavaScript%E7%89%B9%E6%95%88/03-client%E5%AE%B6%E6%97%8F(%E5%8F%AF%E8%A7%86%E5%8C%BA)/","excerpt":"","text":"client 家族的组成clientWidth 和 clientHeight盒子调用时： clientWidth：获取盒子区域宽度（padding + width）。 clientHeight：获取盒子区域高度（padding + height）。 body/html调用时： clientWidth：获取网页可视区域宽度。 clientHeight：获取网页可视区域高度。 clientX 和 clientYevent调用： clientX：鼠标距离可视区域左侧距离。 clientY：鼠标距离可视区域上侧距离。 clientTop 和 clientLeft clientTop：盒子的上border。 clientLeft：盒子的左border。 三大家族 offset/scroll/client 的区别区别1：宽高 offsetWidth = width + padding + border offsetHeight = height + padding + border scrollWidth = 内容宽度（不包含border） scrollHeight = 内容高度（不包含border） clientWidth = width + padding clientHeight = height + padding 区别2：上左offsetTop/offsetLeft： 调用者：任意元素。(盒子为主) 作用：距离父系盒子中带有定位的距离。 scrollTop/scrollLeft： 调用者：document.body.scrollTop（window调用）(盒子也可以调用，但必须有滚动条) 作用：浏览器无法显示的部分（被卷去的部分）。 clientY/clientX： 调用者：event 作用：鼠标距离浏览器可视区域的距离（左、上）。 函数封装：获取浏览器的宽高（可视区域）函数封装如下： 1234567891011121314151617181920212223//函数封装：获取屏幕可视区域的宽高function client() &#123; if (window.innerHeight !== undefined) &#123; //ie9及其以上的版本的写法 return &#123; &quot;width&quot;: window.innerWidth, &quot;height&quot;: window.innerHeight &#125; &#125; else if (document.compatMode === &quot;CSS1Compat&quot;) &#123; //标准模式的写法（有DTD时） return &#123; &quot;width&quot;: document.documentElement.clientWidth, &quot;height&quot;: document.documentElement.clientHeight &#125; &#125; else &#123; //没有DTD时的写法 return &#123; &quot;width&quot;: document.body.clientWidth, &quot;height&quot;: document.body.clientHeight &#125; &#125;&#125; 案例：根据浏览器的可视宽度，给定不同的背景的色。 PS：这个可以用来做响应式。 代码如下：（需要用到上面的封装好的方法） 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;tools.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //需求：浏览器每次更改大小，判断是否符合某一标准然后给背景上色。 // // &gt;960红色，大于640小于960蓝色，小于640绿色。 window.onresize = fn; //页面大小发生变化时，执行该函数。 //页面加载的时候直接执行一次函数，确定浏览器可视区域的宽，给背景上色 fn(); //封装成函数，然后指定的时候去调用和绑定函数名 function fn() &#123; if (client().width &gt; 960) &#123; document.body.style.backgroundColor = &quot;red&quot;; &#125; else if (client().width &gt; 640) &#123; document.body.style.backgroundColor = &quot;blue&quot;; &#125; else &#123; document.body.style.backgroundColor = &quot;green&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上当代码中，window.onresize事件指的是：在窗口或框架被调整大小时发生。各个事件的解释如下： window.onscroll 屏幕滑动 window.onresize 浏览器大小变化 window.onload 页面加载完毕 div.onmousemove 鼠标在盒子上移动（注意：不是盒子移动） 获取显示器的分辨率比如，我的电脑的显示器分辨率是：1920*1080。 获取显示器的分辨率： 123window.onresize = function () &#123; document.title = window.screen.width + &quot; &quot; + window.screen.height;&#125; 显示效果： 上图中，不管我如何改变浏览器的窗口大小，title栏显示的值永远都是我的显示器分辨率：1920*1080。","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：JavaScript特效/02-scroll家族和缓动动画","date":"2021-08-06T01:17:25.819Z","updated":"2021-07-28T07:34:11.354Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：JavaScript特效/02-scroll家族和缓动动画/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9AJavaScript%E7%89%B9%E6%95%88/02-scroll%E5%AE%B6%E6%97%8F%E5%92%8C%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/","excerpt":"","text":"缓动动画三个函数缓慢动画里，我们要用到三个函数，这里先列出来： Math.ceil() 向上取整 Math.floor() 向下取整 Math.round(); 四舍五入 缓动动画的原理缓动动画的原理就是：在移动的过程中，步长越来越小。 设置步长为：目标位置和盒子当前位置的十分之一。用公式表达，即： 1盒子位置 = 盒子本身位置 + (目标位置 - 盒子本身位置)/ 10； 代码举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到left = 400px&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var div = document.getElementsByTagName(&quot;div&quot;)[0]; btn.onclick = function () &#123; setInterval(function () &#123; //动画原理：盒子未来的位置 = 盒子当前的位置+步长 div.style.left = div.offsetLeft + (400 - div.offsetLeft) / 10 + &quot;px&quot;; &#125;, 30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 缓慢动画的封装（解决四舍五入的问题）我们发现一个问题，上图中的盒子最终并没有到达400px的位置，而是只到了396.04px就停住了： 原因是：JS在取整的运算时，进行了四舍五入。 我们把打印396.04px这个left值打印出来看看： 我么发现，通过div.style.left获取的值是精确的，通过div.offsetLeft获取的left值会进行四舍五入。 此时，我们就要用到取整的函数了。 通过对缓动动画进行封装，完整版的代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到200&lt;/button&gt;&lt;button&gt;运动到400&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(&quot;button&quot;); var div = document.getElementsByTagName(&quot;div&quot;)[0]; btn[0].onclick = function () &#123; animate(div, 200); &#125; btn[1].onclick = function () &#123; animate(div, 400); &#125; //缓动动画封装 function animate(ele, target) &#123; //要用定时器，先清定时器 //一个萝卜一个坑儿，一个元素对应一个定时器 clearInterval(ele.timer); //定义定时器 ele.timer = setInterval(function () &#123; //获取步长 //步长应该是越来越小的，缓动的算法。 var step = (target - ele.offsetLeft) / 10; //对步长进行二次加工(大于0向上取整,小于0向下取整) //达到的效果是：最后10像素的时候都是1像素1像素的向目标位置移动，就能够到达指定位置。 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + &quot;px&quot;; console.log(step); //检测缓动动画有没有停止 console.log(&quot;smyhvae&quot;); if (Math.abs(target - ele.offsetLeft) &lt;= Math.abs(step)) &#123; //处理小数赋值 ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); &#125; &#125;, 30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： scroll 家族的组成当我们用鼠标滚轮，滚动网页的时候，会触发window.onscroll()方法。效果如下：（注意看控制台的打印结果） 1、ScrollWidth 和 scrollHeight获取盒子的宽高。调用者为节点元素。不包括 border和margin。如下： scrollWidth = width + padding; scrollHeight = height + padding; scrollHeight有一个特点：如果文字超出了盒子，高度为内容的高（包括超出的内容）；不超出，则是盒子本身高度。 举例： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; padding: 10px; margin: 3px; border: 8px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; //scrollHeight有一个特点：如果文字超出了盒子，高度为内容的高（包括超出的内容）；不超出，则是盒子本身高度。 //IE8以下（不包括IE8），为盒子本身内容的多少。 console.log(div.scrollWidth); console.log(div.scrollHeight);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 2、scrollTop 和 scrollLeft网页被卷去的头部和左边的部分。 比如说，一个网页往上滚动的时候，上面的部分自然被浏览器遮挡了，遮挡的高度就是scrollTop。 scrollTop 这个属性的写法要注意兼容性，如下。 （1）如果文档没有 DTD 声明，写法为： 1document.body.scrollTop 在没有 DTD 声明的情况下，如果不是这种写法，chrome浏览器认不出来。 （2）如果文档有 DTD 声明，写法为： 1document.documentElement.scrollTop 在有 DTD 声明的情况下，如果不是这种写法，IE678认不出来。 综合上面这两个，就诞生了一种兼容性的写法： 123document.body.scrollTop || document.documentElement.scrollTop //方式一document.body.scrollTop + document.documentElement.scrollTop //方式二 另外还有一种兼容性的写法：window.pageYOffset 和 window.pageXOffset。这种写法无视DTD的声明。这种写法支持的浏览器版本是：火狐/谷歌/ie9+。 综合上面的几种写法，为了兼容，不管有没有DTD，最终版的兼容性写法： 1window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop; 判断是否已经 DTD声明方法如下： 12document.compatMode === &quot;CSS1Compat&quot; // 已声明document.compatMode === &quot;BackCompat&quot; // 未声明 将 scrollTop 和 scrollLeft封装为 json将 scrollTop 和 scrollLeft封装为一个方法，名叫scroll()，返回值为 json。json里的键为 top 和 left。以后就直接调用json.top 和json.left就好。 代码实现： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; height: 5000px; width: 5000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //需求：封装一个兼容的scroll().返回值是json，用scroll().top获取scrollTop，用scroll().left获取scrollLeft window.onscroll = function () &#123;// var json = scroll();// json.top; console.log(scroll().top); console.log(scroll().left); &#125; //函数封装（简单封装，实际工作使用） function scroll() &#123; return &#123; //此函数的返回值是json &quot;top&quot;: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, &quot;left&quot;: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，函数定义的那部分就是要封装的代码。另外还有一种较为复杂的封装方式： 12345678910111213141516171819function scroll() &#123; // 开始封装自己的scrollTop if(window.pageYOffset !== undefined) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if(document.compatMode === &quot;CSS1Compat&quot;) &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 获取 html 文档的方法获取title、body、head、html标签的方法如下： document.title 文档标题； document.head 文档的头标签 document.body 文档的body标签； document.documentElement （这个很重要）。 document.documentElement表示文档的html标签。也就是说，基本结构当中的 html 标签而是通过document.documentElement访问的，并不是通过 document.html 去访问的。 scrollTop 举例：固定导航栏完整版代码实现： （1）index.html： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; img &#123; vertical-align: top; &#125; .main &#123; margin: 0 auto; width: 1000px; margin-top: 10px; &#125; #Q-nav1 &#123; overflow: hidden; &#125; .fixed &#123; position: fixed; top: 0; left: 0; &#125; &lt;/style&gt; &lt;!--引入工具js--&gt; &lt;script src=&quot;tools.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求1：当我们滚动界面的时候，被卷曲的头部如果超过第二个盒子距离顶部的位置，那么直接给第二个盒子加类名.fixed //需求2：当我们滚动界面的时候，被卷曲的头部如果小于第二个盒子距离顶部的位置，那么直接给第二个盒子取消类名.fixed //1.老三步。 var topDiv = document.getElementById(&quot;top&quot;); var height = topDiv.offsetHeight; var middle = document.getElementById(&quot;Q-nav1&quot;); var main = document.getElementById(&quot;main&quot;); window.onscroll = function () &#123; //2.判断 ，被卷曲的头部的大小 if (scroll().top &gt; height) &#123; //3.满足条件添加类，否则删除类 middle.className += &quot; fixed&quot;; //第二个盒子也要占位置，为了避免重叠，我们给第三个盒子一个上padding的空间，把这个空间留给第二个盒子 main.style.paddingTop = middle.offsetHeight + &quot;px&quot;; &#125; else &#123; middle.className = &quot;&quot;; //清零 main.style.paddingTop = 0; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;top&quot; id=&quot;top&quot;&gt; &lt;img src=&quot;images/top.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div id=&quot;Q-nav1&quot;&gt; &lt;img src=&quot;images/nav.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;main&quot; id=&quot;main&quot;&gt; &lt;img src=&quot;images/main.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，有一个技巧： 1main.style.paddingTop = middle.offsetHeight + &quot;px&quot;; 仔细看注释就好。 （2）tools.js： 12345678910111213141516171819202122/** * Created by smyhvae on 2018/02/03. */function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset !== undefined) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === &quot;CSS1Compat&quot;) &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 实现效果： 工程文件： 2018-02-03-scrollTop固定导航栏.rar window.scrollTo()方法举例：返回到顶部小火箭（1）index.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; img &#123; position: fixed; bottom: 100px; right: 50px; cursor: pointer; display: none; border: 1px solid #000; &#125; div &#123; width: 1210px; margin: 100px auto; text-align: center; font: 500 26px/35px &quot;simsun&quot;; color: red; &#125; &lt;/style&gt; &lt;script src=&quot;tools.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求：被卷去的头部超过100显示小火箭，然后点击小火箭屏幕缓慢移动到最顶端。 //难点：我们以前是移动盒子，现在是移动屏幕，我们没有学过如何移动屏幕。 // 技术点：window.scrollTo(x,y);浏览器显示区域跳转到指定的坐标 //步骤： //1.老三步 var img = document.getElementsByTagName(&quot;img&quot;)[0]; window.onscroll = function () &#123; //被卷去的距离大于200显示小火箭，否则隐藏 //2.显示隐藏小火箭 if (scroll().top &gt; 1000) &#123; img.style.display = &quot;block&quot;; &#125; else &#123; img.style.display = &quot;none&quot;; &#125; //每次移动滚动条的时候都给leader赋值，模拟leader获取距离顶部的距离 leader = scroll().top; &#125; //3.缓动跳转到页面最顶端（利用我们的缓动动画） var timer = null; var target = 0; //目标位置 var leader = 0; //显示区域自身的位置 img.onclick = function () &#123; //技术点：window.scrollTo(0,0); //要用定时器，先清定时器 clearInterval(timer); timer = setInterval(function () &#123; //获取步长 var step = (target - leader) / 10; //二次处理步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; //往上移动的过程中，step是负数。当前位置减去步长，就等于下一步的位置。 //显示区域移动 window.scrollTo(0, leader); //清除定时器 if (leader === 0) &#123; clearInterval(timer); &#125; &#125;, 25); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/Top.jpg&quot;/&gt;&lt;div&gt; 我是最顶端.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt; 生命壹号，永不止步.....&lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）tools.js: 12345678910111213141516171819202122232425/** * Created by smyhvae on 2015/12/8. *///函数：获取scrollTop和scrollLeft的值function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset != null) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === &quot;CSS1Compat&quot;) &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 实现效果： 小火箭的图片资源： window.scrollTo()方法举例：楼层跳跃（暂略）缓动框架封装1、缓动框架封装：同时设置多个属性这里我们通过window.getComputedStyle的方式获取属性值。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; position: absolute; top: 40px; left: 10px; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到json中设置的位置&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btnArr = document.getElementsByTagName(&quot;button&quot;); var div = document.getElementsByTagName(&quot;div&quot;)[0]; btnArr[0].onclick = function () &#123; var json = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;; animate(div, json); &#125; //参数变为3个 function animate(ele, json) &#123; //先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () &#123; //遍历属性和值，分别单独处理json //attr == key(键) target == json[key](值) for (var key in json) &#123; //四部 var current = parseInt(getStyle(ele, key)) || 0; //1.获取步长 var step = (json[key] - current) / 10; //2.二次加工步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; //3.赋值 ele.style[key] = current + &quot;px&quot;; console.log(1); //4.清除定时器// if(Math.abs(json[key]-current)&lt;=Math.abs(step))&#123;// ele.style[key] = json[key] + &quot;px&quot;;// clearInterval(ele.timer);// &#125; &#125; &#125;, 25); &#125; //兼容方法获取元素样式 function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 2、上方的代码改进：清除定时器上方的代码中，我们还需做一下清除定时器的判断：只有所有的参数都到达指定位置了，我们就清除定时器。 完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; position: absolute; top: 40px; left: 10px; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到json中设置的位置&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btnArr = document.getElementsByTagName(&quot;button&quot;); var div = document.getElementsByTagName(&quot;div&quot;)[0]; btnArr[0].onclick = function () &#123; var json = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;; animate(div, json); &#125; //参数变为3个 function animate(ele, json) &#123; //先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () &#123; //开闭原则 var bool = true; //遍历属性和值，分别单独处理json //attr == key(键) target == json[key](值) for (var key in json) &#123; //四部 var current = parseInt(getStyle(ele, key)) || 0; //1.获取步长 var step = (json[key] - current) / 10; //2.二次加工步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; //3.赋值 ele.style[key] = current + &quot;px&quot;; //4.清除定时器 //判断: 目标值和当前值的差大于步长，就不能跳出循环 //不考虑小数的情况：目标位置和当前位置不相等，就不能清除清除定时器。 if (json[key] !== current) &#123; bool = false; &#125; &#125; console.log(1); //只有所有的属性都到了指定位置，bool值才为true； if (bool) &#123; clearInterval(ele.timer); &#125; &#125;, 25); &#125; //兼容方法获取元素样式 function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果同上。 ### 3、进一步深入：如果有要同时执行讴多个动画时，就要用到回调函数（重要）： 上面的代码中，我们要做的动画是： 1234btnArr[0].onclick = function () &#123; var json = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;; animate(div, json);&#125; 上面的代码是执行这一个动画，可如果要同时执行两个动画呢？一般人自然想到的是下面的写法：（错误的写法） 123456btnArr[0].onclick = function () &#123; var json1 = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;; var json2 = &#123;&quot;left&quot;: 200, &quot;top&quot;: 10, &quot;width&quot;: 150, &quot;height&quot;: 150&#125;; animate(div, json1); animate(div, json2);&#125; 但是这样写的话，第二个动画 json2 会把第一个动画 json1 层叠掉。也就是说，第一个动画直接就不执行了。效果如下： 这显然不是我们想看到的。 如果我们想先执行第一个动画fn1()，再执行第二个动画fn2()的话，就要用到回调函数。意思是，将第二个动画fn2()作为回调函数即可。 完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; position: absolute; top: 40px; left: 10px; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;运动到 json 设置的位置&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btnArr = document.getElementsByTagName(&quot;button&quot;); var div = document.getElementsByTagName(&quot;div&quot;)[0]; btnArr[0].onclick = function () &#123; var json1 = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;; var json2 = &#123;&quot;left&quot;: 300, &quot;top&quot;: 10, &quot;width&quot;: 100, &quot;height&quot;: 100&#125;; animate(div, json1, function () &#123; //第三个参数是回调，可以保证json1的动画执行结束后，再执行json2的动画 animate(div, json2); &#125;) &#125; //带有回调的动画封装 function animate(ele, json, fn) &#123; //先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () &#123; //开闭原则 var bool = true; //遍历属性和值，分别单独处理json //attr == key(键) target == json[key](值) for (var key in json) &#123; //四部 var current = parseInt(getStyle(ele, key)) || 0; //1.获取步长 var step = (json[key] - current) / 10; //2.二次加工步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; //3.赋值 ele.style[key] = current + &quot;px&quot;; //4.清除定时器 //判断: 目标值和当前值的差大于步长，就不能跳出循环 //不考虑小数的情况：目标位置和当前位置不相等，就不能清除清除定时器。 if (json[key] !== current) &#123; bool = false; &#125; &#125; console.log(1); //只有所有的属性都到了指定位置，bool值才不会变成false； if (bool) &#123; clearInterval(ele.timer); //定时器结束，代表第一个函数fn1()执行完毕了，接下来可以执行回调函数fn2()了。 //只有传递了回调函数，才能执行 if (fn) &#123; //【重要】第一个函数执行完毕了，定时器也清除了。现在，如果有人送了fn()这个回调函数过来，那就执行fn() fn(); // 函数名+()：执行该函数 &#125; &#125; &#125;, 25); &#125; //兼容方法获取元素样式 function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上方代码中，如果我们要先后完成两个动画，执行的代码是： 123animate(div, json1, function () &#123; //第三个参数是回调，可以保证json1的动画执行结束后，再执行json2的动画 animate(div, json2);&#125;) 如果想要先后执行两个动画，那就以此类推： 12345animate(div, json1, function () &#123; //第三个参数是回调，可以保证json1的动画执行结束后，再执行json2的动画 animate(div, json2,function () &#123; animate(div,json3); &#125;);&#125;) 举例：仿360的右下角开机效果 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 322px; position: fixed; bottom: 0; right: 0; &#125; span &#123; position: absolute; top: 0; right: 0; width: 30px; height: 20px; cursor: pointer; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：下面的盒子高先变为0，然后上面的大盒子的宽再变为0. var guanbi = document.getElementById(&quot;guanbi&quot;); var box = guanbi.parentNode; var b = document.getElementById(&quot;b&quot;); guanbi.onclick = function () &#123; //下面的盒子高度变为0，然后大盒子的宽在变为0. animate(b, &#123;&quot;height&quot;: 0&#125;, function () &#123; animate(box, &#123;&quot;width&quot;: 0&#125;); &#125;); &#125; &#125; //封装好的动画函数 function animate(ele, json, fn) &#123; //先清定时器 clearInterval(ele.timer); ele.timer = setInterval(function () &#123; //开闭原则 var bool = true; //遍历属性和值，分别单独处理json //attr == key(键) target == json[key](值) for (var key in json) &#123; //四部 var current = parseInt(getStyle(ele, key)) || 0; //1.获取步长 var step = (json[key] - current) / 10; //2.二次加工步长 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; //3.赋值 ele.style[key] = current + &quot;px&quot;; //4.清除定时器 //判断: 目标值和当前值的差大于步长，就不能跳出循环 //不考虑小数的情况：目标位置和当前位置不相等，就不能清除清除定时器。 if (json[key] !== current) &#123; bool = false; &#125; &#125; console.log(1); //只有所有的属性都到了指定位置，bool值才不会变成false； if (bool) &#123; clearInterval(ele.timer); //所有程序执行完毕了，现在可以执行回调函数了 //只有传递了回调函数，才能执行 if (fn) &#123; fn(); &#125; &#125; &#125;, 1); &#125; /** * 获取元素样式兼容写法 * @param ele * @param attr * @returns &#123;*&#125; */ function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;span id=&quot;guanbi&quot;&gt;&lt;/span&gt; &lt;div class=&quot;hd&quot; id=&quot;t&quot;&gt; &lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot; id=&quot;b&quot;&gt; &lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 工程文件： 2018-02-04-仿360开机效果.rar 4、对 opacity和 z-index 属性进行单独改进我们以上的代码中，如果要进行动画参数的设置，是直接把参数放到json里面去的。例如： 12var json1 = &#123;&quot;left&quot;: 100, &quot;top&quot;: 200, &quot;width&quot;: 300, &quot;height&quot;: 300&#125;;var json2 = &#123;&quot;left&quot;: 300, &quot;top&quot;: 10, &quot;width&quot;: 100, &quot;height&quot;: 100&#125;; 可是，下面这两个属性，却不能这样放到json里，会出现兼容性的问题： 12opacity: 0.5; //透明度z-index: 1; 如何改进呢？暂略。","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：JavaScript特效/01-offset家族和匀速动画(含轮播图的实现)","date":"2021-08-06T01:17:25.817Z","updated":"2021-07-28T07:34:11.353Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：JavaScript特效/01-offset家族和匀速动画(含轮播图的实现)/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9AJavaScript%E7%89%B9%E6%95%88/01-offset%E5%AE%B6%E6%97%8F%E5%92%8C%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB(%E5%90%AB%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0)/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言JS动画的主要内容如下： 1、三大家族和一个事件对象： 三大家族：offset/scroll/client。也叫三大系列。 事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。 2、动画(闪现/匀速/缓动) 3、冒泡/兼容/封装 4、正则 offset 家族的组成我们知道，三大家族包括：offset/scroll/client。今天来讲一下offset，以及与其相关的匀速动画。 offset的中文是：偏移，补偿，位移。 js中有一套方便的获取元素尺寸的办法就是offset家族。offset家族包括： offsetWidth offsetHight offsetLeft offsetTop offsetParent 下面分别介绍。 1、offsetWidth 和 offsetHight用于检测盒子自身的宽高+padding+border，不包括margin。如下： offsetWidth = width + padding + border; offsetHeight = Height + padding + border; 这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。 举例如下： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; padding: 10px; border: 10px solid #000; margin: 100px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementsByTagName(&quot;div&quot;)[0]; console.log(div1.offsetHeight); //打印结果：140（100+20+20） console.log(typeof div1.offsetHeight); //打印结果：number&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、offsetLeft 和 offsetTop返回距离上级盒子（带有定位）左边的位置；如果父级都没有定位，则以body为准。 offsetLeft： 从父亲的 padding 开始算，父亲的 border 不算。 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 300px; height: 300px; padding: 100px; margin: 100px; position: relative; border: 100px solid #000; background-color: pink; &#125; .box2 &#123; width: 100px; height: 100px; background-color: red; /*position: absolute;*/ /*left: 10px;*/ /*top: 10px;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot; style=&quot;left: 10px&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var box2 = document.getElementsByClassName(&quot;box2&quot;)[0]; //offsetTop和offsetLeft console.log(box2.offsetLeft); //100 console.log(box2.style.left); //10px&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在父盒子有定位的情况下，offsetLeft == style.left(去掉px之后)。注意，后者只识别行内样式。但区别不仅仅于此，后面会讲。 3、offsetParent检测父系盒子中带有定位的父盒子节点。返回结果是该对象的父级（带有定位）。 如果当前元素的父级元素，没有CSS定位（position为absolute、relative、fixed），那么offsetParent的返回结果为body。 如果当前元素的父级元素，有CSS定位（position为absolute、relative、fixed），那么offsetParent的返回结果为最近的那个父级元素。 举例： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box1&quot; style=&quot;position: absolute;&quot;&gt; &lt;div class=&quot;box2&quot; style=&quot;position: fixed;&quot;&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //offsetParent：复习盒子中带有定位的盒子 //复习盒子中都没有定位，返回body //如果有，谁有返回最近哪个 var box3 = document.getElementsByClassName(&quot;box3&quot;)[0]; console.log(box3.offsetParent);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： offsetLeft和style.left区别（1）最大区别在于： offsetLeft 可以返回没有定位盒子的距离左侧的位置。如果父系盒子中都没有定位，以body为准。 style.left 只能获取行内式，如果没有，则返回””（意思是，返回空）; （2）offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。 比如： 1234div.offsetLeft = 100;div.style.left = &quot;100px&quot;; （3）offsetLeft 和 offsetTop 只读，而 style.left 和 style.top 可读写（只读是获取值，可写是赋值） （4）如果没有给 HTML 元素指定过 top 样式，则style.top 返回的是空字符串。 总结：我们一般的做法是：用offsetLeft 和 offsetTop 获取值，用style.left 和 style.top 赋值（比较方便）。理由如下： style.left：只能获取行内式，获取的值可能为空，容易出现NaN。 offsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。 动画的种类 闪现（基本不用） 匀速（本文重点） 缓动（后续重点） 简单举例如下：（每间隔500ms，向右移动盒子100px） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;动画&lt;/button&gt;&lt;div class=&quot;box&quot; style=&quot;left: 0px&quot;&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var div = document.getElementsByTagName(&quot;div&quot;)[0]; //1、闪动 // btn.onclick = function () &#123; // div.style.left = &quot;500px&quot;; // &#125; //2、匀速运动 btn.onclick = function () &#123; //定时器，每隔一定的时间向右走一些 setInterval(function () &#123; console.log(parseInt(div.style.left)); //动画原理： 盒子未来的位置 = 盒子现在的位置 + 步长； //用style.left赋值，用offsetLeft获取值。 div.style.left = div.offsetLeft + 100 + &quot;px&quot;; //div.style.left = parseInt(div.style.left)+10+&quot;px&quot;; //NaN不能用 &#125;, 500); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 匀速动画的封装：每间隔30ms，移动盒子10px【重要】代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box1 &#123; margin: 0; padding: 5px; height: 300px; background-color: #ddd; position: relative; &#125; button &#123; margin: 5px; &#125; .box2 &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 195px; top: 40px; &#125; .box3 &#123; width: 100px; height: 100px; background-color: yellow; position: absolute; left: 0; top: 150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box1&quot;&gt; &lt;button&gt;运动到 left = 200px&lt;/button&gt; &lt;button&gt;运动到 left = 400px&lt;/button&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var btnArr = document.getElementsByTagName(&quot;button&quot;); var box2 = document.getElementsByClassName(&quot;box2&quot;)[0]; var box3 = document.getElementsByClassName(&quot;box3&quot;)[0]; //绑定事件 btnArr[0].onclick = function () &#123; //如果有一天我们要传递另外一个盒子，那么我们的方法就不好用了 //所以我们要增加第二个参数，被移动的盒子本身。 animate(box2, 200); animate(box3, 200); &#125; btnArr[1].onclick = function () &#123; animate(box2, 400); animate(box3, 400); &#125; //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) &#123; //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target &gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () &#123; //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + &quot;px&quot;; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) &lt; Math.abs(speed)) &#123; ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); &#125; &#125;, 30) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 上方代码中的方法封装，可以作为一个模板步骤，要记住。其实，这个封装的方法，写成下面这样，会更严谨，更容易理解：（将if语句进行了改进） 1234567891011121314151617181920212223//【重要】方法的封装：每间隔30ms，将盒子向右移动10pxfunction animate(ele, target) &#123; //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target &gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () &#123; //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) &lt; Math.abs(speed)) &#123; //如果val小于步长，则直接到达目的地；否则，每次移动一个步长 ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); &#125; else &#123; ele.style.left = ele.offsetLeft + speed + &quot;px&quot;; &#125; &#125;, 30)&#125; 代码举例：轮播图的实现完整版代码如下：（注释已经比较详细） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; padding: 0; margin: 0; list-style: none; border: 0; &#125; .all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; &#125; .screen &#123; width: 500px; height: 200px; overflow: hidden; position: relative; &#125; .screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left; &#125; .screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px; &#125; .all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; &#125; .all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; &#125; .all ol li.current &#123; background: yellow; &#125; #arr &#123; display: none; &#125; #arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: &#x27;黑体&#x27;; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; &#125; #arr #right &#123; right: 5px; left: auto; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：无缝滚动。 //思路：赋值第一张图片放到ul的最后，然后当图片切换到第五张的时候 // 直接切换第六章，再次从第一张切换到第二张的时候先瞬间切换到 // 第一张图片，然后滑动到第二张 //步骤： //1.获取事件源及相关元素。（老三步） //2.复制第一张图片所在的li,添加到ul的最后面。 //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 //4.鼠标放到ol的li上切换图片 //5.添加定时器 //6.左右切换图片（鼠标放上去隐藏，移开显示） //1.获取事件源及相关元素。（老三步） var all = document.getElementById(&quot;all&quot;); var screen = all.firstElementChild || all.firstChild; var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var ol = screen.children[1]; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; //2.复制第一张图片所在的li,添加到ul的最后面。 var ulNewLi = ul.children[0].cloneNode(true); ul.appendChild(ulNewLi); //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 for (var i = 0; i &lt; ul.children.length - 1; i++) &#123; var olNewLi = document.createElement(&quot;li&quot;); olNewLi.innerHTML = i + 1; ol.appendChild(olNewLi) &#125; var olLiArr = ol.children; olLiArr[0].className = &quot;current&quot;; //4.鼠标放到ol的li上切换图片 for (var i = 0; i &lt; olLiArr.length; i++) &#123; //自定义属性，把索引值绑定到元素的index属性上 olLiArr[i].index = i; olLiArr[i].onmouseover = function () &#123; //排他思想 for (var j = 0; j &lt; olLiArr.length; j++) &#123; olLiArr[j].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; //鼠标放到小的方块上的时候索引值和key以及square同步// key = this.index;// square = this.index; key = square = this.index; //移动盒子 animate(ul, -this.index * imgWidth); &#125; &#125; //5.添加定时器 var timer = setInterval(autoPlay, 1000); //固定向右切换图片 //两个定时器（一个记录图片，一个记录小方块） var key = 0; var square = 0; function autoPlay() &#123; //通过控制key的自增来模拟图片的索引值，然后移动ul key++; if (key &gt; olLiArr.length) &#123; //图片已经滑动到最后一张，接下来，跳转到第一张，然后在滑动到第二张 ul.style.left = 0; key = 1; &#125; animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square++; if (square &gt; olLiArr.length - 1) &#123;//索引值不能大于等于5，如果等于5，立刻变为0； square = 0; &#125; for (var i = 0; i &lt; olLiArr.length; i++) &#123; olLiArr[i].className = &quot;&quot;; &#125; olLiArr[square].className = &quot;current&quot;; &#125; //鼠标放上去清除定时器，移开后在开启定时器 all.onmouseover = function () &#123; div.style.display = &quot;block&quot;; clearInterval(timer); &#125; all.onmouseout = function () &#123; div.style.display = &quot;none&quot;; timer = setInterval(autoPlay, 1000); &#125; //6.左右切换图片（鼠标放上去显示，移开隐藏） spanArr[0].onclick = function () &#123; //通过控制key的自增来模拟图片的索引值，然后移动ul key--; if (key &lt; 0) &#123; //先移动到最后一张，然后key的值取之前一张的索引值，然后在向前移动 ul.style.left = -imgWidth * (olLiArr.length) + &quot;px&quot;; key = olLiArr.length - 1; &#125; animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square--; if (square &lt; 0) &#123;//索引值不能大于等于5，如果等于5，立刻变为0； square = olLiArr.length - 1; &#125; for (var i = 0; i &lt; olLiArr.length; i++) &#123; olLiArr[i].className = &quot;&quot;; &#125; olLiArr[square].className = &quot;current&quot;; &#125; spanArr[1].onclick = function () &#123; //右侧的和定时器一模一样 autoPlay(); &#125; function animate(ele, target) &#123; clearInterval(ele.timer); var speed = target &gt; ele.offsetLeft ? 10 : -10; ele.timer = setInterval(function () &#123; var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + &quot;px&quot;; if (Math.abs(val) &lt; Math.abs(speed)) &#123; ele.style.left = target + &quot;px&quot;; clearInterval(ele.timer); &#125; &#125;, 10) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;all&quot; id=&#x27;all&#x27;&gt; &lt;div class=&quot;screen&quot; id=&quot;screen&quot;&gt; &lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;div id=&quot;arr&quot;&gt; &lt;span id=&quot;left&quot;&gt;&lt;&lt;/span&gt; &lt;span id=&quot;right&quot;&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 温馨提示：动图太大，可以把http://img.smyhvae.com/20180202_2020.gif单独在浏览器中打开。 工程文件： 2018-02-02-JS动画实现轮播图.rar 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/08-JavaScript基础：定时器","date":"2021-08-06T01:17:25.812Z","updated":"2021-07-28T07:34:11.352Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/08-JavaScript基础：定时器/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/08-JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"定时器的常见方法 setInterval()：循环定时器。周而复始的执行（循环执行） setTimeout()：定时炸弹。用完以后立刻报废（只执行一次） 定义定时器的方式方式一：匿名函数 每间隔一秒打印一次： 123setInterval(function () &#123; console.log(1);&#125;,1000); 方式二： 每间隔一秒打印一次： 123456setInterval(fn,1000);function fn()&#123; console.log(1);&#125; 定时器高级：清除定时器定时器的返回值可以用来清除定时器。具体方法是：假设定时器setInterval()的返回值是参数1，那么clearInterval(参数1)就可以清除定时器。 setTimeout()的道理是一样的。 代码举例： 12345678910111213&lt;script&gt; var num = 1; var timer = setInterval(function () &#123; console.log(num); //每间隔一秒，打印一次num的值 num ++; if(num ===5) &#123; //打印四次之后，就清除定时器 clearInterval(timer); &#125; &#125;, 1000);&lt;/script&gt; 定时器举例举例一：5秒后关闭网页两侧的广告栏假设网页两侧的广告栏为两个img标签，它们的样式为： 123456&lt;style&gt; ... ...&lt;/style&gt; 5秒后关闭广告栏的js代码为： 123456789101112&lt;script&gt; window.onload = function () &#123; //获取相关元素 var imgArr = document.getElementsByTagName(&quot;img&quot;); //设置定时器：5秒后关闭两侧的广告栏 setTimeout(fn,5000); function fn()&#123; imgArr[0].style.display = &quot;none&quot;; imgArr[1].style.display = &quot;none&quot;; &#125; &#125;&lt;/script&gt; 举例二：关闭京东顶部广告栏（带动画效果关闭）我们在之前的文章中做过这道题。但是现在，要求广告栏在关闭的时候，带动画效果：点击关闭按钮后，顶部广告栏慢慢地变透明，直到全部关闭。 我们可以用定时器来做。完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .top-banner &#123; background-color: pink; height: 80px; &#125; .w &#123; width: 1210px; margin: 10px auto; position: relative; &#125; img &#123; display: block; width: 1210px; height: 80px; background-color: blue; &#125; a &#123; position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px &quot;simsum&quot;; text-align: center; &#125; .hide &#123; display: none !important; &#125; .search &#123; width: 1210px; height: 80px; background-color: green; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;top-banner&quot; id=&quot;topBanner&quot; style=&quot;opacity: 1&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;img src=&quot;blue&quot; alt=&quot;&quot;/&gt; &lt;a href=&quot;#&quot; id=&quot;closeBanner&quot;&gt;×&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;search&quot;&gt;&lt;/div&gt;&lt;script&gt; //需求：点击关闭按钮，先让top-banner这个盒子透明度变为0，紧接着display：none; //1.获取事件源和相关元素 var closeBanner = document.getElementById(&quot;closeBanner&quot;); var topBanner = document.getElementById(&quot;topBanner&quot;); //定义定时器 var timer = null; //2.绑定事件 closeBanner.onclick = function () &#123; //3.书写事件驱动程序（定时器，透明度变为0，清除定时器，并隐藏盒子） timer = setInterval(function () &#123; topBanner.style.opacity -= 0.1; if (topBanner.style.opacity &lt; 0) &#123; topBanner.style.display = &quot;none&quot;; clearInterval(timer); &#125; &#125;, 50); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： 注意，我们要实现给顶部的div加一个行内样式style=&quot;opacity: 1&quot;，然后才能通过定时器判断topBanner.style.opacity的值。 定时器的返回值其实是number类型的，但我们习惯性地设置初始值为null。 实现效果：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/07-DOM操作练习：innerHTML的方式创建元素","date":"2021-08-06T01:17:25.809Z","updated":"2021-07-28T07:34:11.352Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/07-DOM操作练习：innerHTML的方式创建元素/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/07-DOM%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0%EF%BC%9AinnerHTML%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0/","excerpt":"","text":"动态创建DOM元素的三种方式 document.write(); 不常用，因为容易覆盖原来的页面。 innerHTML = (); 用的比较多。绑定属性和内容比较方便。(节点套节点) document.createElement(); 用得也比较多，指定数量的时候一般用它。 1、方式一： 1document.write(); 这种方式的好处是：比较随意，想创建就创建，可以直接在write里写属性都行。但是会把原来的标签给覆盖掉。所以不建议。 举例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; smyhvae&lt;/ul&gt;&lt;script&gt; //第一种创建方式：document.write(); document.write(&quot;&lt;li class=&#x27;hehe&#x27;&gt;我是document.write创建的&lt;/li&gt;&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 方式二：innerHTML 举例如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; smyhvae&lt;/ul&gt;&lt;script&gt; var ul = document.getElementsByTagName(&quot;ul&quot;)[0]; //第二种：直接利用元素的innerHTNL方法。（innerText方法不识别标签） ul.innerHTML += &quot;&lt;li id=&#x27;li1&#x27;&gt;我是innerHTML创建的&lt;/li&gt;&quot; //注意，是用符号“+=”，不是“=”&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意，上方代码中，是用是用符号+=，不是=，前者是在原来的基础之上增加，后者是替换。 效果如下： 3、方式三：利用DOM的api创建 利用DOM的api创建节点，有很多种： 比如： createElement() appendChild() removeChild() insertBefore() replaceChild() 这个我们在上一篇文章的DOM节点的操作这一段中已经讲到了。 1 innerHTML举例：在线用户的获取现在要做下面这样一个页面： 上图的意思是，每次刷新页面，都从服务器获取最新的在线人数的名单（我们先用本地的数组来模拟服务器上的数据）。 它的结构是：div &gt; ul &gt; li。每一个li就是一个头像。 如果在本地直接添加几个头像的话，代码是： 1234567891011121314//往ul中添加li元素以及li元素中的内容 ul.innerHTML += &#x27;&lt;li&gt;&#x27;+ &#x27;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;images/noavatar_small.gif&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;生命壹号&quot;&gt;&lt;/a&gt;&#x27;+ &#x27;&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;生命壹号&quot; target=&quot;_blank&quot;&gt;生命壹号&lt;/a&gt;&lt;/p&gt;&#x27;+ &#x27;&lt;/li&gt;&#x27;; ul.innerHTML += &#x27;&lt;li&gt;&#x27;+ &#x27;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;images/noavatar_small.gif&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;生命壹号&quot;&gt;&lt;/a&gt;&#x27;+ &#x27;&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;生命壹号&quot; target=&quot;_blank&quot;&gt;生命壹号&lt;/a&gt;&lt;/p&gt;&#x27;+ &#x27;&lt;/li&gt;&#x27;; ul.innerHTML += &#x27;&lt;li&gt;&#x27;+ &#x27;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;images/noavatar_small.gif&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;生命壹号&quot;&gt;&lt;/a&gt;&#x27;+ &#x27;&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;生命壹号&quot; target=&quot;_blank&quot;&gt;生命壹号&lt;/a&gt;&lt;/p&gt;&#x27;+ &#x27;&lt;/li&gt;&#x27;; 上方代码有两点比较重要： 我们是通过ul.innerHTML += 元素节点的方式来不停地往ul里面加内容，比createElement的方式要方便。 元素的内容本身有双引号&quot;，所以我们要用单引号&#39;进行字符串的连接。 但是，当我们从服务器获取在线用户的时候，头像和用户的昵称是动态变化的，所以每个字符串要用变量进行表示： 12345ul.innerHTML += &#x27;&lt;li&gt;&#x27;+ &#x27;&lt;a href=&quot;#&quot; target=&quot;blank&quot;&gt;&lt;img src=&quot;&#x27;+users[i].icon+&#x27;&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;&#x27;+users[i].name+&#x27;&quot;&gt;&lt;/a&gt;&#x27;+ &#x27;&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;&#x27;+users[i].name+&#x27;&quot; target=&quot;_blank&quot;&gt;&#x27;+users[i].name+&#x27;&lt;/a&gt;&lt;/p&gt;&#x27;+ &#x27;&lt;/li&gt;&#x27;; 这里我们暂时用本地的数组来代表服务器的数据，最终的完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; word-wrap: break-word; &#125; .wp &#123; width: 730px; margin: 0px auto; &#125; .mtn &#123; margin-top: 5px !important; &#125; #ct .frame &#123; margin: 0; border: none; &#125; .xfs_2 .frame-title, .xfs_2 .frametitle, .xfs_2 .tab-title &#123; background-color: #A90000; background-position: 0 -99px; &#125; .xfs .frame-title, .xfs .frametitle, .xfs .tab-title, .xfs .frame-title a, .xfs .frametitle a, .xfs .tab-title a &#123; color: #FFF !important; &#125; .xfs .frame-title, .xfs .frametitle, .xfs .tab-title &#123; border: none; background: transparent url(images/mu.png) repeat-x 0 95; &#125; .title &#123; padding: 0 10px; height: 32px; font-size: 14px; font-weight: 700; line-height: 32px; overflow: hidden; &#125; .block &#123; margin: 10px 10px 0; &#125; ul, menu, dir &#123; display: block; list-style: none; -webkit-margin-before: 1em; -webkit-margin-after: 1em; -webkit-margin-start: 0px; -webkit-margin-end: 0px; -webkit-padding-start: 25px; &#125; .mls li &#123; padding: 0 0 5px; width: 66px; height: 85px; &#125; .ml li &#123; float: left; text-align: center; overflow: hidden; &#125; a &#123; color: #333; text-decoration: none; font: 12px/1.5 Tahoma, &#x27;Microsoft Yahei&#x27;, &#x27;Simsun&#x27;; &#125; .mls p &#123; margin-top: 5px; &#125; .ml p, .ml span &#123; display: block; width: 100%; height: 20px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; &#125; .mls img &#123; width: 48px; height: 48px; &#125; .ml img &#123; display: block; margin: 0 auto; &#125; a img &#123; border: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wp mtn&quot;&gt; &lt;div id=&quot;diy3&quot; class=&quot;area&quot;&gt; &lt;div id=&quot;frameipq7f2&quot; class=&quot;xfs xfs_2 frame move-span cl frame-1&quot;&gt; &lt;div class=&quot;title frame-title&quot;&gt;&lt;span class=&quot;titletext&quot;&gt;当前在线用户&lt;/span&gt;&lt;/div&gt; &lt;div id=&quot;frameipq7f2_left&quot; class=&quot;column frame-1-c&quot;&gt; &lt;div id=&quot;frameipq7f2_left_temp&quot; class=&quot;move-span temp&quot;&gt;&lt;/div&gt; &lt;div id=&quot;portal_block_695&quot; class=&quot;block move-span&quot;&gt; &lt;div id=&quot;portal_block_695_content&quot; class=&quot;dxb_bc&quot;&gt; &lt;div class=&quot;module cl ml mls&quot; id=&quot;users&quot;&gt; &lt;ul&gt; &lt;!--&lt;li&gt;--&gt; &lt;!--&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;images/noavatar_small.gif&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;生命壹号&quot;&gt;&lt;/a&gt;--&gt; &lt;!--&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;生命壹号&quot; target=&quot;_blank&quot;&gt;生命壹号&lt;/a&gt;&lt;/p&gt;--&gt; &lt;!--&lt;/li&gt;--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; //模拟从服务器获取数据 var users = [ &#123;&quot;name&quot;: &quot;smyhvae&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;smyh&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;smyh02&quot;, &quot;icon&quot;: &quot;images/75_avatar_small.jpg&quot;&#125;, &#123;&quot;name&quot;: &quot;vae&quot;, &quot;icon&quot;: &quot;images/89_avatar_small.jpg&quot;&#125;, &#123;&quot;name&quot;: &quot;today&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;enen&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;oyey&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;dongxiaojie&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;qishi&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;qqtang&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;wawawa&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;haha&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;robot&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;heheda&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;smyhvae1&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125;, &#123;&quot;name&quot;: &quot;lihaile&quot;, &quot;icon&quot;: &quot;images/noavatar_small.gif&quot;&#125; ]; //需求：页面显示所有的在线用户。 //思路：模拟服务器获取数据（数组中装着json）.获取ul，把ul的innerHTML属性获取到，然后不间断的往innerHTML属性中赋值。 //赋值要求：li标签的内容。 //步骤：(获取元素) var div = document.getElementById(&quot;users&quot;); var ul = div.firstElementChild || div.firstChild; // var ul = div.children[0]; //1.模拟服务器获取数据（定义数组），通过循环添加元素（定义for） //数组中有多少元素，我们就创建多少个li标签 for (var i = 0; i &lt; users.length; i++) &#123; //2.模拟实验的操作方式。 ul.innerHTML += &#x27;&lt;li&gt;&#x27; + &#x27;&lt;a href=&quot;#&quot; target=&quot;blank&quot;&gt;&lt;img src=&quot;&#x27; + users[i].icon + &#x27;&quot; width=&quot;48&quot; height=&quot;48&quot; alt=&quot;&#x27; + users[i].name + &#x27;&quot;&gt;&lt;/a&gt;&#x27; + &#x27;&lt;p&gt;&lt;a href=&quot;#&quot; title=&quot;&#x27; + users[i].name + &#x27;&quot; target=&quot;_blank&quot;&gt;&#x27; + users[i].name + &#x27;&lt;/a&gt;&lt;/p&gt;&#x27; + &#x27;&lt;/li&gt;&#x27;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 工程文件： 2018-02-01-获取在线用户列表demo.rar innerHTML举例2：模拟百度搜索的下方提示要求实现的效果如下： 在这之前，我们先实现这样一个例子：判断字符串以某个字符串为开头。 判断字符串是否以某个字符串为开头： 1234567var str = &quot;smyhvae&quot;;//判断str是否以sm为开头？（给定字符串，然后他的索引值为0）var num = str.indexOf(&quot;sm&quot;);//只有返回值为0，那么字符串才是以参数为开头//如果在任何位置都查询不到参数，则返回值为-1； 代码解释：我们可以通过indexOf(&quot;参数&quot;)来实现。如果返回的索引值为0，说明字符串就是以这个参数开头的。 为了实现上方gif图的搜索功能，完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 500px; margin: 200px auto; &#125; ul &#123; width: 392px; padding: 5px; list-style: none; border: 1px solid red; &#125; li:hover &#123; background-color: red; &#125; input &#123; width: 400px; &#125; button &#123; width: 70px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot;/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;!--&lt;ul&gt;--&gt; &lt;!--&lt;li&gt;aaaa&lt;/li&gt;--&gt; &lt;!--&lt;li&gt;bbb&lt;/li&gt;--&gt; &lt;!--&lt;li&gt;ccc&lt;/li&gt;--&gt; &lt;!--&lt;/ul&gt;--&gt;&lt;/div&gt;&lt;script&gt; //需求：输入内容(输入事件，键盘弹起事件)，模拟服务器获取内容，创建ul，并在其中显示。 //1.获取事件源 //模拟服务器获取内容 var arr = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;aa&quot;, &quot;aaa&quot;]; var box = document.getElementsByTagName(&quot;div&quot;)[0]; var inp = box.children[0]; // var inp = document.getElementsByTagName(&quot;input&quot;)[0]; //2.绑定事件(输入内容(输入事件，键盘弹起事件)) inp.onkeyup = function () &#123; //创建一个字符串，里面添加满了li和对应的内容。 var newArr = []; //遍历老数组arr，然后判断每一项，只要是以input的内容为开头的，就添加到新数组newArr中，然后转成字符串。 for (var i = 0; i &lt; arr.length; i++) &#123; //获取输入内容input标签的value属性值。 if (arr[i].indexOf(this.value) === 0) &#123; //【重要】判断老数组arr中的每一项，是否以input的内容为开头 newArr.push(&quot;&lt;li&gt;&quot; + arr[i] + &quot;&lt;/li&gt;&quot;); &#125; &#125; var str = newArr.join(&quot;&quot;); //Bug1：每次创建新的ul之前，如果有就的ul，就先删除旧的ul if (box.getElementsByTagName(&quot;ul&quot;)[0]) &#123; //只要存在，那么就是object，object类型的数据，只要不是null,对应的boolean值都是true； box.removeChild(box.children[2]); &#125; //Bug2.如果input的内容为空，那么就不能再生成ul了。 //如果input为空，那就切断函数 //Bug3.如果arr数组中找不到以input为开头的元素。那就切断函数 //newArr的长度为0，就能证明以input内容为开头的元素，在arr中不存在 if (this.value.length === 0 || newArr.length === 0) &#123; //fix bug2、fix bug3 //切断函数，直接return return; &#125; //3.书写事件驱动程序 var ul = document.createElement(&quot;ul&quot;); //把创建好的内容添加到ul中。 ul.innerHTML = str; box.appendChild(ul); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 动态操作表格方式1： 1createElement() 方式2： rows (只读，table和textarea能用) insertRow() (只有table能调用) deleteRow() (只有table能调用) cells (只读，table和textarea能用) insertCell() (只有tr能调用) deleteCell() (只有tr能调用) PS：括号里可以带index。用的不多。","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/06-DOM操作练习：通过style对象设置样式","date":"2021-08-06T01:17:25.806Z","updated":"2021-07-28T07:34:11.352Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/06-DOM操作练习：通过style对象设置样式/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/06-DOM%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0%EF%BC%9A%E9%80%9A%E8%BF%87style%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"style属性的设置和获取在DOM当中，如果想设置样式，有两种形式： className（针对内嵌样式表） style（针对行内样式） 这一段就来讲一下style。 需要注意的是：style是一个对象，只能获取行内样式，不能获取内嵌的样式和外链的样式。例如： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div &#123; border: 6px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot; style=&quot;width: 200px;height: 100px;background-color: pink;&quot;&gt;&lt;/div&gt; &lt;script&gt; var box1 = document.getElementsByTagName(&quot;div&quot;)[0]; console.log(box1.style.backgroundColor); console.log(box1.style.border); //没有打印结果，因为这个属性不是行内样式 console.log(typeof box1.style); //因为是对象，所以打印结果是Object console.log(box1.style); //打印结果是对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 上图显示，因为border属性不是行内样式，所以无法通过style对象获取。 style属性的注意事项style属性需要注意以下几点： （1）样式少的时候使用。 （2）style是对象。 我们在上方已经打印出来，typeof的结果是Object。 （3）值是字符串，没有设置值是“”。 （4）命名规则，驼峰命名。和css不一样。 （5）只能获取行内样式，和内嵌和外链无关。 本段最开始的时候讲到的。 （6）box.style.cssText = “字符串形式的样式”。 cssText这个属性，其实就是把行内样式里面的值当做字符串来对待。在上方代码的基础之上，举例： 123456789&lt;script&gt; var box1 = document.getElementsByTagName(&quot;div&quot;)[0]; //通过cssText一次性设置行内样式 box1.style.cssText = &quot;width: 300px;height: 300px;background-color: green;&quot;; console.log(box1.style.cssText); //这一行更加可以理解,style是对象&lt;/script&gt; 打印结果： style的常用属性style的常用属性包括： backgroundColor backgroundImage color width height border opacity 设置透明度 (IE8以前是filter: alpha(opacity=xx)) 注意DOM对象style的属性和标签中style内的值不一样，因为在JS中，-不能作为标识符。比如： DOM中：backgroundColor CSS中：background-color style属性的举例我们针对上面列举的几个style的样式，来举几个例子： 1、改变div的大小和透明度 2、当前输入的文本框高亮显示 3、高级隔行变色、高亮显示 4、百度皮肤 （继续下面PPT） 显示隐藏/关闭广告/显示二维码（隐藏方法） 提高层级 下面来逐一实现。 举例1：改变div的大小和透明度代码举例： 12345678910111213141516&lt;body&gt;&lt;div style=&quot;width: 100px;height: 100px;background-color: pink;&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function () &#123; div.style.width = &quot;200px&quot;; div.style.height = &quot;200px&quot;; div.style.backgroundColor = &quot;black&quot;; div.style.opacity = &quot;0.2&quot;; //设置背景色的透明度。单位是0.1 div.style.filter = &quot;alpha(opacity=20)&quot;; //上一行代码的兼容性写法。注意单位是百进制 &#125;&lt;/script&gt;&lt;/body&gt; 举例2：当前输入的文本框高亮显示代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; input &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;text&quot;/&gt;&lt;/ul&gt;&lt;script&gt; //需求：让所有的input标签获取焦点后高亮显示 //1.获取事件源 var inpArr = document.getElementsByTagName(&quot;input&quot;); //2.绑定事件 //3.书写事件驱动程序 for (var i = 0; i &lt; inpArr.length; i++) &#123; //获取焦点后，所有的input标签被绑定onfocus事件 inpArr[i].onfocus = function () &#123; this.style.border = &quot;2px solid red&quot;; this.style.backgroundColor = &quot;#ccc&quot;; &#125; //绑定onblur事件，取消样式 inpArr[i].onblur = function () &#123; this.style.border = &quot;&quot;; this.style.backgroundColor = &quot;&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 举例3：高级隔行变色、高亮显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; text-align: center; &#125; .wrap &#123; width: 500px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 500px; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff; &#125; td &#123; font: 14px &quot;微软雅黑&quot;; &#125; tbody tr &#123; background-color: #f0f0f0; cursor: pointer; &#125; .current &#123; background-color: red !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;课程&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;target&quot;&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt;生命贰号&lt;/td&gt; &lt;td&gt;日语&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;td&gt;生命叁号&lt;/td&gt; &lt;td&gt;营销学&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt;生命伍号&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;td&gt;96&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;td&gt;vae&lt;/td&gt; &lt;td&gt;体育&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(&quot;target&quot;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i &lt; trArr.length; i++) &#123; if (i % 2 !== 0) &#123; trArr[i].style.backgroundColor = &quot;#a3a3a3&quot;; &#125; else &#123; trArr[i].style.backgroundColor = &quot;#ccc&quot;; &#125; //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） var myColor = &quot;&quot;; trArr[i].onmouseover = function () &#123; //赋值颜色之前，先记录颜色 myColor = this.style.backgroundColor; this.style.backgroundColor = &quot;#fff&quot;; &#125; trArr[i].onmouseout = function () &#123; this.style.backgroundColor = myColor; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果如下： 代码解释： 上方代码中，我们用到了计数器myColor来记录每一行最原始的颜色（赋值白色之前）。如果不用计数器，可能很多人以为代码是写的：（错误的代码） 1234567891011121314151617181920212223242526&lt;script&gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(&quot;target&quot;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i &lt; trArr.length; i++) &#123; if (i % 2 !== 0) &#123; trArr[i].style.backgroundColor = &quot;#a3a3a3&quot;; &#125; else &#123; trArr[i].style.backgroundColor = &quot;#ccc&quot;; &#125; //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） trArr[i].onmouseover = function () &#123; this.style.backgroundColor = &quot;#fff&quot;; &#125; trArr[i].onmouseout = function () &#123; this.style.backgroundColor = &quot;#a3a3a3&quot;; &#125; &#125;&lt;/script&gt; 这种错误的代码，实现的效果却是：（未达到效果） js 访问css属性访问行内的css样式，有两种方式： 方式一： 123box.style.widthbox.style.top 方式二： 123元素.style[&quot;属性&quot;]; //格式box.style[&quot;width&quot;]; //举例 方式二最大的优点是：可以给属性传递参数。 获取css的样式上面的内容中，我们通过box1.style.属性只能获得行内样式的属性。可如果我们想获取内嵌或者外链的样式，该怎么办呢？ （1）w3c的做法： 1window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;); 两个参数都是必须要有的，如果没有伪类就用 null 代替。 （2）IE和opera的做法： 1obj.currentStyle; 于是，就有了一种兼容性的写法，同时将其封装。代码举例如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; background-color: pink; /*border: 1px solid #000;*/ padding: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;width: 100px;height: 100px;&quot;&gt;&lt;/div&gt;&lt;script&gt; //赋值：div.style..... var div1 = document.getElementsByTagName(&quot;div&quot;)[0]; console.log(getStyle(div1, &quot;width&quot;)); console.log(getStyle(div1, &quot;padding&quot;)); console.log(getStyle(div1, &quot;background-color&quot;)); //兼容方法获取元素样式 function getStyle(ele, attr) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(ele, null)[attr]; &#125; return ele.currentStyle[attr]; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/05-DOM操作练习：访问关系的封装","date":"2021-08-06T01:17:25.804Z","updated":"2021-07-28T07:34:11.351Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/05-DOM操作练习：访问关系的封装/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/05-DOM%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%85%B3%E7%B3%BB%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"访问关系的函数封装（1）函数封装 新建一个文件名叫tools.js，然后在里面封装访问关系。代码如下。 tools.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Created by smyhvae on 2018/01/28. */function getEle(id)&#123; return document.getElementById(id);&#125;/** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getFirstNode(ele)&#123; var node = ele.firstElementChild || ele.firstChild; return node;&#125;/** * 功能：给定元素查找他的最后一个元素子节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getLastNode(ele)&#123; return ele.lastElementChild || ele.lastChild;&#125;/** * 功能：给定元素查找他的下一个元素兄弟节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getNextNode(ele)&#123; return ele.nextElementSibling || ele.nextSibling;&#125;/** * 功能：给定元素查找他的上一个兄弟元素节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getPrevNode(ele)&#123; return ele.previousElementSibling || ele.previousSibling;&#125;/** * 功能：给定元素和索引值查找指定索引值的兄弟元素节点，并返回 * @param ele 元素节点 * @param index 索引值 * @returns &#123;*|HTMLElement&#125; */function getEleOfIndex(ele,index)&#123; return ele.parentNode.children[index];&#125;/** * 功能：给定元素查找他的所有兄弟元素，并返回数组 * @param ele * @returns &#123;Array&#125; */function getAllSiblings(ele)&#123; //定义一个新数组，装所有的兄弟元素，将来返回 var newArr = []; var arr = ele.parentNode.children; for(var i=0;i&lt;arr.length;i++)&#123; //判断：对同级的所有元素节点进行遍历，如果不是传递过来的元素自身，那就是兄弟元素，于是添加到新数组中。 if(arr[i]!==ele)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 上方代码中，我们单独来重视一下最后一个方法：获取指定元素的兄弟元素： 123456789101112131415161718/** * 功能：给定元素查找他的所有兄弟元素，并返回数组 * @param ele * @returns &#123;Array&#125; */function getAllSiblings(ele)&#123; //定义一个新数组，装所有的兄弟元素，将来返回 var newArr = []; var arr = ele.parentNode.children; for(var i=0;i&lt;arr.length;i++)&#123; //判断：对同级的所有元素节点进行遍历，如果不是传递过来的元素自身，那就是兄弟元素，于是添加到新数组中。 if(arr[i]!==ele)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; （2）函数的调用举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; li &#123; width: 100px; height: 100px; background-color: pink; margin: 5px; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li id=&quot;box&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script src=&quot;tools.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //获取box改为red var box = getEle(&quot;box&quot;); box.style.backgroundColor = &quot;red&quot; //获取第一个和最后一个子节点 var parent = box.parentNode; getFirstNode(parent).style.backgroundColor = &quot;yellow&quot;; getLastNode(parent).style.backgroundColor = &quot;yellow&quot;; //获取上一个和下一个兄弟节点 getNextNode(box).style.backgroundColor = &quot;blue&quot;; getPrevNode(box).style.backgroundColor = &quot;blue&quot;; //指定兄弟节点 getEleOfIndex(box,0).style.backgroundColor = &quot;green&quot;; getEleOfIndex(box,1).style.backgroundColor = &quot;green&quot;; //获取所有的兄弟节点（返回值是数组，所以用for循环操作） var arr = getAllSiblings(box); for(var i=0;i&lt;arr.length;i++)&#123; arr[i].style.backgroundColor = &quot;green&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：上方代码中，我们引用到了tools.js这个工具类。 12 12 12","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/04-DOM操作练习：Tab栏切换（通过className设置样式）","date":"2021-08-06T01:17:25.802Z","updated":"2021-07-28T07:34:11.351Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/04-DOM操作练习：Tab栏切换（通过className设置样式）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/04-DOM%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0%EF%BC%9ATab%E6%A0%8F%E5%88%87%E6%8D%A2%EF%BC%88%E9%80%9A%E8%BF%87className%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%EF%BC%89/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 京东网页上，可以看到下面这种tab栏的切换： 我们把模型抽象出来，实现一下。 举例引入：鼠标悬停时，current元素的背景变色 本段我们先举一个例子，因为这里用到了排他思想（先干掉 all，然后保留我一个）。对于理解tab切换，很有帮助。 完整的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; button &#123; margin: 10px; width: 100px; height: 40px; cursor: pointer; &#125; .current &#123; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;button&gt;按钮4&lt;/button&gt;&lt;button&gt;按钮5&lt;/button&gt;&lt;script&gt; //需求：鼠标放到哪个button上，改button变成黄色背景（添加类） var btnArr = document.getElementsByTagName(&quot;button&quot;); //绑定事件 for(var i=0;i&lt;btnArr.length;i++)&#123; //要为每一个按钮绑定事件，所以用到了for循环 btnArr[i].onmouseover = function () &#123; //【重要】排他思想：先把所有按钮的className设置为空，然后把我（this）这个按钮的className设置为current //排他思想和for循环连用 for(var j=0;j&lt;btnArr.length;j++)&#123; btnArr[j].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; //【重要】核心代码 &#125; &#125; //鼠标离开current时，还原背景色 for(var i=0;i&lt;btnArr.length;i++)&#123; //要为每一个按钮绑定事件，所以用到了for循环 btnArr[i].onmouseout = function () &#123; //鼠标离开任何一个按钮时，就把按钮的背景色还原 this.className = &quot;&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： 鼠标悬停时，current栏变色，这里用到了排他思想：先把所有按钮的className设置为空，然后把我(this)这个按钮的className设置为current，就可以达到变色的效果。核心代码是： 123456//排他思想：先把所有按钮的className设置为空，然后把我（this）这个按钮的className设置为current//排他思想和for循环连用for(var j=0;j&lt;btnArr.length;j++)&#123; btnArr[j].className = &quot;&quot;;&#125;this.className = &quot;current&quot;; 实现的效果如下： tab切换：初步的代码代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 500px; height: 200px; border: 1px solid #ccc; margin: 50px auto; overflow: hidden; &#125; ul &#123; width: 600px; height: 40px; margin-left: -1px; list-style: none; &#125; li &#123; float: left; width: 101px; height: 40px; text-align: center; font: 600 18px/40px &quot;simsun&quot;; background-color: pink; cursor: pointer; &#125; span &#123; display: none; width: 500px; height: 160px; background-color: yellow; text-align: center; font: 700 100px/160px &quot;simsun&quot;; &#125; .show &#123; display: block; &#125; .current &#123; background-color: yellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：鼠标放到上面的li上，li本身变色(添加类)，对应的span也显示出来(添加类); //思路：1.点亮上面的盒子。 2.利用索引值显示下面的盒子。 var liArr = document.getElementsByTagName(&quot;li&quot;); var spanArr = document.getElementsByTagName(&quot;span&quot;); for(var i=0;i&lt;liArr.length;i++)&#123; //绑定索引值（新增一个自定义属性：index属性） liArr[i].index = i; liArr[i].onmouseover = function () &#123; //1.点亮上面的盒子。 2.利用索引值显示下面的盒子。(排他思想) for(var j=0;j&lt;liArr.length;j++)&#123; liArr[j].className = &quot;&quot;; spanArr[j].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; spanArr[this.index].className = &quot;show&quot;; //【重要代码】 &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;鞋子&lt;/li&gt; &lt;li&gt;袜子&lt;/li&gt; &lt;li&gt;帽子&lt;/li&gt; &lt;li&gt;裤子&lt;/li&gt; &lt;li&gt;裙子&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;show&quot;&gt;鞋子&lt;/span&gt; &lt;span&gt;袜子&lt;/span&gt; &lt;span&gt;帽子&lt;/span&gt; &lt;span&gt;裤子&lt;/span&gt; &lt;span&gt;裙子&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 上方代码的核心部分是： 123456789101112131415for(var i=0;i&lt;liArr.length;i++)&#123; //绑定索引值（新增一个自定义属性：index属性） liArr[i].index = i; liArr[i].onmouseover = function () &#123; //1.点亮上面的盒子。 2.利用索引值显示下面的盒子。(排他思想) for(var j=0;j&lt;liArr.length;j++)&#123; liArr[j].className = &quot;&quot;; spanArr[j].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; spanArr[this.index].className = &quot;show&quot;; //【重要代码】 &#125;&#125; 这段代码中，我们是通过给 liArr[i]一个index属性： liArr[i].index = i，然后让下方的span对应的index也随之对应显示：spanArr[this.index].className = &quot;show&quot;。 这样做比较难理解，其实还有一种容易理解的方法是：给liArr[i]增加index属性时，通过attribute的方式，因为这种方式增加的属性是可以显示在标签上的。也就有了下面这样的代码： 123456789101112131415for(var i=0;i&lt;liArr.length;i++)&#123; //绑定索引值(自定义属性)，通过Attribute的方式【重要】 liArr[i].setAttribute(&quot;index&quot;,i); liArr[i].onmouseover = function () &#123; //3.书写事件驱动程序（排他思想） //1.点亮盒子。 2.利用索引值显示盒子。(排他思想) for(var j=0;j&lt;liArr.length;j++)&#123; liArr[j].removeAttribute(&quot;class&quot;); spanArr[j].removeAttribute(&quot;class&quot;); &#125; this.setAttribute(&quot;class&quot;,&quot;current&quot;); spanArr[this.getAttribute(&quot;index&quot;)].setAttribute(&quot;class&quot;,&quot;show&quot;); &#125;&#125; 显示的效果是一样的，不同的地方在于，我们审查元素发现，li标签中确实新增了自定义的index属性： 本段中，我们的目的已经达到了，不足的地方在于，本段中的代码是通过document获取的的标签，如果网页中有很多个这种tab选项卡，必然互相影响。 为了多个tab栏彼此独立，我们就需要通过封装函数的方式把他们抽取出来，于是就有了下面的改进版代码。 tab切换：改进版代码（函数封装）方式一：给current标签设置index值【推荐的代码】完整版代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 500px; height: 200px; border: 1px solid #ccc; margin: 50px auto; overflow: hidden; &#125; ul &#123; width: 600px; height: 40px; margin-left: -1px; list-style: none; &#125; li &#123; float: left; width: 101px; height: 40px; text-align: center; font: 600 18px/40px &quot;simsun&quot;; background-color: pink; cursor: pointer; &#125; span &#123; display: none; width: 500px; height: 160px; background-color: yellow; text-align: center; font: 700 100px/160px &quot;simsun&quot;; &#125; .show &#123; display: block; &#125; .current &#123; background-color: yellow; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：鼠标放到上面的li上，li本身变色(添加类)，下方对应的span也显示出来(添加类); //思路：1.点亮上面的盒子。 2.利用索引值显示下面的对应的盒子。 //1、获取所有的box var boxArr = document.getElementsByClassName(&quot;box&quot;); //让每一个box都调用函数 for (var i = 0; i &lt; boxArr.length; i++) &#123; fn(boxArr[i]); &#125; function fn(element) &#123; var liArr = element.getElementsByTagName(&quot;li&quot;); //注意，是element获取事件源，不是document获取事件源 var spanArr = element.getElementsByTagName(&quot;span&quot;); //2.绑定事件（循环绑定） for (var i = 0; i &lt; liArr.length; i++) &#123; //绑定索引值（新增一个自定义属性：index属性） liArr[i].index = i; liArr[i].onmouseover = function () &#123; //3.书写事件驱动程序（排他思想） //1.点亮上面的盒子。 2.利用索引值显示下面的盒子。(排他思想) for (var j = 0; j &lt; liArr.length; j++) &#123; liArr[j].className = &quot;&quot;; spanArr[j].className = &quot;&quot;; &#125; this.className = &quot;current&quot;; spanArr[this.index].className = &quot;show&quot;; //【重要】核心代码 &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;鞋子&lt;/li&gt; &lt;li&gt;袜子&lt;/li&gt; &lt;li&gt;帽子&lt;/li&gt; &lt;li&gt;裤子&lt;/li&gt; &lt;li&gt;裙子&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;show&quot;&gt;鞋子&lt;/span&gt; &lt;span&gt;袜子&lt;/span&gt; &lt;span&gt;帽子&lt;/span&gt; &lt;span&gt;裤子&lt;/span&gt; &lt;span&gt;裙子&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;鞋子&lt;/li&gt; &lt;li&gt;袜子&lt;/li&gt; &lt;li&gt;帽子&lt;/li&gt; &lt;li&gt;裤子&lt;/li&gt; &lt;li&gt;裙子&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;show&quot;&gt;鞋子&lt;/span&gt; &lt;span&gt;袜子&lt;/span&gt; &lt;span&gt;帽子&lt;/span&gt; &lt;span&gt;裤子&lt;/span&gt; &lt;span&gt;裙子&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;鞋子&lt;/li&gt; &lt;li&gt;袜子&lt;/li&gt; &lt;li&gt;帽子&lt;/li&gt; &lt;li&gt;裤子&lt;/li&gt; &lt;li&gt;裙子&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;show&quot;&gt;鞋子&lt;/span&gt; &lt;span&gt;袜子&lt;/span&gt; &lt;span&gt;帽子&lt;/span&gt; &lt;span&gt;裤子&lt;/span&gt; &lt;span&gt;裙子&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意，通过函数fn的封装之后，我们是通过参数element获取元素，而不再是document了。这样可以达到“抽象性”的作用，各个tab栏之间相互独立。 上方代码中，我们是通过给 liArr[i]一个index属性： liArr[i].index = i，然后让下方的span对应的index也随之对应显示：spanArr[this.index].className = &quot;show&quot;。 这样做比较难理解，根据上一段的规律，当然还有一种容易理解的方法是：给liArr[i]增加index属性时，通过attribute的方式，因为这种方式增加的属性是可以显示在标签上的。也就有了下面的方式二。 方式二：通过attribute设置index的值基于上面方式一中的代码，我们修改一下js部分的代码，其他部分的代码保持不变。js部分的代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; window.onload = function () &#123; //需求：鼠标放到上面的li上，li本身变色(添加类)，下方对应的span也显示出来(添加类); //思路：1.点亮上面的盒子。 2.利用索引值显示下面的对应的盒子。 //1、获取所有的box var boxArr = document.getElementsByClassName(&quot;box&quot;); //让每一个box都调用函数 for (var i = 0; i &lt; boxArr.length; i++) &#123; fn(boxArr[i]); &#125; function fn(element) &#123; var liArr = element.getElementsByTagName(&quot;li&quot;); //注意，是element获取事件源，不是document获取事件源 var spanArr = element.getElementsByTagName(&quot;span&quot;); //2.绑定事件（循环绑定） for (var i = 0; i &lt; liArr.length; i++) &#123; //绑定索引值(自定义属性) liArr[i].setAttribute(&quot;index&quot;, i); liArr[i].onmouseover = function () &#123; //3.书写事件驱动程序（排他思想） //1.点亮盒子。 2.利用索引值显示盒子。(排他思想) for (var j = 0; j &lt; liArr.length; j++) &#123; liArr[j].removeAttribute(&quot;class&quot;); //注意，这里是class，不是className spanArr[j].removeAttribute(&quot;class&quot;); &#125; this.setAttribute(&quot;class&quot;, &quot;current&quot;); spanArr[this.getAttribute(&quot;index&quot;)].setAttribute(&quot;class&quot;, &quot;show&quot;); &#125; &#125; &#125; &#125;&lt;/script&gt; 不过，方式一的写法应该比方式二更常见。 总结：通过函数封装的形式，可以保证各个tab栏之间的切换互不打扰。最终实现效果如下： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/03-DOM操作练习：基础练习","date":"2021-08-06T01:17:25.800Z","updated":"2021-07-28T07:34:11.350Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/03-DOM操作练习：基础练习/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/03-DOM%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/","excerpt":"","text":"DOM操作练习举例1：点击按钮时，显示和隐藏盒子。代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; button &#123; margin: 10px; &#125; div &#123; width: 200px; height: 200px; background-color: pink; &#125; .show &#123; display: block; &#125; .hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;隐藏&lt;/button&gt;&lt;div&gt; 生命壹号&lt;/div&gt;&lt;script&gt; //需求：点击button,隐藏盒子。改变文字，在点击按钮，显示出来。 //步骤： //1.获取事件源和相关元素 //2.绑定事件 //3.书写事件驱动程序 //1.获取事件源和相关元素 var btn = document.getElementById(&quot;btn&quot;); var div1 = document.getElementsByTagName(&quot;div&quot;)[0]; //2.绑定事件 btn.onclick = function () &#123; //3.书写事件驱动程序 //判断btn的innerHTML属性值，如果为隐藏就隐藏盒子，并修改按钮内容为显示。 //反之，则显示，并修改按钮内容为隐藏 if (this.innerHTML === &quot;隐藏&quot;) &#123; div1.className = &quot;hide&quot;; //修改按钮上的文字（innerHTML） btn.innerHTML = &quot;显示&quot;; &#125; else &#123; div1.className = &quot;show&quot;; //修改按钮上的文字（innerHTML） btn.innerHTML = &quot;隐藏&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： 当盒子是显示状态时，就设置为隐藏；当盒子是隐藏状态时，就设置为显示。注意这里的逻辑判断。 另外，这里用到了innerHTHL属性，它可以修改按钮上显示的文字。 代码最终显示的效果如下： 20180127_1518.gif 举例2：美女相册这里推荐一个网站： 占位图片生成的在线网站：https://placeholder.com/ 好处是：素材做出来之前，先留出空位，方便以后换图。比如http://via.placeholder.com/400x300这个链接可以生成400*300的占位图片。 需求： （1）点击小图片，改变下面的大图片的src属性值，让其赋值为a链接中的href属性值。 （2）让p标签的innnerHTML属性值，变成a标签的title属性值。 为了实现美女相册，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; font-family: &quot;Helvetica&quot;, &quot;Arial&quot;, serif; color: #333; margin: 1em 10%; &#125; h1 &#123; color: #333; background-color: transparent; &#125; a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none; &#125; ul &#123; padding: 0; &#125; li &#123; float: left; padding: 1em; list-style: none; &#125; #imagegallery &#123; list-style: none; &#125; #imagegallery li &#123; margin: 0px 20px 20px 0px; padding: 0px; display: inline; &#125; #imagegallery li a img &#123; border: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt; 美女画廊&lt;/h2&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;ul id=&quot;imagegallery&quot;&gt; &lt;li&gt; &lt;a href=&quot;image/1.jpg&quot; title=&quot;美女A&quot;&gt; &lt;img src=&quot;image/1-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女1&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;image/2.jpg&quot; title=&quot;美女B&quot;&gt; &lt;img src=&quot;image/2-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女2&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;image/3.jpg&quot; title=&quot;美女C&quot;&gt; &lt;img src=&quot;image/3-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女3&quot;/&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;image/4.jpg&quot; title=&quot;美女D&quot;&gt; &lt;img src=&quot;image/4-small.jpg&quot; width=&quot;100&quot; alt=&quot;美女4&quot;/&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;&lt;img id=&quot;image&quot; src=&quot;image/placeholder.png&quot; width=&quot;450px&quot;/&gt;&lt;p id=&quot;des&quot;&gt;选择一个图片&lt;/p&gt;&lt;script&gt; //需求： //（1）点击小图片，改变下面的大图片的src属性值，让其赋值为a链接中的href属性值。 //（2）让p标签的innnerHTML属性值，变成a标签的title属性值。 //1.获取事件源和相关元素 //利用元素获取其下面的标签。 var ul = document.getElementById(&quot;imagegallery&quot;); var aArr = ul.getElementsByTagName(&quot;a&quot;); //获取ul中的超链接&lt;a&gt; // console.log(aArr[0]); var img = document.getElementById(&quot;image&quot;); var des = document.getElementById(&quot;des&quot;); //2.绑定事件 //以前是一个一个绑定，但是现在是一个数组。我们用for循环绑定 for (var i = 0; i &lt; aArr.length; i++) &#123; aArr[i].onclick = function () &#123; //3.【核心代码】书写事件驱动程序：修改属性值 img.src = this.href; //this指的是函数调用者，和i并无关系，所以不会出错。// img.src = aArr[i].href; 注意，上面这一行代码不要写成这样 des.innerHTML = this.title; return false; //return false表示：阻止继续执行下面的代码。 &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： （1）获取事件源：我们通过ul.getElementsByTagName(&quot;a&quot;)来获取ul里面的a元素。 （2）绑定事件：因为要绑定一个数组，所以这里用for循环来绑定 （3）【重要】书写事件驱动程序：这里是用img.src = this.href，而不是用img.src = aArr[i].href。因为this指的是函数的调用者。如果写成后者，等i变成了4，就会一直是4。显然不能达到效果。 （4）代码的最后一行：return false表示：阻止继续执行下面的代码。 实现的效果如下： 20180127_1630.gif 工程文件： 2018-01-27-美女相册demo.rar 举例3：鼠标悬停时，显示二维码大图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .code &#123; width: 50px; height: 50px; &#125; .code a &#123; display: block; width: 50px; height: 50px; background: url(http://img.smyhvae.com/20180127_QRcode_small.png) no-repeat -159px -51px; position: relative; &#125; .code-big &#123; position: absolute; top: 10px; left: 80px; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求：鼠标放到a链接上，显示二维码（添加show类名，去掉hide类名） // 鼠标移开a链接，隐藏二维码（添加hide类名，去掉show类名） //1.获取事件源和相关元素 var a = document.getElementsByTagName(&quot;a&quot;)[0]; var div = document.getElementsByClassName(&quot;code-big&quot;)[0]; //2.绑定事件 a.onmouseover = fn1; //鼠标悬停时 a.onmouseout = fn2; //鼠标离开时 //定义方法 function fn1() &#123; //3.书写事件驱动程序 div.className = &quot;code-big show&quot;; //div.className = div.className.replace(&quot;hide&quot;, &quot;show&quot;); &#125; function fn2() &#123; div.className = &quot;code-big hide&quot;; //了解,字符串操作，把字符串中的hide替换成show。 // div.className = div.className.replace(&quot;show&quot;,&quot;hide&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;code&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; &lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot; alt=&quot;&quot; class=&quot;code-big hide&quot;/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 20180127_1800.gif 表单元素的属性表单元素的属性包括：type、value、checked、selected、disabled等。 举例1：禁用文本框/解禁文本框123456789101112131415161718192021&lt;body&gt;账号: &lt;input type=&quot;text&quot; value=&quot;生命壹号...&quot;/&gt;&lt;button&gt;禁用&lt;/button&gt;&lt;button&gt;解禁&lt;/button&gt;&lt;br&gt;&lt;br&gt;密码: &lt;input type=&quot;password&quot; value=&quot;aaabbbccc&quot;/&gt;&lt;script&gt; var inp = document.getElementsByTagName(&quot;input&quot;)[0]; var btn1 = document.getElementsByTagName(&quot;button&quot;)[0]; var btn2 = document.getElementsByTagName(&quot;button&quot;)[1]; btn1.onclick = function () &#123; inp.disabled = &quot;no&quot;; //禁用文本框。属性值里随便写什么字符串都行，但不能为空。 &#125; btn2.onclick = function () &#123; inp.disabled = false; //解禁文本框。让disabled属性消失即可。// inp.removeAttribute(&quot;disabled&quot;); &#125;&lt;/script&gt;&lt;/body&gt; 当文本框被禁用之后，文本框只读，不能编辑，光标点不进去。 上方代码可以看到，禁用文本框的代码是： 1inp.disabled = &quot;no&quot;; //让disabled属性出现，即可禁用 我们的目的时让disabled这个属性出现，即可禁用。所以，属性值里可以写数字，可以写任意一个字符串，但不能写0，不能写false，不能为空。一般我们写no。 解禁文本框的代码是： 123inp.disabled = false; // 方法1：让disabled属性消失，即可解禁。inp.removeAttribute(&quot;disabled&quot;); //方法2：推荐 我们的目的是删除disabled属性，即可解禁。属性值可以是false，可以是0。但我们一般采用方式2进行解禁。 实现效果： 举例2：文本框获取焦点/失去焦点细心的读者会发现，京东和淘宝的搜索框，获取焦点时，提示文字的体验是不同的。 京东： 20180127_2000.gif 淘宝： 20180127_2005.gif 其实，淘宝的提示文字，是用一个绝对定位的单独的标签来做的。 京东是判断输入框是否获取焦点；淘宝是判断输入框内是否有用户输入的文字。 我们现在来实现一下。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; input &#123; width: 300px; height: 36px; padding-left: 5px; color: #ccc; &#125; label &#123; position: absolute; top: 82px; left: 56px; font-size: 12px; color: #ccc; cursor: text; &#125; .hide &#123; display: none; &#125; .show &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;京东: &lt;input id=&quot;inp1&quot; type=&quot;text&quot; value=&quot;微单相机&quot;/&gt;&lt;br&gt;&lt;br&gt;淘宝: &lt;label for=&quot;inp2&quot;&gt;电动牙刷&lt;/label&gt;&lt;input id=&quot;inp2&quot; type=&quot;text&quot;/&gt;&lt;br&gt;&lt;br&gt;placeholder: &lt;input type=&quot;text&quot; placeholder=&quot;我是placeholder&quot;/&gt;&lt;script&gt; //需求：京东的input按钮获取焦点后，立刻删除内容。失去后光标显示文字。 var inp1 = document.getElementById(&quot;inp1&quot;); inp1.onfocus = function () &#123; //判断，如果input里面的内容是“微单相机”，那么把值赋值为“”； if (this.value === &quot;微单相机&quot;) &#123; inp1.value = &quot;&quot;; inp1.style.color = &quot;#000&quot;; &#125; &#125; //失去焦点事件 inp1.onblur = function () &#123; //判断：如果input内容为空，那么把内容赋值为微单相机。 if (this.value === &quot;&quot;) &#123; inp1.value = &quot;微单相机&quot;; inp1.style.color = &quot;#ccc&quot;; &#125; &#125; //需求：在input中输入文字，label标签隐藏；当里面的文字变成空字符串，label显示。 var inp2 = document.getElementById(&quot;inp2&quot;); var lab = document.getElementsByTagName(&quot;label&quot;)[0]; //2.绑定事件(输入文字、和删除文字时，都会触动这个事件) inp2.oninput = function () &#123; //判断input中的值是否为空，如果为空，那么label显示，否则隐藏。 if (this.value === &quot;&quot;) &#123; lab.className = &quot;show&quot;; &#125; else &#123; lab.className = &quot;hide&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下： 20180127_2010.gif 如上方所示，我们还可以用placeholder来做，但是IE678并不支持，所以不建议使用。 举例3：用户注册信息错误时，输入框失去焦点后，高亮显示。代码实现： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .wrong &#123; border: 2px solid red; &#125; .right &#123; border: 2px solid #91B81D; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;账号：&lt;input type=&quot;text&quot; onblur=&quot;fn(this)&quot;/&gt;&lt;br&gt;&lt;br&gt;密码：&lt;input type=&quot;password&quot; onblur=&quot;fn(this)&quot;/&gt;&lt;script&gt; //需求：失去焦点的时候判断input按钮中的值，如果账号或密码在6-12个字符之间通过，否则报错。 function fn(aaa)&#123; //html中的input标签行内调用function的时候,是先通过window调用的function，所以打印this等于打印window// console.log(this) //只有传递的this才指的是标签本身。// console.log(aaa)// console.log(this.value) if(aaa.value.length &lt; 6 || aaa.value.length&gt;12)&#123; aaa.className = &quot;wrong&quot;; &#125;else&#123; aaa.className = &quot;right&quot;; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解释：这次我们是在标签内调用function的，此时是先通过window调用的function。所以行内调用的时候要带this。 实现效果： 20180127_2035.gif 举例4：全选和反选对应的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .my-table &#123; width: 300px; margin: 100px auto 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 300px; &#125; th, td &#123; border: 1px solid #d0d0d0; color: #404060; padding: 10px; &#125; th &#123; background-color: #09c; font: bold 16px &quot;微软雅黑&quot;; color: #fff; &#125; td &#123; font: 14px &quot;微软雅黑&quot;; &#125; tbody tr &#123; background-color: #f0f0f0; &#125; tbody tr:hover &#123; cursor: pointer; background-color: #fafafa; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; //需求1：点击上面的的input，下面全选或者反选。 //思路：获取了上面的input按钮，只需要判断，checked属性是true还是false，如果是true，下面的全部变成true；false同理。 var topInp = document.getElementById(&quot;title&quot;); var tbody = document.getElementById(&quot;content&quot;); var botInpArr = tbody.getElementsByTagName(&quot;input&quot;); //绑定事件 topInp.onclick = function () &#123; //费劲版// for(var i=0;i&lt;botInpArr.length;i++)&#123;// if(topInp.checked === true)&#123;// botInpArr[i].checked = true;// &#125;else&#123;// botInpArr[i].checked = false;// &#125;// &#125; //优化版（被点击的input按钮的checked属性值，应该直接作为下面的所有的input按钮的checked属性值） for(var i=0;i&lt;botInpArr.length;i++)&#123; botInpArr[i].checked = this.checked; &#125; &#125; //需求2：点击下面的的input，如果下面的全部选定了，上面的全选，否则相反。 //思路：为下面的每一个input绑定事件，每点击一次都判断所有的按钮 // checked属性值是否全部都是true，如果有一个是false， // 那么上面的input的checked属性也是false;都是true，topInp的checked就是true； for(var i=0;i&lt;botInpArr.length;i++)&#123; botInpArr[i].onclick = function () &#123; //每一个input都要绑定事件 //开闭原则（用开关来控制） var bool = true; //检测每一个input的checked属性值。 for(var j=0;j&lt;botInpArr.length;j++)&#123; if(botInpArr[j].checked === false)&#123; bool = false; &#125; &#125; topInp.checked = bool; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;my-table&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;title&quot; /&gt; &lt;/th&gt; &lt;th&gt;菜名&lt;/th&gt; &lt;th&gt;饭店&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;菜品1&lt;/td&gt; &lt;td&gt;木屋烧烤&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;菜品2&lt;/td&gt; &lt;td&gt;蒸菜馆&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;菜品3&lt;/td&gt; &lt;td&gt;海底捞火锅&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; /&gt; &lt;/td&gt; &lt;td&gt;菜品4&lt;/td&gt; &lt;td&gt;面点王&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意代码中的注释，需求2是比较难的地方，这里用到了两次for循环。第一次for循环是因为，要给每个input都要进行绑定事件。 实现的效果如下： 20180127_2320.gif 1","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/02-CSS基础练习：JD首页的制作（快捷导航部分）","date":"2021-08-06T01:17:25.798Z","updated":"2021-07-28T07:34:11.350Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/02-CSS基础练习：JD首页的制作（快捷导航部分）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/02-CSS%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%EF%BC%9AJD%E9%A6%96%E9%A1%B5%E7%9A%84%E5%88%B6%E4%BD%9C%EF%BC%88%E5%BF%AB%E6%8D%B7%E5%AF%BC%E8%88%AA%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"","text":"02-CSS基础练习：JD首页的制作（快捷导航部分） 我们在上一篇文章中制作的网页最顶部的导航，是属于网页导航。 本文中，Banner图上方的导航，叫做快捷导航（shortcut）。 ##快捷导航的骨架 我们先制作快捷导航的骨架。如下图所示： 上图中，shortcut-nav-menu-all和shortcut-nav-menu-one都是属于shortcut-nav-menu部分，只不过，后者是将父亲撑破了。 为了实现上图，对应的html代码如下： 1234567891011121314151617181920212223242526272829303132&lt;!--shortcut-nav部分start--&gt;&lt;div class=&quot;shortcut-nav&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;shortcut-nav-menu&quot;&gt; &lt;div class=&quot;shortcut-nav-menu-all&quot;&gt; &lt;a href=&quot;#&quot;&gt;全部商品分类&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;shortcut-nav-menu-one&quot; style=&quot;color: #fff&quot;&gt; 下一段再讲 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shortcut-nav-items&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服装城&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;美妆馆&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;京东超市&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;生鲜&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;全球购&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;闪购&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;团购&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;拍卖&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;金融&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;shortcut-nav-img&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images/img2.jpg&quot;/&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--shortcut-nav部分end--&gt; css代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*shortcut-nav部分start*/.shortcut-nav &#123; height: 44px; border-bottom: 2px solid #B1191A;&#125;.shortcut-nav-menu &#123; /*撑开和撑破是两回事：撑开说明盒子变成那么大，撑破盒子还是那么大，子盒子很大。子盒子shortcut-nav-menu-one把父亲撑破了*/ width: 210px; height: 44px; /*浮动的盒子相互影响，不过是否在同一个盒子中*/ float: left; position: relative; z-index: 1; /*通过z-index属性将层级放到最高*/&#125;.shortcut-nav-menu-all a &#123; display: block; width: 190px; height: 44px; color: white; padding: 0 10px; background-color: #B1191A; font: 400 15px/44px &quot;microsoft yahei&quot;;&#125;.shortcut-nav-menu-one &#123; height: 465px; margin-top: 2px; background-color: #C81623; border-left: 1px solid #B1191A; border-bottom: 1px solid #B1191A; /*border-left: 1px solid #000;*/ /*border-bottom: 1px solid #000;*/&#125;.shortcut-nav-items &#123; width: 730px; height: 44px; float: left;&#125;.shortcut-nav-items li &#123; float: left;&#125;.shortcut-nav-items a &#123; display: inline-block; height: 44px; padding: 0 20px; color: #333; font: 400 16px/44px &quot;microsoft yahei&quot;;&#125;.shortcut-nav-items a:hover &#123; color: #C81623;&#125;.shortcut-nav-img &#123; width: 200px; height: 44px; float: right; margin-top: -10px; margin-right: 50px; /*position: relative;*/ /*left: -50px;*/ /*top: -10px;*/&#125;/*shortcut-nav部分end*/ 具体的商品分类商品的具体分类即shortcut-nav-menu-one部分，我们来实现这部分的代码。要求实现的效果如下： 我们在上面的代码中已经给shortcut-nav-menu-one设置了一些属性（例如给左边和下边增加一个像素的红色边框），在此基础之上，需要新增的代码如下： html代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--具体的商品分类start--&gt;&lt;div class=&quot;shortcut-nav-menu-one&quot; style=&quot;color: #fff&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;家用电器&lt;/a&gt; &lt;i&gt;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;手机&lt;/a&gt; &lt;span&gt;、&lt;/span&gt; &lt;a href=&quot;&quot;&gt;数码&lt;/a&gt; &lt;i&gt;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;电脑&lt;/a&gt; &lt;span&gt;、&lt;/span&gt; &lt;a href=&quot;&quot;&gt;办公&lt;/a&gt; &lt;i&gt;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;家居&lt;/a&gt; &lt;span&gt;、&lt;/span&gt; &lt;a href=&quot;&quot;&gt;家具&lt;/a&gt; &lt;i&gt;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt;男装&lt;/a&gt; &lt;span&gt;、&lt;/span&gt; &lt;a href=&quot;&quot;&gt;女装&lt;/a&gt; &lt;i&gt;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--具体的商品分类end--&gt; css部分如下： 1234567891011121314151617181920212223242526/*具体的商品分类start*/.shortcut-nav-menu-one ul &#123; font: 400 14px/31px &quot;microsoft yahei&quot;; /*字体属性具有继承性，让儿子 a 具有此继承性*/&#125;.shortcut-nav-menu-one li &#123; padding-left: 10px; position: relative;&#125;.shortcut-nav-menu-one a&#123; color: #fff;&#125;.shortcut-nav-menu-one i &#123; right: 10px; position: absolute;&#125;.shortcut-nav-menu-one li:hover &#123; background-color: #fff;&#125;.shortcut-nav-menu-one li:hover a,span,i&#123; color: #C81623;&#125;/*具体的商品分类end*/ 轮播图slider + 京东快报接下来，我们要实现下面这个部分： 组成部分包括：左侧的轮播图、右侧的京东快报 &amp; 充话费 &amp; 右下角的小海报。 结构如下： 1234567891011121314151617181920212223&lt;!--main部分start--&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;main-slider&quot;&gt; &lt;/div&gt; &lt;div class=&quot;main-news&quot;&gt; &lt;div class=&quot;main-news-top&quot;&gt; &lt;!--京东快报+充话费--&gt; &lt;div class=&quot;main-news-top-faster&quot;&gt; &lt;!--京东快报--&gt; &lt;/div&gt; &lt;div class=&quot;main-news-top-money&quot;&gt; &lt;!--充话费--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main-news-bottom&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--main部分end--&gt; 我们依次来讲解。 1、轮播图：main-slider首页的banner图是首页独有的，所以这部分的css代码要写在index.css里，不要写在base.css里。 html代码如下： 123456789101112131415161718192021222324&lt;!--main部分start--&gt;&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;main-slider&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;images/slider.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;ul&gt; &lt;!--指示点--&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/a&gt; &lt;!--左边的箭头--&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/a&gt; &lt;!--右边的箭头--&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--main部分end--&gt; 注意：超链接 a 标签中，href=&quot;javascript:;表示点击超链接时，什么都不做。 CSS代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.main-slider &#123; float: left; margin: 12px 0 0 220px; width: 730px; height: 454px; position: relative;&#125;.main-slider ul &#123; position: absolute; bottom: 10px; left: 50%; margin-left: -66px;&#125;.main-slider ul li &#123; float: left; width: 18px; height: 18px; color: #fff; background-color: #3E3E3E; border-radius: 50%; /*圆角矩形*/ line-height: 18px; text-align: center; /*让 li 里面的文本水平方向居中*/ margin: 0 2px; cursor: pointer; /*鼠标悬停时变成小手*/&#125;.main-slider .arrow-left &#123; /* 轮播图左侧的箭头*/ position: absolute; top: 50%; margin-top: -31px; left: 0px; width: 28px; height: 62px; background-color: rgba(0,0,0,0.3); color: #fff; font: 400 22px/62px &quot;sumsun&quot;; text-align: center; border-radius: 10px 0 0 10px;&#125;.main-slider .arrow-left:hover &#123; background-color: rgba(0,0,0,0.7);&#125;.main-slider .arrow-right &#123; /*轮播图右侧的箭头*/ position: absolute; top: 50%; margin-top: -31px; right: 0px; width: 28px; height: 62px; background-color: pink; background-color: rgba(0,0,0,0.3); color: #fff; font: 400 22px/62px &quot;sumsun&quot;; text-align: center; border-radius: 10px 0 0 10px;&#125;.main-slider .arrow-right:hover &#123; background-color: rgba(0,0,0,0.7);&#125; 代码解释如下； （1）轮播图，我们采取的方式是：在超链接 a 里面放一个img标签。 （2）指示点：在一个ul中放多个li。然后通过绝对定位的方式，让ul放在轮播图的正中间（水平方向）。最后详细设置每个指示点li的属性（比如，text-align: center属性可以让li里面的文字水平居中）。 （3）左右两边的箭头：鼠标悬停时，颜色不同。我们通过background-color: rgba(0,0,0,0.3)设置背景的透明度。 最终实现的效果如下： 京东快报html代码如下： 1234567891011121314151617&lt;div class=&quot;main-news-top-faster&quot;&gt; &lt;!--京东快报--&gt; &lt;div class=&quot;main-news-top-faster-title&quot;&gt; &lt;h2&gt;京东快报&lt;/h2&gt; &lt;a href=&quot;#&quot;&gt;更多 &gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;main-news-top-faster-content&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;[特惠]&lt;/span&gt;新闻1&lt;/li&gt; &lt;li&gt;&lt;span&gt;[公告]&lt;/span&gt;新闻2&lt;/li&gt; &lt;li&gt;&lt;span&gt;[特惠]&lt;/span&gt;新闻3&lt;/li&gt; &lt;li&gt;&lt;span&gt;[公告]&lt;/span&gt;新闻4&lt;/li&gt; &lt;li&gt;&lt;span&gt;[特惠]&lt;/span&gt;新闻5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; css代码如下； 123456789101112131415161718192021222324252627282930313233343536373839404142.main-news-top-faster &#123; height: 163px; border-bottom: 1px dashed #E4E4E4; /*虚线*/&#125;.main-news-top-faster-title &#123; height: 32px; line-height: 32px; border-bottom: 1px dotted #E8E8E8; /*点线*/ padding: 0 15px;&#125;.main-news-top-faster-title h2&#123; float: left; font: 400 16px/32px &quot;microsoft yahei&quot;;&#125;.main-news-top-faster-title a &#123; float: right;&#125;.main-news-top-faster-content &#123; padding: 5px 0 0 15px;&#125;.main-news-top-faster-content li &#123; line-height: 24px;&#125;.main-news-top-faster-content span &#123; font-weight: 700; margin-right: 5px; color: #666;&#125;.main-news-top-money ul &#123; width: 250px;&#125; 3、充话费部分：12个单元格（重要）（1）步骤一：画表格 充话费这部分，我们不用table标签来做，一般table标签一般是用来放文字的。这里因为有图片，所以我们用ul标签来做，在ul里放12个浮动的li。 如果我们直接这样进行设置： 1234567891011.main-news-top-money ul &#123; width: 250px;&#125;.main-news-top-money li &#123; width: 62px; height: 70px; border: 1px solid #E8E8E8; float: left;&#125; 会发现，效果不尽人意： 上图所示，我们发现，红框部分的12个li，并没有按照我们预期的那样进行排列。因为每个li有border。真实的li当中，它们的border是有重叠的。 解决办法： 父亲宽度不够时，为了让盒子浮动不掉下去，可以给子盒子之上父盒子之下再给一个盒子，让它的宽度略大于父亲的宽度即可。 比如这里，本身这个区域整体的宽度是250，我们就设置ul的宽度是260px即可（满足的条件是：li的宽度4 &lt; ul的宽度 &lt; li的宽度5）。 ul的宽度设置为260px之后发现，最右边和最下面的部分会多出来： 我们可以给main-news-top-money设置overflow: hidden，将多余的部分切掉（这是没有办法的事情）。 于是乎，充话费这部分的代码如下： html部分： 1234567891011121314151617&lt;div class=&quot;main-news-top-money&quot;&gt; &lt;!--充话费--&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css部分： 12345678910111213.main-news-top-money ul &#123; width: 260px; /*让宽度略大于整体的宽度250px*/&#125;.main-news-top-money li &#123; width: 62px; height: 70px; border: 1px solid #E8E8E8; float: left; border-top: 0; /* 将每个单元格的上边框去掉，因为跟单元格的下边框重合了。*/ margin-top: -1px; /* 整体向上移动一个单位，因为边框重合了*/ margin-left: -1px ;/* 整体向左移动一个单位，因为边框重合了*/&#125; 这样的话，表格就画好了： （2）步骤二：往表格里填充内容 接下来，我们往表格里填充内容。最终，充话费部分的代码如下： html部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;div class=&quot;main-news-top-money&quot;&gt; &lt;!--充话费--&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i class=&quot;main-news-top-money-icon2&quot;&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;机票&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;!--单元格里的图片--&gt; &lt;span&gt;话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; index.css部分： 123456789101112131415161718192021222324252627282930313233343536373839404142/*充话费部分start*/.main-news-top-money &#123; overflow: hidden; /*将多余的部分切掉*/&#125;.main-news-top-money ul &#123; width: 260px; /*让宽度略大于整体的宽度250px*/&#125;.main-news-top-money li &#123; width: 62px; height: 70px; border: 1px solid #E8E8E8; float: left; border-top: 0; /* 将每个单元格的上边框去掉，因为跟单元格的下边框重合了。*/ margin-top: -1px; /* 整体向上移动一个单位，因为边框重合了*/ margin-left: -1px ;/* 整体向左移动一个单位，因为边框重合了*/&#125;.main-news-top-money li a &#123; display: block; width: 62px; height: 30px; padding-top: 40px; text-align: center; line-height: 30px; position: relative;&#125;.main-news-top-money li a i &#123; width: 25px; height: 25px; position: absolute; top: 13px; left: 18px; background: url(&quot;../images/fly.png&quot;) right top;&#125;.main-news-top-money .main-news-top-money-icon2 &#123; background: url(&quot;../images/fly.png&quot;) right -25px;&#125;/*充话费部分end*/ 代码解释： 单元格里的文字：我们可以给单元格里的文字设置padding-top，保证文字位于单元格的底部。 单元格里的图片（精灵图）的位置：通过子绝父相的方式（子是图片&lt;i&gt;本身，相是每个单元格里的超链接文字&lt;a&gt;）。通过子绝父相的方式定位之后，发现精灵图都是一样的图标，目前的处理办法是：手动添加不同的class进行修改精灵图，以后等我们学习js了，就不用这么麻烦了。 画出的表格如下： 今日推荐接下来，我们开始做下面这部分： 上图中的“今日推荐”，标签可以这样布局：ul &gt; li &gt; a &gt; img 为了防止这部分的内容跑到上面去，我们可以给上面的class-main部分清除浮动。 “今日推荐”这部分的代码如下。 html代码如下： 12345678910111213141516171819202122&lt;!--今日推荐start--&gt;&lt;div class=&quot;today&quot;&gt; &lt;div class=&quot;w clearfix&quot;&gt; &lt;div class=&quot;today-left fl&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;today-right&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;images/today1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;images/today2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;images/today3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;images/today4.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/a&gt; &lt;!--左边的箭头--&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/a&gt; &lt;!--右边的箭头--&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--今日推荐end--&gt; index.css中的代码如下； 1234567891011121314151617181920212223242526272829/*今日推荐start*/.today &#123; padding: 10px 0 20px;&#125;.today-left a&#123; display: block; width: 210px; height: 150px; background: url(&quot;../images/today.jpg&quot;);&#125;.today-right &#123; float: right; width: 1000px; overflow: hidden; /*隐藏掉右侧超出的几个像素*/ position: relative;&#125;.today-right ul &#123; width: 410%; /*这一点很有技巧*/&#125;.today-right li&#123; float: left; margin-right: 1px;&#125;/*今日推荐end*/ banner两侧的广告要实现的内容是下图中的箭头处： 注意这部分的div的位置，是放在class=&quot;shortcut-nav&quot;和class=&quot;main&quot;之间的。 两侧的广告其实是一个放在 a 标签里的超大背景图，而且这个大图的宽度超过了版心。所以，超链接的宽度给width: 100%更合适。a 的高度设置为图片的高度即可。 代码实现如下： html: 12345&lt;!--网页两侧的广告start--&gt;&lt;div class=&quot;banner-ad&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;!--网页两侧的广告end--&gt; index.css: 123456789101112/*banner两侧的广告start*/.banner-ad &#123; position: relative;&#125;.banner-ad a &#123; width: 100%; height: 644px; background: url(&quot;../images/ad.png&quot;) no-repeat center top; position: absolute;&#125;/*banner两侧的广告end*/ 上方代码中，我们不用给图片的父亲banner-ad设置高度。 超链接a ：我们不知道超链接的宽度是多少，所以直接设置为width: 100%。注意它的背景图的摆放位置，center确保了背景图位于水平方向的正中间，top确保了背景图和父亲定边对齐。 注意，上图中，两侧的广告实现之后发现，蓝框部分的两个位置(main-news-top-faster和today-left)点击时，发现跳转的是两侧广告的链接，因为它们的层级不够高。解决办法：给蓝框这两个部分加一个position: relative属性即可提高层级。 总结上一篇文章和这一篇文章，加起来，最终实现的效果如下： 工程文件如下： 2018-01-23-前端基础练习-JD顶部导航.rar","categories":[],"tags":[]},{"title":"","slug":"大前端/05-前端基本功：CSS和DOM练习/01-CSS基础练习：JD首页的制作（顶部和底部）","date":"2021-08-06T01:17:25.795Z","updated":"2021-07-28T07:34:11.349Z","comments":true,"path":"2021/08/06/大前端/05-前端基本功：CSS和DOM练习/01-CSS基础练习：JD首页的制作（顶部和底部）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/05-%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F%EF%BC%9ACSS%E5%92%8CDOM%E7%BB%83%E4%B9%A0/01-CSS%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%EF%BC%9AJD%E9%A6%96%E9%A1%B5%E7%9A%84%E5%88%B6%E4%BD%9C%EF%BC%88%E9%A1%B6%E9%83%A8%E5%92%8C%E5%BA%95%E9%83%A8%EF%BC%89/","excerpt":"","text":"前言京东是典型的电商类网站，学习这个网站的制作比较有价值。我们准备用WebStorm进行开发。 京东首页的截图为：http://img.smyhvae.com/20180119_1653.jpg 页面规划：新建一个空的工程我们首先新建一个空的工程： CSS初始化（基本样式）京东网站有一些基本样式，在各个页面中都要用到：（将这些基本样式copy到css.base里面去） base.css中的公共的部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@charset &quot;UTF-8&quot;;/*css 初始化 */html, body, ul, li, ol, dl, dd, dt, p, h1, h2, h3, h4, h5, h6, form, fieldset, legend, img &#123; margin:0; padding:0; &#125;fieldset, img,input,button &#123; border:none; padding:0;margin:0;outline-style:none; &#125; /*去掉边框、去掉轮廓（比如输入框外面的蓝边框）*//*去掉列表前面的圆点*/ul, ol &#123; list-style: none;&#125;input &#123; padding-top:0; padding-bottom:0; font-family: &quot;SimSun&quot;,&quot;宋体&quot;;&#125; /*字体一般是指定这两个*/select, input &#123; vertical-align:middle;&#125;select, input, textarea &#123; font-size:12px; margin:0; &#125;textarea &#123; resize:none; &#125; /*禁止文本输入框在右下角拖拽（因为拖动后会调整输入框大小）*/img &#123;border:0; vertical-align:middle; &#125; /* 去掉图片底侧默认的3像素空白缝隙*/table &#123; border-collapse:collapse; &#125;body &#123; font:12px/150% Arial,Verdana,&quot;\\5b8b\\4f53&quot;; /*\\5b8b\\4f53指的是宋体*/ color:#666; background:#fff&#125;/*start:清除浮动【推荐此方式进行清除浮动】。左浮动和右浮动都清除了，盒子刚好达到闭合的状态*/.clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1; /*IE/7/6*/&#125;/*end：清除浮动*/a &#123;color:#666; text-decoration:none; &#125; /*去掉超链接的下划线*/a:hover&#123;color:#C81623;&#125; /*鼠标悬停时的颜色*/h1,h2,h3,h4,h5,h6 &#123;text-decoration:none;font-weight:normal;font-size:100%;&#125; /*font-size:100% 的意思是：让它们和父亲一样大，避免在不同的浏览器中显示大小不一致*/s,i,em&#123;font-style:normal;text-decoration:none;&#125; /*去掉i标签和em的斜体，取消s标签的删除线*/.col-red&#123;color: #C81623!important;&#125;/*公共类*/.w &#123; /*版心（可视区）。需要专门提取出来 */ width: 1210px; margin: 0 auto;&#125;.fl &#123; float: left&#125;.fr &#123; float: right&#125;.al &#123; text-align: left&#125;.ac &#123; text-align: center&#125;.ar &#123; text-align: right&#125;.hide &#123; display: none&#125; 上方代码解释： （1）清除浮动的方式： 123456789101112.clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1; /*IE/7/6*/&#125; 这是如今比较流行的清除浮动的方式。比如小米官网就是采用的这种。 （2）其他属性： 我们给fieldset, img,input,button等标签设置了outline-style:none，意思去掉轮廓（比如去掉输入框外面的蓝边框，去掉之后，蓝色没有了，但是黑色依然存在）。去掉的原因是：首先，轮廓不好看；其次，在google浏览器和在火狐浏览器上，渲染的效果不同。 img标签中，我们通过vertical-align:middle属性去掉图片底侧默认的3像素空白缝隙，还有一种方法可以达到效果，那就是display: block。 给h1,h2,h3,h4,h5,h6设置**font-size:100%是因为：h标签在每个浏览器中显示的大小不一致，设置此属性则表示，让它们都和父亲一样大**。 （3）一些小标记 s是删除线，i和em是斜体。我们经常用它们做一些小装饰、小图标。 引入css文件base.css初始化之后，我们需要在html文件中引入它。引入外部样式表的方式如下：（stylesheet指样式表） 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/base.css&quot;&gt; 效果如下： 注意，base.css和index.css的书写顺序不能颠倒，因为是按照书写顺序，从上往下进行加载的。 Favicon 小图标Favicon 图标指的是箭头处这个小图标： 官网链接https://www.jx.com/favicon.ico可以下载这个小图标。 我们把favicon.ico图片放到工程文件的根目录，通过下面这种方式进行加载： 1&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt; 注意，shortcut icon是Favicon的专有名词，不能改成别的单词。 代码位置： 顶部导航的制作我们先制作下面这个部分，它位于网站的最顶部： 顶部导航栏的html结构如下：（直接放在body标签下） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!--顶部导航start--&gt;&lt;div class=&quot;shortcut&quot;&gt; &lt;!--版心--&gt; &lt;div class=&quot;w&quot;&gt; &lt;!--左浮动区域--&gt; &lt;div class=&quot;fl&quot;&gt; &lt;div class=&quot;dt&quot;&gt; 送至：北京 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--右浮动区域--&gt; &lt;div class=&quot;fr&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;你好，请登录&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;#&quot; class=&quot;col-red&quot;&gt;免费注册&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt;我的订单&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fore&quot;&gt;我的京东 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt;京东会员&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li&gt;企业采购&lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fore tel-jd&quot;&gt; &lt;em class=&quot;tel&quot;&gt;&lt;/em&gt; &lt;!--小手机图标--&gt; 手机京东 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fore&quot;&gt; 关注京东 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fore&quot;&gt; 客户服务 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/li&gt; &lt;li class=&quot;line&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fore&quot;&gt; 网站导航 &lt;i&gt;&lt;s&gt;◇&lt;/s&gt;&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--顶部导航end--&gt; 顶部导航栏需要加入的css样式如下：（放到base.css中） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*顶部导航start*/.shortcut &#123; height: 30px; line-height: 30px; background-color: #f1f1f1;&#125;.dt,.shortcut .fore &#123; padding: 0 20px 0 10px; position: relative;&#125;.dt i,.fore i &#123; font: 400 15px/15px &quot;宋体&quot;; position: absolute; top: 13px; right: 3px; height: 7px; overflow: hidden; width: 15px;&#125;.dt s,.fore s &#123; position: absolute; top: -8px; left: 0;&#125;.fr li &#123; float: left; padding: 0 10px;&#125;.fr .line &#123; width: 1px; height: 12px; background-color: #ddd; margin-top: 9px; padding: 0;&#125;.shortcut .tel-jd &#123; padding: 0 20px 0 25px;&#125;.tel &#123; position: absolute; width: 15px; height: 20px; background: url(../images/sprite.png) no-repeat; left: 5px; top: 5px;&#125;/*顶部导航end*/ css代码解释： （1）整个的顶部导航栏是一个shortcut： 12345.shortcut &#123; height: 30px; line-height: 30px; background-color: #f1f1f1;&#125; 然后将左侧的文字设置为左浮动，右侧的文字设置为右浮动。 （2）完成左侧部分的文字。 （3）右侧部分文字的结构：ul中放了九个li，用来存放文字。代码快捷键是ul&gt;li*9（符号&gt;是包含的关系）。 需要注意的是，“登录”和“注册”是同一个里面的两个&lt;a&gt;。它们是一个整体，所以要放到同一个li里。 (4)文字中间的间隔线： 上图所示，我们发现，每个li之间都有1像素宽、12像素高的间隔线，这个也是用li做的。 （5）增加文字右侧的小三角。 （6）在手机京东这个li中增加手机小图标，这里用到了css精灵图。 京东顶部导航条的工程文件如下： http://download.csdn.net/download/smyhvae/10214943 顶部banner图接下来我们只做顶部的banner图，效果如下： 也就是上图中“1元抢宝”的那个位置。 涉及到的html代码如下： 123456789&lt;!--京东的topbanner部分--&gt;&lt;div class=&quot;topbanner&quot;&gt; &lt;div class=&quot;w tb&quot;&gt; &lt;img src=&quot;images/topbanner.jpg&quot; alt=&quot;&quot;/&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;close-banner&quot;&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--京东的topbanner部分 end--&gt; 在base.css中涉及到的css代码如下： 1234567891011121314151617181920/*topbanner start*/.topbanner &#123; background-color: #8A25C6;&#125;.close-banner &#123; position: absolute; right:0; top:5px; width: 19px; height: 19px; background: url(../images/close.png) no-repeat;&#125;.close-banner:hover &#123; background-position:bottom;&#125;.tp&#123; position: relative;&#125;/*topbanner end*/ 代码解释： 重点是close-banner这个class，也就是右上角的那个X。这里用到了子绝父相，注意，设置相对定位的父亲是tb这个class，因为要考虑到网页缩放的情况。 .close-banner:hover这个属性里，我们设置的背景图的定位是bottom，意思是，保证精灵图和父亲的底边贴齐，就不用使用像素的方式对精灵兔图进行定位了。 搜索框搜索框的UI如下： 上图中，包含了四个部分： 左侧的logo 中间的搜索框 右侧的购物车 热搜文字（中间搜索框的下方） 我们在WebStorm中输入.search-logo+.search-input+.search-car+.search-moreA，然后按tab键，就可以补齐代码： 1234&lt;div class=&quot;search-logo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-input&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-car&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-moreA&quot;&gt;&lt;/div&gt; 相关的html代码如下： 12345678910111213141516171819202122232425262728293031&lt;!--search部分start--&gt;&lt;div class=&quot;serach&quot;&gt; &lt;div class=&quot;w clearfix&quot;&gt; &lt;div class=&quot;search-logo&quot;&gt; &lt;a href=&quot;http://www.jx.com&quot; title=&quot;京西&quot; target=&quot;_blank&quot;&gt;京东官网&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;search-input&quot;&gt; &lt;!--placeholder=&quot;运动相机&quot;--&gt; &lt;input type=&quot;text&quot; value=&quot;运动相机&quot;/&gt; &lt;button&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;search-car&quot;&gt; &lt;a href=&quot;#&quot;&gt;我的购物车&lt;/a&gt; &lt;i class=&quot;icon1&quot;&gt;&lt;/i&gt; &lt;i class=&quot;icon2&quot;&gt;&amp;gt;&lt;/i&gt; &lt;i class=&quot;icon3&quot;&gt;8&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;search-moreAlink&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;col-red&quot;&gt;出境999&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;沸腾厨卫&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;249减100&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;手机节&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;每150减50&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;男靴&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;巧克力&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;cool1手机&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;男士卫衣&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--search部分end--&gt; 相关的css代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/*search部分start*/.search-logo &#123; float: left; width: 362px; height: 60px; padding: 20px 0;&#125;.search-logo a &#123; width: 270px; height: 60px; display: block; text-indent: -9999px; background: url(../images/logo.png) no-repeat;&#125;.search-input &#123; float: left; height: 36px; padding-top: 25px;&#125;.search-input input &#123; float: left; width: 450px; height: 32px; padding-left: 4px; font: 400 14px/32px &quot;microsoft yahei&quot;; color: rgb(153, 153, 153); border: 2px solid #B61D1D; border-right: 0;&#125;.search-input button &#123; width: 82px; height: 36px; color: #fff; float: left; font: 400 16px/36px &quot;微软雅黑&quot;; background-color: #B61D1D; cursor: pointer; /*cursor: pointer; 变成小手*/ /*cursor: text; 变成光标*/ /*cursor: move; 变成四角箭头*/ /*cursor: default; 变成小白*/&#125;.search-car &#123; float: right; width: 96px; height: 34px; line-height: 34px; padding-left: 43px; position: relative; margin: 25px 65px 0 0; border: 1px solid #DFDFDF; background-color: #F9F9F9;&#125;.icon1 &#123; position: absolute; top: 9px; left: 18px; width: 18px; height: 16px; background: url(../images/tel.png) no-repeat 0 -58px;&#125;.icon2 &#123; position: absolute; right: 10px; color: #999; /*font-family: &quot;SimSun&quot;;*/ font: 13px/34px &quot;SimSun&quot;;&#125;.icon3 &#123; position: absolute; top: -5px; /*left: 0;*/ width: 16px; height: 14px; background-color: #C81623; line-height: 14px; text-align: center; color: #fff; border-radius: 7px 7px 7px 0; /*画圆角矩形*/&#125;.search-moreAlink &#123; float: left; width: 530px; height: 28px; line-height: 28px;&#125;.search-moreAlink a &#123; margin-right: 8px;&#125;/*search部分end*/ 对于这四个部分，我们依次来讲解。 1、左侧的logo为了便于SEO，需要给图片这个超链接加上文字，然后设置文字的缩进为text-indent: -9999px;。 2、搜索栏“搜索”按钮：当我们把鼠标放在“搜索”上的时候， 发现鼠标变成了小手，这里是用到了cursor属性。 cursor有如下属性值： 1234cursor: pointer; /*变成小手*/cursor: text; /*变成光标*/cursor: move; /*变成四角箭头*/cursor: default; /*变成默认的箭头*/ 3、购物车购物车里包含了四个元素：一个文字，三个图标。 为了让文字“我的购物车”这个&lt;a&gt;上下方向居中，我们给&lt;a&gt;标签的行高line-height为父亲的高度。 另外，“我的购物车”这四个字并不是水平居中的，于是，我们可以给它一个左侧的padding，而不用给右侧padding。 另外三个小图标可以用绝对定位来做。 右上角的小图标（圆角矩形）：它的红色背景不是图片，而是用border-radius属性画的圆角矩形。 圆角矩形border-radius有下面几种画法： 1234border-radius: 宽/高一半;border-radius: 50%;border-radius: 0.3em;border-radius: 左上角 右上角 右下角 左下角; 搜索框下方的热搜文字热搜文字的功能性并不强，仅仅使用几个超链接&lt;a&gt;标签即可（每个 a 之间用margin隔开）。不需要像别的导航栏那样，在ul里放li，在li里放a。 注意，每个 a 之间是用margin隔开，不是用padding隔开；否则的话，鼠标点击中间的空白处也会出现跳转。 顶部导航条+顶部banner+搜索框的工程文件如下： http://download.csdn.net/download/smyhvae/10218022 slogen：口号要求实现的效果如下： 上图可以看到，这里要实现的效果是：无论浏览器如何移动，要保证第二个slogen的左侧位于浏览器的正中间。这是可以用到绝对定位的知识。 html的代码如下： 12345678910111213141516&lt;!--底部的口号 start--&gt;&lt;div class=&quot;slogen&quot;&gt; &lt;span class=&quot;item slogen1&quot;&gt; &lt;img src=&quot;images/slogen1.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt; &lt;span class=&quot;item slogen2&quot;&gt; &lt;img src=&quot;images/slogen2.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt; &lt;span class=&quot;item slogen3&quot;&gt; &lt;img src=&quot;images/slogen3.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt; &lt;span class=&quot;item slogen4&quot;&gt; &lt;img src=&quot;images/slogen4.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/div&gt;&lt;!--底部的口号 end--&gt; class=slogen指的是整个slogen区域。item表示四个口号中相同的部分。 css的代码如下； 123456789101112131415161718192021222324252627282930313233/*底部的口号 start*/.slogen &#123; height: 54px; padding: 20px 0; background-color: #f5f5f5; position: relative; margin-bottom: 15px;&#125;.item &#123; width: 302px; position: absolute; top: 20px; left: 50%;&#125;.slogen1 &#123; margin-left: -608px;&#125;.slogen2 &#123; margin-left: -304px;&#125;.slogen3 &#123; margin-left: 2px;&#125;.slogen4 &#123; margin-left: 304px;&#125;/*底部的口号 end*/ 我们给item设置left: 50%;，确保每个item移到了父亲的正中间。然后每个item各自移动相应的距离即可实现。 最下方的购物指南&amp;区域覆盖需要实现的效果如下： 上图中，需要实现的内容包括两个部分：左侧的购物指南和右侧的区域覆盖（我把这两个部分用红线隔开了）。 购物指南需要使用的布局如下： 这里的重点是要量出dt和dd的行高。 html代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!--购物指南等 start--&gt;&lt;div class=&quot;w footer-shopping clearfix&quot;&gt; &lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;生活旅行/团购&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;大家电&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;配送方式&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;上门自提&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;211限时达&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;配送服务查询&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;配送费收取标准&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;海外配送&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;生活旅行/团购&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;大家电&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;生活旅行/团购&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;大家电&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl class=&quot;last-dl&quot;&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;生活旅行/团购&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;大家电&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;!--购物指南等 end--&gt; 因为这片区域是浮动的，我们要通过clearfix这个class清除浮动，防止其被覆盖。 css代码如下： 12345678910111213141516171819/*购物指南等 start*/.footer-shopping &#123; margin-top: 16px; /*和上方保持距离*/&#125;.footer-shopping dl&#123; float: left; width: 200px;&#125;dl.last-dl &#123; width: 100px;&#125;.footer-shopping dt&#123; height: 34px; font: 400 16px/34px &quot;microsoft yahei&quot;;&#125;.footer-shopping dd&#123; line-height: 20px;&#125;/*购物指南等 end*/ 区域覆盖html代码如下： 12345&lt;div class=&quot;coverage&quot;&gt; &lt;h3&gt;京东自营覆盖区县&lt;/h3&gt; &lt;p&gt;京东已向全国2654个区县提供自营配送服务，支持货到付款、POS机刷卡和售后上门服务。&lt;/p&gt; &lt;a href=&quot;#&quot;&gt;查看详情 &gt;&lt;/a&gt;&lt;/div&gt; css代码如下： 12345678910111213141516171819202122/*覆盖区域 start*/.coverage &#123; float: left; width: 186px; height: 169px; margin-right: 60px; padding-left: 17px; background: url(../images/china.png) no-repeat left bottom;&#125;.coverage h3 &#123; height: 34px; font: 400 16px/34px &quot;microsoft yahei&quot;;&#125;.coverage p &#123; padding-top: 8px;&#125;.coverage a &#123; float: right;&#125;/*覆盖区域 end*/ 注意这里将精灵图设置为背景时，用到的定位属性是left bottom，意思是保证精灵图的左侧跟父亲左侧贴齐，下方和父亲下方贴齐。这样做的话，就不用通过像素来进行定位了。 最底部最底部的效果如下： 如上图所示，它包含了三个部分。 涉及到的html代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!--最底部 start--&gt;&lt;div class=&quot;w footer-bottom&quot;&gt; &lt;div class=&quot;footer-about&quot;&gt; &lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;商家入驻&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;营销中心&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;手机京东&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;友情链接&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;销售联盟&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;京东社区&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;京东公益&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;English Site&lt;/a&gt;| &lt;a href=&quot;#&quot;&gt;Contact Us&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;footer-copyright&quot;&gt; &lt;img src=&quot;images/guohui.png&quot;/&gt;京公网安备 11000002000088号 | 京ICP证070359号 | 互联网药品信息服务资格证编号(京)-经营性-2014-0008 | 新出发京零 字第大120007号&lt;br&gt; 互联网出版许可证编号新出网证(京)字150号 | 出版物经营许可证 | 网络文化经营许可证京网文[2014]2148-348号 | 违法和不良信息举报电话：4006561155&lt;br&gt; Copyright © 2004 - 2016 JX.com 版权所有 | 消费者维权热线：4006067733&lt;br&gt; 京东旗下网站：京东钱包 &lt;/div&gt; &lt;div class=&quot;footer-bottom-img&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/img1.jpg&quot;/&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--最底部 end--&gt; 涉及到的css代码如下： 123456789101112131415161718192021/*最底部start*/.footer-bottom &#123; margin-top: 20px; text-align: center; /*让文字在容器中水平方向居中*/ padding: 20px 0 30px; border-top: 1px solid #E5E5E5;&#125;.footer-bottom .footer-about a&#123; margin: 0 10px;&#125;.footer-copyright &#123; padding: 10px 0;&#125;.footer-bottom-img a &#123; margin: 0 5px;&#125;/*最底部end*/ 你去京东官网看看，发现最最底部的文字竟然是图片： 总结以上全部内容，最终实现的效果如下： 对应的工程文件如下： 2018-01-22-前端基础练习-JD顶部导航.rar","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/浅拷贝和深拷贝","date":"2021-08-06T01:17:25.791Z","updated":"2021-07-28T07:34:11.348Z","comments":true,"path":"2021/08/06/大前端/04-JavaScript进阶/浅拷贝和深拷贝/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝对于对象或数组类型，当我们将a赋值给b，然后更改b中的属性，a也会随着变化。 也就是说，a和b指向了同一块堆内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。 深拷贝那么相应的，如果给b放到新的内存中，将a的各个属性都复制到新内存里，就是深拷贝。 也就是说，当b中的属性有变化的时候，a内的属性不会发生变化。 参考链接： 深拷贝与浅拷贝的实现（一） javaScript中浅拷贝和深拷贝的实现","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/创建对象和继承","date":"2021-08-06T01:17:25.789Z","updated":"2021-07-28T07:34:11.348Z","comments":true,"path":"2021/08/06/大前端/04-JavaScript进阶/创建对象和继承/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/","excerpt":"","text":"创建对象的几种方式通过Object12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01_Object构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式一: Object构造函数模式 * 套路: 先创建空Object对象, 再动态添加属性/方法 * 适用场景: 起始时不确定对象内部数据 * 问题: 语句太多--&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* 一个人: name:&quot;Tom&quot;, age: 12 */ // 先创建空Object对象 var p = new Object() p = &#123;&#125; //此时内部数据是不确定的 // 再动态添加属性/方法 p.name = &#x27;Tom&#x27; p.age = 12 p.setName = function (name) &#123; this.name = name &#125; //测试 console.log(p.name, p.age) p.setName(&#x27;Bob&#x27;) console.log(p.name, p.age)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式二：对象字面量1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02_对象字面量&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式二: 对象字面量模式 * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法 * 适用场景: 起始时对象内部数据是确定的 * 问题: 如果创建多个对象, 有重复代码--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var p = &#123; name: &#x27;Tom&#x27;, age: 12, setName: function (name) &#123; this.name = name &#125; &#125; //测试 console.log(p.name, p.age) p.setName(&#x27;JACK&#x27;) console.log(p.name, p.age) var p2 = &#123; //如果创建多个对象代码很重复 name: &#x27;Bob&#x27;, age: 13, setName: function (name) &#123; this.name = name &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式三：工厂模式 方式：通过工厂函数动态创建对象并返回。 返回一个对象的函数，就是工厂函数。 适用场景: 需要创建多个对象。 问题: 对象没有一个具体的类型，都是Object类型。 由于这个问题的存在，工厂模式用得不多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;03_工厂模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式三: 工厂模式 * 套路: 通过工厂函数动态创建对象并返回 * 适用场景: 需要创建多个对象 * 问题: 对象没有一个具体的类型, 都是Object类型--&gt;&lt;script type=&quot;text/javascript&quot;&gt; function createPerson(name, age) &#123; //返回一个对象的函数===&gt;工厂函数 var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj &#125; // 创建2个人 var p1 = createPerson(&#x27;Tom&#x27;, 12) var p2 = createPerson(&#x27;Bob&#x27;, 13) // p1/p2是Object类型 function createStudent(name, price) &#123; var obj = &#123; name: name, price: price &#125; return obj &#125; var s = createStudent(&#x27;张三&#x27;, 12000) // s也是Object&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式四：自定义构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_自定义构造函数模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--方式四: 自定义构造函数模式 * 套路: 自定义构造函数, 通过new创建对象 * 适用场景: 需要创建多个类型确定的对象 * 问题: 每个对象都有相同的数据, 浪费内存--&gt;&lt;script type=&quot;text/javascript&quot;&gt; //定义类型 function Person(name, age) &#123; this.name = name this.age = age this.setName = function (name) &#123; this.name = name &#125; &#125; var p1 = new Person(&#x27;Tom&#x27;, 12) p1.setName(&#x27;Jack&#x27;) console.log(p1.name, p1.age) console.log(p1 instanceof Person) function Student(name, price) &#123; this.name = name this.price = price &#125; var s = new Student(&#x27;Bob&#x27;, 13000) console.log(s instanceof Student) var p2 = new Person(&#x27;JACK&#x27;, 23) console.log(p1, p2)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式四引入了继承。 继承的几种方式通过构造函数继承在子类型构造函数中通用call()调用父类型构造函数 原型链继承子类型的原型为父类型的一个实例对象 组合继承","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/作用域和闭包","date":"2021-08-06T01:17:25.786Z","updated":"2021-07-28T07:34:11.347Z","comments":true,"path":"2021/08/06/大前端/04-JavaScript进阶/作用域和闭包/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"前言面试问题： 说一下对变量提升的理解 说明this的几种不同的使用场景 创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号 如何理解作用域 实际开发中闭包的应用 涉及到的知识点： 执行上下文 this 作用域 作用域链 闭包 执行上下文执行上下文主要有两种情况： 全局代码： 一段&lt;script&gt;标签里，有一个全局的执行上下文。所做的事情是：变量定义、函数声明 函数代码：每个函数里有一个上下文。所做的事情是：变量定义、函数声明、this、arguments PS：注意“函数声明”和“函数表达式”的区别。 全局执行上下文在执行全局代码前将window确定为全局执行上下文。 （1）对全局数据进行预处理：（并没有赋值） var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) （2）开始执行全局代码 函数执行上下文在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)。 （1）对局部数据进行预处理： 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) （2）开始执行函数体代码 执行上下文栈 1.在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 2.在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 3.在函数执行上下文创建后, 将其添加到栈中(压栈) 4.在当前函数执行完后,将栈顶的对象移除(出栈) 5.当所有的代码执行完后, 栈中只剩下window thisthis指的是，调用函数的那个对象。this永远指向函数运行时所在的对象。 解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this。 根据函数的调用方式的不同，this会指向不同的对象：【重要】 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的那个对象 4.使用call和apply调用时，this是指定的那个对象 需要特别提醒的是：this的指向在函数定义时无法确认，只有函数执行时才能确定。 this的几种场景： 1、作为构造函数执行 例如： 1234567function Foo(name) &#123; //this = &#123;&#125;; this.name = name; //return this;&#125;var foo = new Foo(); 2、作为对象的属性执行 123456789var obj = &#123; name: &#x27;A&#x27;, printName: function () &#123; console.log(this.name); &#125;&#125;obj.printName(); 3、作为普通函数执行 12345function fn() &#123; console.log(this); //this === window&#125;fn(); 4、call apply bind 作用域作用域指一个变量的作用范围。它是静态的(相对于上下文对象), 在编写代码时就确定了。 作用：隔离变量，不同作用域下同名变量不会有冲突。 作用域的分类： 全局作用域 函数作用域 没有块作用域(ES6有了) 1234if (true) &#123; var name = &#x27;smyhvae&#x27;;&#125;console.log(name); 上方代码中，并不会报错，因为：虽然 name 是在块里面定义的，但是 name 是全局变量。 全局作用域直接编写在script标签中的JS代码，都在全局作用域。 在全局作用域中： 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。 创建的变量都会作为window对象的属性保存。 创建的函数都会作为window对象的方法保存。 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问到。 变量的声明提前：（变量提升） 使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写a = 1），则变量不会被声明提前。 举例1： 12console.log(a);var a = 123; 打印结果：undefined 举例2： 12console.log(a);a = 123; //此时a相当于window.a 程序会报错： 函数的声明提前： 使用函数声明的形式创建的函数function foo()&#123;&#125;，会被声明提前。 也就是说，它会在所有的代码执行之前就被创建，所以我们可以在函数声明之前，调用函数。 使用函数表达式创建的函数var foo = function()&#123;&#125;，不会被声明提前，所以不能在声明前调用。 很好理解，因为此时foo被声明了，且为undefined，并没有给其赋值function()&#123;&#125;。 所以说，下面的例子，会报错： 函数作用域调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁。 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。 在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用window.a） 提醒1： 在函数作用域也有声明提前的特性： 使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 因此，在函数中，没有var声明的变量都会成为全局变量，而且并不会提前声明。 举例1： 12345678910var a = 1;function foo() &#123; console.log(a); a = 2; // 此处的a相当于window.a&#125;foo();console.log(a); //打印结果是2 上方代码中，foo()的打印结果是1。如果去掉第一行代码，打印结果是Uncaught ReferenceError: a is not defined 提醒2：定义形参就相当于在函数作用域中声明了变量。 1234567function fun6(e) &#123; console.log(e);&#125;fun6(); //打印结果为 undefinedfun6(123);//打印结果为123 作用域与执行上下文的区别区别1： 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 函数执行上下文是在调用函数时, 函数体代码执行之前创建 区别2： 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放 联系： 执行上下文(对象)是从属于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 作用域链当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错ReferenceError。 外部函数定义的变量可以被内部函数所使用，反之则不行。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; //只要是函数就可以创造作用域 //函数中又可以再创建函数 //函数内部的作用域可以访问函数外部的作用域 //如果有多个函数嵌套，那么就会构成一个链式访问结构，这就是作用域链 //f1---&gt;全局 function f1()&#123; //f2---&gt;f1---&gt;全局 function f2()&#123; //f3----&gt;f2---&gt;f1---&gt;全局 function f3()&#123; &#125; //f4---&gt;f2---&gt;f1----&gt;全局 function f4()&#123; &#125; &#125; //f5---&gt;f1----&gt;全局 function f5()&#123; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 理解： 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则： 123456789101112131415var a = 1function fn1() &#123; var b = 2 function fn2() &#123; var c = 3 console.log(c) console.log(b) console.log(a) console.log(d) &#125; fn2()&#125;fn1() 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 闭包闭包就是能够读取其他函数内部数据（变量/函数）的函数。 只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 上面这两句话，是阮一峰的文章里的，你不一定能理解，来看下面的讲解和举例。 如何产生闭包当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量或函数时, 就产生了闭包。 闭包到底是什么? 使用chrome调试查看 理解一: 闭包是嵌套的内部函数(绝大部分人) 理解二: 包含被引用变量 or 函数的对象(极少数人) 注意: 闭包存在于嵌套的内部函数中。 产生闭包的条件 1.函数嵌套 2.内部函数引用了外部函数的数据(变量/函数)。 来看看条件2： 123456789function fn1() &#123; function fn2() &#123; &#125; return fn2;&#125;fn1(); 上面的代码不会产生闭包，因为内部函数fn2并没有引用外部函数fn1的变量。 PS：还有一个条件是外部函数被调用，内部函数被声明。比如： 12345678910111213141516171819202122function fn1() &#123; var a = 2 var b = &#x27;abc&#x27; function fn2() &#123; //fn2内部函数被提前声明，就会产生闭包(不用调用内部函数) console.log(a) &#125;&#125;fn1();function fn3() &#123; var a = 3 var fun4 = function () &#123; //fun4采用的是“函数表达式”创建的函数，此时内部函数的声明并没有提前 console.log(a) &#125;&#125;fn3(); 常见的闭包 将一个函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用。 闭包1：将一个函数作为另一个函数的返回值1234567891011121314function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1(); //执行外部函数fn1，返回的是内部函数fn2f() // 3 //执行fn2f() // 4 //再次执行fn2 当f()第二次执行的时候，a加1了，也就说明了：闭包里的数据没有消失，而是保存在了内存中。如果没有闭包，代码执行完倒数第三行后，变量a就消失了。 上面的代码中，虽然调用了内部函数两次，但是，闭包对象只创建了一个。 也就是说，要看闭包对象创建了一个，就看：外部函数执行了几次（与内部函数执行几次无关）。 闭包2. 将函数作为实参传递给另一个函数调用123456function showDelay(msg, time) &#123; setTimeout(function() &#123; //这个function是闭包，因为是嵌套的子函数，而且引用了外部函数的变量msg alert(msg) &#125;, time)&#125;showDelay(&#x27;atguigu&#x27;, 2000) 上面的代码中，闭包是里面的funciton，因为它是嵌套的子函数，而且引用了外部函数的变量msg。 闭包的作用 作用1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期) 作用2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 我们让然拿这段代码来分析： 1234567891011121314function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2;&#125;var f = fn1(); //执行外部函数fn1，返回的是内部函数fn2f() // 3 //执行fn2f() // 4 //再次执行fn2 作用1分析： 上方代码中，外部函数fn1执行完毕后，变量a并没有立即消失，而是保存在内存当中。 作用2分析： 函数fn1中的变量a，是在fn1这个函数作用域内，因此外部无法访问。但是通过闭包，外部就可以操作到变量a。 达到的效果是：外界看不到变量a，但可以操作a。 比如上面达到的效果是：我看不到变量a，但是每次执行函数后，让a加1。当然，如果我真想看到a，我可以在fn2中将a返回即可。 回答几个问题： 问题1. 函数执行完后, 函数内部声明的局部变量是否还存在? 答案：一般是不存在, 存在于闭包中的变量才可能存在。 闭包能够一直存在的根本原因是f，因为f接收了fn1()，这个是闭包，闭包里有a。注意，此时，fn2并不存在了，但是里面的对象（即闭包）依然存在，因为用f接收了。 问题2. 在函数外部能直接访问函数内部的局部变量吗? 不能，但我们可以通过闭包让外部操作它。 闭包的生命周期 产生: 嵌套内部函数fn2被声明时就产生了(不是在调用) 死亡: 嵌套的内部函数成为垃圾对象时。（比如f = null，就可以让f成为垃圾对象。意思是，此时f不再引用闭包这个对象了） 闭包的应用：定义具有特定功能的js模块 将所有的数据和功能都封装在一个函数内部(私有的)，只向外暴露一个包含n个方法的对象或函数。 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能。 方式一（1）myModule.js：（定义一个模块，向外暴露多个函数，供外界调用） 12345678910111213141516171819function myModule() &#123; //私有数据 var msg = &#x27;Smyhvae Haha&#x27; //操作私有数据的函数 function doSomething() &#123; console.log(&#x27;doSomething() &#x27; + msg.toUpperCase()); //字符串大写 &#125; function doOtherthing() &#123; console.log(&#x27;doOtherthing() &#x27; + msg.toLowerCase()) //字符串小写 &#125; //通过【对象字面量】的形式进行包裹，向外暴露多个函数 return &#123; doSomething1: doSomething, doOtherthing2: doOtherthing &#125;&#125; 上方代码中，外界可以通过doSomething1和doOtherthing2来操作里面的数据，但不让外界看到。 （2）index.html: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_闭包的应用_自定义JS模块&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--闭包的应用 : 定义JS模块 * 具有特定功能的js文件 * 将所有的数据和功能都封装在一个函数内部(私有的) * 【重要】只向外暴露一个包含n个方法的对象或函数 * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var module = myModule(); module.doSomething1(); module.doOtherthing2();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 方式二同样是实现方式一种的功能，这里我们采取另外一种方式。 （1）myModule2.js：（是一个立即执行的匿名函数） 12345678910111213141516171819(function () &#123; //私有数据 var msg = &#x27;Smyhvae Haha&#x27; //操作私有数据的函数 function doSomething() &#123; console.log(&#x27;doSomething() &#x27; + msg.toUpperCase()) &#125; function doOtherthing() &#123; console.log(&#x27;doOtherthing() &#x27; + msg.toLowerCase()) &#125; //外部函数是即使运行的匿名函数，我们可以把两个方法直接传给window对象 window.myModule = &#123; doSomething1: doSomething, doOtherthing2: doOtherthing &#125;&#125;)() （2）index.html： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;05_闭包的应用_自定义JS模块2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--闭包的应用2 : 定义JS模块 * 具有特定功能的js文件 * 将所有的数据和功能都封装在一个函数内部(私有的) * 只向外暴露一个包信n个方法的对象或函数 * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能--&gt;&lt;!--引入myModule文件--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; myModule.doSomething1() myModule.doOtherthing2()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方两个文件中，我们在myModule2.js里直接把两个方法直接传递给window对象了。于是，在index.html中引入这个js文件后，会立即执行里面的匿名函数。在index.html中把myModule直接拿来用即可。 总结： 当然，方式一和方式二对比后，我们更建议采用方式二，因为很方便。 但无论如何，两种方式都采用了闭包。 闭包的缺点及解决缺点：函数执行完后, 函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄露。 解决：能不用闭包就不用，及时释放。比如： 1f = null; // 让内部函数成为垃圾对象 --&gt;回收闭包 总而言之，你需要它，就是优点；你不需要它，就成了缺点。 内存溢出和内存泄露内存溢出内存溢出：一种程序运行出现的错误。当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误。 代码举例： 12345var obj = &#123;&#125;;for (var i = 0; i &lt; 10000; i++) &#123;obj[i] = new Array(10000000); //把所有的数组内容都放到obj里保存，导致obj占用了很大的内存空间console.log(&quot;-----&quot;);&#125; 内存泄漏内存泄漏：占用的内存没有及时释放。 注意，内存泄露的次数积累多了，就容易导致内存溢出。 常见的内存泄露： 1.意外的全局变量 2.没有及时清理的计时器或回调函数 3.闭包 情况1举例： 1234567// 意外的全局变量function fn() &#123; a = new Array(10000000); console.log(a);&#125;fn(); 情况2举例： 123456// 没有及时清理的计时器或回调函数var intervalId = setInterval(function () &#123; //启动循环定时器后不清理 console.log(&#x27;----&#x27;)&#125;, 1000)// clearInterval(intervalId); //清理定时器 情况3举例： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function fn1() &#123; var a = 4; function fn2() &#123; console.log(++a) &#125; return fn2 &#125; var f = fn1() f() // f = null //让内部函数成为垃圾对象--&gt;回收闭包&lt;/script&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/this","date":"2021-08-06T01:17:25.784Z","updated":"2021-07-28T07:34:11.347Z","comments":true,"path":"2021/08/06/大前端/04-JavaScript进阶/this/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/this/","excerpt":"","text":"thisthis的作用 this可以帮我们简化很多代码。比如xiaoming.name、xiaoming.age可以直接写成this.name、this.age。 特别是当我们不知道一个对象是什么，或者这个对象没有名字但又很想调用它的时候，就会使用到this对象。 举例： 遍历DOM对象，绑定click事件，调用当前点击的对象的id，而不是所有对象的id。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: green; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; window.onload = function () &#123; var myDiv = document.getElementsByTagName(&#x27;div&#x27;); for (var i = 0; i &lt; myDiv.length; i++) &#123; myDiv[i].onclick = function () &#123; console.log(i); console.log(this.id); &#125; &#125; &#125;&lt;/script&gt;&lt;section&gt; &lt;div id=&quot;div0&quot;&gt; div0&lt;/div&gt; &lt;div id=&quot;div1&quot;&gt; div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; div3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt; div4&lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 点击其中的任何一个元素后，i的打印结果是5。你可能会觉得很惊讶。我们来解释一下： 当代码执行完毕后，i已经等于5了。因为一旦运行程序，for循环已经执行完了，此时i等于5。 现在，我们尝试在 myDiv[i].onclick事件中写代码，如果打印： 1console.log(i); //打印结果为5 如果打印： 1console.log(myDiv[i].id); 上方这行代码，打印会报错，因为i=5；如果想打印每个div的id，应该这样写： 1console.log(this.id); 你看，this的作用，就体现出来了。 PS：顺便提醒一下，上面的代码中，如果把var i改成let i，效果又完全不同了。参考链接：let和var在for循环中的表现 全局作用域中的this当一段代码在浏览器中执行时，所有的全局变量和对象都是在window对象上定义的。换而言之，所有的全局变量和对象都属于window对象。 this的定律this关键字永远指向函数（方法）运行时的所有者。 函数赋值给变量时，this指向window比如： 12345var foo1 = args.getInfo;foo1();var foo2 = function()&#123;&#125;;foo2(); this都是指向window。 以函数形式调用时，this永远都是window以方法的形式调用时，this是调用方法的对象解决闭包中的this指向问题内部函数是可以访问到外部函数的变量的。 方式一：直接通过父函数的名字访问 方式二：如果不知道父函数的名字，在父函数里加一句_this = this，此时_this相当于父函数的名字。 当this遇到一些特殊的函数时","categories":[],"tags":[]},{"title":"","slug":"大前端/04-JavaScript进阶/call、apply、bind的区别","date":"2021-08-06T01:17:25.782Z","updated":"2021-07-28T07:34:11.347Z","comments":true,"path":"2021/08/06/大前端/04-JavaScript进阶/call、apply、bind的区别/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/04-JavaScript%E8%BF%9B%E9%98%B6/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"call()和apply()介绍这两个方法都是函数对象的方法，需要通过函数对象来调用。 当函数调用call()和apply()时，函数都会立即执行。 都可以用来改变函数的this对象的指向。 第一个参数都是this要指向的对象（函数执行时，this将指向这个对象），后续参数用来传实参。 显式绑定thisJS提供的绝大多数函数以及我们自己创建的所有函数，都可以使用call 和apply方法。 它们的第一个参数是一个对象。因为你可以直接指定 this 绑定的对象，因此我们称之为显式绑定。 例1： 12345678910function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2&#125;;// 将 this 指向 objfoo.apply(obj); //打印结果：2 第一个参数的传递1、thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。 2、传递一个别的函数名时，函数中的this将指向这个函数的引用。 3、传递的值为数字、布尔值、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String。 4、传递一个对象时，函数中的this则指向传递的这个对象。 call()和apply()的区别call()和apply()方法都可以将实参在对象之后依次传递，但是apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。 比如针对下面这样的代码： 12345678910111213var persion1 = &#123; name: &quot;小王&quot;, gender: &quot;男&quot;, age: 24, say: function (school, grade) &#123; alert(this.name + &quot; , &quot; + this.gender + &quot; ,今年&quot; + this.age + &quot; ,在&quot; + school + &quot;上&quot; + grade); &#125;&#125;var person2 = &#123; name: &quot;小红&quot;, gender: &quot;女&quot;, age: 18&#125; 如果是通过call的参数进行传参，是这样的： 1persion1.say.call(persion2, &quot;实验小学&quot;, &quot;六年级&quot;); 如果是通过apply的参数进行传参，是这样的： 1persion1.say.apply(persion2, [&quot;实验小学&quot;, &quot;六年级&quot;]); 看到区别了吗，call后面的实参与say方法中是一一对应的，而apply传实参时，要封装成一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。 call()和apply()的作用 改变this的指向 实现继承。Father.call(this) bind() 都能改变this的指向 call()/apply()是立即调用函数 bind()是将函数返回，因此后面还需要加()才能调用。 bind()传参的方式与call()相同。 参考链接： https://www.jianshu.com/p/56a9c2d11adc https://github.com/lin-xin/blog/issues/7 https://segmentfault.com/a/1190000007402815 JS中改变this指向的方法","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/30-常见代码解读","date":"2021-08-06T01:17:25.777Z","updated":"2021-07-28T07:34:11.346Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/30-常见代码解读/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/30-%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"callback &amp;&amp; callback()的含义1callback &amp;&amp; callback() 含义是：如果callback存在，则执行callback()函数。 这个 callback 通常作为函数的参数使用。举例： 123456789function foo(callback) &#123; &#123; // do something &#125; callback &amp;&amp; callback() // 不传 callback 参数，则不会执行 callback() 函数 &#125;foo(); // 只执行do something中的代码 foo(callback);//callback是另一个函数，将此函数传入 foo，将会执行callback()","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/29-原型链","date":"2021-08-06T01:17:25.775Z","updated":"2021-07-28T07:34:11.346Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/29-原型链/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/29-%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"常见概念 构造函数 构造函数-扩展 原型规则和示例 原型链 instanceof 构造函数任何一个函数都可以被new，new了之后，就成了构造方法。 如下： 123456789function Foo(name, age) &#123; this.name = name; this.age = age; //retrun this; //默认有这一行。new一个构造函数，返回一个对象&#125;var fn1 = new Foo(&#x27;smyhvae&#x27;, 26);var fn2 = new Foo(&#x27;vae&#x27;,30); //new 多个实例对象 与普通函数相比，构造函数有以下明显特点： 用new关键字调用。 不需要用return显式返回值的，默认会返回this，也就是新的实例对象。 建议函数名的首字母大写，与普通函数区分开。 参考链接： JavaScript中的普通函数与构造函数 当new之后，this会先变成一个空对象，然后通过this.name = name来赋值。 构造函数的扩展 上图中发现，数组、对象、函数也有构造函数，它们的构造函数是Array、Object、funtion。实际开发中，都推荐前面的书写方式。 原型规则原型规则是学习原型链的基础。原型规则有五条，下面来讲解。 规则1所有的引用类型（数组、对象、函数），都具有对象特性，都可以自由扩展属性。null除外。 举例： 规则2所有的引用类型（数组、对象、函数），都有一个_proto_属性，属性值是一个普通的对象。_proto_的含义是隐式原型。 其实，规则2是规则1的特例，只不过，js语法帮我们自动加了 规则2。 规则三所有的函数（不包括数组、对象），都有一个prototype属性，属性值是一个普通的对象。prototype的含义是显式原型。（实例没有这个属性） 规则四所有的引用类型（数组、对象、函数），_proto_属性指向它的构造函数的prototype值。 总结：以上四条，要先理解清楚，然后再来看下面的第五条。 规则五当试图获取一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_中寻找（即它的构造函数的prototype）。 举例代码1： 123456789101112131415161718//创建方法function Foo(name) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123;// 既然 Foo.prototype 是普通的对象，那也允许给它添加额外的属性 alertName console.log(this.name);&#125;var fn = new Foo(&#x27;smyhvae&#x27;);fn.printName = function () &#123; console.log(this.name);&#125;//测试fn.printName(); //输出结果：smyhvaefn.alertName(); //输出结果：smyhvae 上方代码中，虽然 alertName 不是 fn 自身的属性，但是会从它的构造函数的prototype里面找。 扩展：遍历循环对象自身的属性 我们知道，for ... in循环可以遍历对象。针对上面的那个fn对象，它自身有两个属性：name、printName，另外从原型中找到了第三个属性alertName。现在，如果我们对fn进行遍历，能遍历到两个属性还是三个属性呢？ 答案：两个。因为，高级浏览器中已经在 for ... in循环中屏蔽了来自原型的属性。但是，为了保证代码的健壮性，我们最好自己加上判断，手动将第三个属性屏蔽掉： 123456for (var item in fn) &#123; if (fn.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; 原型链还是拿上面的举例代码1举例，如果此时在最后面加一行代码： 1fn.toString(); //去 fn._proto_._proto_ 中查找 toString()方法 上面的代码中，fn直接调用了 toString()方法，这是因为它通过原型链，去_proto_的_proto_里找到了Object，而Object是由toString()方法的。 instanceof格式： 1对象 instanceof 构造函数 instanceof的作用：用于判断引用类型属于哪个构造函数。 例1：判断一个变量是否为数组： 变量 instanceof Array 例2： 1234567function Person()&#123;&#125;//p---&gt;Person.prototype---&gt;Object.prototype---&gt;nullvar p = new Person();//构造函数的**原型**是否在 p 对象的原型链上！console.log(p instanceof Person); 例3： 1fn instanceof Foo 上面这句话，判断逻辑是：fn 的_proto_一层一层往上找，看能否对应到 Foo.prototype。 原型链如下：（重要） 注意，Object这个构造方法的显式原型是null，这是一个特例。 常见题目 如何准确判断一个变量时数组类型 写一个原型链继承的例子 描述 new 一个对象的过程 zepto(或其他框架)源码中如何使用原型链 下面分别讲解。 题目一：如何准确判断一个变量时数组类型答案： 1234var arr1 = [];console.log(arr1 instanceof Array); //打印结果：true。console.log(typeof arr1); //打印结果：object。提示：typeof 方法无法判断是否为数组 上方代码表明，只能通过 instanceof 来判断是否为数组。而 typeof 的打印结果是 object。 题目二：写一个原型链继承的例子来看个基础的代码： 上面这个例子是基础，但是，在回答面试官的问题时，不要写上面的例子。要写成下面这个例子：（更贴近实战） 举例：写一个封装DOM查询的例子 这个例子有点像 jQuery 操作DOM节点。 表示这个例子，略难。 题目三：描述 new 一个对象的过程（1）创建一个新对象 （2）this 指向这个新对象 （3）执行代码（对this 赋值） （4）返回this 参考链接： 原型、原型链、继承模式","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/28-BOM的常见内置方法和内置对象","date":"2021-08-06T01:17:25.773Z","updated":"2021-07-28T07:34:11.346Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/28-BOM的常见内置方法和内置对象/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/28-BOM%E7%9A%84%E5%B8%B8%E8%A7%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 BOM的介绍JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。 什么是BOMBOM：Browser Object Model，浏览器对象模型。 BOM的结构图： 从上图也可以看出： window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。 DOM越是BOM的一部分。 window对象： window对象是JavaScript中的顶级对象。 全局变量、自定义函数也是window对象的属性和方法。 window对象下的属性和方法调用时，可以省略window。 下面讲一下 BOM 的常见内置方法和内置对象。 弹出系统对话框比如说，alert(1)是window.alert(1)的简写，因为它是window的子方法。 系统对话框有三种： 1234alert(); //不同浏览器中的外观是不一样的confirm(); //兼容不好prompt(); //不推荐使用 打开窗口、关闭窗口1、打开窗口： 1window.open(url,target,param) 参数解释： url：要打开的地址。 target：新窗口的位置。可以是：_blank 、_self、 _parent 父框架。 param：新窗口的一些设置。 返回值：新窗口的句柄。 param这个参数，可以填各种各样的参数（），比如： name：新窗口的名称，可以为空 features：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。 fullscreen= { yes/no/1/0 } 是否全屏，默认no channelmode= { yes/no/1/0 } 是否显示频道栏，默认no toolbar= { yes/no/1/0 } 是否显示工具条，默认no location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持） directories = { yes/no/1/0 } 是否显示转向按钮，默认no status= { yes/no/1/0 } 是否显示窗口状态条，默认no menubar= { yes/no/1/0 } 是否显示菜单，默认no scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no width=number 窗口宽度（像素单位） height=number 窗口高度（像素单位） top=number 窗口离屏幕顶部距离（像素单位） left=number 窗口离屏幕左边距离（像素单位） 各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。 2、关闭窗口：window.close() （1）和（2）的代码举例： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;javascript:;&quot;&gt;点击我打开一个新的页面&lt;/a&gt;&lt;a href=&quot;javascript:;&quot;&gt;点击我关闭本页面&lt;/a&gt;&lt;script&gt; //新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数); var a1 = document.getElementsByTagName(&quot;a&quot;)[0]; var a2 = document.getElementsByTagName(&quot;a&quot;)[1]; a1.onclick = function () &#123;//举例1： window.open(&quot;http://www.jx.com&quot;,&quot;_blank&quot;); var json = &#123; &quot;name&quot;: &quot;helloworld&quot;, &quot;fullscreen&quot;: &quot;no&quot;, &quot;location&quot;: &quot;no&quot;, &quot;width&quot;: &quot;100px&quot;, &quot;height&quot;: &quot;100px&quot;, &quot;top&quot;: &quot;100px&quot;, &quot;left&quot;: &quot;100px&quot; &#125;; window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;, json); //举例2 &#125; //关闭本页面 a2.onclick = function () &#123; window.close(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、新窗口相关： 新窗口.moveTo(5,5) 新窗口.moveBy() 新窗口.resizeTo() window.resizeBy() 代码举例： 12var newWin = window.open(&quot;demo.html&quot;, &quot;_blank&quot;, json);newWin.moveTo(500, 500); location对象window.location可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。 location对象的属性 href：跳转 hash 返回url中#后面的内容，包含# host 主机名，包括端口 hostname 主机名 pathname url中的路径部分 protocol 协议 一般是http、https search 查询字符串 location.href属性举例： 举例1：点击盒子时，进行跳转。 12345678910111213&lt;body&gt;&lt;div&gt;smyhvae&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onclick = function () &#123; location.href = &quot;http://www.baidu.com&quot;; //点击div时，跳转到指定链接 // window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;); //方式二 &#125;&lt;/script&gt;&lt;/body&gt; 举例2：5秒后自动跳转到百度。 有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例： 123456&lt;script&gt; setTimeout(function () &#123; location.href = &quot;http://www.baidu.com&quot;; &#125;, 5000);&lt;/script&gt; location对象的方法 location.assign()：改变浏览器地址栏的地址，并记录到历史中 设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。 location.replace()：替换浏览器地址栏的地址，不会记录到历史中 location.reload()：重新加载 navigator对象window.navigator 的一些属性可以获取客户端的一些信息。 userAgent：系统，浏览器) platform：浏览器支持的系统，win/mac/linux 举例： 12console.log(navigator.userAgent);console.log(navigator.platform); 效果如下： history对象1、历史记录管理 2、后退： history.back() history.go(-1)：0是刷新 3、前进： history.forward() history.go(1) 用的不多。因为浏览器中已经自带了这些功能的按钮： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/27-事件委托","date":"2021-08-06T01:17:25.771Z","updated":"2021-07-28T07:34:11.345Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/27-事件委托/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/27-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件委托","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/26-事件对象Event和冒泡","date":"2021-08-06T01:17:25.769Z","updated":"2021-07-28T07:34:11.345Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/26-事件对象Event和冒泡/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/26-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1Event%E5%92%8C%E5%86%92%E6%B3%A1/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 绑定事件的两种方式/DOM事件的级别我们在上一篇文章 DOM操作详解 中已经讲过事件的概念。这里讲一下注册事件的两种方式，我们以onclick事件为例。 DOM0的写法：onclick123element.onclick = function () &#123;&#125; 举例： 1234567891011121314151617&lt;body&gt;&lt;button&gt;点我&lt;/button&gt;&lt;script&gt; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; //这种事件绑定的方法容易被层叠。 btn.onclick = function () &#123; console.log(&quot;事件1&quot;); &#125; btn.onclick = function () &#123; console.log(&quot;事件2&quot;); &#125;&lt;/script&gt;&lt;/body&gt; 点击按钮后，上方代码的打印结果： 1事件2 我们可以看到，这种绑定事件的方式，会层叠掉之前的事件。 DOM2的写法：addEventListener123element.addEventListener(&#x27;click&#x27;, function () &#123;&#125;, false); 参数解释： 参数1：事件名(注意，没有on) 参数2：事件名(执行函数) 参数3：true表示捕获阶段触发，false表示冒泡阶段触发（默认）。如果不写，则默认为false。【重要】 举例： 1234567891011121314151617181920&lt;body&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;script&gt; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; //addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行 //第二种事件绑定的方法不会出现层叠。（更适合团队开发） btn.addEventListener(&quot;click&quot;, fn1); btn.addEventListener(&quot;click&quot;, fn2); function fn1() &#123; console.log(&quot;事件1&quot;); &#125; function fn2() &#123; console.log(&quot;事件2&quot;); &#125;&lt;/script&gt;&lt;/body&gt; 点击按钮后，上方代码的打印结果： 12事件1事件2 我们可以看到，这种绑定事件的方式，不会层叠掉之前的事件。 事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。比如鼠标操作时候，会添加鼠标位置的相关信息到事件对象中。 所有浏览器都支持event对象，但支持的方式不同。如下。 （1）普通浏览器支持 event。比如： （2）ie 678 支持 window.event。 于是，我们可以采取一种兼容性的写法。如下： 1event = event || window.event; ////兼容性写法 代码举例： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //点击页面的任何部分 document.onclick = function (event) &#123; event = event || window.event; ////兼容性写法 console.log(event); console.log(event.timeStamp); console.log(event.bubbles); console.log(event.button); console.log(event.pageX); console.log(event.pageY); console.log(event.screenX); console.log(event.screenY); console.log(event.target); console.log(event.type); console.log(event.clientX); console.log(event.clientY); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; event 属性event 有很多属性，比如： 由于pageX 和 pageY的兼容性不好，我们可以这样做： 鼠标在页面的位置 = 被卷去的部分+可视区域部分。 Event举例举例1：鼠标跟随代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; height: 5000px; &#125; img &#123; position: absolute; padding: 10px 0; border: 1px solid #ccc; cursor: pointer; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt;&lt;script&gt; //需求：点击页面的任何地方，图片跟随鼠标移动到点击位置。 //思路：获取鼠标在页面中的位置，然图片缓慢运动到鼠标点击的位置。 // 兼容ie67做pageY和pageX； // 原理： 鼠标在页面的位置 = 被卷去的部分+可视区域部分。 //步骤： //1.老三步。 //2.获取鼠标在页面中的位置。 //3.利用缓动原理，慢慢的运动到指定位置。（包括左右和上下） //1.老三步。 var img = document.getElementsByTagName(&quot;img&quot;)[0]; var timer = null; var targetx = 0; var targety = 0; var leaderx = 0; var leadery = 0; //给整个文档绑定点击事件获取鼠标的位置。 document.onclick = function (event) &#123; //新五步 //兼容获取事件对象 event = event || window.event; //鼠标在页面的位置 = 被卷去的部分+可视区域部分。 var pagey = event.pageY || scroll().top + event.clientY; var pagex = event.pageX || scroll().left + event.clientX; targety = pagey - 30; targetx = pagex - 50; //要用定时器，先清定时器 clearInterval(timer); timer = setInterval(function () &#123; //为盒子的位置获取值 leaderx = img.offsetLeft; //获取步长 var stepx = (targetx - leaderx) / 10; //二次处理步长 stepx = stepx &gt; 0 ? Math.ceil(stepx) : Math.floor(stepx); leaderx = leaderx + stepx; //赋值 img.style.left = leaderx + &quot;px&quot;; //为盒子的位置获取值 leadery = img.offsetTop; //获取步长 var stepy = (targety - leadery) / 10; //二次处理步长 stepy = stepy &gt; 0 ? Math.ceil(stepy) : Math.floor(stepy); leadery = leadery + stepy; //赋值 img.style.top = leadery + &quot;px&quot;; //清定时器 if (Math.abs(targety - img.offsetTop) &lt;= Math.abs(stepy) &amp;&amp; Math.abs(targetx - img.offsetLeft) &lt;= Math.abs(stepx)) &#123; img.style.top = targety + &quot;px&quot;; img.style.left = targetx + &quot;px&quot;; clearInterval(timer); &#125; &#125;, 30); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： event应用举例：获取鼠标距离所在盒子的距离关键点： 1鼠标距离所在盒子的距离 = 鼠标在整个页面的位置 - 所在盒子在整个页面的位置 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; height: 200px; padding-top: 100px; background-color: pink; margin: 100px; text-align: center; font: 18px/30px &quot;simsun&quot;; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //需求：鼠标进入盒子之后只要移动，哪怕1像素，随时显示鼠标在盒子中的坐标。 //技术点：新事件，onmousemove：在事件源上，哪怕鼠标移动1像素也会触动这个事件。 //一定程度上，模拟了定时器 //步骤： //1.老三步和新五步 //2.获取鼠标在整个页面的位置 //3.获取盒子在整个页面的位置 //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 //1.老三步和新五步 var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmousemove = function (event) &#123; event = event || window.event; //2.获取鼠标在整个页面的位置 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //3.获取盒子在整个页面的位置 // var xx = // var yy = //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 var targetx = pagex - div.offsetLeft; var targety = pagey - div.offsetTop; this.innerHTML = &quot;鼠标在盒子中的X坐标为：&quot; + targetx + &quot;px;&lt;br&gt;鼠标在盒子中的Y坐标为：&quot; + targety + &quot;px;&quot; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 举例：商品放大镜 代码实现： （1）index.html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 350px; height: 350px; margin: 100px; border: 1px solid #ccc; position: relative; &#125; .big &#123; width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none; &#125; /*mask的中文是：遮罩*/ .mask &#123; width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0; left: 0; cursor: move; display: none; &#125; .small &#123; position: relative; &#125; img &#123; vertical-align: top; &#125; &lt;/style&gt; &lt;script src=&quot;tools.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; //需求：鼠标放到小盒子上，让大盒子里面的图片和我们同步等比例移动。 //技术点：onmouseenter==onmouseover 第一个不冒泡 //技术点：onmouseleave==onmouseout 第一个不冒泡 //步骤： //1.鼠标放上去显示盒子，移开隐藏盒子。 //2.老三步和新五步（黄盒子跟随移动） //3.右侧的大图片，等比例移动。 //0.获取相关元素 var box = document.getElementsByClassName(&quot;box&quot;)[0]; var small = box.firstElementChild || box.firstChild; var big = box.children[1]; var mask = small.children[1]; var bigImg = big.children[0]; //1.鼠标放上去显示盒子，移开隐藏盒子。(为小盒子绑定事件) small.onmouseenter = function () &#123; //封装好方法调用：显示元素 show(mask); show(big); &#125; small.onmouseleave = function () &#123; //封装好方法调用：隐藏元素 hide(mask); hide(big); &#125; //2.老三步和新五步（黄盒子跟随移动） //绑定的事件是onmousemove，而事件源是small(只要在小盒子上移动1像素，黄盒子也要跟随) small.onmousemove = function (event) &#123; //新五步 event = event || window.event; //想要移动黄盒子，必须要知道鼠标在small小图中的位置。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //x：mask的left值，y：mask的top值。 var x = pagex - box.offsetLeft - mask.offsetWidth / 2; //除以2，可以保证鼠标mask的中间 var y = pagey - box.offsetTop - mask.offsetHeight / 2; //限制换盒子的范围 //left取值为大于0，小盒子的宽-mask的宽。 if (x &lt; 0) &#123; x = 0; &#125; if (x &gt; small.offsetWidth - mask.offsetWidth) &#123; x = small.offsetWidth - mask.offsetWidth; &#125; //top同理。 if (y &lt; 0) &#123; y = 0; &#125; if (y &gt; small.offsetHeight - mask.offsetHeight) &#123; y = small.offsetHeight - mask.offsetHeight; &#125; //移动黄盒子 console.log(small.offsetHeight); mask.style.left = x + &quot;px&quot;; mask.style.top = y + &quot;px&quot;; //3.右侧的大图片，等比例移动。 //如何移动大图片？等比例移动。 // 大图片/大盒子 = 小图片/mask盒子 // 大图片走的距离/mask走的距离 = （大图片-大盒子）/（小图片-黄盒子）// var bili = (bigImg.offsetWidth-big.offsetWidth)/(small.offsetWidth-mask.offsetWidth); //大图片走的距离/mask盒子都的距离 = 大图片/小图片 var bili = bigImg.offsetWidth / small.offsetWidth; var xx = bili * x; //知道比例，就可以移动大图片了 var yy = bili * y; bigImg.style.marginTop = -yy + &quot;px&quot;; bigImg.style.marginLeft = -xx + &quot;px&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;small&quot;&gt; &lt;img src=&quot;images/001.jpg&quot; alt=&quot;&quot;/&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;big&quot;&gt; &lt;img src=&quot;images/0001.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （2）tools.js: 123456789101112131415161718192021222324252627282930313233/** * Created by smyhvae on 2018/02/03. *///显示和隐藏function show(ele) &#123; ele.style.display = &quot;block&quot;;&#125;function hide(ele) &#123; ele.style.display = &quot;none&quot;;&#125;function scroll() &#123; // 开始封装自己的scrollTop if (window.pageYOffset != null) &#123; // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode === &quot;CSS1Compat&quot;) &#123; // 标准浏览器 来判断有没有声明DTD return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125; 效果演示： 小窗口拖拽案例暂略。 DOM事件流事件传播的三个阶段是：事件捕获、事件冒泡和目标。 事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标 target。（从祖先元素往子元素查找，DOM树结构）。在这个过程中，事件相应的监听函数是不会被触发的。 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。 事件冒泡阶段：事件从事件目标 target 开始，往上冒泡直到页面的最上一级标签。（从子元素到祖先元素冒泡） 如下图所示： PS：这个概念类似于 Android 里的 touch 事件传递。 事件捕获addEventListener可以捕获事件： 123box1.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 box3&quot;);&#125;, true); 上面的方法中，参数为true，代表事件在捕获阶段执行。 代码演示： 12345678910111213141516//参数为true，代表捕获；参数为false或者不写参数，代表冒泡box3.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 child&quot;);&#125;, true);box2.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 father&quot;);&#125;, true);box1.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 grandfather&quot;);&#125;, true);document.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 body&quot;);&#125;, true); 效果演示： 说明：捕获阶段，事件依次传递的顺序是：window –&gt; document –&gt; html–&gt; body –&gt; 父元素、子元素、目标元素。 PS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 事件捕获阶段的完整写法是： 123456789101112131415161718192021222324window.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 window&quot;);&#125;, true);document.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 document&quot;);&#125;, true);document.documentElement.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 html&quot;);&#125;, true);document.body.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 body&quot;);&#125;, true);fatherBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 father&quot;);&#125;, true);childBox.addEventListener(&quot;click&quot;, function () &#123; alert(&quot;捕获 child&quot;);&#125;, true); 补充一个知识点： 在 js中： 如果想获取 html节点，方法是document.documentElement。 如果想获取 body 节点，方法是：document.body。 二者不要混淆了。 事件冒泡事件冒泡: 当一个元素上的事件被触发的时候（比如说鼠标点击了一个按钮），同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。 通俗来讲，冒泡指的是：子元素的事件被触发时，父盒子的同样的事件也会被触发。取消冒泡就是取消这种机制。 代码演示： 1234567891011121314151617//事件冒泡box3.onclick = function () &#123; alert(&quot;child&quot;);&#125;box2.onclick = function () &#123; alert(&quot;father&quot;);&#125;box1.onclick = function () &#123; alert(&quot;grandfather&quot;);&#125;document.onclick = function () &#123; alert(&quot;body&quot;);&#125; 上图显示，当我点击儿子 box3的时候，它的父亲box2、box1、body都依次被触发了。即使我改变代码的顺序，也不会影响效果的顺序。 当然，上面的代码中，我们用 addEventListener 这种 DOM2的写法也是可以的，但是第三个参数要写 false，或者不写。 冒泡顺序： 一般的浏览器: （除IE6.0之外的浏览器） div -&gt; body -&gt; html -&gt; document -&gt; window IE6.0： div -&gt; body -&gt; html -&gt; document 不是所有的事件都能冒泡以下事件不冒泡：blur、focus、load、unload、onmouseenter、onmouseleave。意思是，事件不会往父元素那里传递。 我们检查一个元素是否会冒泡，可以通过事件的以下参数： 1event.bubbles 如果返回值为true，说明该事件会冒泡；反之则相反。 举例： 123456box1.onclick = function (event) &#123; alert(&quot;冒泡 child&quot;); event = event || window.event; console.log(event.bubbles); //打印结果：true&#125; 阻止冒泡的方法w3c的方法：（火狐、谷歌、IE11） 1event.stopPropagation(); IE10以下则是： 1event.cancelBubble = true 兼容代码如下： 12345678910111213box3.onclick = function (event) &#123; alert(&quot;child&quot;); //阻止冒泡 event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125; 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。 事件委托事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素。 比如说有一个列表 ul，列表之中有大量的列表项 li： 12345678&lt;ul id=&quot;parent-list&quot;&gt; &lt;li id=&quot;li-1&quot;&gt;Item 1&lt;/li&gt; &lt;li id=&quot;li-2&quot;&gt;Item 2&lt;/li&gt; &lt;li id=&quot;li-3&quot;&gt;Item 3&lt;/li&gt; &lt;li id=&quot;li-4&quot;&gt;Item 4&lt;/li&gt; &lt;li id=&quot;li-5&quot;&gt;Item 5&lt;/li&gt; &lt;li id=&quot;li-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 当我们的鼠标移到Li上的时候，需要获取此Li的相关信息并飘出悬浮窗以显示详细信息，或者当某个Li被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个Li都绑定类似onMouseOver或者onClick之类的事件监听： 12345678910111213//每个 li 中做的事情function addListeners4Li(liNode)&#123; liNode.onclick = function clickHandler()&#123;...&#125;; liNode.onmouseover = function mouseOverHandler()&#123;...&#125;&#125;window.onload = function()&#123; var ulNode = document.getElementById(&quot;parent-list&quot;); var liNodes = ulNode.getElementByTagName(&quot;Li&quot;); for(var i=0, l = liNodes.length; i &lt; l; i++)&#123; addListeners4Li(liNodes[i]); &#125;&#125; 但是，上面的做法会消耗内存和性能。 因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件的时候再去匹配判断目标元素。如下： 123456789// 获取父节点，并为它注册click事件。 false 表示事件在冒泡阶段触发（默认）document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;, function (e) &#123; // event.target 代表的是子元素。toUpperCase 指的是转换为大写字母 if (e.target &amp;&amp; e.target.nodeName.toUpperCase == &quot;LI&quot;) &#123; // 真正的处理过程在这里 console.log(&quot;List item &quot;, e.target.id, &quot; was clicked!&quot;); &#125;&#125;, false); 上方代码，为父节点注册click事件，当子节点被点击的时候，click事件会从子节点开始向上冒泡。父节点捕获到事件之后，开始执行方法体里的内容：通过判断 e.target 拿到了被点击的子节点li。从而可以获取到相应的信息，并作处理。 换而言之，事件是在父节点上注册的，参数为false，说明事件是在冒泡阶段触发（往上传递），那就只有父节点能拿到事件，子节点是不可能拿到事件的。 所以事件委托可以减少大量的内存消耗，提高效率。 事件委托的参考链接： 荐 | JavaScript事件代理和委托（Delegation） JavaScript 事件委托详解 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/25-DOM操作","date":"2021-08-06T01:17:25.767Z","updated":"2021-07-28T07:34:11.345Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/25-DOM操作/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/25-DOM%E6%93%8D%E4%BD%9C/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 前言JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。 事件 JS是以事件驱动为核心的一门语言。 事件的三要素事件的三要素：事件源、事件、事件驱动程序。 比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯的开和关。 再比如，网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。 于是我们可以总结出：谁引发的后续事件，谁就是事件源。 总结如下： 事件源：引发后续事件的html标签。 事件：js已经定义好了（见下图）。 事件驱动程序：对样式和html的操作。也就是DOM。 代码书写步骤如下：（重要） （1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById （2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 }; （3）书写事件驱动程序：关于DOM的操作。 最简单的代码举例：（点击box1，然后弹框） 1234567891011121314&lt;body&gt;&lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 1、获取事件源 var div = document.getElementById(&quot;box1&quot;); // 2、绑定事件 div.onclick = function () &#123; // 3、书写事件驱动程序 alert(&quot;我是弹出的内容&quot;); &#125;&lt;/script&gt;&lt;/body&gt; 常见的事件如下： 下面针对这事件的三要素，进行分别介绍。 1、获取事件源的方式（DOM节点的获取）获取事件源的常见方式如下： 12345 var div1 = document.getElementById(&quot;box1&quot;); //方式一：通过id获取单个标签var arr1 = document.getElementsByTagName(&quot;div&quot;); //方式二：通过 标签名 获得 标签数组，所以有svar arr2 = document.getElementsByClassName(&quot;hehe&quot;); //方式三：通过 类名 获得 标签数组，所以有s 2、绑定事件的方式方式一：直接绑定匿名函数 123456789&lt;div id=&quot;box1&quot; &gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var div1 = document.getElementById(&quot;box1&quot;); //绑定事件的第一种方式 div1.onclick = function () &#123; alert(&quot;我是弹出的内容&quot;); &#125;&lt;/script&gt; 方式二：先单独定义函数，再绑定 1234567891011 &lt;div id=&quot;box1&quot; &gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var div1 = document.getElementById(&quot;box1&quot;); //绑定事件的第二种方式 div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。 //单独定义函数 function fn() &#123; alert(&quot;我是弹出的内容&quot;); &#125;&lt;/script&gt; 注意上方代码的注释。**绑定的时候，是写fn，不是写fn()**。fn代表的是整个函数，而fn()代表的是返回值。 方式三：行内绑定 12345678910&lt;!--行内绑定--&gt;&lt;div id=&quot;box1&quot; onclick=&quot;fn()&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; function fn() &#123; alert(&quot;我是弹出的内容&quot;); &#125;&lt;/script&gt; 注意第一行代码，绑定时，是写的&quot;fn()&quot;，不是写的&quot;fn&quot;。因为绑定的这段代码不是写在js代码里的，而是被识别成了字符串。 3、事件驱动程序我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下： 点击鼠标时，原本粉色的div变大了，背景变红： 1234567891011121314151617181920212223 &lt;style&gt; #box1 &#123; width: 100px; height: 100px; background-color: pink; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box1&quot; &gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var div1 = document.getElementById(&quot;box1&quot;); //点击鼠标时，原本粉色的div变大了，背景变红了 div1.onclick = function () &#123; div1.style.width = &quot;200px&quot;; //属性值要写引号 div1.style.height = &quot;200px&quot;; div1.style.backgroundColor = &quot;red&quot;; //属性名是backgroundColor，不是background-color &#125;&lt;/script&gt; 上方代码的注意事项： 在js里写属性值时，要用引号 在js里写属性名时，是backgroundColor，不是CSS里面的background-color。 实现效果如下： onload事件 onload事件比较特殊，这里单独讲一下。 当页面加载（文本和图片）完毕的时候，触发onload事件。 举例： 12345&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; console.log(&quot;smyhvae&quot;); //等页面加载完毕时，打印字符串 &#125;&lt;/script&gt; 有一点我们要知道：js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。 建议是：整个页面上所有元素加载完毕在执行js内容。所以，window.onload可以预防使用标签在定义标签之前。 事件举例：京东顶部广告栏 比如上面这张图，当鼠标点击右上角的X时，关掉整个广告栏，这就要用到事件。 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .top-banner &#123; background-color: pink; height: 80px; &#125; .w &#123; width: 1210px; margin: 10px auto; position: relative; &#125; img &#123; display: block; width: 1210px; height: 80px; background-color: blue; &#125; a &#123; position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px &quot;simsum&quot;; text-align: center; &#125; .hide &#123; display: none!important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;top-banner&quot; id=&quot;topBanner&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; &lt;a href=&quot;#&quot; id=&quot;closeBanner&quot;&gt;×&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt; //需求：点击案例，隐藏盒子。 //思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。 //1.获取事件源和相关元素 var closeBanner = document.getElementById(&quot;closeBanner&quot;); var topBanner = document.getElementById(&quot;topBanner&quot;); //2.绑定事件 closeBanner.onclick = function () &#123; //3.书写事件驱动程序 //类控制// topBanner.className += &quot; hide&quot;; //保留原类名，添加新类名 topBanner.className = &quot;hide&quot;;//替换旧类名（方式一）// topBanner.style.display = &quot;none&quot;; //方式二：与上一行代码的效果相同 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。 事件举例：要求实现效果：当鼠标悬停在img上时，更换为另外一张图片；鼠标离开时，还原为本来的图片。 代码实现： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; //window.onload页面加载完毕以后再执行此代码 window.onload = function () &#123; //需求：鼠标放到img上，更换为另一张图片，也就是修改路径（src的值）。 //步骤： //1.获取事件源 //2.绑定事件 //3.书写事件驱动程序 //1.获取事件源 var img = document.getElementById(&quot;box&quot;); //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseover = function () &#123; //3.书写事件驱动程序(修改src) img.src = &quot;image/jd2.png&quot;;// this.src = &quot;image/jd2.png&quot;; &#125; //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseout = function () &#123; //3.书写事件驱动程序(修改src) img.src = &quot;image/jd1.png&quot;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=&quot;box&quot; src=&quot;image/jd1.png&quot; style=&quot;cursor: pointer;border: 1px solid #ccc;&quot;/&gt;&lt;/html&gt; DOM的介绍什么是DOMDOM：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。 DOM就是由节点组成的。 解析过程HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的属性。 DOM树（一切都是节点）DOM的数据结构如下： 上图可知，在HTML当中，一切都是节点：（非常重要） 元素节点：HMTL标签。 文本节点：标签中的文字（比如标签之间的空格、换行） 属性节点：：标签的属性。 整个html文档就是一个文档节点。所有的节点都是Object。 DOM可以做什么 找对象（元素节点） 设置元素的属性值 设置元素的样式 动态创建和删除元素 事件的触发响应：事件源、事件、事件的驱动程序 DOM节点的获取DOM节点的获取方式其实就是获取事件源的方式，在上一段已经讲到。这里再重复一下。 操作元素节点，必须首先找到该节点。有三种方式可以获取DOM节点： 12345 var div1 = document.getElementById(&quot;box1&quot;); //方式一：通过id获取单个标签var arr1 = document.getElementsByTagName(&quot;div&quot;); //方式二：通过 标签名 获得 标签数组，所以有svar arr2 = document.getElementsByClassName(&quot;hehe&quot;); //方式三：通过 类名 获得 标签数组，所以有s 既然方式二、方式三获取的是标签数组，那么习惯性是先遍历之后再使用。 特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下： 123document.getElementsByTagName(&quot;div1&quot;)[0]; //取数组中的第一个元素document.getElementsByClassName(&quot;hehe&quot;)[0]; //取数组中的第一个元素 DOM访问关系的获取DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下： 节点的访问关系，是以属性的方式存在的。 JS中的父子兄访问关系： 这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。 获取父节点调用者就是节点。一个节点只有一个父节点，调用方式就是 1节点.parentNode 获取兄弟节点1、下一个节点 | 下一个元素节点： Sibling的中文是兄弟。 （1）nextSibling： 火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。 IE678版本：指下一个元素节点（标签）。 （2）nextElementSibling： 火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。 总结：为了获取下一个元素节点，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写： 1下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling 2、前一个节点 | 前一个元素节点： previous的中文是：前一个。 （1）previousSibling： 火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。 IE678版本：指前一个元素节点（标签）。 （2）previousElementSibling： 火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。 总结：为了获取前一个元素节点，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写： 1前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling 3、补充：获得任意一个兄弟节点： 1节点自己.parentNode.children[index]; //随意得到兄弟节点 获取单个的子节点1、第一个子节点 | 第一个子元素节点： （1）firstChild： 火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。 IE678版本：指第一个子元素节点（标签）。 （2）firstElementChild： 火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。 总结：为了获取第一个子元素节点，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写： 1第一个子元素节点 = 节点.firstElementChild || 节点.firstChild 2、最后一个子节点 | 最后一个子元素节点： （1）lastChild： 火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。 IE678版本：指最后一个子元素节点（标签）。 （2）lastElementChild： 火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。 总结：为了获取最后一个子元素节点，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写： 1最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild 获取所有的子节点（1）childNodes：标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。 火狐 谷歌等高本版会把换行也看做是子节点。 用法： 1子节点数组 = 父节点.childNodes; //获取所有节点。 （2）children：非标准属性。返回的是指定元素的子元素节点的集合。【重要】 它只返回HTML节点，甚至不返回文本节点。 在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。 虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。 用法：（用的最多） 1子节点数组 = 父节点.children; //获取所有节点。用的最多。 DOM节点的操作（重要）上一段的内容：节点的访问关系都是属性。 本段的内容：节点的操作都是函数（方法）。 创建节点格式如下： 1新的标签(元素节点) = document.createElement(&quot;标签名&quot;); 比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; var a1 = document.createElement(&quot;li&quot;); //创建一个li标签 var a2 = document.createElement(&quot;adbc&quot;); //创建一个不存在的标签 console.log(a1); console.log(a2); console.log(typeof a1); console.log(typeof a2);&lt;/script&gt; 打印结果： 插入节点插入节点有两种方式，它们的含义是不同的。 方式1： 1父节点.appendChild(新的子节点); 解释：父节点的最后插入一个新的子节点。 方式2： 1父节点.insertBefore(新的子节点,作为参考的子节点) 解释： 在参考节点前插入一个新的节点。 如果参考节点为null，那么他将在父节点里面的最后插入一个子节点。 我们可以看到，li标签确实被插入到了box1标签的里面，和box2并列了。 方式2的举例： 我们可以看到，b1标签被插入到了box1标签的里面，和a1标签并列，在a1标签的前面。 特别强调： 关于方式1的appendChild方法，这里要强调一下。比如，现在有下面这样一个div结构： 12345678&lt;div class=&quot;box11&quot;&gt; &lt;div class=&quot;box12&quot;&gt;生命壹号&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box21&quot;&gt; &lt;div class=&quot;box22&quot;&gt;永不止步&lt;/div&gt;&lt;/div&gt; 上方结构中，子盒子box12是在父亲box11里的，子盒子box22是在父亲box21里面的。现在，如果我调用方法box11.appendChild(box22)，最后产生的结果是：box22会跑到box11中（也就是说，box22不在box21里面了）。这是一个很神奇的事情： 删除节点格式如下： 1父节点.removeChild(子节点); 解释：用父节点删除子节点。必须要指定是删除哪个子节点。 如果我想删除自己这个节点，可以这么做： 1node1.parentNode.removeChild(node1); 复制节点（克隆节点）格式如下： 123要复制的节点.cloneNode(); //括号里不带参数和带参数false，效果是一样的。要复制的节点.cloneNode(true); 括号里带不带参数，效果是不同的。解释如下： 不带参数/带参数false：只复制节点本身，不复制子节点。 带参数true：既复制节点本身，也复制其所有的子节点。 设置节点的属性我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。 我们就统一拿下面这个标签来举例： 1&lt;img src=&quot;images/1.jpg&quot; class=&quot;image-box&quot; title=&quot;美女图片&quot; alt=&quot;地铁一瞥&quot; id=&quot;a1&quot;&gt; 下面分别介绍。 1、获取节点的属性值方式1： 12元素节点.属性;元素节点[属性]; 举例：（获取节点的属性值） 1234567891011121314151617&lt;body&gt;&lt;img src=&quot;images/1.jpg&quot; class=&quot;image-box&quot; title=&quot;美女图片&quot; alt=&quot;地铁一瞥&quot; id=&quot;a1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var myNode = document.getElementsByTagName(&quot;img&quot;)[0]; console.log(myNode.src); console.log(myNode.className); //注意，是className，不是class console.log(myNode.title); console.log(&quot;------------&quot;); console.log(myNode[&quot;src&quot;]); console.log(myNode[&quot;className&quot;]); //注意，是className，不是class console.log(myNode[&quot;title&quot;]);&lt;/script&gt;&lt;/body&gt; 上方代码中的img标签，有各种属性，我们可以逐一获取，打印结果如下： 方式2： 1元素节点.getAttribute(&quot;属性名称&quot;); 举例： 123console.log(myNode.getAttribute(&quot;src&quot;));console.log(myNode.getAttribute(&quot;class&quot;)); //注意是class，不是classNameconsole.log(myNode.getAttribute(&quot;title&quot;)); 打印结果： 方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。 2、设置节点的属性值方式1举例：（设置节点的属性值） 12myNode.src = &quot;images/2.jpg&quot; //修改src的属性值myNode.className = &quot;image2-box&quot;; //修改class的name 方式2： 1元素节点.setAttribute(属性名, 新的属性值); 方式2举例：（设置节点的属性值） 123myNode.setAttribute(&quot;src&quot;,&quot;images/3.jpg&quot;);myNode.setAttribute(&quot;class&quot;,&quot;image3-box&quot;);myNode.setAttribute(&quot;id&quot;,&quot;你好&quot;); 3、删除节点的属性格式： 1元素节点.removeAttribute(属性名); 举例：（删除节点的属性） 12myNode.removeAttribute(&quot;class&quot;);myNode.removeAttribute(&quot;id&quot;); 总结： 获取节点的属性值和设置节点的属性值，都有两种方式，但这两种方式是有区别的。 方式一的元素节点.属性和元素节点[属性]:绑定的属性值不会出现在标签上。 方式二的get/set/removeAttribut: 绑定的属性值会出现在标签上。 这其实很好理解，方式一操作的是属性而已，方式二操作的是标签本身。 另外，需要注意的是：这两种方式不能交换使用，get值和set值必须使用用一种方法。 举例： 123456789101112131415161718&lt;body&gt;&lt;div id=&quot;box&quot; title=&quot;主体&quot; class=&quot;asdfasdfadsfd&quot;&gt;我爱你中国&lt;/div&gt;&lt;script&gt; var div = document.getElementById(&quot;box&quot;); //采用方式一进行set div.aaaa = &quot;1111&quot;; console.log(div.aaaa); //打印结果：1111。可以打印出来，但是不会出现在标签上 //采用方式二进行set div.setAttribute(&quot;bbbb&quot;,&quot;2222&quot;); //bbbb作为新增的属性，会出现在标签上 console.log(div.getAttribute(&quot;aaaa&quot;)); //打印结果：null。因为方式一的set，无法采用方式二进行get。 console.log(div.bbbb); //打印结果：undefined。因为方式二的set，无法采用方式一进行get。&lt;/script&gt;&lt;/body&gt; DOM对象的属性DOM对象的属性和HTML的标签属性几乎是一致的。例如：src、title、className、href等。 innerHTML和innerText的区别 value：标签的value属性。 innerHTML：双闭合标签里面的内容（识别标签）。 innerText：双闭合标签里面的内容（不识别标签）。（老版本的火狐用textContent） 获取内容举例： 如果我们想获取innerHTML和innerText里的内容，看看会如何：（innerHTML会获取到标签本身，而innerText则不会） 修改内容举例：（innerHTML会修改标签本身，而innerText则不会） nodeType属性这里讲一下nodeType属性。 nodeType == 1 表示的是元素节点（标签） 。记住：元素就是标签。 nodeType == 2 表示是属性节点。 nodeType == 3 是文本节点。 nodeType、nodeName、nodeValue我们那下面这个标签来举例： 123&lt;div id=&quot;box&quot; value=&quot;111&quot;&gt; 生命壹号&lt;/div&gt; 上面这个标签就包含了三种节点： 元素节点（标签） 属性节点 文本节点 获取这三个节点的方式如下： 12345678910111213var element = document.getElementById(&quot;box1&quot;); //获取元素节点（标签）var attribute = element.getAttributeNode(&quot;id&quot;); //获取box1的属性节点var txt = element.firstChild; //获取box1的文本节点var value = element.getAttribute(&quot;id&quot;); //获取id的属性值console.log(element);console.log(&quot;--------------&quot;);console.log(attribute);console.log(&quot;--------------&quot;);console.log(txt);console.log(&quot;--------------&quot;);console.log(value); 打印结果如下： 既然这三个都是节点，如果我想获取它们的nodeType、nodeName、nodeValue，代码如下： 12345678910111213141516171819202122var element = document.getElementById(&quot;box1&quot;); //获取元素节点（标签）var attribute = element.getAttributeNode(&quot;id&quot;); //获取box1的属性节点var txt = element.firstChild; //获取box1的文本节点//获取nodeTypeconsole.log(element.nodeType); //1console.log(attribute.nodeType); //2console.log(txt.nodeType); //3console.log(&quot;--------------&quot;);//获取nodeNameconsole.log(element.nodeName); //DIVconsole.log(attribute.nodeName); //idconsole.log(txt.nodeName); //#textconsole.log(&quot;--------------&quot;);//获取nodeValueconsole.log(element.nodeValue); //nullconsole.log(attribute.nodeValue); //box1console.log(txt.nodeValue); //生命壹号 打印结果如下： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/22-正则表达式","date":"2021-08-06T01:17:25.765Z","updated":"2021-07-28T07:34:11.344Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/22-正则表达式/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/22-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式简介定义：正则表达式用于定义一些字符串的规则。 作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。 如果你想查看正则更多的内容，可以查阅官方文档关于 RegExp 这个内置对象的用法。 创建正则表达式的对象方式一：使用构造函数创建正则表达式的对象语法： 123var 变量 = new RegExp(&quot;正则表达式&quot;); // 注意，参数是字符串var 变量 = new RegExp(&quot;正则表达式&quot;, &quot;匹配模式&quot;); // 注意，两个参数都是字符串 备注：RegExp的意思是 Regular expression。使用typeof检查正则对象，会返回object。 上面的语法中，既可以传一个参数，也可以传两个参数。 创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤： （1）创建正则表达式的对象 reg。 （2）使用 reg 的test() 方法，判断指定字符串是否符合规则。 我们来看看下面的例子。 1、传一个参数时： 构造函数 RegExp 中，可以只传一个参数。 代码举例： 123456789var reg = new RegExp(&quot;a&quot;); // 定义一个正则表达式：检查一个字符串中是否含有 avar str1 = &quot;qianguyihao&quot;;var str2 = &quot;smyh&quot;;// 通过 test()方法，判断字符串是否符合 上面定义的 reg 规则console.log(reg.test(str1)); // 打印结果：trueconsole.log(reg.test(str2)); // 打印结果：false 注意，上面的例子中，我们是先定义了一个正则表达式的规则，然后通过正则表达式的test()方法来判断字符串是否符合之前定义的规则。 正则表达式的test()方法： 1myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则 解释：使用test()这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false。 2、传两个参数时：匹配模式 【重要】 构造函数 RegExp 中，也可以传两个参数。我们可以传递一个匹配模式作为第二个参数。这个参数可以是： i 忽略大小写。这里的 i 指的是 ignore。 g 全局匹配模式。这里的 g 指的是 global。 代码举例： 1234var reg = new RegExp(&#x27;A&#x27;, &#x27;i&#x27;);var str = &#x27;qiangu&#x27;;console.log(reg.test(str)); // 打印结果：true 方式二：使用字面量创建正则表达式我们可以使用字面量来创建正则表达式。 语法： 123var 变量 = /正则表达式/; // 注意，这个语法里没有引号var 变量 = /正则表达式/匹配模式; // 注意，这个语法里没有引号 代码举例： 12345var reg = /A/i; // 定义正则表达式的规则：检查一个字符串中是否含有 a。忽略大小写。var str = &quot;qiangu&quot;;console.log(typeof reg); // 打印结果：objectconsole.log(reg.test(str)); // 打印结果：true 两种方式的对比以上两种方式的对比： 方式一：使用构造函数创建时，更加灵活，因为参数中还可以传递变量。 方式二：使用字面量的方式创建，更加简单。 代码举例： 123var reg = new RegExp(&quot;a&quot;, &quot;i&quot;); // 方式一var reg = /a/i; // 方式二 上面这两行代码的作用是等价的。 正则表达式的常见语法检查一个字符串中是否包含 a或b写法1： 1var reg = /a|b/; 解释：使用 | 表示或的意思。 写法2： 1var reg = /[ab]/; // 跟上面的那行语法，是等价的 解释：这里的[]也是表示或的意思。 []这个符号在正则还是比较常用的。我们接下来看几个例子。 []表示：或一些规则： /[ab]/ 等价于 /a|b/：检查一个字符串中是否包含 a或b /[a-z]/：检查一个字符串那种是否包含任意小写字母 /[A-Z]/：任意大写字母 /[A-z]/：任意字母 /[0-9]/：任意数字 /a[bde]c/：检查一个字符串中是否包含 abc 或 adc 或 aec [^ ] 表示：除了举例1： 1234var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容var str = &quot;acb&quot;;console.log(reg.test(str)); // 打印结果：true 举例2：（可以用来验证某字符串是否为 纯数字） 123456var reg = /[^0-9]/; // 规则：字符串中，除了数字之外，还有没有其他的内容var str1 = &quot;1991&quot;;var str2 = &quot;199a1&quot;;console.log(reg.test(str1)); // 打印结果：false （如果字符串是 纯数字，则返回 false）console.log(reg.test(str2)); // 打印结果：true 支持正则表达式的 String 对象的方法 String对象的如下方法，是支持正则表达式的： 方法 描述 备注 split() 将字符串拆分成数组 search() 搜索字符串中是否含有指定内容，返回索引 index match() 根据正则表达式，从一个字符串中将符合条件的内容提取出来 replace() 将字符串中的指定内容，替换为新的内容并返回 下面来分别介绍和举例。 split()split()：将一个字符串拆分成一个数组。 备注：关于split()更详细的用法，可以看之前的关于”内置对象：String”的文章。 split()方法可以接受一个正则表达式作为参数。 正则相关的举例：根据任意字母，将字符串拆分成数组。 代码实现：（通过正则） 1234var str = &quot;1a2b3c4d5e6f7g&quot;;var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字符console.log(result); 打印结果： 1[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;&quot;] search()search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引；否则返回-1。 search()方法可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串。serach()只会查找第一个，即使设置全局匹配也没用。 举例： 123456var str = &quot;hello abc hello aec afc&quot;;/** 搜索字符串中是否含有abc 或 aec 或 afc*/result = str.search(/a[bef]c/);console.log(result); // 打印结果：6 match()match()：根据正则表达式，从一个字符串中将符合条件的内容提取出来，封装到一个数组中返回（即使只查询到一个结果）。 注意：默认情况下，match()方法只会找到第一个符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容。 另外，我们可以为一个正则表达式设置多个匹配模式，且顺序无所谓。 代码举例： 123456789var str = &quot;1a2a3a4a5e6f7A8B9C&quot;;var result1 = str.match(/[a-z]/); // 找到符合要求的第一个内容，然后返回var result2 = str.match(/[a-z]/g); // 设置为“全局匹配”模式，匹配字符串中所有的内容var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，且顺序无所谓console.log(result1); // 打印结果：[&quot;a&quot;]console.log(result2); // 打印结果：[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;e&quot;, &quot;f&quot;]console.log(result3); // 打印结果：[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;e&quot;, &quot;f&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;] 总结： match()这个方法还是很实用的，可以在一个很长的字符串中，提取出有规则的内容。这不就是爬虫的时候经常会遇到的场景么？ replace()replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。 语法： 1新的字符串 = str.replace(被替换的内容，新的内容); 参数解释： 被替换的内容：可以接受一个正则表达式作为参数。 新的内容：默认只会替换第一个。如果需要替换全部符合条件的内容，可以设置正则表达式为全局匹配模式。 代码举例： 123456//replace()方法：替换var str2 = &quot;Today is fine day,today is fine day !!!&quot;console.log(str2);console.log(str2.replace(&quot;today&quot;,&quot;tomorrow&quot;)); //只能替换第一个todayconsole.log(str2.replace(/today/gi,&quot;tomorrow&quot;)); //这里用到了正则，且为“全局匹配”模式，才能替换所有的today","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/21-内置对象：String","date":"2021-08-06T01:17:25.763Z","updated":"2021-07-28T07:34:11.344Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/21-内置对象：String/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/21-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9AString/","excerpt":"","text":"前言 在日常开发中，String对象的使用频率是非常高的。所以有必要详细介绍。 基本数据类型不能绑定属性和方法1、基本数据类型： 注意，基本数据类型string是无法绑定属性和方法的。比如说： 12345var str = &quot;qianguyihao&quot;;str.aaa = 12;console.log(typeof str); //打印结果为：stringconsole.log(str.aaa); //打印结果为：undefined 上方代码中，当我们尝试打印str.aaa的时候，会发现打印结果为：undefined。也就是说，不能给 string 绑定属性和方法。 当然，我们可以打印str.length、str.indexOf(“m”)等等。因为这两个方法的底层做了数据类型转换（临时将 string 字符串转换为 String 对象，然后再调用内置方法），也就是我们在上一篇文章中讲到的包装类。 2、引用数据类型： 引用数据类型String是可以绑定属性和方法的。如下： 12345var strObj = new String(&quot;smyhvae&quot;);strObj.aaa = 123;console.log(strObj);console.log(typeof strObj); //打印结果：Objectconsole.log(strObj.aaa); 打印结果： 内置对象Number也有一些自带的方法，比如： Number.MAX_VALUE; Number.MIN_VALUE; 内置对象Boolean也有一些自带的方法，但是用的不多。 在底层，字符串以字符数组的形式保存在底层，字符串是以字符数组的形式保存的。代码举例： 123var str = &quot;smyhvae&quot;;console.log(str.length); // 获取字符串的长度console.log(str[2]); // 获取字符串中的第2个字符 上方代码中，smyhvae这个字符串在底层是以[&quot;s&quot;, &quot;m&quot;, &quot;y&quot;, &quot;h&quot;, &quot;v&quot;, &quot;a&quot;, &quot;e&quot;]的形式保存的。因此，我们既可以获取字符串的长度，也可以获取指定索引index位置的单个字符。这很像数组中的操作。 内置对象 String 的常见方法charAt()charAt：返回字符串指定位置的字符。不会修改原字符串。 语法： 1字符 = str.charAt(index); 解释：字符串中第一个字符的下标是 0。如果参数 index 不在 [0, string.length) 之间，该方法将返回一个空字符串。 而且，这里的 str.charAt(index)和str[index]的效果是一样的。 代码举例： 12345var str = new String(&quot;smyhvae&quot;); for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); &#125; 打印结果： 上面这个例子一般不用。一般打印数组和json的时候用索引，打印String不建议用索引。 charCodeAt()charCodeAt：返回字符串指定位置的字符的 Unicode 编码。不会修改原字符串。 语法： 1字符 = str.charCodeAt(index); 代码举例：打印字符串的占位长度 提示：一个英文占一个位置，一个中文占两个位置。 思路：判断该字符是否在0-127之间（在的话是英文，不在是非英文）。 代码实现： 1234567891011121314151617181920212223242526&lt;script&gt; // sort(); 底层用到了charCodeAt(); var str = &quot;I love my country!我你爱中国！&quot;; //需求：求一个字符串占有几个字符位。 //思路；如果是英文，站一个字符位，如果不是英文占两个字符位。 //技术点：判断该字符是否在0-127之间。（在的话是英文，不在是非英文） alert(getZFWlength(str)); alert(str.length); //定义方法：字符位 function getZFWlength(string) &#123; //定义一个计数器 var count = 0; for (var i = 0; i &lt; string.length; i++) &#123; //对每一位字符串进行判断，如果Unicode编码在0-127，计数器+1；否则+2 if (string.charCodeAt(i) &lt; 128 &amp;&amp; string.charCodeAt(i) &gt;= 0) &#123; count++; &#125; else &#123; count += 2; &#125; &#125; return count; &#125;&lt;/script&gt; 打印结果： 123024 从打印结果可以看出：字符串的长度是24，但是却占了30个字符位（一个中文占两个字符位）。 另外，sort()方法其实底层也是用到了charCodeAt()，因为用到了Unicode编码。 String.fromCharCode()String.fromCharCode()：根据字符的 Unicode 编码获取字符。 代码举例： 12345var result1 = String.fromCharCode(72);var result2 = String.fromCharCode(20013);console.log(result1); // 打印结果：Hconsole.log(result2); // 打印结果：中 indexOf()/lastIndexOf()indexOf()/lastIndexOf()：获取指定字符的索引。 语法： 1索引值 = str.indexOf(想要查询的字符); 解释：indexOf() 是从前向后索引字符串的位置。同理，lastIndexOf()是从后向前寻找。 作用：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。 因此可以得出一个技巧：如果获取的索引值为0，说明字符串是以查询的参数为开头的。 这个方法还可以指定第二个参数，用来 指定开始查找的位置。 代码举例1： 123456789var str = &quot;abcdea&quot;;//给字符查索引(索引值为0,说明字符串以查询的参数为开头)console.log(str.indexOf(&quot;c&quot;));console.log(str.lastIndexOf(&quot;c&quot;));console.log(str.indexOf(&quot;a&quot;));console.log(str.lastIndexOf(&quot;a&quot;)); 打印结果： 代码举例2：（两个参数时，需要特别注意） 1234var str = &#x27;qianguyihao&#x27;;result = str.indexOf(&#x27;a&#x27;, 3); // 从第三个位置开始查找 &#x27;a&#x27;这个字符 【重要】console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。 concat()concat()：字符串的连接。 语法： 1新字符串 = str1.concat(str2)； //链接两个字符串 这种方法基本不用，直接把两个字符串相加就好。 是的，你会发现，数组中也有concat()方法，用于数组的连接。这个方法在数组中用得挺多的。 代码举例： 12345var str1 = &#x27;qiangu&#x27;;var str2 = &#x27;yihao&#x27;;var result = str1.concat(str2);console.log(result); // 打印结果：qianguyihao slice()slice()：从字符串中截取指定的内容。不会修改原字符串，而是将及截取到的内容返回。 语法： 1字符串 = str.slice(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：上面的参数，包左不包右。参数举例如下： (2, 5) 截取时，包左不包右。 (2) 表示从指定的索引位置开始，截取到最后。 (-3) 表示从倒数第几个开始，截取到最后。 (1, -1) 表示从第一个截取到倒数第一个。 (5, 2) 表示前面的大，后面的小，返回值为空。 substring()substring()：从字符串中截取指定的内容。和slice()类似。 语法： 1字符串 = str.substring(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 substring()和slice()是类似的。但不同之处在于： substring()不能接受负值作为参数。如果传递了一个负值，则默认使用0。 substring()还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。比如说， substring(1, 0)截取的是第一个字符。 substr()substr()：从字符串中截取指定的内容。不会修改原字符串，而是将及截取到的内容返回。 语法： 1字符串 = str.substr(开始索引, 截取的长度); 参数举例： (2,4)：从索引值为2的字符开始，截取4个字符。 (1)：从指定位置开始，截取到最后。 (-3)：从倒数第几个开始，剪到最后. 不包括前大后小的情况。 备注：ECMAscript 没有对 substr() 方法进行标准化，因此不建议使用它。 split() 【重要】split()：将一个字符串拆分成一个数组。 语法： 1数组 = str.split(); 备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的json数据中，经常会收到类似于&quot;q, i, a, n&quot;这样的字符串，前端需要将这个字符串拆分成[&#39;q&#39;, &#39;i&#39;, &#39;a&#39;, &#39;n&#39;]数组，这个时候split()方法就排上用场了。 代码举例1： 12345var str = &quot;qian, gu, yi, hao&quot;; // 用逗号隔开的字符串var array = str.split(&quot;,&quot;); // 将字符串 str 拆分成数组，通过逗号来拆分console.log(array); // 打印结果是数组：[&quot;qian&quot;, &quot; gu&quot;, &quot; yi&quot;, &quot; hao&quot;] 代码举例2： 123456789101112//split()方法：字符串变数组var str3 = &quot;生命壹号|许嵩|smyhvae&quot;;console.log(str3);console.log(str3.split()); // 无参数，表示：把字符串作为一个元素添加到数组中。console.log(str3.split(&quot;&quot;)); //参数为空字符串，则表示：分隔字符串中每一个字符，分别添加到数组中console.log(str3.split(&quot;|&quot;)); //参数为指定字符，表示：此字符将不会出现在数组的任意一个元素中console.log(str3.split(&quot;许&quot;)); //同理 打印结果： trim()trim()：去除字符串前后的空白。 代码举例： 1234//去除前后的空格，trim();var str1 = &quot; a b c &quot;;console.log(str1);console.log(str1.trim()); 打印结果： replace()replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。 语法： 1新的字符串 = str.replace(被替换的内容，新的内容); 代码举例： 12345//replace()方法：替换var str2 = &quot;Today is fine day,today is fine day !!!&quot;console.log(str2);console.log(str2.replace(&quot;today&quot;,&quot;tomorrow&quot;)); //只能替换第一个todayconsole.log(str2.replace(/today/gi,&quot;tomorrow&quot;)); //这里用到了正则，才能替换所有的today 大小写转换举例： 1234567var str = &quot;abcdEFG&quot;;//转换成小写console.log(str.toLowerCase());//转换成大写console.log(str.toUpperCase()); html方法 anchor() 创建a链接 big() sub() sup() link() bold() 注意，str.link() 返回值是字符串。 举例： 12345678var str = &quot;你好&quot;;console.log(str.anchor())console.log(str.big())console.log(str.sub())console.log(str.sup())console.log(str.link(&quot;http://www.baidu.com&quot;));console.log(str.bold()) 字符串练习练习1：”smyhvaevaesmyh”查找字符串中所有m出现的位置。 代码实现： 12345678var str2 = &quot;abcoefoxyozzopp&quot;;for(var i=0;i&lt;str2.length;i++)&#123; //如果指定位置的符号=== &quot;o&quot; //str2[i] if( str2.charAt(i)===&quot;o&quot;)&#123; console.log(i); &#125;&#125; 练习2：判断一个字符串中出现次数最多的字符，统计这个次数 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var str2 = &quot;smyhvaevaesmyhvae&quot;; //定义一个json，然后判断json中是够有该属性，如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var json = &#123;&#125;; for (var i = 0; i &lt; str2.length; i++) &#123; //判断：如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var key = str2.charAt(i); if (json[key] === undefined) &#123; json[key] = 1; &#125; else &#123; json[key] += 1; &#125; &#125; console.log(json); console.log(&quot;----------------&quot;); //获取json中属性值最大的选项 var maxKey = &quot;&quot;; var maxValue = 0; for (var k in json) &#123; // if(maxKey == &quot;&quot;)&#123; // maxKey = k; // maxValue = json[k]; // &#125;else&#123; if (json[k] &gt; maxValue) &#123; maxKey = k; maxValue = json[k]; &#125; // &#125; &#125; console.log(maxKey); console.log(maxValue);&lt;/script&gt; 打印结果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/20-包装类","date":"2021-08-06T01:17:25.761Z","updated":"2021-07-28T07:34:11.343Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/20-包装类/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/20-%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"包装类包装类的介绍我们都知道，js中的数据类型包括以下几种。 基本数据类型：String、Number、Boolean、Null、Undefined 引用数据类型：Object JS为我们提供了三个包装类： String()：将基本数据类型字符串，转换为String对象。 Number()：将基本数据类型的数字，转换为Number对象。 Boolean()：将基本数据类型的布尔值，转换为Boolean对象。 通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。 代码举例： 1234567var num = new Number(3);var str = new String(&quot;hello&quot;);var bool = new Boolean(true);console.log(typeof num); // 打印结果：object 需要注意的是：我们在实际应用中不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。 比如说： 1234var boo1 = new Boolean(true);var boo2 = new Boolean(true);console.log(boo1 === boo2); // 打印结果竟然是：false 再比如说： 12345var boo3 = new Boolean(false);if (boo3) &#123; console.log(&#x27;qianguyihao&#x27;); // 这行代码竟然执行了&#125; 基本数据类型不能添加属性和方法方法和属性只能添加给对象，不能添加给基本数据类型。 注意：当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法；调用完以后，在将其转换为基本数据类型。 代码举例： 1234567var str = 123;str = str.toString(); // 将 number 类型转换为 string 类型str.hello = &quot;千古壹号&quot;; // 添加属性console.log(typeof str); // 打印结果：stringconsole.log(str.hello); // 打印结果：undefined 再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/19-内置对象：Math","date":"2021-08-06T01:17:25.759Z","updated":"2021-07-28T07:34:11.343Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/19-内置对象：Math/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/19-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9AMath/","excerpt":"","text":"内置对象 Math内置对象 Math 的常见方法 方法 描述 备注 Math.abs() 返回绝对值 Math.floor() 向下取整（向小取） Math.ceil() 向上取整（向大取） Math.round() 四舍五入取整（正数四舍五入，负数五舍六入） Math.random() 生成0-1之间的随机数 不包含0和1 Math.max(x, y, z) 返回多个数中的最大值 Math.min(x, y, z) 返回多个数中的最小值 Math.pow(x,y) 返回 x 的 y 次幂 Math.sqrt() 对一个数进行开方运算 Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。 Math属于一个工具类，里面封装了数学运算相关的属性和方法。 举例： 1234567891011var num = -0.6;console.log(Math.abs(num)); //取绝对值console.log(Math.floor(num)); //向下取整，向小取console.log(Math.ceil(num)); //向上取整，向大取console.log(Math.round(num)); //四舍五入取整（正数四舍五入，负数五舍六入）console.log(Math.random()); //生成0-1之间的随机数 运行结果： 1234567890.6-1-0-10.6453756205275165 Math.random()方法举例：生成 x-y 之间的随机数生成 0-x 之间的随机数： 1Math.round(Math.random()*x) 生成 x-y 之间的随机数： 1Math.round(Math.random()*(y-x)+x) url 编码和解码URI (Uniform ResourceIdentifiers,通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 123encodeURIComponent(); //把字符串作为 URI 组件进行编码decodeURIComponent(); //把字符串作为 URI 组件进行解码 举例： 12345var url = &quot;http://www.cnblogs.com/smyhvae/&quot;;var str = encodeURIComponent(url);console.log(str); //打印url的编码console.log(decodeURIComponent(str)); //对url进行编码后，再解码，还原为url 打印结果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/18-内置对象：Date","date":"2021-08-06T01:17:25.757Z","updated":"2021-07-28T07:34:11.343Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/18-内置对象：Date/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/18-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9ADate/","excerpt":"","text":"内置对象简介内置对象就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用的或是最基本而必要的功能。 JavaScript的内置对象： 内置对象 对象说明 Arguments 函数参数集合 Array 数组 Boolean 布尔对象 Date 日期时间 Error 异常对象 Function 函数构造器 Math 数学对象 Number 数值对象 Object 基础对象 RegExp 正则表达式对象 String 字符串对象 前面的几篇文章中，我们专门讲到了数组 Array。今天这篇文章，我们来讲一下其他的内置对象。 内置对象：DateDate对象的创建写法一：表示的是当前代码执行的时间（也可以理解成是获取当前时间对象） 12var date1 = new Date();console.log(date1); 写法二：在参数中传递一个表示时间的字符串（兼容性最强） 12var date2 = new Date(&quot;2017/09/06 09:00:00&quot;);console.log(date2); 写法三：（不常用） 12var date3 = new Date(&#x27;Wed Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)&#x27;);console.log(date3 ); 写法四：（不常用） 12var date4 = new Date(2017, 1, 27); //写法四console.log(date4); 以上四种写法的打印结果是： 获取日期和时间Date对象 有如下方法，可以获取日期和时间： getDate() 获取日 1-31 getDay() 获取星期 0-6（0代表周日，1代表周一） getMonth() 获取月 0-11（0代表一月） getFullYear() 获取年份 getHours() 获取小时 0-23 getMinutes() 获取分钟 0-59 getSeconds() 获取秒 0-59 getMilliseconds() 获取毫秒 （1s = 1000ms） 代码举例： 1234567891011121314// 我在执行这行代码时，当前时间为 2019年2月4日，周一，13:23:52var myDate = new Date();console.log(myDate); // 打印结果：Mon Feb 04 2019 13:23:52 GMT+0800 (中国标准时间)console.log(myDate.getDate()); // 打印结果：4console.log(myDate.getDay()); // 打印结果：1console.log(myDate.getMonth()); // 打印结果：1console.log(myDate.getFullYear()); // 打印结果：2019console.log(myDate.getHours()); // 打印结果：13console.log(myDate.getMinutes()); // 打印结果：23console.log(myDate.getSeconds()); // 打印结果：52console.log(myDate.getMilliseconds()); // 打印结果：393console.log(myDate.getTime()); // 获取时间戳。打印结果：1549257832393 getTime()：获取时间戳Date对象 还有如下方法： getTime() 获取当前日期对象的时间戳。这个方法在实际开发中，用得比较多。 啥叫时间戳？接下来，我们解释一下。 时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。 计算机底层在保存时间时，使用的都是时间戳。时间戳的存在，就是为了统一时间的单位。 我们再来看下面这样的代码： 123var myDate = new Date(&quot;1970/01/01 0:0:0&quot;);console.log(myDate.getTime()); // 获取时间戳 打印结果（可能会让你感到惊讶） 1-28800000 为啥打印结果是-28800000，而不是0呢？这是因为，我们的当前代码，是在中文环境下运行的，与英文时间会存在8个小时的时差（中文时间比英文时间早了八个小时）。如果代码是在英文环境下运行，打印结果就是0。 利用时间戳检测代码的执行时间： 我们可以在业务代码的前面定义 时间戳1，在业务代码的后面定义 时间戳2。把这两个时间戳相减，就能得出业务代码的执行时间。 format()将时间对象转换为指定格式。 参考链接：https://www.cnblogs.com/tugenhua0707/p/3776808.html 练习举例1：模拟日历要求每天打开这个页面，都能定时显示当前的日期。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 800px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px &quot;simsun&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; //模拟日历 //需求：每天打开这个页面都能定时显示年月日和星期几 //1.创建一个当前日期的日期对象 var date = new Date(); //2.然后获取其中的年、月、日和星期 var year = date.getFullYear(); var month = date.getMonth(); var hao = date.getDate(); var week = date.getDay();// console.log(year+&quot; &quot;+month+&quot; &quot;+hao+&quot; &quot;+week); //3.赋值给div var arr = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.innerText = &quot;今天是：&quot;+year+&quot;年&quot;+(month+1)+&quot;月&quot;+hao+&quot;日 &quot;+arr[week]; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 举例2：发布会倒计时实现思路： 设置一个定时器，每间隔1毫秒就自动刷新一次div的内容。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 1210px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px &quot;simsun&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; var timer = setInterval(fn, 1); function fn() &#123; var nowtime = new Date(); var future = new Date(&quot;2019/02/03 11:20:00&quot;); var timeSum = future.getTime() - nowtime.getTime(); //获取时间差：发布会时间减去此刻的毫秒值 var day = parseInt(timeSum / 1000 / 60 / 60 / 24); var hour = parseInt(timeSum / 1000 / 60 / 60 % 24); var minu = parseInt(timeSum / 1000 / 60 % 60); var sec = parseInt(timeSum / 1000 % 60); var millsec = parseInt(timeSum % 1000); //问题处理：所有的时间小于10的时候，在前面自动补0，毫秒值要补双0（比如如，把 8 秒改成 08 秒） day = day &lt; 10 ? &quot;0&quot; + day : day; //day小于10吗？如果小于，就补0；如果不小于，就是day本身 hour = hour &lt; 10 ? &quot;0&quot; + hour : hour; minu = minu &lt; 10 ? &quot;0&quot; + minu : minu; sec = sec &lt; 10 ? &quot;0&quot; + sec : sec; if (millsec &lt; 10) &#123; millsec = &quot;00&quot; + millsec; &#125; else if (millsec &lt; 100) &#123; millsec = &quot;0&quot; + millsec; &#125;// console.log(day);// console.log(parseInt(timeSum/1000/60/60/24)); if (timeSum &lt; 0) &#123; div.innerHTML = &quot;距离苹果发布会还有00天00小时00分00秒000毫秒&quot;; clearInterval(timer); return; &#125; div.innerHTML = &quot;距离苹果发布会还有&quot; + day + &quot;天&quot; + hour + &quot;小时&quot; + minu + &quot;分&quot; + sec + &quot;秒&quot; + millsec + &quot;毫秒&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现效果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/17-数组的其他方法","date":"2021-08-06T01:17:25.754Z","updated":"2021-07-28T07:34:11.342Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/17-数组的其他方法/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/17-%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言数组的其他方法如下： 方法 描述 备注 indexOf(value) 从前往后索引，获取 value 在数组中的第一个下标 lastIndexOf(value) 从后往前索引，获取 value 在数组中的最后一个下标 find(function()) 找出第一个满足「指定条件返回true」的元素。 findIndex(function()) 找出第一个满足「指定条件返回true」的元素的index Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 将一系列值转换成数组。 数组的其他方法indexOf() 和 lastIndexOf()：获取数据的索引语法： 123索引值 = 数组.indexOf(value);索引值 = 数组.lastIndexOf(value); 解释： indexOf(value)：从前往后索引，获取 value 在数组中的第一个下标。 lastIndexOf(value) ：从后往前索引，获取 value 在数组中的最后一个下标。 作用： 利用这个方法，我们可以判断某个值是否在指定的数组中。**如果没找到则返回-1**。 举例1： 1234var arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;d&quot;,&quot;c&quot;];console.log(arr.indexOf(&quot;c&quot;)); //从前往后，找第一个&quot;c&quot;在哪个位置console.log(arr.lastIndexOf(&quot;d&quot;)); //从后往前，找第一个&quot;d&quot;在哪个位置 打印结果： 举例2：判断某个值是否在数组中 123456789101112var arr = [&quot;29926392220&quot;, &quot;29965620629&quot;, &quot;28003663436&quot;, &quot; &quot;, &quot;28818504366&quot;];var str = [ &#123;name:&quot;smyh&quot;, id: &quot;12334&quot;&#125;, &#123;name:&quot;vae&quot;, id: &quot;28818504366&quot;&#125;];str.filter(item =&gt; &#123; console.log(arr.indexOf(item.id));&#125;) find()语法： 1find(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素。 举例： 1234567let arr = [2, 3, 2, 5, 7, 6];let result = arr.find(function (item, index) &#123; return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回&#125;);console.log(result); //打印结果：5 findIndex()语法： 1findIndex(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素的index。 举例： 我们直接把上面的代码中的find方法改成findIndex，来看看效果。 1234567let arr = [2, 3, 2, 5, 7, 6];let result = arr.findIndex(function (item, index) &#123; return item &gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回&#125;);console.log(result); //打印结果：3 Array.from()语法： 1array = Array.from(arrayLike) 作用：将伪数组或可遍历对象转换为真数组。 举例： 1234567891011121314&lt;body&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;script&gt; let btnArray = document.getElementsByTagName(&#x27;button&#x27;); console.log(btnArray); console.log(btnArray[0]);&lt;/script&gt;&lt;/body&gt; 上面的布局中，有三个button标签，我们通过getElementsByTagName获取到的btnArray实际上是伪数组，并不是真实的数组： 既然btnArray是伪数组，它就不能使用数组的一般方法，否则会报错： 解决办法：采用Array.from方法将btnArray这个伪数组转换为真数组即可： 1Array.from(btnArray); 然后就可以使用数组的一般方法了： 伪数组与真数组的区别： 伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有 pop、join等属性。 Array.of()语法： 1Array.of(value1, value2, value3) 作用：将一系列值转换成数组。 举例： 123//Array.of(value1, value2, value3) : 将一系列值转换成数组let arr = Array.of(1, &#x27;abc&#x27;, true);console.log(arr); 其他isArray()：判断是否为数组1布尔值 = Array.isArray(被检测的值) ; 以前，我们会通过 A instanceof B来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有下面isArray()方法。 toString()：转换数组1字符串 = 数组.toString(); 解释：把数组转换成字符串，每一项用,分割。 valueOf()：返回数组本身1数组本身 = 数组.valueOf(); 这个方法的意义不大。因为我们指直接写数组对象的名字，就已经是数组本身了。 清空数组清空数组，有以下几种方式： 12345var array = [1,2,3,4,5,6];array.splice(0); //方式1：删除数组中所有项目array.length = 0; //方式2：length属性可以赋值，在其它语言中length是只读array = []; //方式3：推荐 数组练习练习1问题：将一个字符串数组输出为|分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。 答案： 方式1：（不推荐） 12345678var arr = [&quot;千古&quot;,&quot;宿敌&quot;,&quot;素颜&quot;];var str = arr[0];var separator = &quot;|&quot;;for(var i = 1;i&lt; arr.length;i++) &#123; str += separator+arr[i]; //从第1个数组元素开始，每个元素前面加上符号&quot;|&quot;&#125;console.log(str); 输出结果： 不推荐这种方式，因为：由于字符串的不变性，str拼接过多的话，容易导致内存溢出（很多个str都堆放在栈里）。 方式2：（推荐。通过array数组自带的api来实现） 123var arr = [&quot;千古&quot;,&quot;宿敌&quot;,&quot;素颜&quot;];console.log(arr.join(&quot;|&quot;)); 结果： 练习2题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第i个和第length-i-1个进行交换。 答案： 方式1： 1234567function reverse(array) &#123; var newArr = []; for (var i = array.length - 1; i &gt;= 0; i--) &#123; newArr[newArr.length] = array[i]; &#125; return newArr;&#125; 方式2：（算法里比较常见的方式） 12345678function reverse(array)&#123; for(var i=0;i&lt;array.length/2;i++)&#123; var temp = array[i]; array[i] = array[array.length-1-i]; array[array.length-1-i] = temp; &#125; return array;&#125; 方式3：（数组自带的reverse方法） 现在我们学习了数组自带的api，我们就可以直接使用reverse()方法。 练习3问题：针对工资的数组[1500,1200,2000,2100,1800]，把工资超过2000的删除。 答案： 12345678910var arr1 = [1500, 1200, 2000, 2100, 1800];var arr2 = arr1.filter(function (ele, index, array) &#123; if (ele &lt; 2000) &#123; return true; &#125; return false;&#125;)console.log(arr1);console.log(arr2); 结果： 练习4问题：找到数组[“c”,”a”,”z”,”a”,”x”,”a”]中每一个元素出现的次数。 分析：这道题建议用json数据来做，因为我们想知道a出现了几次，c出现了几次，x出现了几次。恰好k:v .. k:v这种键值对的形式就比数组方便很多了。 键值对的形式：用key代表数组中的元素，用value代表元素出现的次数。 略难，答案暂略。 练习5：数组去重问题：编写一个方法去掉一个数组中的重复元素。 分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 答案： 1234567891011121314151617181920212223// 编写一个方法 去掉一个数组的重复元素 var arr = [1,2,3,4,5,2,3,4]; console.log(arr); var aaa = fn(arr); console.log(aaa); //思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 function fn(array)&#123; var newArr = []; for(var i=0;i&lt;array.length;i++)&#123; //开闭原则 var bool = true; //每次都要判断新数组中是否有旧数组中的值。 for(var j=0;j&lt;newArr.length;j++)&#123; if(array[i] === newArr[j])&#123; bool = false; &#125; &#125; if(bool)&#123; newArr[newArr.length] = array[i]; &#125; &#125; return newArr; &#125; 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/14-数组简介","date":"2021-08-06T01:17:25.748Z","updated":"2021-07-28T07:34:11.341Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/14-数组简介/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/14-%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B/","excerpt":"","text":"之前学习的数据类型，只能存储一个值（字符串为一个值）。如果我们想存储多个值，就可以使用数组。 数组简介数组（Array）是属于内置对象，我们可以在MDN网站上查询各种方法。 数组和普通对象的功能类似，也是用来存储一些值的。不同的是： 普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引来操作元素。索引：从0开始的整数就是索引。 数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。 数组的基本操作数组的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组。 数组的元素中，如果存放的是数组，我们就称这种数组为二维数组。 创建数组对象方式一：字面量定义。举例： 1var arr = [1,2,3]; 方式二：对象定义（数组的构造函数）。 语法： 1var arr = new Array(参数); 如果参数为空，则表示创建一个空数组；参数位置是一个数值时，表示数组长度；参数位置是多个数值时，表示数组中的元素。 上面的两种方式，我来举个例子： 1234567891011121314// 方式一var arr1 = [11, 12, 13];// 方式二var arr2 = new Array(); // 参数为空var arr3 = new Array(4); // 参数为一个数值var arr4 = new Array(15, 16, 17); // 参数为多个数值console.log(typeof arr1); // 打印结果：objectconsole.log(&quot;arr1 = &quot; + JSON.stringify(arr1));console.log(&quot;arr2 = &quot; + JSON.stringify(arr2));console.log(&quot;arr3 = &quot; + JSON.stringify(arr3));console.log(&quot;arr4 = &quot; + JSON.stringify(arr4)); 打印结果： 123456objectarr1 = [11,12,13]arr2 = []arr3 = [null,null,null,null]arr4 = [15,16,17] 从上方打印结果的第一行里，可以看出，数组的类型其实也是属于对象。 向数组中添加元素语法： 1数组[索引] = 值 代码举例： 1234567var arr1 = [];// 向数组中添加元素arr[0] = 10;arr[1] = 33;arr[2] = 22;arr[3] = 44; 获取数组中的元素语法： 1数组[索引] 数组的索引代表的是数组中的元素在数组中的位置，从0开始。 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回undefined。 代码举例： 1234var arr = [21, 22, 23];console.log(arr[0]); // 打印结果：21console.log(arr[5]); // 打印结果：undefined 获取数组的长度可以使用length属性来获取数组的长度(元素的个数)。 语法： 1数组的长度 = 数组名.length； 代码举例： 123var arr = [21, 22, 23];console.log(arr.length); // 打印结果：3 补充： 对于连续的数组，使用length可以获取到数组的长度（元素的个数）；对于非连续的数组，使用length会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组。 修改数组的长度（修改length） 如果修改的length大于原长度，则多出部分会空出来，置为 null。 如果修改的length小于原长度，则多出的元素会被删除，数组将从后面删除元素。 （特例：伪数组arguments的长度可以修改，但是不能修改里面的元素，后面单独讲。） 代码举例： 12345678910var arr1 = [11, 12, 13];var arr2 = [21, 22, 23];// 修改数组 arr1 的 lengtharr1.length = 1;console.log(JSON.stringify(arr1));// 修改数组 arr2 的 lengtharr2.length = 5;console.log(JSON.stringify(arr2)); 打印结果： 123[11][21,22,23,null,null] 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/13-原型对象","date":"2021-08-06T01:17:25.746Z","updated":"2021-07-28T07:34:11.341Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/13-原型对象/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/13-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"在看本文之前，我们可以先复习上一篇文章：《03-JavaScript基础/12-对象的创建&amp;构造函数.md》 原型对象原型的引入1234567891011121314151617function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = function () &#123; console.log(&quot;我是&quot; + this.name); &#125;&#125;//创建一个Person的实例var per = new Person(&quot;孙悟空&quot;, 18, &quot;男&quot;);var per2 = new Person(&quot;猪八戒&quot;, 28, &quot;男&quot;);per.sayName();per2.sayName();console.log(per.sayName == per2.sayName); //打印结果为false 分析如下： 上方代码中，我们的sayName方法是写在构造函数 Person 内部的，然后在两个实例中进行了调用。造成的结果是，构造函数每执行一次，就会给每个实例创建一个新的 sayName 方法。也就是说，每个实例的sayName都是唯一的。因此，最后一行代码的打印结果为false。 按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？ 还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释） 12345678910111213141516function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 */function fun() &#123; alert(&quot;Hello大家好，我是:&quot; + this.name);&#125;; 比较好的方式是，在原型中添加sayName方法： 123Person.prototype.sayName = function()&#123; alert(&quot;Hello大家好，我是:&quot;+this.name);&#125;; 这也就引入了我们本文要讲的「原型」。 原型prototype的概念认识1： 我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。 如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过__proto__来访问该属性。 代码举例： 123456789// 定义构造函数function Person() &#123;&#125;var per1 = new Person();var per2 = new Person();console.log(Person.prototype); // 打印结果：[object object]console.log(per1.__proto__ == Person.prototype); // 打印结果：true 上方代码的最后一行：打印结果表明，实例.__proto__ 和 构造函数.prototype都指的是原型对象。 认识2： 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。 认识3： 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true。 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。 原型链原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时： 它会先在对象自身中寻找，如果有则直接使用； 如果没有则会去原型对象中寻找，如果找到则直接使用； 如果没有则去原型的原型中寻找，直到找到Object对象的原型。 Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null 总结第一次接触「原型」和「原型链」的时候，会比较难理解。多接触几次，再回过头来看，就慢慢熟悉了。 对象的 toString() 方法我们先来看下面这段代码： 12345678910function Person(name, age, gender) &#123;this.name = name;this.age = age;this.gender = gender;&#125;var per1 = new Person(&quot;vae&quot;, 26, &quot;男&quot;);console.log(&quot;per1 = &quot; + per1);console.log(&quot;per1 = &quot; + per1.toString()); 打印结果： 12per1 = [object Object]per1 = [object Object] 上面的代码中，我们尝试打印实例 per1 的内部信息，但是发现，无论是打印 per1 还是打印 per1.toString()，结果都是object，这是为啥呢？分析如下： 当我们直接在页面中打印一个对象时，其实是输出了对象的toString()方法的返回值。 如果我们希望在打印对象时，不输出[object Object]，可以手动为对象添加一个toString()方法。意思是，重写 toString() 方法。 重写 toString() 方法，具体做法如下： 12345678910111213141516171819202122232425262728293031323334353637383940function Person(name, age, gender) &#123;this.name = name;this.age = age;this.gender = gender;&#125;//方式一：重写 Person 原型的toString方法。针对 Person 的所有实例生效Person.prototype.toString = function() &#123; return ( &quot;Person[name=&quot; + this.name + &quot;,age=&quot; + this.age + &quot;,gender=&quot; + this.gender + &quot;]&quot; );&#125;;// 方式二：仅重写实例 per1 的 toString方法。但是这种写法，只对 per1 生效， 对 per2 无效/*per1.toString = function() &#123; return ( &quot;Person[name=&quot; + this.name + &quot;,age=&quot; + this.age + &quot;,gender=&quot; + this.gender + &quot;]&quot; );&#125;;*/var per1 = new Person(&quot;smyh&quot;, 26, &quot;男&quot;);var per2 = new Person(&quot;vae&quot;, 30, &quot;男&quot;);console.log(&quot;per1 = &quot; + per1);console.log(&quot;per2 = &quot; + per2.toString()); 打印结果： 12per1 = Person[name=smyh,age=26,gender=男]per2 = Person[name=vae,age=30,gender=男] 代码分析： 上面的代码中，仔细看注释。我们重写了 Person 原型的 toString()，这样的话，可以保证对 Person 的所有实例生效。 从这个例子，我们可以看出 prototype 的作用。 JS的垃圾回收（GC）机制程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢。所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾。 当一个对象没有任何的变量或属性对它进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。 上面这句话，也可以这样理解：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。 JS拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁。我们不需要也不能进行垃圾回收的操作。我们仅仅需要做的是：如果你不再使用该对象，那么，将改对象的引用设置为 null 即可。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/12-对象的创建&构造函数","date":"2021-08-06T01:17:25.744Z","updated":"2021-07-28T07:34:11.341Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/12-对象的创建&构造函数/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/12-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA&%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"","text":"在看本文之前，可以先复习前面的一篇文章：《03-JavaScript基础/07-对象简介和对象的基本操作.md》 创建自定义对象的几种方法方式一：对象字面量对象的字面量就是一个{}。里面的属性和方法均是键值对。 例如： 12345678910var o = &#123; name: &quot;生命壹号&quot;, age: 26, isBoy: true, sayHi: function() &#123; console.log(this.name); &#125; &#125;;console.log(o); 控制台输出： 方式二：工厂模式通过该方法可以大批量的创建对象。 123456789101112131415161718192021/* * 使用工厂方法创建对象 * 通过该方法可以大批量的创建对象 */function createPerson(name, age, gender) &#123; //创建一个新的对象 var obj = new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function() &#123; alert(this.name); &#125;; //将新的对象返回 return obj;&#125;var obj2 = createPerson(&quot;猪八戒&quot;, 28, &quot;男&quot;);var obj3 = createPerson(&quot;白骨精&quot;, 16, &quot;女&quot;);var obj4 = createPerson(&quot;蜘蛛精&quot;, 18, &quot;女&quot;); 弊端： 使用工厂方法创建的对象，使用的构造函数都是Object。所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象。 方式三：利用构造函数1234567891011121314151617//利用构造函数自定义对象var stu1 = new Student(&quot;smyh&quot;);console.log(stu1);stu1.sayHi();var stu2 = new Student(&quot;vae&quot;);console.log(stu2);stu2.sayHi();// 创建一个构造函数function Student(name) &#123; this.name = name; //this指的是构造函数中的对象实例 this.sayHi = function () &#123; console.log(this.name + &quot;厉害了&quot;); &#125;&#125; 打印结果： 接下来，我们专门来讲一下构造函数。 构造函数代码引入123456789101112131415161718// 创建一个构造函数，专门用来创建Person对象function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function() &#123; alert(this.name); &#125;;&#125;// 创建一个构造函数，专门用来创建 Dog 对象function Dog() &#123;&#125;var per = new Person(&quot;孙悟空&quot;, 18, &quot;男&quot;);var per2 = new Person(&quot;玉兔精&quot;, 16, &quot;女&quot;);var per3 = new Person(&quot;奔波霸&quot;, 38, &quot;男&quot;);var dog = new Dog(); 构造函数和普通函数的区别构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。 构造函数和普通函数的区别就是调用方式的不同：普通函数是直接调用，而构造函数需要使用new关键字来调用。 this的指向也有所不同： 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的那个对象 new 一个构造函数的执行流程（1）开辟内存空间，存储新创建的对象 （2）将新建的对象设置为构造函数中的this，在构造函数中可以使用this来引用 新建的对象 （3）执行函数中的代码（包括设置对象属性和方法等） （4）将新建的对象作为返回值返回 因为this指的是new一个Object之后的对象实例。于是，下面这段代码： 12345// 创建一个函数function createStudent(name) &#123; var student = new Object(); student.name = name; //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样&#125; 可以改进为： 12345// 创建一个函数function Student(name) &#123; this.name = name; //this指的是构造函数中的对象实例&#125; 注意上方代码中的注释。 类、实例使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。 通过一个构造函数创建的对象，称为该类的实例。 instanceof使用 instanceof 可以检查一个对象是否为一个类的实例。 语法如下： 1对象 instanceof 构造函数 如果是，则返回true；否则返回false。 代码举例： 123456789101112function Person() &#123;&#125;function Dog() &#123;&#125;var person1 = new Person();var dog1 = new Dog();console.log(person1 instanceof Person); // 打印结果： trueconsole.log(dog1 instanceof Person); // 打印结果：falseconsole.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true 根据上方代码中的最后一行，需要补充一点：所有的对象都是Object的后代，因此 任何对象 instanceof Object 的返回结果都是true。 othersjson的介绍 对象字面量和json比较像，这里我们对json做一个简单介绍。 JSON：JavaScript Object Notation（JavaScript对象表示形式）。 JSON和对象字面量的区别：JSON的属性必须用双引号引号引起来，对象字面量可以省略。 json举例： 12345678&#123; &quot;name&quot; : &quot;zs&quot;, &quot;age&quot; : 18, &quot;sex&quot; : true, &quot;sayHi&quot; : function() &#123; console.log(this.name); &#125; &#125;; 注：json里一般放常量、数组、对象等，但很少放function。 另外，对象和json没有长度，json.length的打印结果是undefined。于是乎，自然也就不能用for循环遍历（因为遍历时需要获取长度length）。 json遍历的方法： json 采用 for...in...进行遍历，和数组的遍历方式不同。如下： 1234567891011121314&lt;script&gt; var myJson = &#123; &quot;name&quot;: &quot;smyhvae&quot;, &quot;aaa&quot;: 111, &quot;bbb&quot;: 222 &#125;; //json遍历的方法：for...in... for (var key in myJson) &#123; console.log(key); //获取 键 console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法） console.log(&quot;------&quot;); &#125;&lt;/script&gt; 打印结果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/11-this","date":"2021-08-06T01:17:25.742Z","updated":"2021-07-28T07:34:11.340Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/11-this/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/11-this/","excerpt":"","text":"this解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的 上下文对象。 根据函数的调用方式的不同，this会指向不同的对象：【重要】 1.以函数的形式调用时，this永远都是window。比如fun();相当于window.fun(); 2.以方法的形式调用时，this是调用方法的那个对象 3.以构造函数的形式调用时，this是新创建的那个对象 4.使用call和apply调用时，this是指定的那个对象 针对第1条的举例： 12345678910111213141516171819function fun() &#123; console.log(this); console.log(this.name);&#125;var obj1 = &#123; name: &quot;smyh&quot;, sayName: fun&#125;;var obj2 = &#123; name: &quot;vae&quot;, sayName: fun&#125;;var name = &quot;全局的name属性&quot;;//以函数形式调用，this是windowfun(); //可以理解成 window.fun() 打印结果： 12Window全局的name属性 上面的举例可以看出，this指向的是window对象，所以 this.name 指的是全局的name。 第2条的举例： 1234567891011121314151617181920function fun() &#123; console.log(this); console.log(this.name);&#125;var obj1 = &#123; name: &quot;smyh&quot;, sayName: fun&#125;;var obj2 = &#123; name: &quot;vae&quot;, sayName: fun&#125;;var name = &quot;全局的name属性&quot;;//以方法的形式调用，this是调用方法的对象obj2.sayName(); 打印结果： 12Objectvae 上面的举例可以看出，this指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。 箭头函数中this的指向： ES6中的箭头函数并不会使用上面四条标准的绑定规则，而是会继承外层函数调用的this绑定（无论this绑定到什么）。 类数组 arguments 这部分，小白可能看不懂。所以，这一段，暂时可以忽略。 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1.函数的上下文对象 this 2.封装实参的对象 arguments 例如： 123456function foo() &#123; console.log(arguments); console.log(typeof arguments);&#125;foo(); arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。 arguments代表的是实参。在调用函数时，我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments只在函数中使用。 1、返回函数实参的个数：arguments.lengtharguments.length可以用来获取实参的长度。 举例： 1234567891011fn(2,4);fn(2,4,6);fn(2,4,6,8);function fn(a,b) &#123; console.log(arguments); console.log(fn.length); //获取形参的个数 console.log(arguments.length); //获取实参的个数 console.log(&quot;----------------&quot;);&#125; 打印结果： 我们即使不定义形参，也可以通过arguments来使用实参（只不过比较麻烦）：arguments[0] 表示第一个实参、arguments[1] 表示第二个实参… 2、返回正在执行的函数：arguments.calleearguments里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。 123456function fun() &#123; console.log(arguments.callee == fun); //打印结果为true&#125;fun(&quot;hello&quot;); 在使用函数递归调用时，推荐使用arguments.callee代替函数名本身。 3、arguments可以修改元素之所以说arguments是伪数组，是因为：arguments可以修改元素，但不能改变数组的长短。举例： 123456789fn(2,4);fn(2,4,6);fn(2,4,6,8);function fn(a,b) &#123; arguments[0] = 99; //将实参的第一个数改为99 arguments.push(8); //此方法不通过，因为无法增加元素&#125; 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/10-作用域","date":"2021-08-06T01:17:25.740Z","updated":"2021-07-28T07:34:11.340Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/10-作用域/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/10-%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"作用域、变量提升的知识点，面试时会经常遇到。 作用域（Scope）的概念作用域指一个变量的作用范围。在js中，一共有两种作用域： 全局作用域 函数作用域 全局作用域直接编写在script标签中的JS代码，都在全局作用域。 全局作用域在页面打开时创建，在页面关闭时销毁。 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。 在全局作用域中： 创建的变量都会作为window对象的属性保存。 创建的函数都会作为window对象的方法保存。 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到。 变量的声明提前（变量提升）使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写a = 1），则变量不会被声明提前。 举例1： 12console.log(a);var a = 123; 打印结果：undefined。（说明变量 a 被 被提前声明了，只是尚未被赋值） 举例2： 12console.log(a);a = 123; //此时a相当于window.a 程序会报错： 函数的声明提前函数声明： 使用函数声明的形式创建的函数function foo()&#123;&#125;，会被声明提前。 也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。 代码举例： 123456fn1(); // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数function fn1() &#123; console.log(&#x27;我是函数 fn1&#x27;);&#125; 函数表达式： 使用函数表达式创建的函数var foo = function()&#123;&#125;，不会被声明提前，所以不能在声明前调用。 很好理解，因为此时foo被声明了，且为undefined，并没有把 function()&#123;&#125; 赋值给 foo。 所以说，下面的例子，会报错： 作用域作用域：变量和函数生效的区域。作用域在函数定义时，就已经确定了。 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。 执行期上下文：当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁。参考链接：https://www.cnblogs.com/chenyingjie1207/p/9966036.html 作用域的上下级关系： 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错ReferenceError。 在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用window.a） 提醒1： 在函数作用域也有声明提前的特性： 使用var关键字声明的变量，会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 因此，在函数中，没有var声明的变量都是全局变量，而且并不会提前声明。 举例1： 12345678910var a = 1;function foo() &#123; console.log(a); a = 2; // 此处的a相当于window.a&#125;foo();console.log(a); //打印结果是2 上方代码中，foo()的打印结果是1。如果去掉第一行代码，打印结果是Uncaught ReferenceError: a is not defined 提醒2：定义形参就相当于在函数作用域中声明了变量。 123456function fun6(e) &#123; // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e; console.log(e);&#125;fun6(); //打印结果为 undefinedfun6(123);//打印结果为123 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/09-函数","date":"2021-08-06T01:17:25.738Z","updated":"2021-07-28T07:34:11.340Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/09-函数/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/09-%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数的介绍函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。 函数也是一个对象 使用typeof检查一个函数对象时，会返回function 函数的作用： 将大量重复的语句写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。 简化编程，让编程模块化。 来看个例子： 12345678console.log(&quot;你好&quot;);sayHello(); // 调用函数// 定义函数function sayHello()&#123; console.log(&quot;欢迎&quot;); console.log(&quot;welcome&quot;);&#125; 函数的定义和调用第一步：函数的定义方式一：使用函数声明来创建一个函数。语法： 123function 函数名([形参1,形参2...形参N])&#123; // 备注：语法中的中括号，表示“可选” 语句...&#125; 举例： 123function sum(a, b)&#123; return a+b;&#125; 解释如下： function：是一个关键字。中文是“函数”、“功能”。 函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。 参数：可选。 大括号里面，是这个函数的语句。 PS：在有些编辑器中，方法写完之后，我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 方式二：使用函数表达式来创建一个函数。语法： 123var 函数名 = function([形参1,形参2...形参N])&#123; 语句....&#125; 举例： 123var fun3 = function() &#123; console.log(&quot;我是匿名函数中封装的代码&quot;);&#125;; 从方式二的举例中可以看出：所谓的“函数表达式”，其实就是将匿名函数赋值给一个变量。 当然，我们还有方式三：使用构造函数来创建一个对象。这种方式，用的少。 第二步：函数的调用函数调用的语法： 1函数名字(); 函数的参数：形参和实参函数的参数包括形参和实参。来看下面的图就懂了： 注意：实际参数和形式参数的个数，要相同。 举例： 12345678sum(3,4);sum(&quot;3&quot;,4);sum(&quot;Hello&quot;,&quot;World&quot;);//函数：求和function sum(a, b) &#123; console.log(a + b);&#125; 控制台输出结果： 123734helloworld 函数的参数：形参和实参假设我们定义一个求和的函数。 形参： 可以在函数的()中来指定一个或多个形参。 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。 实参： 在调用函数时，可以在 ()中指定实参。 实参将会赋值给函数中对应的形参。 举例： 123456789// 调用函数sum(3,4);sum(&quot;3&quot;,4);sum(&quot;Hello&quot;,&quot;World&quot;);// 定义函数：求和function sum(a, b) &#123; console.log(a + b);&#125; 控制台输出结果： 123734helloworld 实参的类型： 函数的实参可以是任意的数据类型。 调用函数时解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。 实参的数量： 调用函数时，解析器也不会检查实参的数量： 多余实参不会被赋值 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined。例如： 函数的返回值举例： 123456console.log(sum(3, 4));//函数：求和function sum(a, b) &#123; return a + b;&#125; return的作用是结束方法。 注意： return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。 在函数中return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出） 如果return语句后不跟任何值，就相当于返回一个undefined 如果函数中不写return，则也会返回undefined 返回值可以是任意的数据类型，可以是对象，也可以是函数。 函数名、函数体和函数加载问题（重要，请记住）我们要记住：函数名 == 整个函数。举例： 123456console.log(fn) == console.log(function fn()&#123;alert(1)&#125;);//定义fn方法function fn()&#123; alert(1)&#125;; 我们知道，当我们在调用一个函数时，通常使用函数()这种格式；但此时，我们是直接使用函数这种格式，它的作用相当于整个函数。 函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。 fn() 和 fn 的区别【重要】 fn()：调用函数。相当于获取了函数的返回值。 fn：函数对象。相当于直接获取了函数对象。 立即执行函数现有匿名函数如下： 1234function(a, b) &#123; console.log(&quot;a = &quot; + a); console.log(&quot;b = &quot; + b);&#125;; 立即执行函数如下： 1234(function(a, b) &#123; console.log(&quot;a = &quot; + a); console.log(&quot;b = &quot; + b);&#125;)(123, 456); 立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。 立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。 方法函数也可以称为对象的属性。如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法。 调用这个函数就说调用对象的方法（method）。相比于方法，它只是名称上的区别，并没有其他的区别。 函数举例： 12// 调用函数fn(); 方法举例： 12// 调用方法obj.fn(); 我们可以这样说，如果直接是fn()，那就说明是函数调用。如果是发现XX.fn()的这种形式，那就说明是方法调用。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/08-基本数据类型vs引用数据类型","date":"2021-08-06T01:17:25.736Z","updated":"2021-07-28T07:34:11.339Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/08-基本数据类型vs引用数据类型/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/08-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"前言在之前的javascript基础文章中（编号02、编号07），我们介绍过，变量有以下数据类型： 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 本文，我们针对这两种类型，做个详细介绍。我们先来看个例子。 基本数据类型举例： 1234567var a = 23;var b = a;a++;console.log(a); // 打印结果：24console.log(b); // 打印结果：23 上面的代码中：a 和 b 都是基本数据类型，让 b 等于 a，然后改变 a 的值之后，发现 b 的值并没有被改变。 但是在引用数据类型中，就不同了，我们来看一看。 引用数据类型举例： 1234567891011var obj1 = new Object();obj1.name = &#x27;smyh&#x27;;// 让 obj2 等于 obj1var obj2 = obj1;// 修改 obj1 的 name 属性obj1.name = &#x27;vae&#x27;;console.log(obj1.name); // 打印结果：vaeconsole.log(obj2.name); // 打印结果：vae 上面的代码中：obj1 和 obj2 都是引用数据类型，让 obj2 等于 obj1，然后修改 obj1.name 的值之后，发现 obj2.name 的值也发生了改变。 从上面的例子中，可以反映出，基本数据类型和引用数据类型是有区别的。 栈内存和堆内存我们首先记住一句话：JS中，所有的变量都是保存在栈内存中的。 然后来看看下面的区别。 基本数据类型： 基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。 引用数据类型： 对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存了对象的内存地址（对象的引用）。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/07-对象简介和对象的基本操作","date":"2021-08-06T01:17:25.733Z","updated":"2021-07-28T07:34:11.339Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/07-对象简介和对象的基本操作/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/07-%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"面向对象简介对象的作用是：封装信息。比如Student类里可以封装学生的姓名、年龄、成绩等。 对象具有特征（属性）和行为（方法）。 面向对象：可以创建自定义的类型，很好的支持继承和多态。 面向对象的特征：封装、继承、多态。 对象简介基本数据类型和引用数据类型的对比 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 基本数据类型： 基本数据类型的值直接保存在栈内存中，值与值之间是独立存在，修改一个变量不会影响其他的变量。 对象： 只要不是那五种基本数据类型，就全都是对象。 如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间。变量保存的是对象的内存地址（对象的引用）。 换而言之，对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。 例如： 1234567var obj = new Object();obj.name = &quot;孙悟空&quot;;var obj2 = obj;//修改obj的name属性obj.name = &quot;猪八戒&quot;; 上面的代码中，当我修改obj的name属性后，会发现，obj2的name属性也会被修改。因为obj和obj2指向的是堆内存中的同一个地址。 对象的分类1.内置对象： 由ES标准中定义的对象，在任何的ES的实现中都可以使用 比如：Math、String、Number、Boolean、Function、Object…. 2.宿主对象： 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。 比如 BOM DOM。比如console、document。 3.自定义对象： 由开发人员自己创建的对象 对象的基本操作创建对象使用new关键字调用的函数，是构造函数constructor。构造函数是专门用来创建对象的函数。 例如： 1var obj = new Object(); 另外，使用typeof检查一个对象时，会返回object。 向对象中添加属性在对象中保存的值称为属性。 向对象添加属性的语法： 1对象.属性名 = 属性值; 举例： 123456789101112var obj = new Object();//向obj中添加一个name属性obj.name = &quot;孙悟空&quot;;//向obj中添加一个gender属性obj.gender = &quot;男&quot;;//向obj中添加一个age属性obj.age = 18;console.log(JSON.stringify(obj)); // 将 obj 以字符串的形式打印出来 打印结果： 12345&#123; &quot;name&quot;:&quot;孙悟空&quot;, &quot;gender&quot;:&quot;男&quot;, &quot;age&quot;:18&#125; 补充1：对象的属性值可以是任何的数据类型，也可以是个函数：（也称之为方法） 123456789var obj = new Object();obj.sayName = function () &#123; console.log(&#x27;smyhvae&#x27;);&#125;;console.log(obj.sayName); //没加括号，获取的是对象console.log(&#x27;-----------&#x27;);console.log(obj.sayName()); //加了括号，执行函数内容，并执行函数体的内容 打印结果： 补充2：js中的属性值，也可以是一个对象。 举例： 123456789101112//创建对象 obj1var obj1 = new Object();obj1.test = undefined;//创建对象 obj2var obj2 = new Object();obj2.name = &quot;smyhvae&quot;;//将整个 obj2 对象，设置为 obj1 的属性obj1.test = obj2;console.log(obj1.test.name); 打印结果为：smyhvae 获取对象中的属性方式1： 语法： 1对象.属性名 如果获取对象中没有的属性，不会报错而是返回undefined。 举例： 1234567891011121314var obj = new Object();//向obj中添加一个name属性obj.name = &quot;孙悟空&quot;;//向obj中添加一个gender属性obj.gender = &quot;男&quot;;//向obj中添加一个age属性obj.age = 18;// 获取对象中的属性，并打印出来console.log(obj.gender); // 打印结果：男console.log(obj.color); // 打印结果：undefined 方式2：可以使用[]这种形式去操作属性 对象的属性名不强制要求遵守标识符的规范，但是我们使用是还是尽量按照标识符的规范去做。 但如果要使用特殊的属性名，就不能采用.的方式来操作对象的属性。比如说，123这种属性名，如果我们直接写成obj.123 = 789，是会报错的。那怎么办呢？办法如下： 语法格式如下：（读取时，也是采用这种方式） 12对象[&quot;属性名&quot;] = 属性值 上面这种语法格式，举例如下： 1obj[&quot;123&quot;] = 789; 重要：使用[]这种形式去操作属性，更加的灵活，因为，我们可以在[]中直接传递一个变量，这样变量值是多少就会读取那个属性。 修改对象的属性值语法： 1对象.属性名 = 新值 1obj.name = &quot;tom&quot;; 删除对象的属性语法： 1delete obj.name; in 运算符通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回true，没有则返回false。 语法： 1&quot;属性名&quot; in 对象 举例： 12//检查obj中是否含有name属性console.log(&quot;name&quot; in obj); 我们平时使用的对象不一定是自己创建的，可能是别人提供的，这个时候，in 运算符可以派上用场。 对象字面量如果要创建一个对象，我们可以使用下面这种方式： 1var obj = new Object(); 但是上面的这种方式，比较麻烦，我们还有更简洁的方式来创建一个对象。如下。 使用对象字面量来创建一个对象： 1var obj = &#123;&#125;; 使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值….} 例如： 12345678910111213var obj2 = &#123; name: &quot;猪八戒&quot;, age: 13, gender: &quot;男&quot;, test: &#123; name: &quot;沙僧&quot; &#125; //我们还可以在对象中增加一个方法。以后可以通过obj2.sayName()的方式调用这个方法 sayName: function()&#123; console.log(&#x27;smyhvae&#x27;); &#125;&#125;; 对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。 属性名和属性值是一组一组的键值对结构，键和值之间使用:连接，多个值对之间使用,隔开。如果一个属性之后没有其他的属性了，就不要写,，因为它是对象的最后一个属性。 遍历对象中的属性：for in语法： 123for (var 变量 in 对象) &#123;&#125; 解释：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。 举例： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123; name: &quot;smyhvae&quot;, age: 26, gender: &quot;男&quot;, address: &quot;shenzhen&quot; &#125;; //枚举对象中的属性 for (var n in obj) &#123; console.log(&quot;属性名:&quot; + n); console.log(&quot;属性值:&quot; + obj[n]); // 注意，因为这里的属性名 n 是变量，所以，如果想获取属性值，不能写成 obj.n，而是要写成 obj[n] &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/06-流程控制语句：循环结构（for和while）","date":"2021-08-06T01:17:25.731Z","updated":"2021-07-28T07:34:11.339Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/06-流程控制语句：循环结构（for和while）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%88for%E5%92%8Cwhile%EF%BC%89/","excerpt":"","text":"前言循环语句：通过循环语句可以反复的执行一段代码多次。 for循环for循环的语法语法： 123for(①初始化表达式; ②条件表达式; ④更新表达式)&#123; ③语句...&#125; 执行流程： 1234567①执行初始化表达式，初始化变量（初始化表达式只会执行一次）②执行条件表达式，判断是否执行循环： 如果为true，则执行循环③ 如果为false，终止循环④执行更新表达式，更新表达式执行完毕继续重复② for循环举例： 123for (var i = 1; i &lt;= 100; i++) &#123; console.log(i);&#125; 上方代码的解释： for循环举例1234for (var i = 1; i &lt; 13; i = i + 4) &#123; console.log(i);&#125; 上方代码的遍历步骤： 12345678910111213程序一运行，将执行var i = 1;这条语句， 所以i的值是1。然后程序会验证一下i &lt; 13是否满足，1&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i=i+4这条语句，所以i的值，是5。程序会会验证一下i &lt; 13是否满足，5&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i=i+4这条语句，所以i的值，是9。程序会会验证一下i &lt; 13是否满足，9&lt;13是真，所以执行一次循环体（就是大括号里面的语句）。执行完循环体之后，会执行i=i+4这条语句，所以i的值，是13。程序会会验证一下i &lt; 13是否满足，13&lt;13是假，所以不执行循环体了，将退出循环。最终输出输出结果为：1、5、9 接下来做几个题目。 题目1： 1234for (var i = 1; i &lt; 10; i = i + 3) &#123; i = i + 1; console.log(i);&#125; 输出结果：2、6、10 题目2： 1234for (var i = 1; i &lt;= 10; i++) &#123;&#125;console.log(i); 输出结果：11 题目3： 1234for(var i = 1; i &lt; 7; i = i + 3)&#123;&#125;console.log(i); 输出结果：7 题目4： 123for (var i = 1; i &gt; 0; i++) &#123; console.log(i);&#125; 死循环。 while循环语句while循环语法： 123while(条件表达式)&#123; 语句...&#125; 执行流程： 1234567while语句在执行时，先对条件表达式进行求值判断： 如果值为true，则执行循环体： 循环体执行完毕以后，继续对表达式进行判断 如果为true，则继续执行循环体，以此类推 如果值为false，则终止循环 如果有必要的话，我们可以使用 break 来终止循环。 do…while循环语法： 1234do&#123; 语句...&#125;while(条件表达式) 执行流程： 1234567do...while语句在执行时，会先执行循环体： 循环体执行完毕以后，在对while后的条件表达式进行判断： 如果结果为true，则继续执行循环体，执行完毕继续判断以此类推 如果结果为false，则终止循环 while循环和 do…while循环的区别这两个语句的功能类似，不同的是： while是先判断后执行，而do…while是先执行后判断。 也就是说，do…while可以保证循环体至少执行一次，而while不能。 while循环举例题目：假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年？ 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta&gt; &lt;meta&gt; &lt;meta&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; /* * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年 * * 1000 1000*1.05 * 1050 1050*1.05 */ //定义一个变量，表示当前的钱数 var money = 1000; //定义一个计数器 var count = 0; //定义一个while循环来计算每年的钱数 while (money &lt; 5000) &#123; money *= 1.05; //使count自增 count++; &#125; console.log(money); console.log(&quot;一共需要&quot; + count + &quot;年&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 1235003.18854203379一共需要33年 另外，你也可以自己算一下，假如投资的年利率为5%，从1000块增长到1万块，需要花费48年： 12310401.269646942128一共需要48年 break 和 continue 这个知识点非常重要。 break break可以用来退出switch语句或整个循环语句（循环语句包括for、while。不包括if。if里不能用 break 和 continue，否则会报错）。 break会立即终止离它最近的那个循环语句。 可以为循环语句创建一个label，来标识当前的循环（格式：label:循环语句）。使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的。 举例1：通过 break 终止循环语句 1234567for (var i = 0; i &lt; 5; i++) &#123; console.log(&#x27;i的值:&#x27; + i); if (i == 2) &#123; break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。 &#125;&#125; 打印结果： 123i的值:0i的值:1i的值:2 举例2：label的使用 123456789outer:for (var i = 0; i &lt; 5; i++) &#123; console.log(&quot;外层循环 i 的值：&quot; + i) for (var j = 0; j &lt; 5; j++) &#123; break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label） console.log(&quot;内层循环 j 的值:&quot; + j); &#125;&#125; 打印结果： 1外层循环 i 的值：0 continue continue可以用来跳过当次循环。 同样，continue默认只会离他最近的循环起作用。 各种练习练习一：质数相关题目：在页面中接收一个用户输入的数字，并判断该数是否是质数。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数。 */ var num = prompt(&quot;请输入一个大于1的整数:&quot;); //判断这个值是否合法 if (num &lt;= 1) &#123; alert(&quot;该值不合法！&quot;); &#125; else &#123; //先用flag标志位，来保存当前的数的状态 //默认当前num是质数 var flag = true; //判断num是否是质数 //获取2-num之间的数 for (var i = 2; i &lt; num; i++) &#123; //console.log(i); //判断num是否能被i整除 if (num % i == 0) &#123; //如果num能被i整除，则说明num一定不是质数 //设置flag为false flag = false; &#125; &#125; //如果num是质数则输出 if (flag) &#123; alert(num + &quot;是质数！！！&quot;); &#125; else &#123; alert(&quot;这个不是质数&quot;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 练习二：质数相关题目：打印1~100之间的所有质数 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* * 打印出1-100之间所有的质数 */ //打印2-100之间所有的数 for (var i = 2; i &lt;= 100; i++) &#123; //创建一个布尔值，用来保存结果，默认i是质数 var flag = true; //判断i是否是质数 //获取到2-i之间的所有的数 for (var j = 2; j &lt; i; j++) &#123; //判断i是否能被j整除 if (i % j == 0) &#123; //如果进入判断则证明i不是质数,修改flag值为false flag = false; &#125; &#125; //如果是质数，则打印i的值 if (flag) &#123; console.log(i); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 打印结果： 练习三：99乘法表代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; width: 2000px; &#125; span &#123; display: inline-block; width: 80px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* * 1.打印99乘法表 * 1*1=1 * 1*2=2 2*2=4 * 1*3=3 2*3=6 3*3=9 * 1*4=4 2*4=8 3*4=12 4*4=16 * ....9*9=81 * * 2.打印出1-100之间所有的质数 */ //创建外层循环，用来控制乘法表的高度 for (var i = 1; i &lt;= 9; i++) &#123; //创建一个内层循环来控制图形的宽度 for (var j = 1; j &lt;= i; j++) &#123; document.write(&quot;&lt;span&gt;&quot; + j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot;&lt;/span&gt;&quot;); &#125; //输出一个换行 document.write(&quot;&lt;br /&gt;&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面效果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/05-流程控制语句：选择结构（if和switch）","date":"2021-08-06T01:17:25.729Z","updated":"2021-07-28T07:34:11.338Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/05-流程控制语句：选择结构（if和switch）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%EF%BC%88if%E5%92%8Cswitch%EF%BC%89/","excerpt":"","text":"本文首发于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 代码块用&#123;&#125;包围起来的代码，就是代码块。 JS中的代码块，只具有分组的作用，没有其他的用途。 代码块中的内容，在外部是完全可见的。举例： 1234567&#123; var a = 2; alert(&quot;smyhvae&quot;); console.log(&quot;永不止步&quot;);&#125;console.log(&quot;a = &quot; + a); 打印结果：（可以看出，虽然变量 a 是定义在代码块中的，但是在外部依然可以访问） 12永不止步a = 2 流程控制语句在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。 流程控制语句分类 顺序结构 选择结构：if语句、switch语句 循环结构：while语句、for语句 顺序结构按照代码的先后顺序，依次执行。结构图如下： if语句if语句有以下三种。 1、条件判断语句 条件成立才执行。如果条件不成立，那就什么都不做。 格式： 1234if (条件表达式) &#123; // 条件为真时，做的事情&#125; 2、条件分支语句格式1： 1234567if (条件表达式) &#123; // 条件为真时，做的事情&#125; else &#123; // 条件为假时，做的事情&#125; 格式：（多分支的if语句） 123456789101112if (条件表达式1) &#123; // 条件1为真时，做的事情&#125; else if (条件表达式2) &#123; // 条件1不满足，条件2满足时，做的事情&#125; else if (条件表达式3) &#123; // 条件1、2不满足，条件3满足时，做的事情&#125; else &#123; // 条件1、2、3都不满足时，做的事情&#125; 以上所有的语句体中，只执行其中一个。 做个题目123456789101112131415根据BMI（身体质量指数）显示一个人的体型。BMI指数，就是体重、身高的一个计算公式。公式是：BMI =体重÷身高的平方比如，老师的体重是81.6公斤，身高是1.71米。那么老师的BMI就是 81.6 ÷ 1.712 等于 27.906022365856163过轻：低于18.5正常：18.5-24.99999999过重：25-27.9999999肥胖：28-32非常肥胖, 高于32用JavaScript开发一个程序，让用户先输入自己的体重，然后输入自己的身高（弹出两次prompt框）。计算它的BMI，根据上表，弹出用户的身体情况。比如“过轻” 、 “正常” 、“过重” 、 “肥胖” 、“非常肥胖”。 答案： 写法1： 1234567891011121314151617//第一步，输入身高和体重var height = parseFloat(prompt(&quot;请输入身高，单位是米&quot;));var weight = parseFloat(prompt(&quot;请输入体重，单位是公斤&quot;));//第二步，计算BMI指数var BMI = weight / Math.pow(height, 2);//第三步，if语句来判断。注意跳楼现象if (BMI &lt; 18.5) &#123; alert(&quot;偏瘦&quot;);&#125; else if (BMI &lt; 25) &#123; alert(&quot;正常&quot;);&#125; else if (BMI &lt; 28) &#123; alert(&quot;过重&quot;);&#125; else if (BMI &lt;= 32) &#123; alert(&quot;肥胖&quot;);&#125; else &#123; alert(&quot;非常肥胖&quot;);&#125; 写法2： 1234567891011121314151617//第一步，输入身高和体重var height = parseFloat(prompt(&quot;请输入身高，单位是米&quot;));var weight = parseFloat(prompt(&quot;请输入体重，单位是公斤&quot;));//第二步，计算BMI指数var BMI = weight / Math.pow(height, 2);//第三步，if语句来判断。注意跳楼现象if (BMI &gt; 32) &#123; alert(&quot;非常肥胖&quot;);&#125; else if (BMI &gt;= 28) &#123; alert(&quot;肥胖&quot;);&#125; else if (BMI &gt;= 25) &#123; alert(&quot;过重&quot;);&#125; else if (BMI &gt;= 18.5) &#123; alert(&quot;正常&quot;)&#125; else &#123; alert(&quot;偏瘦&quot;);&#125; if语句的嵌套我们通过下面这个例子来引出if语句的嵌套。 1234一个加油站为了鼓励车主多加油，所以加的多有优惠。92号汽油，每升6元；如果大于等于20升，那么每升5.9；97号汽油，每升7元；如果大于等于30升，那么每升6.95编写JS程序，用户输入自己的汽油编号，然后输入自己加多少升，弹出价格。 代码实现如下： 123456789101112131415161718192021222324//第一步，输入var bianhao = parseInt(prompt(&quot;您想加什么油？填写92或者97&quot;));var sheng = parseFloat(prompt(&quot;您想加多少升？&quot;));//第二步，判断if (bianhao == 92) &#123; //编号是92的时候做的事情 if (sheng &gt;= 20) &#123; var price = sheng * 5.9; &#125; else &#123; var price = sheng * 6; &#125;&#125; else if (bianhao == 97) &#123; //编号是97的时候做的事情 if (sheng &gt;= 30) &#123; var price = sheng * 6.95; &#125; else &#123; var price = sheng * 7; &#125;&#125; else &#123; alert(&quot;对不起，没有这个编号的汽油！&quot;);&#125;alert(&quot;价格是&quot; + price); switch语句（条件分支语句）switch语句也叫条件分支语句。 格式： 12345678910111213141516switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; ... ... default： 语句体 n+1; break;&#125; 备注1：当所有的比较结果都为false时，则只执行default里的语句。 备注2：break可以省略，但一般不建议。否则结果可能不是你想要的，会出现一个现象：case穿透。 switch语句的执行流程 首先，计算出表达式的值，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 然后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 switch语句的结束条件 情况a：遇到break就结束，而不是遇到default就结束。（因为break在此处的作用就是退出switch语句） 情况b：执行到程序的末尾就结束。 我们来举两个例子就明白了。 举例1：（case穿透的情况） 123456789101112131415161718192021222324252627282930var num = 4;//switch判断语句switch (num) &#123; case 1: console.log(&quot;星期一&quot;); break; case 2: console.log(&quot;星期二&quot;); break; case 3: console.log(&quot;星期三&quot;); break; case 4: console.log(&quot;星期四&quot;); //break; case 5: console.log(&quot;星期五&quot;); //break; case 6: console.log(&quot;星期六&quot;); break; case 7: console.log(&quot;星期日&quot;); break; default: console.log(&quot;你输入的数据有误&quot;); break;&#125; 上方代码的运行结果，可能会令你感到意外： 123星期四星期五星期六 上方代码的解释：因为在case 4和case 5中都没有break，那语句走到case 6的break才会停止。 举例2： 12345678910111213141516//switch判断语句switch (number) &#123; default: console.log(&quot;我是defaul语句&quot;); // break; case (2): console.log(number); //break; case (3): console.log(number); break; case (4): console.log(number); break;&#125; 上方代码的运行结果，你也许会意外： 123我是defaul语句55 上方代码的解释：从这个例子可以看出：switch语句结束与default无关。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/04-运算符","date":"2021-08-06T01:17:25.728Z","updated":"2021-07-28T07:34:11.338Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/04-运算符/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/04-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"本文首发于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 我们在本文件夹的第二篇里讲到了JS中变量的概念，本篇文章讲一下运算符和表达式。 前言比如说+、*、/、( 都是运算符，而（3+5）/2则是表达式。 运算符的定义和分类运算符也叫操作符。通过运算符可以对一个或多个值进行运算，并获取运算结果。 比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以字符串的形式返回：number string boolean undefined object。 注：运算符都是会返回结果的，而typeof这个运算符返回的结果就是变量的类型。那返回的结果的类型是什么呢？是字符串。 运算符有很多分类，比如： 算数运算符 自增运算符 逻辑运算符 赋值运算符 关系运算符 三元运算符（条件运算符） 算数运算符常见的算数运算符有以下几种： 求余的举例： 假设用户输入345，怎么分别得到3、4、5这三个数呢？ 答案： 12345得到3的方法：345 除以100，得到3.45然后取整，得到3。即：parseInt(345/100)得到4的方法：345 除以100，余数是45，除以10，得到4.5，取整。即：parseInt(345 % 100 / 10)得到5的方法：345 除以10，余数就是5。即：345 % 10 算数运算符的运算规则（1）先算乘除、后算加减。 （2）小括号：能够影响计算顺序，且可以嵌套。没有中括号、没有大括号，只有小括号。 （3）百分号：取余。只关心余数。 举例1：(取余) 1console.log(3 % 5); 输出结果为3。 举例2：（注意运算符优先级） 1var a = 1 + 2 * 3 % 4 / 3; 结果分析： 原式 = 1 + 6 % 4 / 3 = 1 + 2 / 3 = 1.66666666666666 算数运算符的注意事项（1）当对非Number类型的值进行运算（包括+、-、*、/）时，会将这些值转换为Number然后再运算。（注：字符串 + Number、字符串 + 字符串是特例，稍后再讲） 比如： 1234567result1 = true + 1; // 2 = 1+ 1result2 = true + false; // 1 = 1+ 0result3 = 1 + null; // 1 = 1+ 0result4 = 100 - &#x27;1&#x27; // 99 （2）任何值和NaN做运算的结果都是NaN。 （3）任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。 比如： 123result1 = 1 + 2 + &#x27;3&#x27; // 33result2 = &#x27;1&#x27; + 2 + 3; // 123 我们可以利用这一特点，来将一个任意的数据类型转换为String：我们只需要为任意的数据类型 + 一个 “” 即可将其转换为String。这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数。也就是说，c = c + &quot;&quot; 等价于 c = String(c)。 （4）任何值做-、*、/运算时都会自动转换为Number。 我们可以利用这一特点，为一个值-0、*1、/1来将其转换为Number。原理和Number()函数一样，使用起来更加简单。 乘方如果想计算 a 的 b 次方，可以使用如下函数： 1Math.pow(a, b); Math的中文是“数学”，pow是“power 幂”。 举例1： 代码实现： 12var a = Math.pow(3, Math.pow(2, 2));console.log(a); 举例2： 代码实现： 12var a = Math.pow(Math.pow(3, 2), 4);console.log(a); 开方如果想计算数值a的开二次方，可以使用如下函数： 1Math.sqrt(a); sqrt即“square 开方”。比如： 1var a = Math.sqrt(36); 一元运算符一元运算符，只需要一个操作数。 常见的一元运算符如下。 typeoftypeof就是典型的一元运算符，因为后面只跟一个操作数。 举例如下： 12var a = &#x27;123&#x27;;console.log(typeof a); // 打印结果：string 正号 +（1）正号不会对数字产生任何影响。比如说，2和+2是一样的。 （2）我们可以对一个其他的数据类型使用+，来将其转换为number【小技巧】。比如： 1234567891011var a = true;a = +a; // 注意这行代码的一元运算符操作console.log(&#x27;a：&#x27; + a);console.log(typeof a);console.log(&#x27;-----------------&#x27;);var b = &#x27;18&#x27;;b = +b; // 注意这行代码的一元运算符操作console.log(&#x27;b：&#x27; + b);console.log(typeof b); 打印结果： 负号 -负号可以对数字进行取反。 自增和自减自增 ++自增分成两种：a++和++a。 （1）对于一个变量自增以后，原变量的值会立即自增1。也就是说，无论是 a++ 还是++a，都会立即使原变量的值自增1。 （2）我们要注意的是：a是变量，而a++和++a是表达式。 那这两种自增，有啥区别呢？区别是：a++ 和 ++a的值不同：（也就是说，表达式的值不同） a++的值等于原变量的值（a自增前的值） ++a的值等于新值 （a自增后的值） 自减 -- 原理同上。 代码举例1234567891011121314151617181920var n1=10;var n2=20;var n = n1++; //n1 = 11 n1++ = 10console.log(&#x27;n=&#x27;+n); // 10console.log(&#x27;n1=&#x27;+n1); //11n = ++n1 //n1 = 12 ++n1 =12console.log(&#x27;n=&#x27;+n); //12console.log(&#x27;n1=&#x27;+n1); //12n = n2--;// n2=19 n2--=20console.log(&#x27;n=&#x27;+n); //20console.log(&#x27;n2=&#x27;+n2); //19n = --n2; //n2=18 --n2 = 18console.log(&#x27;n=&#x27;+n); //18console.log(&#x27;n2=&#x27;+n2); //18 逻辑运算符逻辑运算符有三个： &amp;&amp; 与（且）：两个都为真，结果才为真。 || 或：只要有一个是真，结果就是真。 ! 非：对一个布尔值进行取反。 连比的写法： 来看看逻辑运算符连比的写法。 举例1： 1console.log(3 &lt; 2 &amp;&amp; 2 &lt; 4); 输出结果为false。 举例2：（判断一个人的年龄是否在18~60岁之间） 12var a = prompt(&quot;请输入您的年龄&quot;);alert(a&gt;=18 &amp;&amp; a&lt;= 65); PS：上面的这个a&gt;=18 &amp;&amp; a&lt;= 65千万别想当然的写成 18&lt;= a &lt;= 65，没有这种语法。 注意事项（1）能参与逻辑运算的，都是布尔值。 （2）JS中的&amp;&amp;属于短路的与，如果第一个值为false，则不会看第二个值。举例： 12345//第一个值为true，会检查第二个值true &amp;&amp; alert(&quot;看我出不出来！！&quot;); // 可以弹出 alert 框//第一个值为false，不会检查第二个值false &amp;&amp; alert(&quot;看我出不出来！！&quot;); // 不会弹出 alert 框 （3）JS中的||属于短路的或，如果第一个值为true，则不会看第二个值。举例： （4）如果对非布尔值进行逻辑运算，则会先将其转换为布尔值，然后再操作。举例： 12345var a = 10;a = !a;console.log(a); // falseconsole.log(typeof a); // boolean 上面的例子，我们可以看到，对非布尔值进行!操作之后，返回结果为布尔值。 非布尔值的与或运算【重要】 之所以重要，是因为在实际开发中，我们经常用这种代码做容错处理。 非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但返回结果是原值。比如说： 12var result = 5 &amp;&amp; 6; // 运算过程：true &amp;&amp; true;console.log(&#x27;result：&#x27; + result); // 打印结果：6（也就是说最后面的那个值。） 上方代码可以看到，虽然运算过程为布尔值的运算，但返回结果是原值。 那么，返回结果是哪个原值呢？我们来看一下。 与运算的返回结果：（以两个非布尔值的运算为例） 如果第一个值为true，则必然返回第二个值（所以说，如果所有的值都为true，则返回的是最后一个值） 如果第一个值为false，则直接返回第一个值 或运算的返回结果：（以两个非布尔值的运算为例） 如果第一个值为true，则直接返回第一个值 如果第一个值为false，则返回第二个值 实际开发中，我们经常是这样来处理容错的： 当成功调用一个接口后，针对返回的数据 result，假设我们用变量a 接收。通常的写法是这样的：（这里我只是举个例子） 1234if (result.resultCode == 0) &#123; var a = result &amp;&amp; result.data &amp;&amp; result.data.imgUrl;&#125; 赋值运算符可以将符号右侧的值赋值给符号左侧的变量。 举例： +=。a += 5 等价于 a = a + 5 -=。a -= 5 等价于 a = a - 5 *=。a *= 5 等价于 a = a * 5 /=。a /= 5 等价于 a = a / 5 %=。a %= 5 等价于 a = a % 5 关系运算符通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false。 关系运算符有很多种，比如： 12345678&gt; 大于号&lt; 小于号&gt;= 大于或等于&lt;= 小于或等于== 等于=== 全等于!= 不等于!== 不全等于 关系运算符，得到的结果都是布尔值：要么是true，要么是false。 举例如下： 1var result = 5 &gt; 10; // false 非数值的比较（1）对于非数值进行比较时，会将其转换为数字然后再比较。 举例如下： 1234567891011console.log(1 &gt; true); //falseconsole.log(1 &gt;= true); //trueconsole.log(1 &gt; &quot;0&quot;); //true//console.log(10 &gt; null); //true//任何值和NaN做任何比较都是falseconsole.log(10 &lt;= &quot;hello&quot;); //falseconsole.log(true &gt; false); //true （2）特殊情况：如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode编码。【非常重要，这里是个大坑】 比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位，所以借用它可以来对英文进行排序。 PS：所以说，当你尝试去比较&quot;123&quot;和&quot;56&quot;这两个字符串时，你会发现，字符串”56”竟然比字符串”123”要大。也就是说，下面这样代码的打印结果，其实是true:（这个我们一定要注意，在日常开发中，很容易忽视） 12// 比较两个字符串时，比较的是字符串的字符编码，所以可能会得到不可预期的结果console.log(&quot;56&quot; &gt; &quot;123&quot;); // true 因此：当我们在比较两个字符串型的数字时，一定一定要先转型，比如 parseInt()。 （3）任何值和NaN做任何比较都是false。 ==符号的强调注意==这个符号，它是判断是否等于，而不是赋值。 （1）== 这个符号，还可以验证字符串是否相同。例如： 1console.log(&quot;我爱你中国&quot; == &quot;我爱你中国&quot;); //输出结果为true （2）== 这个符号并不严谨，会将不同类型的东西，转为相同类型进行比较（大部分情况下，都是转换为数字）。例如： 12345console.log(&quot;6&quot; == 6); // 打印结果：true。这里的字符串&quot;6&quot;会先转换为数字6，然后再进行比较console.log(true == &quot;1&quot;); // 打印结果：trueconsole.log(0 == -0); // 打印结果：trueconsole.log(null == 0); // 打印结果：true （3）undefined 衍生自 null，所以这两个值做相等判断时，会返回true。 1console.log(undefined == null); //打印结果：true。 （4）NaN不和任何值相等，包括他本身。 1console.log(NaN == NaN); //false 问题：那如果我想判断 b的值是否为NaN，该怎么办呢？ 答案：可以通过isNaN()函数来判断一个值是否是NaN。举例： 1console.log(isNaN(b)); //false 如上方代码所示，如果 b 为 NaN，则返回true；否则返回false。 ===全等符号的强调如果要保证完全等于，我们就要用三个等号===。全等不会做类型转换。例如： 12console.log(&quot;6&quot; === 6); //falseconsole.log(6 === 6); //true 上述内容分析出： ==两个等号，不严谨，”6”和6是true。 ===三个等号，严谨，”6”和6是false。 另外还有：**==的反面是!=，===的反面是!==。**。例如： 123console.log(3 != 8); //trueconsole.log(3 != &quot;3&quot;); //false，因为3==&quot;3&quot;是true，所以反过来就是false。console.log(3 !== &quot;3&quot;); //true，应为3===&quot;3&quot;是false，所以反过来是true。 三元运算符三元运算符也叫条件运算符。 语法： 1条件表达式?语句1:语句2; 执行的流程： 条件运算符在执行时，首先对条件表达式进行求值： 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。 运算符的优先级运算符的优先级如下：（越往上，优先级越高） .、[]、new () ++、– !、~、+（单目）、-（单目）、typeof、void、delete %、*、/ +（双目）、-（双目） &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; &lt;、&lt;=、&gt;、&gt;= ==、!==、=== &amp; ^ | &amp;&amp; || ?: =、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|= , 备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。 Unicode 编码表 这一段中，我们来讲引申的内容：Unicode编码的使用。 1、在字符串中可以使用转义字符输入Unicode编码。格式如下： 1\\u四位编码 举例如下： 12console.log(&quot;\\u2600&quot;); // 这里的 2600 采用的是16进制console.log(&quot;\\u2602&quot;); // 这里的 2602 采用的是16进制。 打印结果： 2、同样，我们可以在网页中使用Unicode编码。格式如下： 1&amp;#编码; PS：我们知道，Unicode编码采用的是16进制，但是，这里的编码需要使用10进制。 举例如下： 12&lt;h1 style=&quot;font-size: 100px;&quot;&gt;&amp;#9860;&lt;/h1&gt; 打印结果： 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/03-变量的强制类型转换","date":"2021-08-06T01:17:25.726Z","updated":"2021-07-28T07:34:11.337Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/03-变量的强制类型转换/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/03-%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"前言强制类型转换：将一个数据类型强制转换为其他的数据类型。 类型转换主要指，将其他的数据类型，转换为：String、Number、Boolean。你会把某个数据类型转换成 null 或者 undefined 吗？不会，因为这样做，没有意义。 其他的简单类型 –&gt; String方法一：变量+”” 或者 变量+”abc”举例如下： 123vat a = 123; // Number 类型console.log(a + &#x27;&#x27;); // 转换成 String 类型console.log(a + &#x27;haha&#x27;); // 转换成 String 类型 上面的例子中，打印的结果，都是字符串类型的数据。 方法二：调用toString()方法举例如下： 1变量.toString() 【重要】该方法不会影响到原变量，它会将转换的结果返回。当然我们还可以直接写成a = a.toString()，这样的话，就是直接修改原变量。 注意：null和undefined这两个值没有toString()方法，所以它们不能用方法二。如果调用，会报错。 另外，Number类型的变量，在调用toString()时，可以在方法中传递一个整数作为参数。此时它将会把数字转换为指定的进制，如果不指定则默认转换为10进制。例如： 12345678var a = 255;//对于Number调用toString()时可以在方法中传递一个整数作为参数//此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制a = a.toString(2);console.log(a); // 11111111console.log(typeof a); // string 方法三：使用String()函数格式如下： 1String(变量) 使用String()函数做强制类型转换时： 对于Number和Boolean而言，实际上就是调用toString()方法。 但是对于null和undefined，就不会调用toString()方法。它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。 prompt()：用户的输入我们在JS基础的第一篇里，就讲过，prompt()就是专门用来弹出能够让用户输入的对话框。重要的是：用户不管输入什么，都是字符串。 其他的数据类型 –&gt; Number方式一：使用Number()函数情况一：字符串 –&gt; 数字 1.如果字符串中是纯数字，则直接将其转换为数字。 2.如果字符串中有非数字的内容，则转换为NaN。（此处可以看到Number()函数的局限性） 3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0。 情况二：布尔 –&gt; 数字 true 转成 1 false 转成 0 情况三：null –&gt; 数字 结果为：0 情况四：undefined –&gt; 数字 结果为：NaN 方式二：parseInt()：字符串 -&gt; 整数【重要】 parseInt()是专门用来对付字符串的。 parseInt()的作用是将字符串中的有效的整数内容转为数字。parse表示“转换”，Int表示“整数”（注意Int的拼写）。例如： 1parseInt(&quot;5&quot;); 得到的结果是数字5。 parseInt()还具有以下特性： （1）只保留字符串最开头的数字，后面的中文自动消失。例如： 12345console.log(parseInt(&quot;2017在公众号上写了6篇文章&quot;)); //打印结果：2017console.log(parseInt(&quot;2017.01在公众号上写了6篇文章&quot;)); //打印结果仍是：2017 （说明只会取整数）console.log(parseInt(&quot;aaa2017.01在公众号上写了6篇文章&quot;)); //打印结果：NaN （2）自动带有截断小数的功能：取整，不四舍五入。 例1： 12var a = parseInt(5.8) + parseInt(4.7);console.log(a); 控制台输出： 19 例2： 12var a = parseInt(5.8 + 4.7);console.log(a); 控制台输出： 110 （3）如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后再操作。 比如： 123456789101112var a = true;console.log(parseInt(a)); //打印结果：NaN （因为是先将a转为字符串&quot;true&quot;，然后然后再操作）var b = null;console.log(parseInt(b)); //打印结果：NaN （因为是先将b转为字符串&quot;null&quot;，然后然后再操作）var c = undefined;console.log(parseInt(c)); //打印结果：NaN （因为是先将b转为字符串&quot;undefined&quot;，然后然后再操作）var d = 168.23;console.log(parseInt(d)); //打印结果：168 （因为是先将c转为字符串&quot;168.23&quot;，然后然后再操作） （4）带两个参数时，表示进制转换。 parseFloat()：字符串 –&gt; 浮点数（小数） parseFloat()是专门用来对付字符串的。 parseFloat()的作用是：将字符串转换为浮点数。 parseFloat()和parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。 代码举例： 12var a = &#x27;123.456.789px&#x27;;console.log(parseFloat(a)); // 打印结果：123.456 转换为Boolean将其他的数据类型转换为Boolean，可以使用Boolean()函数。 情况一：数字 –&gt; 布尔。除了0和NaN，其余的都是true。 情况二：字符串 —&gt; 布尔。除了空串，其余的都是true。 情况三：null和undefined都会转换为false。 情况四：对象也会转换为true。 PS：上面的这就种情况，很重要，开发中会经常用到。 其他进制的数字 16进制的数字，以0x开头 8进制的数字，以0开头 2进制的数字，0b开头（不是所有的浏览器都支持：chrome和火狐支持，IE不支持） 比如070这个字符串，如果我调用parseInt()转成数字时，有些浏览器会当成8进制解析，有些会当成10进制解析。 所以，比较建议的做法是：可以在parseInt()中传递第二个参数，来指定数字的进制。例如： 123a = &quot;070&quot;;a = parseInt(a,10); //转换成十进制 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/02-变量","date":"2021-08-06T01:17:25.724Z","updated":"2021-07-28T07:34:11.337Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/02-变量/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/02-%E5%8F%98%E9%87%8F/","excerpt":"","text":"字面量：数字和字符串“字面量”即常量，是固定值，不可改变。看见什么，它就是什么。 简单的字面量有2种：数字、字符串。 （1）数值的字面量非常简单，写上去就行了，不需要任何的符号。例如： 11 alert(886); //886是数字，所以不需要加引号。 （2）字符串的字面量也很简单，但一定要加上引号。可以是单词、句子等。 温馨提示：100是数字，”100”是字符串。 总结字面量都可以直接使用，但是我们一般不会直接使用字面量。 如果直接使用字面量的话，非常麻烦。比如说，多个地方要用到同一个字面量，还不如事先定义一个变量，用来保存字面量。 变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，而不会直接使用字面量。 变量变量的概念变量：变量可以用来保存字面量，而且变量的值可以任意改变。 变量的定义和赋值在js中使用var关键字来声明一个变量。 变量举例如下： 1var a = 100; 如下图所示： var是英语“variant”变量的缩写。后面要加一个空格，空格后面的东西就是“变量名”： 定义变量：var就是一个关键字，用来定义变量。所谓关键字，就是有特殊功能的小词语。关键字后面一定要有空格隔开。 变量的赋值：等号表示赋值，将等号右边的值，赋给左边的变量。 变量名：我们可以给变量任意的取名字。 PS：在JavaScript中，永远都是用var来定义变量（在ES6 之前），这和C、Java等语言不同。 变量要先定义，才能使用。比如，我们不设置变量，直接输出： 123&lt;script type=&quot;text/javascript&quot;&gt; console.log(a);&lt;/script&gt; 控制台将会报错： 正确写法： 123var a; // 定义a = 100; //赋值console.log(a); //输出100 有经验的程序员，会把定义和赋值写在一起： 12var a = 100; //定义，并且赋值100console.log(a); //输出100 变量的命名规范变量名有命名规范：只能由英语字母、数字、下划线、美元符号$构成，且不能以数字开头，并且不能是JavaScript保留字。 下列的单词，叫做保留字，就是说不允许当做变量名，不用记： 12abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、gotoimplements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 大写字母是可以使用的，并且大小写敏感。也就是说A和a是两个变量。 12var A = 250; //变量1var a = 888; //变量2 我们来整理一下变量的命名规则： 1.建议用驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc 2.变量命名必须以字母或是下标符号”_”或者”$”为开头。 3.变量名长度不能超过255个字符。 4.变量名中不允许使用空格，首个字不能为数字。 5.不用使用脚本语言中保留的关键字及保留字作为变量名。 6.变量名区分大小写(javascript是区分大小写的语言)。 7.汉语可以作为变量名。但是不建议使用，因为 low。 标识符标识符：在JS中所有的可以由我们自主命名的都可以称之为标识符。 例如：变量名、函数名、属性名都是属于标识符。 标识符的命名规则和变量的命令规则是一样的。看上面一段就可以了。 重点要注意的是：标识符不能使用脚本语言中保留的关键字及保留字。如下。 关键字： 保留字： 其他不建议使用的标识符： 变量的数据类型变量里面能够存储数字、字符串等。变量会自动的根据存储内容的类型不同，来决定自己的类型。 在JS中一共有六种数据类型： 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。 引用数据类型（引用类型）：Object 对象。 注意：内置对象function、Array、Date、RegExp、Error等都是属于Object类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。 面试问：引用数据类型有几种？ 面试答：只有一种，即 Object 类型。 数据类型之间最大的区别： 基本数据类型：参数赋值的时候，传数值。 引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。 接下来，我们详细讲一下基本数据类型。 String 字符串来看个示例。现有如下代码： 1234567891011var a = &quot;abcde&quot;;var b = &quot;生命壹号&quot;;var c = &quot;123123&quot;;var d = &quot;哈哈哈哈哈&quot;;var e = &quot;&quot;; //空字符串console.log(typeof a);console.log(typeof b);console.log(typeof c);console.log(typeof d);console.log(typeof e); 控制台输出如下： 12345stringstringstringstringstring 注意事项： （1）在JS中，字符串需要使用引号引起来。使用双引号或单引号都可以，但是不要混着用。比如下面这样写是不可以的： 1var str = `hello&quot;; （2）引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。但是单引号里可以嵌套双引号。 （3）转义字符：在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\进行转义。 \\&quot; 表示 &quot; \\&#39; 表示 &#39; \\n 表示换行 \\r 表示回车 \\t 表示制表符 \\b 表示空格 \\\\ 表示\\ 举例： 12345var str1 = &quot;我说:\\&quot;今天\\t天气真不错！\\&quot;&quot;;var str2 = &quot;\\\\\\\\\\\\&quot;;console.log(str1);console.log(str2); 上方代码的打印结果： 12我说:&quot;今天 天气真不错！&quot;\\\\\\ 将其他数值转换为字符串有三种方式： 拼串 toString() String() 补充知识：typeof 运算符typeof()表示“获取变量的类型”，返回的是小写，语法为： 1typeof 变量 返回结果： typeof 数值的返回结果：number typeof 字符串的返回结果：string typeof 布尔型的返回结果：boolean typeof undefined的返回结果：undefined typeof null的返回结果：object 在JavaScript中，只要是数，就是 number 数值型的。无论整浮、浮点数（即小数）、无论大小、无论正负，都是 number 类型的。 数值型：Number在JS中所有的数值都是Number类型，包括整数和浮点数（小数）。 12var a = 100; //定义了一个变量a，并且赋值100console.log(typeof a); //输出a变量的类型 上方代码的输出结果为： 1number 数值范围： 由于内存的限制，ECMAScript 并不能保存世界上所有的数值。 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为： 5e-324 如果使用Number表示的变量超过了最大值，则会返回Infinity。 无穷大（正无穷）：Infinity 无穷小（负无穷）：-Infinity 注意：typeof Infinity的返回结果是number。 NaN和isNaN()函数： （1）NaN：是一个特殊的数字，表示Not a Number，非数值。比如： 123console.log(&quot;abc&quot; / 18); //结果是NaNconsole.log(&quot;abc&quot; * &quot;abcd&quot;); //按理说，字符串相乘是没有结果的，但如果你非要让JS去算，它就一定会给你一个结果。结果是NaN 注意：typeof NaN的返回结果是number。 Undefined和任何数值计算的结果为NaN。NaN 与任何值都不相等，包括 NaN 本身。 （2）isNaN() :任何不能被转换为数值的值，都会让这个函数返回 true。 1234isNaN(NaN);// trueisNaN(&quot;blue&quot;); // trueisNaN(123); // false 浮点数的运算： 在JS中，整数的运算基本可以保证精确；但是小数的运算，可能会得到一个不精确的结果。所以，千万不要使用JS进行对精确度要求比较高的运算。 如下： 12var a = 0.1 + 0.2;console.log(a); //打印结果：0.30000000000000004 上方代码中，打印结果并不是0.3，而是0.30000000000000004。 我们知道，所有的运算都要转换成二进制去计算，然而，二进制是无法精确表示1/10的。因此存在小数的计算不精确的问题。 连字符和加号的区别键盘上的+可能是连字符，也可能是数字的加号。如下： 123console.log(&quot;我&quot; + &quot;爱&quot; + &quot;你&quot;); //连字符，把三个独立的汉字，连接在一起了console.log(&quot;我+爱+你&quot;); //原样输出console.log(1+2+3); //输出6 输出： 123我爱你我+爱+你6 总结：如果加号两边都是数值，此时是加。否则，就是连字符（用来连接字符串）。 举例1： 123var a = &quot;1&quot;;var b = 2;console.log(a + b); 控制台输出： 112 举例2： 1234var a = 1;var b = 2;console.log(&quot;a&quot; + b); //&quot;a&quot;就不是变量了！所以就是&quot;a&quot;+2 输出a2 控制台输出： 1a2 于是我们明白了，在变量中加入字符串进行拼接，可以被同化为字符串。【重要】 隐式转换我们知道，&quot;2&quot;+1得到的结果其实是字符串，但是&quot;2&quot;-1得到的结果却是数值1，这是因为计算机自动帮我们进行了“隐式转换”。 也就是说，-、*、/、`%``这几个符号会自动进行隐式转换。例如： 12var a = &quot;4&quot; + 3 - 6;console.log(a); 输出结果： 137 虽然程序可以对-、*、/、`%``这几个符号自动进行“隐式转换”；但作为程序员，我们最好自己完成转换，方便程序的可读性。 布尔值：Booleantrue 和 fase。主要用来做逻辑判断。 布尔值直接使用就可以了，千万不要加上引号。 代码： 12var a = true;console.log(typeof a); 控制台输出结果： 1boolean null和undefinednull：空值专门用来表示一个为空的对象（例如：var a = null）。注意，专门用来表示空对象。 Null类型的值只有一个，就是null。比如：var a = null。 使用 typeof 检查一个null值时，会返回object。 undefined：未定义声明了一个变量，但是没有赋值（例如：var a;），此时它的值就是undefined。 Undefined类型的值只有一个，就是undefind 使用 type of 检查一个undefined时，会返回undefined。 null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。 但是null === undefined的结果(false)。它们虽然相似，但还是有区别的，其中一个区别是：和数字运算时，10 + null结果为：10；10 + undefined结果为：NaN。 任何数据类型和undefined运算都是NaN; 任何值和null运算，null可看做0运算。 变量值的传递（赋值）语句： 1a = b; 把b的值赋给a，b不变。 将等号右边的值，赋给左边的变量；等号右边的变量，值不变。 来做几个题目。 举例1： 12345678910 //a b cvar a = 1; //1var b = 2; //1 2var c = 3; //1 2 3a = b + c; //5 2 3b = c - a; //5 -2 3c = a * b; //5 -2 -10console.log(a);console.log(b);console.log(c); 输出： 1235-2-10 举例2： 12345678910 //a b cvar a = 1;var b = 2;var c = 3; //1 2 3a = a + b; //3 2 3b = b + a; //3 5 3c = c + b; //3 5 8console.log(a); //3console.log(b); //5console.log(c); //8 输出： 123358 举例3： 1234567 //a bvar a = &quot;1&quot;;var b = 2; //&quot;1&quot; 2a = a + b; //&quot;12&quot; 2b = b + a; //&quot;12&quot; &quot;212&quot;console.log(a); //输出12console.log(b); //输出212 输出： 1212212 举例4： 1234567 //a bvar a = &quot;1&quot;;var b = 2;a = b + a; //&quot;21&quot; 2b = b + a; //&quot;21&quot; &quot;221&quot;console.log(a); //21console.log(b) //221 效果： 1221221 举例5：（这个例子比较特殊，字符串减去数字） 123var a = &quot;3&quot;;var b = 2;console.log(a-b); 效果：（注意，字符串 - 数值 = 数值） 11 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/03-JavaScript基础/01-JS简介","date":"2021-08-06T01:17:25.722Z","updated":"2021-07-28T07:34:11.337Z","comments":true,"path":"2021/08/06/大前端/03-JavaScript基础/01-JS简介/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/03-JavaScript%E5%9F%BA%E7%A1%80/01-JS%E7%AE%80%E4%BB%8B/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 JavaScript背景Web前端有三层： HTML：从语义的角度，描述页面结构 CSS：从审美的角度，描述样式（美化页面） JavaScript：从交互的角度，描述行为（提升用户体验） JavaScript是世界上用的最多的脚本语言。 发展历史JavaScript诞生于1995年。布兰登 • 艾奇（Brendan Eich，1961年～），1995年在网景公司，发明的JavaScript。 JavaScript是由网景公司发明，起初命名为LiveScript，后来由于SUN公司的介入更名为了JavaScript。 备注：由于当时Java这个语言特别火，所以为了傍大牌，就改名为JavaScript。如同“北大”和“北大青鸟”的关系。“北大青鸟”就是傍“北大”大牌。 同时期还有其他的网页语言，比如VBScript、JScript等等，但是后来都被JavaScript打败了，所以现在的浏览器中，只运行一种脚本语言就是JavaScript。 JavaScript和ECMAScript的关系ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）制定和发布的脚本语言规范。 JavaScript是由公司开发而成的，问题是不便于其他的公司拓展和使用。所以欧洲的这个ECMA的组织，牵头制定JavaScript的标准，取名为ECMAScript。 简单来说，ECMAScript不是一门语言，而是一个标准。 ECMAScript在2015年6月，发布了ECMAScript 6版本（ES6），语言的能力更强（也包含了很多新特性）。但是，浏览器的厂商不会那么快去追上这个标准，需要时间。 JavaScript的发展：蒸蒸日上2003年之前，JavaScript被认为“牛皮鲜”，用来制作页面上的广告，弹窗、漂浮的广告。什么东西让人烦，什么东西就是JavaScript开发的。所以很多浏览器就推出了屏蔽广告功能。 2004年，JavaScript命运开始改变。那一年，谷歌公司开始带头使用Ajax技术，Ajax技术就是JavaScript的一个应用。并且，那时候人们逐渐开始提升用户体验了。Ajax有一些应用场景。比如，当我们在百度搜索框搜文字时，输入框下方的智能提示，可以通过Ajax实现。比如，当我们注册网易邮箱时，能够及时发现用户名是否被占用，而不用调到另外一个页面。 2007年乔布斯发布了第一款iPhone，这一年开始，用户就多了上网的途径，就是用移动设备上网。JavaScript在移动页面中，也是不可或缺的。并且这一年，互联网开始标准化，按照W3C规则三层分离，JavaScript越来越被重视。 2010年，人们更加了解HTML5技术，HTML5推出了一个东西叫做Canvas（画布），工程师可以在Canvas上进行游戏制作，利用的就是JavaScript。 2011年，Node.js诞生，使JavaScript能够开发服务器程序了。 如今，WebApp已经非常流行，就是用网页技术开发手机应用。手机系统有iOS、安卓。比如公司要开发一个“携程网”App，就需要招聘三队人马，比如iOS工程师10人，安卓工程师10人，前端工程师10人。共30人，开发成本大；而且如果要改版，要改3个版本。现在，假设公司都用web技术，用html+css+javascript技术就可以开发App。也易于迭代（网页一改变，所有的终端都变了）。 虽然目前WebApp在功能和性能上的体验远不如Native App，但是“WebApp慢慢取代Native App”很有可能是未来的趋势。 JavaScript介绍JavaScript入门易学性 JavaScript对初学者比较友好。 JavaScript是有界面效果的（比如C语言却只有白底黑字）。 JavaScript是弱变量类型的语言，变量只需要用var来声明。而Java中变量的声明，要根据变量的类型来定义。 比如Java中需要定义如下变量： 12345int a;float a;double a;String a;boolean a; 而JavaScript中，只需要用一种方式来定义： 1var a; JavaScript不用关心其他的一些事情（比如内存的释放、指针等），更关心自己的业务。 浏览器工作原理 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 参考链接：https://www.2cto.com/kf/201202/118111.html JavaScript是前台语言JavaScript是前台语言，而不是后台语言。 JavaScript运行在用户的终端网页上，而不是服务器上，所以我们称为“前台语言”。就是服务于页面的交互效果、美化，不能操作数据库。 后台语言是运行在服务器上的，比如PHP、ASP、JSP等等，这些语言都能够操作数据库，都能够对数据库进行“增删改查”操作。Node.js除外。 JavaScript的组成JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。 DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。 BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。 PS：JS机械重复性的劳动几乎为0，基本都是创造性的劳动。而不像HTML、CSS中margin、padding都是机械重复劳动。 JavaScript的特点（1）简单易用：可以使用任何文本编辑工具编写，只需要浏览器就可以执行程序。 （2）解释型语言：事先不需要被编译为机器码再执行，逐行执行、无需进行严格的变量声明。 由于少了编译这一步骤，所以解释型语言开发起来尤为轻松，但是解释型语言运行较慢也是它的劣势。不过解释型语言中使用了JIT技术，使得运行速度得以改善。 （3）基于对象：内置大量现成对象，编写少量程序可以完成目标 编程语言的分类 解释型语言：边解析边执行，不需要事先编译。例如：JavaScript、php。 编译型语言：事先把所有的代码翻译成计算机能够执行的指令，然后整体执行。例如：c、c++。 开始写第一行JavaScript代码JavaScript代码的书写位置（1）内嵌的方式： 页面中，我们可以在&lt;body&gt;标签里放入&lt;script type=”text/javascript”&gt;&lt;/script&gt;标签对儿，并在&lt;script&gt;里书写JavaScript程序： 123&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; text表示纯文本，因为JavaScript也是一个纯文本的语言。 PS：在Sublime Text里，输入&lt;sc后，按tab键，可以自动补齐。 （2）外链式：引入外部JavaScript文件（放到body标签里，可以和内嵌的js代码并列） 1&lt;script src=&quot;tool.js&quot;&gt;&lt;/script&gt; alert语句我们要学习的第一个语句，就是alert语句。 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;生命壹号&quot;);&lt;/script&gt; alert（英文翻译为“警报”）的用途：弹出“警告框”。 alert(&quot;&quot;)警告框的效果如下： 这个警告框，在IE浏览器中长这样： 上面的代码中，如果写了两个alert()语句的话，网页的效果是：弹出第一个警告框，点击确定后，继续弹出第二个警告框。 语法规则学习程序，是有规律可循的，就是程序是有相同的部分，这些部分就是一种规定，不能更改，我们成为：语法。 （1）JavaScript对换行、缩进、空格不敏感。每一条语句以分号结尾。 也就是说： 代码一： 1234&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;今天蓝天白云&quot;); alert(&quot;我很高兴&quot;);&lt;/script&gt; 等价于代码二： 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;今天蓝天白云&quot;);alert(&quot;我很高兴&quot;);&lt;/script&gt; 备注：每一条语句末尾要加上分号，虽然分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。 （2）所有的符号，都是英语的。比如括号、引号、分号。 如果你用的是搜狗拼音，建议不要用shift切换中英文（可以在搜狗软件里进行设置），不然很容易输入中文的分号；建议用ctrl+space切换中英文输入法。 （3）严格区分大小写 注释我们不要把html、CSS、JavaScript三者的注释格式搞混淆了。 （1）html的注释： 1&lt;!-- 我是注释 --&gt; （2）CSS的注释： 12345678910111213&lt;style type=&quot;text/css&quot;&gt; /* 我是注释 */ p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才算生效哦。 （3）JavaScript的注释： 单行注释： 1// 我是注释 多行注释： 1234/* 多行注释1 多行注释2*/ 备注：sublime中，单行注释的快捷键是ctrl+/，多行注释的快捷键是ctrl+shift+/。 Javascript 网页中输出信息的写法弹出警告框：alert(“”)我们在上一段讲到了alert语句，这里不再赘述。 控制台输出：console.log(“”)console.log(&quot;&quot;)表示在控制台中输出。console表示“控制台”，log表示“输出”。 控制台在Chrome浏览器的F12中。控制台是工程师、程序员调试程序的地方。程序员经常使用这条语句输出一些东西，来测试程序是否正确。 console.log(&quot;&quot;)效果如下： 普通人是不会在意控制台的，但是有些网站另藏玄机。有个很有意思的地方是，百度首页的控制台，悄悄地放了一段招聘信息： 毕竟做前端的人是经常使用控制台的。 接下来，我们开始学习JavaScript语法。 用户输入：prompt()语句prompt()就是专门用来弹出能够让用户输入的对话框。用得少，测试的时候可能会用。 JS代码如下： 12var a = prompt(&quot;请随便输入点什么东西吧&quot;);console.log(a); 上方代码中，用户输入的内容，将被传递到变量 a 里面。 效果如下： prompt()语句中，用户不管输入什么内容，都是字符串。 alert和prompt的区别： 12alert(&quot;从前有座山&quot;); //直接使用，不需要变量var a = prompt(&quot;请输入一个数字&quot;); // 必须用一个变量，来接收用户输入的值 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/浏览器的兼容性问题","date":"2021-08-06T01:17:25.716Z","updated":"2021-07-28T07:34:11.336Z","comments":true,"path":"2021/08/06/大前端/02-CSS/浏览器的兼容性问题/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们在div里放一个img，发现： 在html和html5中，div的长宽是不同的，后者的高度要超过几个像素。 比如说，下面这个是html的。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0px; padding: 0px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;/Users/smyhvae/Dropbox/img/20170813_1143.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/12","date":"2021-08-06T01:17:25.715Z","updated":"2021-07-28T07:34:11.336Z","comments":true,"path":"2021/08/06/大前端/02-CSS/12/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/12/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; label &#123; display: block; vertical-align: middle; &#125; label, input, select &#123; vertical-align: middle; &#125; .mui-switch &#123; width: 52px; height: 31px; position: relative; border: 1px solid #dfdfdf; background-color: #fdfdfd; box-shadow: #dfdfdf 0 0 0 0 inset; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-clip: content-box; display: inline-block; -webkit-appearance: none; user-select: none; outline: none; &#125; .mui-switch:before &#123; content: &#x27;&#x27;; width: 29px; height: 29px; position: absolute; top: 0px; left: 0; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); &#125; .mui-switch:checked &#123; border-color: #64bd63; box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63; &#125; .mui-switch:checked:before &#123; left: 21px; &#125; .mui-switch.mui-switch-animbg &#123; transition: background-color ease 0.4s; &#125; .mui-switch.mui-switch-animbg:before &#123; transition: left 0.3s; &#125; .mui-switch.mui-switch-animbg:checked &#123; box-shadow: #dfdfdf 0 0 0 0 inset; background-color: #64bd63; transition: border-color 0.4s, background-color ease 0.4s; &#125; .mui-switch.mui-switch-animbg:checked:before &#123; transition: left 0.3s; &#125; .mui-switch.mui-switch-anim &#123; transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s; &#125; .mui-switch.mui-switch-anim:before &#123; transition: left 0.3s; &#125; .mui-switch.mui-switch-anim:checked &#123; box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63; transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s; &#125; .mui-switch.mui-switch-anim:checked:before &#123; transition: left 0.3s; &#125; /*# sourceMappingURL=mui-switch.css.map */&lt;/style&gt;&lt;body&gt; &lt;label&gt; &lt;input class=&quot;mui-switch&quot; type=&quot;checkbox&quot;&gt; 默认未选中&lt;/label&gt; &lt;label&gt; &lt;input class=&quot;mui-switch&quot; type=&quot;checkbox&quot; checked&gt; 默认选中&lt;/label&gt; &lt;label&gt; &lt;input class=&quot;mui-switch mui-switch-animbg&quot; type=&quot;checkbox&quot;&gt; 默认未选中,简单的背景过渡效果,加mui-switch-animbg类即可&lt;/label&gt; &lt;label&gt; &lt;input class=&quot;mui-switch mui-switch-animbg&quot; type=&quot;checkbox&quot; checked&gt; 默认选中&lt;/label&gt; &lt;label&gt; &lt;input class=&quot;mui-switch mui-switch-anim&quot; type=&quot;checkbox&quot;&gt; 默认未选中，过渡效果，加 mui-switch-anim 类即可 &lt;/label&gt; &lt;label&gt; &lt;input class=&quot;mui-switch mui-switch-anim&quot; type=&quot;checkbox&quot; checked&gt; 默认选中&lt;/label&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/11-Sass入门","date":"2021-08-06T01:17:25.713Z","updated":"2021-07-28T07:34:11.336Z","comments":true,"path":"2021/08/06/大前端/02-CSS/11-Sass入门/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/11-Sass%E5%85%A5%E9%97%A8/","excerpt":"","text":"Sass简介大家都知道，js 中可以自定义发量，css 仅仅是一个标记语言，不是编程语言，因此不可以自定义发量、不可以引用等等。 面对返些问题，我们现在来引入 Sass，简单的说，他是 css 的升级版，可以自定义发量，可以有 if 语句，还可以嵌套等等，很神奇吧！那下面我们就来介绍返个神奇的 Sass。 Sass比Less的功能更强大，也更复杂。 Sass 的定义Sass：英文是 Syntactically Awesome Stylesheets Sass。最早由 Hampton Catlin 开发和设计。 一种帮助你简化 CSS 工作流程的方式，帮助你更容易维护和开发 CSS 内容。 官网是：https://sass-lang.com/ Sass 是这个世界上最成熟、稳定和强大的专业级 CSS 扩展语言。 Sass专注的是怎样创建优雅的样式表，而不是内容。 Sass、Compass与CSS关系： Less/Sass是语法、Compass是框架、CSS是目标。 Sass&amp;Compass的好处： 写出更优秀的CSS。 解决CSS编写过程中的痛点问题，比如精灵图合图、属性的浏览器前缀处理等。 有效组织样式、图片、字体等项目元素。 受众群体： 重构的同学，写很多CSS，不知如何自动化。 希望在项目周期内更好地组织项目内容。 Sass的安装sass引擎是用Ruby语言开发的（但是两者的语法没有关系），因此在安装 Sass 前，需要先安装Ruby（mac下自带Ruby无需再安装Ruby）。 下面来讲一下 Windows 下的安装Sass的步骤。 第一步：安装Ruby（windows环境）下载地址：http://rubyinstaller.org/downloads/ 貌似网络很慢，不一定能下载成功~ 安装时，记得勾选“环境变量”： 安装完ruby之后，在命令行中输入ruby -v，查看ruby的的版本： 关于Mac下的Ruby刚刚说了，Mac下自带Ruby，但是版本肯定很老： 有的时候，我们可能需要使用特定版本的ruby，或者在不同的ruby版本之间进行切换，所以，大家可以尝试安装rvm，它是ruby的版本管理工具。官网是：https://rvm.io 第二步：安装 Sass安装完ruby之后，在开始菜单中，找到刚才我们安装的ruby，打开Start Command Prompt with Ruby。输入gem install sass安装Sass。 PS：Ruby 是使用 gem 来管理它的各种包（比如Sass）。我们安装好ruby之后，gem会自动安装上；类似于，我们安装完node之后，npm也自动安装好了。 但是，由于访问网络受限，我们可以先切换到淘宝的镜像，再安装Sass。步骤如下： （1）移除默认的镜像，添加淘宝的镜像： 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/ //注意：如果你系统不支持https，请将淘宝源更换成：gem sources -a http://gems.ruby-china.org PS：我测试了一下，Win 7 不支持https，Mac支持https。 （2）查看当前使用的是哪个镜像： 1gem sources -l （3）安装sass： 紧接着，输入如下命令安装Sass： 1gem install sass // 如果mac下输入这个命令时没有权限，则需要在前面加上 sudo 系统会自动安装上最新版本的Sass。 查看sass版本的命令为: 1sass -v 升级sass版本的命令为： 1gem update sass 你也可以运行帮助命令行来查看你需要的命令： 1sass -h 参考链接：https://www.w3cplus.com/sassguide/install.html Compass 简介和安装安装完sass之后，我们在main.scss中写一些代码，然后输入如下命令，就可以将scss文件转化为css文件： 1sass main.scss main.css 然而，真正的项目开发中，我们不一定是直接使用 sass 命令，而是使用 Compass。 Compass 简介官网是：http://compass-style.org/。 Compass 是开源的CSS书写框架。 Compass 安装输入如下命令安装 Compass： 1gem isntall compass 输入如下命令查看版本： 1compass -v compass可以直接用来搭建前端项目的样式部分，但并不是常用的方法。 Compass的简单使用通过 Compass 创建工程目录： 123cd workspacecompass create CompassDemo 文件结构如下： /sass ie.scss print.scss screen.scss /stylesheets ie.css print.css screen.css config.rb 为了能够让文件实时编译，我们可以通过 copass watch 监听sass文件的变化： 123cd CompassDemocompass watch 当.scss文件改动时，会自动生成对应的.css文件。 Sass的语法两种后缀名（两种语法）sass 有两种后缀名文件： （1）.sass：对空格敏感。不使用大括号和分号，所以每个属性之间是通过换行来分隔。 比如： 123h1 color: #000 background: #fff 这种语法是类ruby的语法，和CSS的语法相比，相差较大。所以，在3.0版本中就引入了.scss的语法。 （2）.scss：是css语法的超级，可以使用大括号和分号。 比如： 1234h1 &#123; color: #000; background: #fff;&#125; 注意：一个项目中可以混合使用两种语法，但是一个文件中不能同时使用两种语法。 两种格式之间的转换： 我们在工程目录下新建main.scss，输入如下代码： 1234*&#123; margin: 0; padding: 0;&#125; 然后输入如下命令，就可以将上面的main.scss转化为main.sass： 1sass-convert main.scss main.sass 打开生成的main.sass，内容如下： 1234* margin: 0 padding: 0 变量语法Sass 是通过$符号来声明变量。 （1）我们新建一个文件_variables.scss，这个文件专门用来存放变量，然后在其他的文件中引入_variables.scss即可。 因为这个文件只需要存储变量，并不需要它编译出对应的 css 文件，所以我们给文件名的前面加了下划线，意思是声明为局部文件。 我们在这个文件中，声明两个字体变量： 123$font1: Braggadocio, Arial, Verdana, Helvetica, sans-serif;$font2: Arial, Verdana, Helvetica, sans-serif; （2）新建文件main.scss，在里面引入步骤（1）中的变量文件： 123456789@import &quot;variables&quot;; // 引入变量文件.div1&#123; font-family: $font1;&#125;.div2&#123; font-family: $font2;&#125; 基于 Sass 的既定规则： 没有文件后缀名时，Sass 会自动添加 .scss 或者 .sass 的后缀（具体要看已经存在哪个后缀的文件）。 同一目录下，局部文件和非局部文件不能重名。 对应生成的main.css文件如下： main.css 12345678910/* line 9, ../sass/main.scss */.div1 &#123; font-family: Braggadocio, Arial, Verdana, Helvetica, sans-serif;&#125;/* line 13, ../sass/main.scss */.div2 &#123; font-family: Arial, Verdana, Helvetica, sans-serif;&#125; 注释语法单行注释： 1//我是单行注释 块级注释： 12345/* 我是块级注释 哈哈*/ 二者的区别是：单行注释不会出现在自动生成的css文件中。","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/10-CSS的一些小知识","date":"2021-08-06T01:17:25.711Z","updated":"2021-07-28T07:34:11.335Z","comments":true,"path":"2021/08/06/大前端/02-CSS/10-CSS的一些小知识/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/10-CSS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"隐藏盒子的几种方式隐藏盒子，有以下几种方式： （1）方式一： 1overflow：hidden; //隐藏盒子超出的部分 （2）方式二： 1display: none; 隐藏盒子，而且不占位置(用的最多) 比如，点击X，关闭京东首页上方的广告栏。 （3）方式三： 123visibility: hidden; //隐藏盒子，占位置。visibility: visible; //让盒子重新显示 （4）方式四： 1pacity: 0; //设置盒子的透明度（不建议，因为内容也会半透明），占位置 （4）方式五： 1Position/top/left/...-999px //把盒子移得远远的，占位置。 （5）方式六： 1margin-left: 1000px; 设置盒子的半透明方式一：pacity: 0.4。优点是方便。缺点是：里面的内容也会半透明 方式二：css3的技术来解决半透明。如下： background: rgba(0,0,0,0.3); background: rgba(0,0,0,.3); 备注：a指的是alpha透明度。 给标签的形状设置为圆角矩形12border-radius: 50%;border-radius: 10px 0 0 10px; 行高的问题：儿子把父亲撑开比如对于下面这样的标签： 1234&lt;div&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 前置条件：如果我们给父亲div的行高设为31px，然后给儿子a的行高也设置为31 结果：当我们给儿子a设置了字体属性之后，会发现，父亲被撑高为32px了。因为font字体自身会比较大，多撑出了一个像素。 解决办法：行内元素尽量不要设置font属性。对于行内元素而言，如果它和父亲都设置了行高，就不要去给自己设置font属性了。要么就，不要同时设置行高。 背景图不能撑开盒子高和行高都可以城开盒子，但背景图不能撑开盒子。 JS超链接&lt;a&gt;的href跳转一个空白的超链接如下： 1&lt;a href=&quot;&quot;&gt;&lt;/a&gt; 当点击超链接时，由于 href 的属性值的不同，可以产生很多种情况： 12345678href=&quot;&quot; //刷新页面href=&quot;#&quot; //跳转到当前页面的顶部（不会刷新）href=&quot;javascript:void(0)&quot; // 什么都不做href=&quot;javascript:;&quot; // 什么都不做","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/09-CSS案例讲解：博雅互动","date":"2021-08-06T01:17:25.709Z","updated":"2021-07-28T07:34:11.335Z","comments":true,"path":"2021/08/06/大前端/02-CSS/09-CSS案例讲解：博雅互动/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/09-CSS%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3%EF%BC%9A%E5%8D%9A%E9%9B%85%E4%BA%92%E5%8A%A8/","excerpt":"","text":"前言 CSS已经学了一些基础内容了，我们来讲解一个小案例吧。以博雅互动的官网首页举例。 版心首页的版心如下： 这里我们要普及一个概念，叫“版心”。版心是页面中主要内容所在的区域。 比如说，网站左上角的logo，设计图给出的左边距是143像素，此时，我们千万不要以为，logo的左边距真的是143像素。因为设计图只是一个版心；而整个页面是处于浏览器的中间，浏览器的宽度是可以随时调整的。 我们量一下中间四个方形图的width，是1000px，所以，网页版心的宽度是1000px。 网页的结构从结构上来看，网页分为头部（导航栏）、banner区、内容区、底部。 导航栏的制作在此我们只讲基础知识的使用，不涉及浏览器的优化。 class==header这个div是顶部的通栏，我们在里面放一个1000px宽的div，作为通栏的版心，我一般把这个版心称为class=inner_c，c指的是center。 class=inner_c不需要给高，因为它可以被内容撑高。 现在我们需要在class=inner_c里放三个东西：左侧的logo、中间的导航栏、右侧的“加入我们”。 接下来我们开始做右侧的「加入我们」，「加入我们」的背景是带圆角的矩形，这个圆角，实现的方式有两种：要么切图，要么用CSS3实现（IE 7、IE 8不兼容）。我们暂时使用切图来实现。 我们最好把「加入我们」这个超链接&lt;a&gt;放到div里，然后设置div的margin和padding，而不是直接设置&lt;a&gt;的边距。 我们起个名字叫class=jrwm是没有问题的，这在工作当中很常见，如果写成class=join_us反倒很别扭。 暂时我们的做法是： （1）给class=jrwm_box这个div里放一个class=jrwm的div。class=jrwm用来放绿色的背景图片。 （2）在class=jrwm里放一个超链接，并将超链接转为块级元素。 最终，导航栏的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0px; padding: 0px; &#125; body&#123; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;,&quot;SimSun&quot;; height: 8888px; &#125; .header&#123; height: 58px; background-color: #191D3A; &#125; /*版心*/ .inner_c&#123; width: 1000px; margin: 0 auto; /*让导航条、内容区域等部分的版心在父亲里居中*/ &#125; /*导航条的logo*/ .header .logo&#123; float: left; margin-right: 40px; &#125; .header .nav&#123; float: left; &#125; .header .nav ul&#123; list-style: none; /*去掉列表前面的圆点*/ &#125; .header .nav ul li&#123; float: left; width: 100px; line-height: 58px; /*让行高等于这一行的高度，保证里面的文字垂直居中*/ border-left: 1px solid #252947; /*每个li之间有间隔线*/ &#125; .header .nav ul li.last&#123; border-right: 1px solid #252947;/*最后一个li的右边加间隔线*/ &#125; .header .nav ul li a&#123; display: block; /*将超链接转为块儿，可以保证其霸占父亲的整行*/ height: 58px; text-decoration: none; /*去掉超链的下划线*/ color:#818496; text-align: center; /*让这个div内部的文本居中*/ &#125; .header .nav ul li a.current&#123; color:white; background: #252947; &#125; .header .nav ul li a:hover&#123; color: white; background: #252947; &#125; .header .jrwm_box&#123; float: left; height: 58px; width: 100px; padding-left: 48px; padding-top: 12px; &#125; /*放背景图片的div*/ .header .jrwm_box .jrwm&#123; height: 34px; background-image: url(images/jrwm.png); background-repeat: no-repeat; text-align: center; /*让这个div内部的超链接居中*/ &#125; .header .jrwm_box .jrwm a&#123; display: block; /*将超链接转为块儿，可以保证其霸占父亲的整行*/ line-height: 34px; /*让行高为背景图片的高度，可以保证超链接的文字在背景图片里垂直居中*/ text-decoration: none; /*去掉超链的下划线*/ color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;inner_c&quot;&gt; &lt;div class=&quot;logo&quot;&gt; &lt;img src=&quot;images/logo.png &quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;current&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博雅游戏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博雅新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;客服中心&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;&lt;a href=&quot;#&quot;&gt;投资者关系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;jrwm_box&quot;&gt; &lt;div class=&quot;jrwm&quot;&gt; &lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;加入我们&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 导航栏的效果如下： banenr图 因为涉及到 js 的内容，这里先不讲内容区域轮播图的效果。 我们首先在导航条和banner图之间加一道墙，即class=cl，然后采用隔墙法对其设置clear: both;的属性。 然后设置banner的背景图片属性，添加banner图。 内容区域的制作导航栏+banner+内容区域的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0px; padding: 0px; &#125; /*清除浮动的影响*/ .cl&#123; clear: both; &#125; body&#123; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;,&quot;SimSun&quot;; height: 8888px; &#125; .header&#123; height: 58px; background-color: #191D3A; &#125; /*版心*/ .inner_c&#123; width: 1000px; margin: 0 auto; /*让导航条、内容区域等部分的版心在父亲里居中*/ &#125; /*导航条的logo*/ .header .logo&#123; float: left; margin-right: 40px; &#125; .header .nav&#123; float: left; &#125; .header .nav ul&#123; list-style: none; /*去掉列表前面的圆点*/ &#125; .header .nav ul li&#123; float: left; width: 100px; line-height: 58px; /*让行高等于这一行的高度，保证里面的文字垂直居中*/ border-left: 1px solid #252947; /*每个li之间有间隔线*/ &#125; .header .nav ul li.last&#123; border-right: 1px solid #252947;/*最后一个li的右边加间隔线*/ &#125; .header .nav ul li a&#123; display: block; /*将超链接转为块儿，可以保证其霸占父亲的整行*/ height: 58px; text-decoration: none; /*去掉超链的下划线*/ color:#818496; text-align: center; /*让这个div内部的文本居中*/ &#125; .header .nav ul li a.current&#123; color:white; background: #252947; &#125; .header .nav ul li a:hover&#123; color: white; background: #252947; &#125; .header .jrwm_box&#123; float: left; height: 58px; width: 100px; padding-left: 48px; padding-top: 12px; &#125; /*放背景图片的div*/ .header .jrwm_box .jrwm&#123; height: 34px; background-image: url(images/jrwm.png); background-repeat: no-repeat; text-align: center; /*让这个div内部的超链接居中*/ &#125; .header .jrwm_box .jrwm a&#123; display: block; /*将超链接转为块儿，可以保证其霸占父亲的整行*/ line-height: 34px; /*让行高为背景图片的高度，可以保证超链接的文字在背景图片里垂直居中*/ text-decoration: none; /*去掉超链的下划线*/ color: white; &#125; .banner&#123; height: 465px; background: url(images/banner.jpg) no-repeat center top; &#125; .content&#123; padding-top: 50px; &#125; .content .product&#123; height: 229px; border-bottom: 1px solid #DBE1E7; &#125; .content .product ul&#123; list-style: none; &#125; .content .product ul li&#123; float: left; width: 218px; margin-right: 43px; &#125; .content .product ul li.last&#123; margin-right: 0; width: 217px; &#125; .content .product ul li img&#123; width: 218px; height: 130px; &#125; .content .product ul li.last img&#123; width: 217px; &#125; .content .product ul li h3&#123; text-align: center; line-height: 38px; font-size: 14px; font-weight: bold; &#125; .content .product ul li p.djbf&#123; text-align: center; line-height: 16px; &#125; .content .product ul li p.djbf a&#123; font-size: 12px; color:#38B774; text-decoration: none; background:url(images/sanjiaoxing.png) no-repeat right 5px; padding-right: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;inner_c&quot;&gt; &lt;div class=&quot;logo&quot;&gt; &lt;img src=&quot;images/logo.png &quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;current&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博雅游戏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博雅新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;客服中心&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;&lt;a href=&quot;#&quot;&gt;投资者关系&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;jrwm_box&quot;&gt; &lt;div class=&quot;jrwm&quot;&gt; &lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;加入我们&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 在导航条和banner之间隔一堵墙 --&gt; &lt;div class=&quot;cl&quot;&gt;&lt;/div&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;!-- 内容区域 --&gt; &lt;div class=&quot;content inner_c&quot;&gt; &lt;div class=&quot;product&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;img src=&quot;images/pro1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3&gt;BPT宣传片&lt;/h3&gt; &lt;p class=&quot;djbf&quot;&gt; &lt;a href=&quot;#&quot;&gt;点击播放&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;img src=&quot;images/pro2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3&gt;BPT宣传片&lt;/h3&gt; &lt;p class=&quot;djbf&quot;&gt; &lt;a href=&quot;#&quot;&gt;点击播放&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;img src=&quot;images/pro3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3&gt;BPT宣传片&lt;/h3&gt; &lt;p class=&quot;djbf&quot;&gt; &lt;a href=&quot;#&quot;&gt;点击播放&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;li class=&quot;last&quot;&gt; &lt;p&gt;&lt;img src=&quot;images/pro4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3&gt;BPT宣传片&lt;/h3&gt; &lt;p class=&quot;djbf&quot;&gt; &lt;a href=&quot;#&quot;&gt;点击播放&lt;/a&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解释： （1）导航栏，左侧的logo： 错误的写法： 可能会有人直接将img标签作为logo的布局： 123&lt;div class=&quot;logo&quot;&gt; &lt;img src=&quot;images/logo.png &quot; alt=&quot;&quot;&gt;&lt;/div&gt; 然后将img的样式设置为： 1234.header .logo&#123; float: left; margin-right: 40px;&#125; 这样写虽然视觉效果上达到了，但是搜索引擎是搜不到图片的，不利于SEO。 正确的写法： 正确的写法是将超链接作为logo的布局，里面放入文字（文字可以被SEO）： 12345&lt;h1 class=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot;&gt; 博雅互动-世界上最好的游戏公司 &lt;/a&gt;&lt;/h1&gt; 然后将logo设置为背景图： 123456789101112131415.header .logo&#123; float: left; padding-left: 12px; margin-right: 39px; width: 174px; height: 58px;&#125;.header .logo a&#123; display: block; width: 174px; height: 58px; background:url(images/logo.png) no-repeat; text-indent: -999em;&#125; 由于搜索引擎是搜不到图片的，所以一定要把“博雅互动”这几个文字加上去，然后通过text-indent缩进的属性把文字赶走到视线以外的地方。这是做搜索引擎优化的一个重要的技巧。 另外，背景要放在里层的a标签里，不要放在外层的h1标签里。假设背景图放在h1里，那么不管h1的padding有多大，背景图的位置都不会变。 （1）内容区域，“点击播放”右侧的小三角形： 我们在“点击播放”的右侧放了一个三角形。这个很有技巧。 代码截取如下： 1234567.content .product ul li p.djbf a&#123; font-size: 12px; color:#38B774; text-decoration: none; background:url(images/sanjiaoxing.png) no-repeat right center; padding-right: 12px;&#125; 上方代码中，我们在第6行给“点击播放”这个超链接加一个右padding（很关键），然后在第5行把小三角这个背景图放在右padding的位置，就能达到想要的视觉效果。 （2） 导航栏+banner+内容区域的效果如下：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/08-CSS属性：定位属性","date":"2021-08-06T01:17:25.707Z","updated":"2021-07-28T07:34:11.335Z","comments":true,"path":"2021/08/06/大前端/02-CSS/08-CSS属性：定位属性/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/08-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。 123456position: absolute; &lt;!-- 绝对定位 --&gt;position: relative; &lt;!-- 相对定位 --&gt;position: fixed; &lt;!-- 固定定位 --&gt; 下面逐一介绍。 相对定位相对定位：让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。 我们之前学习的背景属性中，是通过如下格式： 1background-position:向右偏移量 向下偏移量; 但这回的定位属性，是通过如下格式： 123position: relative;left: 50px;top: 50px; 相对定位的举例： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; margin: 0px; &#125; .div1&#123; width: 200px; height: 200px; border: 1px solid red; &#125; .div2&#123; position: relative;/*相对定位：相对于自己原来的位置*/ left: 50px;/*横坐标：正值表示向右偏移，负值表示向左偏移*/ top: 50px;/*纵坐标：正值表示向下偏移，负值表示向上偏移*/ width: 200px; height: 200px; border: 1px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt;有生之年&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;狭路相逢&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 相对定位不脱标相对定位：不脱标，老家留坑，别人不会把它的位置挤走。 也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。 相对定位的用途如果想做“压盖”效果（把一个div放到另一个div之上），我们一般不用相对定位来做。相对定位，就两个作用： （1）微调元素 （2）做绝对定位的参考，子绝父相 相对定位的定位值 left：盒子右移 right：盒子左移 top：盒子下移 bottom：盒子上移 PS：负数表示相反的方向。 ↘： 123position: relative;left: 40px;top: 10px; ↙： 123position: relative;right: 100px;top: 100px; ↖： 123position: relative;right: 100px;bottom: 100px; ↗： 1234position: relative;left: 200px;bottom: 200px; 如果要描述上面这张图的方向，我们可以首先可以这样描述： 1234position: relative;left: 200px;top: 100px; 因为left: 200px等价于right: -200px，所以这张图其实有四种写法。 绝对定位绝对定位：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。 格式举例如下： 123position: absolute; /*绝对定位*/left: 10px; /*横坐标*/top/bottom: 20px; /*纵坐标*/ 绝对定位脱标绝对定位的盒子脱离了标准文档流。 所以，所有的标准文档流的性质，绝对定位之后都不遵守了。 绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。 绝对定位的参考点（重要）（1）如果用top描述，那么参考点就是页面的左上角，而不是浏览器的左上角： （2）如果用bottom描述，那么参考点就是浏览器首屏窗口尺寸（好好理解“首屏”二字），对应的页面的左下角： 为了理解“首屏”二字的含义，我们来看一下动态图： 问题： 答案： 用bottom的定位的时候，参考的是浏览器首屏大小对应的页面左下角。 以盒子为参考点一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。 如下：（子绝父相） 以下几点需要注意。 （1） 要听最近的已经定位的祖先元素的，不一定是父亲，可能是爷爷： 123456&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 没有定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box1为参考，因为box2没有定位，box1就是最近的父辈元素 &lt;/div&gt;&lt;/div&gt; 再比如： 12345&lt;div class=&quot;box1&quot;&gt; 相对定位 &lt;div class=&quot;box2&quot;&gt; 相对定位 &lt;p&gt;&lt;/p&gt; 绝对定位，将以box2为参考，因为box2是自己最近的父辈元素 &lt;/div&gt;&lt;/div&gt; （2）不一定是相对定位，任何定位，都可以作为儿子的参考点： 子绝父绝、子绝父相、子绝父固，都是可以给儿子定位的。但是在工程上，如果子绝、父绝，没有一个盒子在标准流里面了，所以页面就不稳固，没有任何实战用途。 工程应用： “子绝父相”有意义：这样可以保证父亲没有脱标，儿子脱标在父亲的范围里面移动。于是，工程上经常这样做： 父亲浮动，设置相对定位（零偏移），然后让儿子绝对定位一定的距离。 （3）绝对定位的儿子，无视参考的那个盒子的padding： 下图中，绿色部分是父亲div的padding，蓝色部分p是div的内容区域。此时，如果div相对定位，p绝对定位，那么，p将无视父亲的padding，在border内侧为参考点，进行定位： 工程应用： 绝对定位非常适合用来做“压盖”效果。我们来举个lagou.com上的例子。 现在有如下两张图片素材： 要求作出如下效果： 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box&#123; margin: 100px; width: 308px; height: 307px; border: 1px solid #FF7E00; position: relative; /*子绝父相*/ &#125; .box .image img&#123; width: 308px; height: 196px; &#125; .box .dtc&#123; display: block; /*转为块级元素，才能设置span的宽高*/ width: 52px; height: 28px; background-image: url(http://img.smyhvae.com/20180116_1115.png); background-position: -108px 0px; /*这里用到了精灵图*/ position: absolute; /*采用绝对定位的方式，将精灵图盖在最上层*/ top: -9px; left: 13px; &#125; .box h4&#123; background-color: black; color: white; width:308px; height: 40px; line-height: 40px; position: absolute; top: 156px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;dtc&quot;&gt;&lt;/span&gt; &lt;div class=&quot;image&quot;&gt; &lt;img src=&quot;http://img.smyhvae.com/20180116_1116.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h4&gt;广东深圳宝安区建安一路海雅缤纷城4楼&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解释如下： 为了显示“多套餐”那个小图，我们需要用到精灵图。 “多套餐”下方黑色背景的文字都是通过“子绝父相”的方式的盖在大海报image的上方的。 代码的效果如下： 让绝对定位中的盒子在父亲里居中我们知道，如果想让一个标准流中的盒子在父亲里居中（水平方向看），可以将其设置margin: 0 auto属性。 可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做： 12345678div &#123; width: 600px; height: 60px; position: absolute; 绝对定位的盒子 left: 50%; 首先，让左边线居中 top: 0; margin-left: -300px; 然后，向左移动宽度（600px）的一半&#125; 如上方代码所示，我们先让这个宽度为600px的盒子，左边线居中，然后向左移动宽度（600px）的一半，就达到效果了。 我们可以总结成一个公式： left:50%; margin-left:负的宽度的一半 固定定位固定定位：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。 备注：IE6不兼容。 用途1：网页右下角的“返回到顶部” 比如我们经常看到的网页右下角显示的“返回到顶部”，就可以固定定位。 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; .backtop&#123; position: fixed; bottom: 100px; right: 30px; width: 60px; height: 60px; background-color: gray; text-align: center; line-height:30px; color:white; text-decoration: none; /*去掉超链接的下划线*/ &#125;&lt;/style&gt; 用途2：顶部导航条 我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。 需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。 顶部导航条的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125;body&#123; /*为什么要写这个？*/ /*不希望我们的页面被nav挡住*/ padding-top: 60px; /*IE6不兼容固定定位，所以这个padding没有什么用，就去掉就行了*/ _padding-top:0; &#125; .nav&#123; position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: #333; z-index: 99999999; &#125; .inner_c&#123; width: 1000px; height: 60px; margin: 0 auto; &#125; .inner_c ul&#123; list-style: none; &#125; .inner_c ul li&#123; float: left; width: 100px; height: 60px; text-align: center; line-height: 60px; &#125; .inner_c ul li a&#123; display: block; width: 100px; height: 60px; color:white; text-decoration: none; &#125; .inner_c ul li a:hover&#123; background-color: gold; &#125; p&#123; font-size: 30px; &#125; .btn&#123; display: block; width: 120px; height: 30px; background-color: orange; position: relative; top: 2px; left: 1px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;inner_c&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页栏目&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5、z-index属性：z-index属性：表示谁压着谁。数值大的压盖住数值小的。 有如下特性： （1）属性值大的位于上层，属性值小的位于下层。 （2）z-index值没有单位，就是一个正整数。默认的z-index值是0。 （3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。 （4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。 （5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。 针对（1）（2）（3）条，举例如下： 这是默认情况下的例子：（div2在上层，div1在下层） 现在加一个z-index属性，要求效果如下： 第五条分析： z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是层级的应用。 层级： （1）必须有定位（除去static） （2）用z-index来控制层级数。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/07-浮动","date":"2021-08-06T01:17:25.704Z","updated":"2021-07-28T07:34:11.334Z","comments":true,"path":"2021/08/06/大前端/02-CSS/07-浮动/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/07-%E6%B5%AE%E5%8A%A8/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新。以下是正文。 文本主要内容 标准文档流 标准文档流的特性 行内元素和块级元素 行内元素和块级元素的相互转换 浮动的性质 浮动的清除 浏览器的兼容性问题 浮动中margin相关 关于margin的IE6兼容问题 标准文档流宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作，是个“流”，必须从上而下，像“织毛衣”。而设计软件，想往哪里画个东西，都能画。 标准文档流的特性（1）空白折叠现象： 无论多少个空格、换行、tab，都会折叠为一个空格。 比如，如果我们想让img标签之间没有空隙，必须紧密连接： 1&lt;img src=&quot;images/0.jpg&quot; /&gt;&lt;img src=&quot;images/1.jpg&quot; /&gt;&lt;img src=&quot;images/2.jpg&quot; /&gt; （2）高矮不齐，底边对齐： 举例如下： （3）自动换行，一行写不满，换行写。 行内元素和块级元素学习的初期，我们就要知道，标准文档流等级森严。标签分为两种等级： 行内元素 块级元素 我们可以举一个例子，看看块级元素和行内元素的区别： 上图中可以看到，h1标签是块级元素，占据了整行，span标签是行内元素，只占据内容这一部分。 现在我们尝试给两个标签设置宽高。效果如下： 上图中，我们尝试给两个标签设置宽高，但发现，宽高属性只对块级元素h1生效。于是我们可以做出如下总结。 行内元素和块级元素的区别：（非常重要） 行内元素： 与其他行内元素并排； 不能设置宽、高。默认的宽度，就是文字的宽度。 块级元素： 霸占一行，不能与其他任何元素并列； 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。 行内元素和块级元素的分类： 在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。 从HTML的角度来讲，标签分为： 文本级标签：p、span、a、b、i、u、em。 容器级标签：div、h系列、li、dt、dd。 PS：为甚么说p是文本级标签呢？因为p里面只能放文字&amp;图片&amp;表单元素，p里面不能放h和ul，p里面也不能放p。 现在，从CSS的角度讲，CSS的分类和上面的很像，就p不一样： 行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级，但是是个块级元素。 块级元素：所有的容器级标签都是块级元素，还有p标签。 我们把上面的分类画一个图，即可一目了然： 行内元素和块级元素的相互转换我们可以通过display属性将块级元素和行内元素进行相互转换。display即“显示模式”。 块级元素可以转换为行内元素：一旦，给一个块级元素（比如div）设置： 1display: inline; 那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说： 此时这个div不能设置宽度、高度； 此时这个div可以和别人并排了。 举例如下： 行内元素转换为块级元素：同样的道理，一旦给一个行内元素（比如span）设置： 1display: block; 那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说： 此时这个span能够设置宽度、高度 此时这个span必须霸占一行了，别人无法和他并排 如果不设置宽度，将撑满父亲 举例如下： 标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：移民！脱离标准流！ css中一共有三种手段，使一个元素脱离标准文档流： （1）浮动 （2）绝对定位 （3）固定定位 这便引出我们今天要讲的内容：浮动。 浮动的性质 浮动是css里面布局用的最多的属性。 现在有两个div，分别设置宽高。我们知道，它们的效果如下： 此时，如果给这两个div增加一个浮动属性，比如float: left;，效果如下： 这就达到了浮动的效果。此时，两个元素并排了，并且两个元素都能够设置宽度、高度了（这在上一段的标准流中，不能实现）。 浮动想学好，一定要知道三个性质。接下来讲一讲。 性质1：浮动的元素脱标脱标即脱离标准流。我们来看几个例子。 证明1： 上图中，在默认情况下，两个div标签是上下进行排列的。现在由于float属性让上图中的第一个&lt;div&gt;标签出现了浮动，于是这个标签在另外一个层面上进行排列。而第二个&lt;div&gt;还在自己的层面上遵从标准流进行排列。 证明2： 上图中，span标签在标准流中，是不能设置宽高的（因为是行内元素）。但是，一旦设置为浮动之后，即使不转成块级元素，也能够设置宽高了。 所以能够证明一件事：一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。所有标签，浮动之后，已经不区分行内、块级了。 性质2：浮动的元素互相贴靠我们来看一个例子就明白了。 我们给三个div均设置了float: left;属性之后，然后设置宽高。当改变浏览器窗口大小时，可以看到div的贴靠效果： 上图显示，3号如果有足够空间，那么就会靠着2号。如果没有足够的空间，那么会靠着1号大哥。如果没有足够的空间靠着1号大哥，3号自己去贴左墙。 不过3号自己去贴墙的时候，注意： 上图显示，3号贴左墙的时候，并不会往1号里面挤。 同样，float还有一个属性值是right，这个和属性值left是对称的。 性质3：浮动的元素有“字围”效果来看一张图就明白了。我们让div浮动，p不浮动。 上图中，我们发现：div挡住了p，但不会挡住p中的文字，形成“字围”效果。 总结：标准流中的文字不会被浮动的盒子遮挡住。（文字就像水一样） 关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。 性质4：收缩收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。 举例如下： 上图中，div本身是块级元素，如果不设置width，它会单独霸占整行；但是，设置div浮动后，它会收缩 浮动的补充（做网站时注意） 上图所示，将para1和para2设置为浮动，它们是div的儿子。此时para1+para2的宽度小于div的宽度。效果如上图所示。可如果设置para1+para2的宽度大于div的宽度，我们会发现，para2掉下来了： 布置一个作业布置一个作业，要求实现下面的效果： 为实现上方效果，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .header&#123; width: 970px; height: 103px; /*居中。这个语句的意思是：居中：*/ margin: 0 auto; &#125; .header .logo&#123; float: left; width: 277px; height: 103px; background-color: red; &#125; .header .language&#123; float: right; width: 137px; height: 49px; background-color: green; margin-bottom: 8px; &#125; .header .nav&#123; float: right; width: 679px; height: 46px; background-color: green; &#125; .content&#123; width: 970px; height: 435px; /*居中，这个语句今天没讲，你照抄，就是居中：*/ margin: 0 auto; margin-top: 10px; &#125; .content .banner&#123; float: left; width: 310px; height: 435px; background-color: gold; margin-right: 10px; &#125; .content .rightPart&#123; float: left; width: 650px; height: 435px; &#125; .content .rightPart .main&#123; width: 650px; height: 400px; margin-bottom: 10px; &#125; .content .rightPart .links&#123; width: 650px; height: 25px; background-color: blue; &#125; .content .rightPart .main .news&#123; float: left; width: 450px; height: 400px; &#125; .content .rightPart .main .hotpic&#123; float: left; width: 190px; height: 400px; background-color: purple; margin-left: 10px; &#125; .content .rightPart .main .news .news1&#123; width: 450px; height: 240px; background-color: skyblue; margin-bottom: 10px; &#125; .content .rightPart .main .news .news2&#123; width: 450px; height: 110px; background-color: skyblue; margin-bottom: 10px; &#125; .content .rightPart .main .news .news3&#123; width: 450px; height: 30px; background-color: skyblue; &#125; .footer&#123; width: 970px; height: 35px; background-color: pink; /*没学，就是居中：*/ margin: 0 auto; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部 --&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;logo&quot;&gt;logo&lt;/div&gt; &lt;div class=&quot;language&quot;&gt;语言选择&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;导航条&lt;/div&gt; &lt;/div&gt; &lt;!-- 主要内容 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;banner&quot;&gt;大广告&lt;/div&gt; &lt;div class=&quot;rightPart&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;news&quot;&gt; &lt;div class=&quot;news1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;news2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;news3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hotpic&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;links&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其实，这个页面的布局是下面这个网站： 浮动的清除 这里所说的清除浮动，指的是清除浮动与浮动之间的影响。 前言通过上面这个例子，我们发现，此例中的网页就是通过浮动实现并排的。 比如说一个网页有header、content、footer这三部分。就拿content部分来举例，如果设置content的儿子为浮动，但是，这个儿子又是一个全新的标准流，于是儿子的儿子仍然在标准流里。 从学习浮动的第一天起，我们就要明白，浮动有开始，就要有清除。我们先来做个实验。 下面这个例子，有两个块级元素div，div没有任何属性，每个div里有li，效果如下： 上面这个例子很简单。可如果我们给里面的&lt;li&gt;标签加浮动。效果却成了下面这个样子： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; &#125; li&#123; float: left; width: 100px; height: 20px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;ul&gt; &lt;li&gt;生命壹号1&lt;/li&gt; &lt;li&gt;生命壹号2&lt;/li&gt; &lt;li&gt;生命壹号3&lt;/li&gt; &lt;li&gt;生命壹号4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;ul&gt; &lt;li&gt;许嵩1&lt;/li&gt; &lt;li&gt;许嵩2&lt;/li&gt; &lt;li&gt;许嵩3&lt;/li&gt; &lt;li&gt;许嵩4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 上图中，我们发现：第二组中的第1个li，去贴靠第一组中的最后一个li了（我们本以为这些li会分成两排）。 这便引出我们要讲的：清除浮动的第一种方式。那该怎么解决呢？ 方法1：给浮动元素的祖先元素加高度造成前言中这个现象的根本原因是：li的父亲div没有设置高度，导致这两个div的高度均为0px（我们可以通过网页的审查元素进行查看）。div的高度为零，导致不能给自己浮动的孩子，撑起一个容器。 撑不起一个容器，导致自己的孩子没办法在自己的内部进行正确的浮动。 好，现在就算给这个div设置高度，可如果div自己的高度小于孩子的高度，也会出现不正常的现象： 给div设置一个正确的合适的高度（至少保证高度大于儿子的高度），就可以看到正确的现象： 总结： 如果一个元素要浮动，那么它的祖先元素一定要有高度。 有高度的盒子，才能关住浮动。（记住这句过来人的经验之语） 只要浮动在一个有高度的盒子中，那么这个浮动就不会影响后面的浮动元素。所以就是清除浮动带来的影响了。 方法2：clear:both;网页制作中，高度height其实很少出现。为什么？因为能被内容撑高！也就是说，刚刚我们讲解的方法1，工作中用得很少。 那么，能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？ 这个时候，我们可以使用clear:both;这个属性。如下： 1clear:both; clear就是清除，both指的是左浮动、右浮动都要清除。clear:both的意思就是：不允许左侧和右侧有浮动对象。 这种方法有一个非常大的、致命的问题，它所在的标签，margin属性失效了。读者可以试试看。 margin失效的本质原因是：上图中的box1和box2，高度为零。 方法3：隔墙法上面这个例子中，为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置clear: both;属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果（曲线救国）。这便是隔墙法。 我们看看例子效果就知道了： 上图这个例子就是隔墙法。 内墙法： 近些年，有演化出了“内墙法”： 上面这个图非常重要，当作内墙法的公式，先记下来。 为了讲内墙法，我们先记住一句重要的话：一个父亲是不能被浮动的儿子撑出高度的。举例如下： （1）我们在一个div里放一个有宽高的p，效果如下：（很简单） （2）可如果在此基础之上，给p设置浮动，却发现父亲div没有高度了： （3）此时，我么可以在div的里面放一个div（作为内墙），就可以让父亲div恢复高度： 于是，我们采用内墙法解决前言中的问题： 与外墙法相比，内墙法的优势（本质区别）在于：内墙法可以给它所在的家撑出宽度（让box1有高）。即：box1的高度可以自适应内容。 而外墙法，虽然一道墙可以把两个div隔开，但是这两个div没有高，也就是说，无法wrap_content。 清除浮动方法4：overflow:hidden;我们可以使用如下属性： 1overflow:hidden; overflow即“溢出”， hidden即“隐藏”。这个属性的意思是“溢出隐藏”。顾名思义：所有溢出边框的内容，都要隐藏掉。如下： 上图显示，overflow:hidden;的本意是清除溢出到盒子外面的文字。但是，前端开发工程师发现了，它能做偏方。如下： 一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上overflow:hidden; 那么，父亲就能被儿子撑出高了。这是一个偏方。 举个例子： 那么对于前言中的例子，我们同样可以使用这一属性： 浮动清除的总结 我们在上一段讲了四种清除浮动的方法，本段来进行一个总结。 浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。 1、加高法工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。 1234567891011&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //设置height &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 2、clear:both;法最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。 1234567891011&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt; //clear:both; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。 3、隔墙法在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。墙用自己的身体当做了间隙。 12345678910111213&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动根据自己的儿子撑出高度，我们就要想一些“小伎俩”。 内墙法： 123456789101112&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;cl h10&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。 4、overflow:hidden;这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的偏方。并且,overflow:hidden;能够让margin生效。 清除浮动的例子： 我们现在举个例子，要求实现下图中无序列表部分的效果： 对比一下我们讲的四种清除浮动的方法。如果用外墙法，ul中不能插入div标签，因为ul中只能插入li，如果插入li的墙，会浪费语义。如果用内墙法，不美观。综合对比，还是用第四种方法来实现吧，这会让标签显得极其干净整洁： 上方代码中，如果没有加overflow:hidden;，那么第二行的li会紧跟着第一行li的后面。 浏览器的兼容性问题 讲一下上述知识点涉及到的浏览器兼容问题。 兼容性1（微型盒子）兼容性的第一条：IE6不支持小于12px的盒子，任何小于12px的盒子，在IE6中看都大。即：IE 6不支持微型盒子。 举个例子。我们设置一个height为 5px 、宽度为 200px的盒子，看下在IE 8和 IE 6中的显示效果： 解决办法很简单，就是将盒子的字号大小，设置为小于盒子的高，比如，如果盒子的高为5px，那就把font-size设置为0px(0px &lt; 5px)。如下： 12height: 5px;_font-size: 0px; 我们现在介绍一下浏览器hack。hack就是“黑客”，就是使用浏览器提供的后门，针对某一种浏览器做兼容。 IE6留了一个后门：只要给css属性之前，加上下划线，这个属性就是IE6的专有属性。 比如说，我们给背景颜色这个属性加上下划线，就变成了_background-color: green;。效果如下： 于是乎，为了解决微型盒子（即height小于12px）的问题，正确写法：（注意不要忘记下划线） 12height: 10px;_font-size:0; 兼容性2兼容性的第二条：IE6不支持用overflow:hidden;来清除浮动。 解决办法，以毒攻毒。追加一条： 1_zoom:1; 完整写法： 12overflow: hidden;_zoom:1; 实际上，_zoom:1;能够触发浏览器hasLayout机制。这个机制，不要深究了，因为只有IE6有。我们只需要让IE6好用，具体的实现机制，可以自行查阅。 需要强调的是，overflow:hidden;的本意，就是让溢出盒子的border的内容隐藏，这个功能是IE6兼容的。不兼容的是overflow:hidden;清除浮动的时候。 总结： 我们刚才学习的两个IE6的兼容问题，都是通过多写一条hack来解决的，这个我们称为伴生属性，即两个属性，要写一起写。 属性1： 12height:6px;_font-size:0; 属性2： 12overflow:hidden;_zoom:1; margin相关 我们来讲一下浮动中和margin相关的知识。 margin塌陷/margin重叠标准文档流中，竖直方向的margin不叠加，取较大的值**作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。如下图所示： 如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的。 盒子居中margin:0 auto;margin的值可以为auto，表示自动。当left、right两个方向都是auto的时候，盒子居中了： 12margin-left: auto;margin-right: auto; 盒子居中的简写为： 1margin:0 auto; 对上方代码的理解：上下的margin为0，左右的margin都尽可能的大，于是就居中了。 注意： （1）只有标准流的盒子，才能使用margin:0 auto;居中。也就是说，当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto; （2）使用margin:0 auto;的盒子，必须有width，有明确的width。（可以这样理解，如果没有明确的witdh，那么它的witdh就是霸占整行，没有意义） （3）margin:0 auto;是让盒子居中，不是让盒子里的文本居中。文本的居中，要使用text-align:center; 对上面的第三条总结一下：（非常重要） 12margin:0 auto; //让这个div自己在大容器中的水平方向上居中。text-align: center; //让这个div内部的文本居中。 顺便普及一下知识，text-align还有： 12text-align:left; //没啥用，因为默认居左text-align:right; //文本居右 善于使用父亲的padding，而不是儿子的margin我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p） 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象： 此时我们给父亲div加一个border属性，就正常了： 如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。 margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。 所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。 关于margin的IE6兼容问题IE6的双倍margin的bug：当出现连续浮动的元素，携带与浮动方向相同的margin时，队首的元素，会双倍marign。 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 解决方案： （1）使浮动的方向和margin的方向，相反。 所以，你就会发现，我们特别喜欢，浮动的方向和margin的方向相反。并且，前端开发工程师，把这个当做习惯了。 12float: left;margin-right: 40px; （2）使用hack：（没必要，别惯着这个IE6） 单独给队首的元素，写一个一半的margin： 1&lt;li class=&quot;no1&quot;&gt;&lt;/li&gt; 123ul li.no1&#123; _margin-left:20px;&#125; PS：双倍margin的问题，面试经常问哦。 IE6的3px bug 解决办法：不用管，因为根本就不允许用儿子踹父亲（即描述父子之间的距离，请用padding，而不是margin）。所以，如果你出现了3px bug，说明你的代码不标准。 IE6，千万不要跟他死坑、较劲，它不配。 格调要高，我们讲IE6的兼容性问题，就是为了增加面试的成功率，不是为了成为IE6的专家。 Fireworks和othersFireworksfireworks是Adobe公司的一个设计软件。功能非常多，我们以后用啥讲啥。Fireworks的默认文件格式是png。 标尺的快捷键：Ctrl + Alt+ R others首行缩进两个汉字： 1text-indent: 2em; 上方属性中，单位比较奇怪，叫做em，em就是汉字的一个宽度。indent的意思是缩进。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/06-CSS盒模型详解","date":"2021-08-06T01:17:25.701Z","updated":"2021-07-28T07:34:11.334Z","comments":true,"path":"2021/08/06/大前端/02-CSS/06-CSS盒模型详解/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/06-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新。以下是正文。 盒子模型前言盒子模型，英文即box model。无论是div、span、还是a都是盒子。 但是，图片、表单元素一律看作是文本，它们并不是盒子。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。 盒子中的区域一个盒子中主要的属性就5个：width、height、padding、border、margin。如下： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 盒子模型的示意图： 代码演示： 上面这个盒子，width:200px; height:200px; 但是真实占有的宽高是302*302。 这是因为还要加上padding、border。 注意：宽度和真实占有宽度，不是一个概念！来看下面这例子。 标准盒模型和IE盒模型 我们目前所学习的知识中，以标准盒子模型为准。 标准盒子模型： IE盒子模型： 上图显示： 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式： width和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别： 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。 &lt;body&gt;标签也有margin&lt;body&gt;标签有必要强调一下。很多人以为&lt;body&gt;标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是&lt;document&gt;，即浏览器。而&lt;body&gt;是&lt;document&gt;的儿子。浏览器给&lt;body&gt;默认的margin大小是8个像素，此时&lt;body&gt;占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。 123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; padding: 20px; margin: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;有生之年&lt;/div&gt; &lt;div&gt;狭路相逢&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码中，我们对div标签设置了边距等信息。打开google浏览器，按住F12，显示效果如下： 认识width、height一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。 比如说，丈量稿纸，前端开发工程师只会丈量内容宽度： 下面这两个盒子，真实占有宽高，都是302*302： 盒子1： 123456.box1&#123; width: 100px; height: 100px; padding: 100px; border: 1px solid red;&#125; 盒子2： 123456.box2&#123; width: 250px; height: 250px; padding: 25px; border: 1px solid red;&#125; 真实占有宽度 = 左border + 左padding + width + 右padding + 右border 上面这两个盒子的盒模型图如下： 如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。 认识paddingpadding区域也有颜色padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充所有border以内的区域。 效果如下： padding有四个方向padding是4个方向的，所以我们能够分别描述4个方向的padding。 方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。 小属性的写法： 1234padding-top: 30px;padding-right: 20px;padding-bottom: 40px;padding-left: 100px; 综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的） 1padding:30px 20px 40px 100px; 如果写了四个值，则顺序为：上、右、下、左。 如果只写了三个值，则顺序为：上、右、下。??和右一样。 如果只写了两个值，比如说： 1padding: 30px 40px; 则顺序等价于：30px 40px 30px 40px; 要懂得，用小属性层叠大属性。比如： 12padding: 20px;padding-left: 30px; 上面的padding对应盒子模型为： 下面的写法： 12padding-left: 30px;padding: 20px; 第一行的小属性无效，因为被第二行的大属性层叠掉了。 下面的题，会做了，说明你明白了。 一些题目题目1：说出下面盒子真实占有宽高，并画出盒模型图。 1234567div&#123; width: 200px; height: 200px; padding: 10px 20px 30px; padding-right: 40px; border: 1px solid #000;&#125; 答案： 题目2：说出下面盒子真实占有宽高，并画出盒模型图。 123456789div&#123; width: 200px; height: 200px; padding-left: 10px; padding-right: 20px; padding:40px 50px 60px; padding-bottom: 30px; border: 1px solid #000;&#125; 答案： padding-left:10px； 和padding-right:20px; 没用，因为后面的padding大属性，层叠掉了他们。 盒子模型如下： 题目3：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。 答案： 1234width:123px;height:123px;padding:20px 40px;border:1px solid red; 题目4：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。 答案： 123456width:123px;height:123px;padding:20px;padding-right:40px;border:1px solid red; 一些元素，默认带有padding一些元素，默认带有padding，比如ul标签。如下： 上图显示，不加任何样式的ul，也是有40px的padding-left。 所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。 可以使用*进行清除： 1234*&#123; margin: 0; padding: 0;&#125; 但是，*的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）： 1234body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123; margin:0; padding:0;&#125; 认识borderborder就是边框。边框有三个要素：像素（粗细）、线型、颜色。 颜色如果不写，默认是黑色。另外两个属性不写，要命了，显示不出来边框。 border-styleborder的所有的线型如下：（我们可以通过查看CSS参考手册得到） 比如border:10px ridge red;这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已） 如果公司里面的设计师是处女座的，追求极高的页面还原度，那么不能使用css来制作边框。就要用到图片，就要切图了。 所以，比较稳定的border-style就几个：solid、dashed、dotted。 border拆分border是一个大综合属性。比如说： 1border:1px solid red; 就是把4个边框，都设置为1px宽度、线型实线、red颜色。 PS：小技巧：在sublime text中，为了快速输入border:1px solid red;这个属性，可以直接输入bd，然后选第二个后回车。 border属性是能够被拆开的，有两大种拆开的方式： （1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的） （2）按方向拆开：border-top、border-right、border-bottom、border-left。 现在我们明白了：一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下： 123border-width:10px 20px;border-style:solid dashed dotted;border-color:red green blue yellow; 效果如下： （1）按三要素拆： 123border-width:10px; //边框宽度border-style:solid; //线型border-color:red; //颜色。 等价于： 1border:10px solid red; (2)按方向来拆： 1234border-top:10px solid red;border-right:10px solid red;border-bottom:10px solid red;border-left:10px solid red; 等价于： 1border:10px solid red; （3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12) 123456789101112border-top-width:10px;border-top-style:solid;border-top-color:red;border-right-width:10px;border-right-style:solid;border-right-color:red;border-bottom-width:10px;border-bottom-style:solid;border-bottom-color:red;border-left-width:10px;border-left-style:solid;border-left-color:red; 等价于： 12border:10px solid red; 工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下： 为了实现上方效果，写法如下： 12border:10px solid red;border-right-color:blue; 为了实现上方效果，写法如下： 12border:10px solid red;border-style:solid dashed; border可以没有： 1border:none; 可以某一条边没有： 1border-left: none; 也可以调整左边边框的宽度为0： 1border-left-width: 0; 举例：利用border属性画一个三角形（小技巧）步骤如下： （1）当我们设置盒子的width和height为0时，此时效果如下： （2）然后将border的底部取消： （3）最后设置border的左边和右边为白色： 这样，一个三角形就画好了。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/05-CSS样式表的继承性和层叠性","date":"2021-08-06T01:17:25.699Z","updated":"2021-07-28T07:34:11.333Z","comments":true,"path":"2021/08/06/大前端/02-CSS/05-CSS样式表的继承性和层叠性/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/05-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7/","excerpt":"","text":"本文最初于2017-07-29发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 本文重点 CSS的继承性 CSS的层叠性 计算权重 权重问题大总结 CSS样式表的冲突的总结 权重问题深入 同一个标签，携带了多个类名 !important标记 CSS的继承性我们来看下面这样的代码，来引入继承性： 上方代码中，我们给div标签增加红色属性，却发现，div里的每一个子标签&lt;p&gt;也增加了红色属性。于是我们得到这样的结论： 有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。 继承性是从自己开始，直到最小的元素。 但是呢，如果再给上方的代码加一条属性： 上图中，我们给div加了一个border，但是发现只有div具备了border属性，而p标签却没有border属性。于是我们可以得出结论： 关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。 关于盒子、定位、布局的属性，都不能继承。 以后当我们谈到css有哪些特性的时候，我们要首先想到继承性。而且，要知道哪些属性具有继承性、哪些属性没有继承性。 CSS的层叠性很多公司如果要笔试，那么一定会考层叠性。 层叠性：计算权重层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！ CSS像艺术家一样优雅，像工程师一样严谨。 我们来看一个例子，就知道什么叫层叠性了。 上图中，三种选择器同时给P标签增加颜色的属性，但是，文字最终显示的是蓝色，这个时候，就出现了层叠性的情况。 当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重： id的数量，类的数量，标签的数量 因为对于相同方式的样式表，其选择器排序的优先级为：ID选择器 &gt; 类选择器 &gt; 标签选择器 针对上面这句话，我们接下来举一些复杂一点的例子。 层叠性举例举例1：计算权重 如上图所示，统计各个选择器的数量，优先级高的胜出。文字的颜色为红色。 PS：不进位，实际上能进位（奇淫知识点：255个标签，等于1个类名）但是没有实战意义！ 举例2：权重相同时 上图可以看到，第一个样式和第二个样式的权重相同。但第二个样式的书写顺序靠后，因此以第二个样式为准（就近原则）。 举例3：具有实战性的例子 现在我要让一个列表实现上面的这种样式：第一个li为红色，剩下的li全部为蓝色。 如果写成下面这种代码是无法实现的： 无法实现的原因很简单，计算一下三个选择器的权重就清楚了，显然第二个样式被第一个样式表覆盖了。 正确的做法是：（非常重要） 上图中，第二个样式比第一个样式的权重要大。因此在实战中可以实现这种效果：所有人当中，让某一个人为红，让其他所有人为蓝。 这种方式好用是好用，但用好很难。 就拿上方代码来举例，为了达到这种效果，即为了防止权重不够，比较稳妥的做法是：把第二个样式表照着第一个样式表来写，在此基础上，给第二个样式表再加一个权重。 上面这个例子很具有实战性。 举例4：继承性造成的影响这里需要声明一点： 如果不能直接选中某个元素，通过继承性影响的话，那么权重是0。 为了验证上面这句话，我们来看看下面这样的例子： 另外：如果大家的权重相同，那么就采用就近原则：谁描述的近，听谁的。举例如下：(box3 描述得最近，所以采用 box3 的属性) 上方代码的文字版如下： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;meta /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box1 &#123; color: red; &#125; #box2 &#123; color: green; &#125; #box3 &#123; color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt; &lt;div id=&quot;box2&quot;&gt; &lt;div id=&quot;box3&quot;&gt;&lt;p&gt;猜猜我是什么颜色&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 层叠性：权重计算的问题大总结（非常重要）层叠性。层叠性是一种能力，就是处理冲突的能力。当不同选择器，对一个标签的同一个样式，有不同的值，听谁的？这就是冲突。css有着严格的处理冲突的机制。 通过列举上面几个例子，我们对权重问题做一个总结。 上面这个图非常重要，我们针对这个图做一个文字描述： 选择上了，数权重，(id的数量，类的数量，标签的数量)。如果权重一样，谁写在后面听谁的。 没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。 CSS样式表的冲突的总结 1、对于相同的选择器（比如同样都是类选择器），其样式表排序：行级样式 &gt; 内嵌样式表 &gt; 外部样式表（就近原则） 2、对于相同类型的样式表（比如同样都是内部样式表），其选择器排序：ID选择器 &gt; 类选择器 &gt; 标签选择器 3、外部样式表的ID选择器 &gt; 内嵌样式表的标签选择器 总结：就近原则。ID选择器优先级最大。 举例：如果都是内嵌样式表，优先级的顺序如下：（ID 选择器 &gt; 类选择器 &gt; 标签选择器） 另外还有两个冲突的情况： 1、对同一个标签，如果用到的都是内嵌样式表，且权重一致，那它的优先级：定义的CSS样式表中，谁最近，就用谁。 2、对于同一个标签，如果用到的都是外部样式表，且权重一致，那它的优先级：html文件中，引用样式表的位置越近，就用谁。 例如： 题目演示CSS的层叠性讲完了，我们来做几个题目吧。 题目1 题目2 题目3 题目4 权重问题深入同一个标签，携带了多个类名，有冲突：这里需要补充两种冲突的情况： 1、对同一个标签，如果用到了了多个相同的内嵌样式表，它的优先级： 定义的样式表中，谁最近，就用谁。 2、对于同一个标签，如果引用了多个相同的外部样式表，它的优先级：html文件中，引用样式表的位置越近，就用谁。 例如：（就近原则） 上图中，文字显示的颜色均为红色。因为这和在标签中的挂类名的书序无关，只和css的顺序有关。 !important标记来看个很简单的例子： 上图中，显然id选择器的权重最大，所以文字的颜色是红色。 如果我们想让文字的颜色显示为绿色，只需要给标签选择器的加一个!important标记，此时其权重为无穷大。如下： important是英语里面的“重要的”的意思。我们可以通过如下语法： 1k:v !important; 来给一个属性提高权重。这个属性的权重就是无穷大。 注意，一定要注意语法的正确性。 正确的语法： 1font-size:60px !important; 错误的语法： 12font-size:60px; !important; 不能把!important写在外面font-size:60px important; 不能忘记感叹号 !important标记需要强调如下3点： （1）!important提升的是一个属性，而不是一个选择器 123456789101112p&#123; color:red !important; 只写了这一个!important，所以只有字体颜色属性提升了权重 font-size: 100px ; 这条属性没有写!important，所以没有提升权重&#125;#para1&#123; color:blue; font-size: 50px;&#125;.spec&#123; color:green; font-size: 20px;&#125; 所以，综合来看，字体颜色是red（听important的）；字号是50px（听id的）。 （2）!important无法提升继承的权重，该是0还是0 比如HTML结构： 123&lt;div&gt; &lt;p&gt;哈哈哈哈哈哈哈哈&lt;/p&gt;&lt;/div&gt; 有CSS样式： 123456div&#123; color:red !important;&#125;p&#123; color:blue;&#125; 由于div是通过继承性来影响文字颜色的，所以!important无法提升它的权重，权重依然是0。 干不过p标签，因为p标签是实实在在选中了，所以字是蓝色的（以p为准）。 (3)!important不影响就近原则 如果大家都是继承来的，按理说应该按照“就近原则”，那么important能否影响就近原则呢？答案是：不影响。远的，永远是远的。不能给远的写一个important，干掉近的。 为了验证这个问题，我们可以搞两层具有继承性的标签，然后给外层标签加一个!important，最终看看就近原则有没有被打破。举例如下： PS：! important做站的时候，不允许使用。因为会让css写的很乱。现在，我们知道层叠性能比较很多东西：选择器的写法权重，谁离的近，谁写在下面。 知识回顾 我们把以上内容和上一篇文章做一个简单的知识回顾。 CSS属性 css属性，面试的时候会有笔试，笔试没有智能感应的。 加粗，倾斜，下划线： 123font-weight:bold;font-style:italic;text-decoration:underline; 背景颜色、前景色： 12background-color:red;color:red; class和id的区别class用于css的，id用于js的。 1）class页面上可以重复。id页面上唯一，不能重复。2）一个标签可以有多个class，用空格隔开。但是id只能有id。 各种选择器(浏览器兼容性)IE6层面兼容的选择器： 标签选择器、id选择器、类选择器、后代、交集选择器、并集选择器、通配符。如下： 1234567p#box.specdiv pdiv.specdiv,p* IE7能够兼容的：儿子选择器、下一个兄弟选择器。如下： 12div&gt;ph3+p IE8能够兼容的： 12ul li:first-childul li:last-child css两个性质 继承性：好的事儿。继承从上到下，哪些能？哪些不能？ 层叠性：冲突，多个选择器描述了同一个属性，听谁的？ 再看几个题目： 权重问题大总结，最后有个例子，比较难，暂时略掉。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/04-CSS选择器：伪类","date":"2021-08-06T01:17:25.698Z","updated":"2021-07-28T07:34:11.332Z","comments":true,"path":"2021/08/06/大前端/02-CSS/04-CSS选择器：伪类/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/04-CSS%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9A%E4%BC%AA%E7%B1%BB/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 伪类（伪类选择器）伪类：同一个标签，根据其不同的种状态，有不同的样式。这就叫做“伪类”。伪类用冒号来表示。 比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。 静态伪类和动态伪类伪类选择器分为两种。 （1）静态伪类：只能用于超链接的样式。如下： :link 超链接点击之前 :visited 链接被访问过之后 PS：以上两种样式，只能用于超链接。 （2）动态伪类：针对所有标签都适用的样式。如下： :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点） PS：以上三种样式，只能用于超链接。 超链接a标签超链接的四种状态a标签有4种伪类（即对应四种状态），要求背诵。如下： :link “链接”：超链接点击之前 :visited “访问过的”：链接被访问过之后 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 对应的代码如下：（不带注释） 123456789101112a:link&#123; color:red;&#125;a:visited&#123; color:orange;&#125;a:hover&#123; color:green;&#125;a:active&#123; color:black;&#125; 对应的代码如下：（带注释） 12345678910111213141516 /*让超链接点击之前是红色*/a:link&#123; color:red;&#125;/*让超链接点击之后是绿色*/a:visited&#123; color:orange;&#125;/*鼠标悬停，放到标签上的时候*/a:hover&#123; color:green;&#125;/*鼠标点击链接，但是不松手的时候*/a:active&#123; color:black; 记住，在css中，这四种状态必须按照固定的顺序写： a:link 、a:visited 、a:hover 、a:active 如果不按照顺序，那么将失效。“爱恨准则”：love hate。必须先爱，后恨。 看一下这四种状态的动图效果： 超链接的美化问：既然a&#123;&#125;定义了超链的属性，和a:link&#123;&#125;定义了超链点击之前的属性，那这两个有啥区别呢？ 答： a&#123;&#125;和a:link&#123;&#125;的区别： a&#123;&#125;定义的样式针对所有的超链接(包括锚点) a:link&#123;&#125;定义的样式针对所有写了href属性的超链接(不包括锚点) 超链接a标签在使用的时候，比较难。因为不仅仅要控制a这个盒子，也要控制它的伪类。 我们一定要将a标签写在前面，将:link、:visited、:hover、:active这些伪类写在后面。 举个例子。如果效果： 为了实现上面这个效果，完整版代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .nav&#123; width: 960px; height: 50px; border: 1px solid red; margin: 100px auto; &#125; .nav ul&#123; /*去掉小圆点*/ list-style: none; &#125; .nav ul li&#123; float: left; width: 120px; height: 50px; /*让内容水平居中*/ text-align: center; /*让行高等于nav的高度，就可以保证内容垂直居中*/ line-height: 50px; &#125; .nav ul li a&#123; display: block; width: 120px; height: 50px; &#125; /*两个伪类的属性，可以用逗号隔开*/ .nav ul li a:link , .nav ul li a:visited&#123; text-decoration: none; background-color: purple; color:white; &#125; .nav ul li a:hover&#123; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站栏目&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们发现，当我们在定义a:link和 a:visited这两个伪类的时候，如果它们的属性相同，我们其实可以写在一起，用逗号隔开就好，摘抄如下： 1234567891011121314.nav ul li a&#123; display: block; width: 120px; height: 50px;&#125;/*两个伪类的属性，可以用逗号隔开*/.nav ul li a:link , .nav ul li a:visited&#123; text-decoration: none; background-color: purple; color:white;&#125;.nav ul li a:hover&#123; background-color: orange;&#125; 如上方代码所示，最标准的写法，就是把link、visited、hover这三个伪类都要写。但是前端开发工程师在大量的实践中，发现不写link、visited也挺兼容。写法是： a:link、a:visited都是可以省略的，简写在a标签里面。也就是说，a标签涵盖了link、visited的状态（前提是都具有了相同的属性）。写法如下： 123456789101112.nav ul li a&#123; display: block; width: 120px; height: 50px; text-decoration: none; background-color: purple; color:white;&#125;.nav ul li a:hover&#123; background-color: orange;&#125; 当然了，在写a:link、a:visited这两个伪类的时候，要么同时写，要么同时不写。如果只写a属性和a:link属性，不规范。 动态伪类举例我们在第一段中描述过，下面这三种动态伪类，针对所有标签都适用。 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 :focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点） 我们不妨来举下例子。 举例1： 1234567891011121314151617181920212223242526272829303132 &lt;style type=&quot;text/css&quot;&gt; /*伪类选择器：动态伪类 */ /*让文本框获取焦点时：边框：#FF6F3D这种橙色文字：绿色背景色：#6a6a6a这种灰色 */input:focus&#123; border:3px solid #FF6F3D; color:white; background-color:#6a6a6a;&#125;/*鼠标放在标签上时显示蓝色 */label:hover&#123; color:blue;&#125;/*点击标签鼠标没有松开时显示红色 */label:active&#123; color:red;&#125; &lt;/style&gt; 效果： 利用这个hover属性，我们同样对表格做一个样式的设置：表格举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*整个表格的样式*/ table&#123; width: 300px; height: 200px; border: 1px solid blue; /*border-collapse属性：对表格的线进行折叠*/ border-collapse: collapse; &#125; /*鼠标悬停时，让当前行显示#868686这种灰色*/ table tr:hover&#123; background: #868686; &#125; /*每个单元格的样式*/ table td&#123; border:1px solid red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果： ##我的公众号 想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/03-CSS样式表和选择器","date":"2021-08-06T01:17:25.695Z","updated":"2021-07-28T07:34:11.332Z","comments":true,"path":"2021/08/06/大前端/02-CSS/03-CSS样式表和选择器/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/03-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"本文最初于2015-10-03发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 本文主要内容 CSS概述 CSS和HTML结合的三种方式：行内样式表、内嵌样式表、外部样式表 CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器 CSS几种扩展选择器：后代选择器、交集选择器、并集选择器 CSS样式优先级 前言现在的互联网前端分三层： HTML：超文本标记语言。从语义的角度描述页面结构。 CSS：层叠样式表。从审美的角度负责页面样式。 JS：JavaScript 。从交互的角度描述页面行为。 CSS 概述CSS：Cascading Style Sheet，层叠样式表。CSS的作用就是给HTML页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS将网页内容和显示样式进行分离，提高了显示功能。 css的最新版本是css3，我们目前学习的是css2.1。 因为css3和css2.1不矛盾，必须先学2.1然后学3。 接下来我们要讲一下为什么要使用CSS。 HTML的缺陷： 不能够适应多种设备 要求浏览器必须智能化足够庞大 数据和显示没有分开 功能不够强大 CSS 优点： 使数据和显示分开 降低网络流量 使整个网站视觉效果一致 使开发效率提高了（耦合性降低，一个人负责写html，一个人负责写css） 比如说，有一个样式需要在一百个页面上显示，如果是html来实现，那要写一百遍，现在有了css，只要写一遍。现在，html只提供数据和一些控件，完全交给css提供各种各样的样式。 CSS的重点知识点盒子模型、浮动、定位 CSS 整体感知我们先来看一段简单的css代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p&#123; color:red; font-size: 30px; text-decoration: underline; font-weight: bold; text-align: center; font-style: italic; &#125; h1&#123; color:blue; font-size: 50px; font-weight: bold; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是大标题&lt;/h1&gt; &lt;p&gt; 我是内容 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解释如下： 我们写css的地方是style标签，就是“样式”的意思，写在head里面。后面的课程中我们将知道，css也可以写在单独的文件里面，现在我们先写在style标签里面。 如果在sublime中输入&lt;st或者&lt;style然后按tab键，可以自动生成的格式如下：（建议） 1&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; type表示“类型”，text就是“纯文本”，css也是纯文本。 但是，如果在sublime中输入st或者style然后按tab键，可以自动生成的格式如下：（不建议） 1&lt;style&gt;&lt;/style&gt; css对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。 CSS语法语法格式：（其实就是键值对） 1234选择器&#123; 属性名: 属性值; 属性名: 属性值;&#125; 或者可以写成： 123456789101112选择器&#123; k:v; k:v; k:v; k:v;&#125;选择器&#123; k:v; k:v; k:v; k:v;&#125; 解释： 选择器代表页面上的某类元素，选择器后一定是大括号。 属性名后必须用冒号隔开，属性值后用分号（最后一个属性可以不用分号）。 属性名和冒号之间最好不要有空格（经验）。 如果一个属性有多个值的话，那么多个值用 空格 隔开 举例： 1p&#123;color: red;&#125; 完整版代码举例： 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; &lt;body&gt; &lt;p&gt;洗白白&lt;/p&gt; &lt;p&gt;你懂得&lt;/p&gt; &lt;p&gt;我不会就这样轻易的狗带&lt;/p&gt; &lt;/body&gt; 效果： css代码的注释格式： 12345678910111213&lt;style type=&quot;text/css&quot;&gt; /* 具体的注释 */ p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; 注意：CSS只有/* */这种注释，没有//这种注释。而且注释要写在&lt;style&gt;标签里面才算生效哦。 接下来，我们要开始真正地讲css的知识咯。 css怎么学？CSS有两个知识部分：1） 选择器，怎么选；2） 属性，样式是什么 CSS的一些简单常见的属性 我们先来接触CSS的一些简单常见的属性，因为接下来需要用到。后期会专门用一篇文章来写CSS的属性。 以下属性值中，括号中的内容表示sublime中的快捷键。 字体颜色：（c） 1color:red; color属性的值，可以是英语单词，比如red、blue、yellow等等；也可以是rgb、十六进制(后期详细讲)。 字号大小：（fos） 1font-size:40px; font就是“字体”，size就是“尺寸”。px是“像素”。单位必须加，不加不行。 背景颜色：（bgc） 1background-color: blue; background就是“背景”。 加粗：（fwb） 1font-weight: bold; font是“字体” weight是“重量”的意思，bold粗。 不加粗：（fwn） 1font-weight: normal; normal就是正常的意思。 斜体：（fsi） 1font-style: italic; italic就是“斜体”。 不斜体：（fsn） 1font-style: normal; 下划线：（tdu） 1text-decoration: underline; decoration就是“装饰”的意思。 没有下划线：（tdn） 1text-decoration:none; PS：css没啥难的，就是要把属性给记忆准确。 CSS和HTML结合的方式（样式表）CSS和HTML结合的方式，其实就是问你css的代码放在哪里比较合适。CSS代码理论上的位置是任意的，但通常写在&lt;style&gt;标签里。只要是&lt;style&gt;标签里的代码，那就是css代码，浏览器就是这样来进行解析的。 CSS和HTML的结合方式有3种： 行内样式：在某个特定的标签里采用style属性。范围只针对此标签。 内嵌样式表：在页面的head里采用&lt;style&gt;标签。范围针对此页面。 引入外部样式表css文件的方式。这种方式又分为两种： 1、采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; 2、采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别：外部样式表中不能写标签,但是可以写import语句。 下面来详细的讲一讲这三种方式。 1、CSS和HTML结合方式一：行内样式采用style属性。范围只针对此标签适用。 该方式比较灵活，但是对于多个相同标签的同一样式定义比较麻烦，适合局部修改。 举例： 1&lt;p style=&quot;color:white;background-color:red&quot;&gt;我不会就这样轻易的狗带&lt;/p&gt; 效果： 2、CSS和HTML结合方式二：内嵌样式表在head标签中加入&lt;style&gt;标签，对多个标签进行统一修改，范围针对此页面。 该方式可以对单个页面的样式进行统一设置，但对于局部不够灵活。 举例： 123456789101112131415&lt;style type=&quot;text/css&quot;&gt; p&#123; font-weight: bold; font-style: italic; color: red; &#125;&lt;/style&gt; &lt;body&gt; &lt;p&gt;洗白白&lt;/p&gt; &lt;p style=&quot;color:blue&quot;&gt;你懂得&lt;/p&gt; &lt;/body&gt; 3、CSS和HTML结合方式三：引入外部样式表css文件引入样式表文件的方式又分为两种： （1）采用&lt;link&gt;标签。例如：&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt; （2）采用import，必须写在&lt;style&gt;标签中，并且必须是第一句。例如：@import url(a.css) ; 两种引入样式方式的区别：外部样式表中不能写标签，但是可以写import语句。 具体操作如下：我们先在html页面的同级目录下新建一个a.css文件，那说明这里面的代码全是css代码，此时就没有必要再写&lt;style&gt;标签这几个字了。a.css的代码如下： 1234p&#123; border: 1px solid red; font-size: 40px;&#125; 上方的css代码中，注意像素要带上px这个单位，不然不生效。然后我们在html文件中通过&lt;link&gt;标签引入这个css文件就行了。效果如下： 这里再讲一个补充的知识：link标签的rel属性&lt;link&gt;标签的rel属性：其属性值有以下两种： stylesheet：定义的样式表 alternate stylesheet：候选的样式表 看字面意思可能比较难理解，我们来举个例子，一下子就明白了。举例： 现在定义我们来定义3种样式表：a.css：定义一个实线的黑色边框 12345div&#123; width: 200px; height: 200px; border: 3px solid black;&#125; ba.css：蓝色的虚线边框 12345div&#123; width: 200px; height: 200px; border: 3px dotted blue;&#125; c.css：来个背景图片 123456div&#123; width: 200px; height: 200px; border: 3px solid red; background-image: url(&quot;1.jpg&quot;);&#125; 然后我们在html文件中引用三个样式表： 123&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt;&lt;link rel = &quot;alternate stylesheet&quot; type = &quot;text/css&quot; href = &quot;b.css&quot; title=&quot;第二种样式&quot;&gt;&lt;/link&gt;&lt;link rel = &quot;alternate stylesheet&quot; type = &quot;text/css&quot; href = &quot;c.css&quot; title=&quot;第三种样式&quot;&gt;&lt;/link&gt; 上面引入的三个样式表中，后面两个样式表作为备选。注意备选的样式表中，title属性不要忘记写，不然显示不出来效果的。现在来看一下效果：（在IE中打开网页） CSS的四种基本选择器CSS选择器：就是指定CSS要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。 CSS的选择器分为两大类：基本选择题和扩展选择器。 基本选择器： 标签选择器：针对一类标签 ID选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 下面来分别讲一讲。 1、标签选择器：选择器的名字代表html页面上的标签标签选择器，选择的是页面上所有这种类型的标签，所以经常描述“共性”，无法描述某一个元素的“个性”。 举例： 123p&#123; font-size:14px;&#125; 上方选择器的意思是说：所有的&lt;p&gt;标签里的内容都将显示14号字体。 效果： 再比如说，我想让“生命壹号学完了安卓，继续学前端哟”这句话中的“前端”两个变为红色字体，那么我可以用&lt;span&gt;标签把“前端”这两个字围起来，然后给&lt;span&gt;标签加一个标签选择器。 代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; span&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;生命壹号学完了安卓，继续学&lt;span&gt;前端&lt;/span&gt;哟&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 【总结】需要注意的是： （1）所有的标签，都可以是选择器。比如ul、li、label、dt、dl、input。 （2）无论这个标签藏的多深，一定能够被选择上。 （3）选择的所有，而不是一个。 2、ID选择器：规定用#来定义针对某一个特定的标签来使用，只能使用一次。css中的ID选择器以”#”来定义。 举例： 123#mytitle&#123; border:3px dashed green;&#125; 效果： id选择器的选择符是“#”。 任何的HTML标签都可以有id属性。表示这个标签的名字。这个标签的名字，可以任取，但是： （1）只能有字母、数字、下划线。 （2）必须以字母开头。 （3）不能和标签同名。比如id不能叫做body、img、a。 另外，特别强调的是：HTML页面，不能出现相同的id，哪怕他们不是一个类型。比如页面上有一个id为pp的p，一个id为pp的div，是非法的！ 一个标签可以被多个css选择器选择： 比如，我们可以同时让标签选择器和id选择器作用于同一个标签。如下： 然后我们通过网页的审查元素看一下效果： 现在，假设选择器冲突了，比如id选择器说这个文字是红色的，标签选择器说这个文字是绿色的。那么听谁的？实际上，css有着非常严格的计算公式，能够处理冲突. 一个标签可以被多个css选择器选择，共同作用，这就是“层叠式”的第一层含义（第一层含义和第二层含义，放到css基础的第三篇文章里讲）。 3、类选择器：规定用圆点.来定义、针对你想要的所有标签使用。优点：灵活。 css中用.来表示类。举例如下： 1234.one&#123; width:800px;&#125; 效果： 和id非常相似，任何的标签都可以携带id属性和class属性。class属性的特点： 特性1：类选择器可以被多种标签使用。 特性2：同一个标签可以使用多个类选择器。用空格隔开。举例如下：（正确） 1&lt;h3 class=&quot;teshu zhongyao&quot;&gt;我是一个h3啊&lt;/h3&gt; 初学者常见的错误，就是写成了两个class。举例如下：（错误） 1&lt;h3 class=&quot;teshu&quot; class=&quot;zhongyao&quot;&gt;我是一个h3啊&lt;/h3&gt; 类选择器使用的举例： 类选择器的使用，能够决定一个人的css水平。 比如，我们现在要做下面这样一个页面： 正确的思路，就是用所谓“公共类”的思路，就是我们类就是提供“公共服务”，比如有绿、大、线，一旦携带这个类名，就有相应的样式变化。对应css里的代码如下： 1234567891011&lt;style type=&quot;text/css&quot;&gt; .lv&#123; color: green; &#125; .da&#123; font-size: 30px; &#125; .underline&#123; text-decoration: underline; &#125;&lt;/style&gt; 然后让每个标签去选取自己想要用的类选择器： 123 &lt;p class=&quot;lv da&quot;&gt;段落1&lt;/p&gt;&lt;p class=&quot;lv xian&quot;&gt;段落2&lt;/p&gt;&lt;p class=&quot;da xian&quot;&gt;段落3&lt;/p&gt; 也就是说： （1）不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同完成这个标签的样式。 （2）每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。 问题：到底用id还是用class？ 答案：尽可能的用class，除非极特殊的情况可以用id。 原因：id是js用的。也就是说，js要通过id属性得到标签，所以css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。 举例如下： 上图所示，css和js都在用同一个id，会出现不好沟通的情况。 我们记住这句话：类上样式，id上行为。意思是说，class属性交给css使用，id属性交给js使用。 上面这三种选择器的区别： 标签选择器针对的是页面上的一类标签。 ID选择器是只针对特定的标签(一个)，ID是此标签在此页面上的唯一标识。 类选择器可以被多种标签使用。 4、通配符*：匹配任何标签通用选择器，将匹配任何标签。不建议使用，IE有些版本不支持，大网站增加客户端负担。 效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。 举例： 12345*&#123; margin-left:0px; margin-top:0px;&#125; 效果： CSS的几种高级选择器高级选择器： 后代选择器：用空格隔开 交集选择器：用.隔开 并集选择器（分组选择器）：用逗号隔开 伪类选择器 下面详细讲一下这几种高级（扩展）选择器。 1、后代选择器: 定义的时候用空格隔开对于E F这种格式，表示所有属于E元素后代的F元素，有这个样式。空格就表示后代。 后代选择器，就是一种平衡：共性、特性的平衡。当要把某一个部分的所有的什么，进行样式改变，就要想到后代选择器。 后代选择器，描述的是祖先结构。 看定义可能有点难理解，我们来看例子吧。 举例1： 12345&lt;style type=&quot;text/css&quot;&gt; .div1 p&#123; color:red; &#125;&lt;/style&gt; 空格就表示后代。.div1 p 表示.div1的后代所有的p。 这里强调一下：这两个标签不一定是连续紧挨着的，只要保持一个后代的关联即可。也就是说，选择的是后代，不一定是儿子。 举例： 12345&lt;style type=&quot;text/css&quot;&gt; h3 b i&#123; color:red ; &#125;&lt;/style&gt; 上方代码的意思是说：定义了&lt;h3&gt;标签中的&lt;b&gt;标签中的&lt;i&gt;标签的样式。同理：h3和b和i标签不一定是连续紧挨着的，只要保持一个后代的关联即可。 效果： 或者还有下面这种写法： 上面的这种写法，&lt;h3&gt;标签和&lt;i&gt;标签并不是紧挨着的，但他们保持着一种后代关系。 还有下面这种写法：（含类选择器、id选择器都是可以的） 我们在开头说了：后代选择器，描述的是一种祖先结构。我们举个例子来说明这句话： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div div p&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=&quot;div2&quot;&gt; &lt;div class=&quot;div3&quot;&gt; &lt;div class=&quot;div4&quot;&gt; &lt;p&gt;我是什么颜色？&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面css中的div div p，也能使文字的颜色变红。通过浏览器的审查元素，我们可以看到 p元素的祖先列表： 讲到这里，我们再提一个sublme的快捷键。 在sublime中输入p#haha，按tab键后，会生成&lt;p id=&quot;haha&quot;&gt;&lt;/p&gt;。 在sublime中输入p.haha，按tab键后，会生成&lt;p class=&quot;haha&quot;&gt;&lt;/p&gt;。 2、交集选择器来看下面这张图就明白了： 123h3.special&#123; color:red;&#125; 选择的元素要求同时满足两个条件：必须是h3标签，然后必须是special标签。 举例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;交集选择器测试&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h3.special &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3 class=&quot;special zhongyao&quot;&gt;标题1&lt;/h3&gt; &lt;h3 class=&quot;special&quot;&gt;我也是标题&lt;/h3&gt; &lt;p&gt;我是段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 注意，交集选择器没有空格。所以，没有空格的div.red（交集选择器）和有空格的div .red（后代选择器）不是一个意思。 交集选择器可以连续交：（一般不要这么写） 123h3.special.zhongyao&#123; color:red;&#125; 上面这种写法，是 IE7 开始兼容的，IE6 不兼容。 交集选择器，我们一般都是以标签名开头，比如div.haha 比如p.special。 3、并集选择器：定义的时候用逗号隔开三种基本选择器都可以放进来。 举例： 123p,h1,#mytitle,.one&#123; color:red;&#125; 效果： 一些 CSS3 选择器 所有的css3选择器，我们放在HTML5和CSS3课上介绍。暂时先接触一部分。 PS：我们可以用IETester这个软件测一下CSS在各个版本IE浏览器上的显示效果。 浏览器的兼容性问题IE： 微软的浏览器，随着操作系统安装的。所以每个windows都有IE浏览器。各版本如下： windows xp 操作系统安装的IE6 windows vista 操作系统安装的IE7 windows 7 操作系统安装的IE8 windows 8 操作系统安装的IE9 windows10 操作系统安装的edge 浏览器兼容问题，要出，就基本上就是出在IE6、7身上，这两个浏览器是非常低级的浏览器。 为了测试浏览器CSS 3的兼容性，我们可以在网上搜”css3 机器猫”关键字，然后在不同的浏览器中打开如下链接： http://www1.pconline.com.cn/pcedu/specialtopic/css3-doraemon/ 测试结果如下： 我们可以在百度统计里查看浏览器的市场占有率： IE9 5.94% IE8 21.19% IE7 4.79% IE6 4.11% 我们可以在http://html5test.com/results/desktop.html中查看 我们要知道典型的IE6兼容问题（面试要问），但是做项目我们兼容到IE8即可。不解决IE8以下的兼容问题，目的在于：培养更高的兴趣和眼光，别天天的跟IE6较劲。 我们可以用「IETester」软件看看css在各个浏览器中的显示效果。 1.子代选择器，用符号&gt;表示 IE7开始兼容，IE6不兼容。 123div&gt;p&#123; color:red;&#125; div的儿子p。和div的后代p的截然不同。 能够选择： 123&lt;div&gt; &lt;p&gt;我是div的儿子&lt;/p&gt;&lt;/div&gt; 不能选择： 1234567&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;我是div的重孙子&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.序选择器 IE8开始兼容；IE6、7都不兼容 设置无序列表&lt;ul&gt;中的第一个&lt;li&gt;为红色： 12345&lt;style type=&quot;text/css&quot;&gt; ul li:first-child&#123; color:red; &#125;&lt;/style&gt; 设置无序列表&lt;ul&gt;中的最后一个&lt;li&gt;为红色： 123ul li:last-child&#123; color:blue;&#125; 序选择器还有更复杂的用法，以后再讲。 由于浏览器的更新需要过程，所以现在如果公司还要求兼容IE6、7，那么就要自己写类名： 123456789101112&lt;ul&gt; &lt;li class=&quot;first&quot;&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;项目&lt;/li&gt;&lt;/ul&gt; 用类选择器来选择第一个或者最后一个： 1234567ul li.first&#123; color:red;&#125;ul li.last&#123; color:blue;&#125; 3.下一个兄弟选择器 IE7开始兼容，IE6不兼容。 +表示选择下一个兄弟 12345&lt;style type=&quot;text/css&quot;&gt; h3+p&#123; color:red; &#125;&lt;/style&gt; 上方的选择器意思是：选择的是h3元素后面紧挨着的第一个兄弟。 12345678910111213 &lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt;我是一个段落&lt;/p&gt;&lt;h3&gt;我是一个标题&lt;/h3&gt; 效果如下： 这种选择器作用不大。 ##我的公众号 想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/02-CSS属性：背景属性","date":"2021-08-06T01:17:25.693Z","updated":"2021-07-28T07:34:11.331Z","comments":true,"path":"2021/08/06/大前端/02-CSS/02-CSS属性：背景属性/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/02-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/","excerpt":"","text":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 background系列属性常见背景属性CSS样式中，常见的背景属性有以下几种：（经常用到，要记住） background-color:#ff99ff; 设置元素的背景颜色。 background-image:url(images/2.gif); 将图像设置为背景。 background-repeat: no-repeat; 设置背景图片是否重复及如何重复，默认平铺满。（重要） no-repeat不要平铺； repeat-x横向平铺； repeat-y纵向平铺。 background-position:center top; 设置背景图片在当前容器中的位置。 background-attachment:scroll; 设置背景图片是否跟着滚动条一起移动。属性值可以是：scroll（与fixed属性相反，默认属性）、fixed（背景就会被固定住，不会被滚动条滚走）。 另外还有一个简写属性叫做background，它的作用是：将上面的多个属性写在一个声明中。 上面这几个属性经常用到，需要记住。现在我们逐个进行讲解。 background-color：背景颜色的表示方法css2.1中，背景颜色的表示方法有三种：单词、rgb表示法、十六进制表示法。 比如红色可以有下面的三种表示方法： 123background-color: red;background-color: rgb(255,0,0);background-color: #ff0000; 下面分别介绍。 1、用英语单词来表示： 能够用英语单词来表述的颜色，都是简单颜色。比如红色： 1background-color: red; 2、rgb表示法： rgb表示三原色“红”red、“绿”green、“蓝”blue。 光学显示器中，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。r、g、b的值，每个值的取值范围0~255，一共256个值。 比如红色： 1background-color: rgb(255,0,0); 黑色： 1background-color: rgb(0,0,0); 颜色可以叠加，比如黄色就是红色和绿色的叠加： 1background-color: rgb(255,255,0); 3、十六进制表示法： 比如红色： 1background-color: #ff0000; PS:所有用#开头的值，都是16进制的。 这里，我们就要学会16进制与10进制之间的转换。下面举几个例子。 问：16进制中28等于10进制多少？答：2*16+8 = 40。 16进制中的af等于10进制多少？答：10 * 16 + 15 = 175 所以，#ff0000就等于rgb(255,0,0)。 background-color: #123456;等价于background-color: rgb(18,52,86); 十六进制可以简化为3位，所有#aabbcc的形式，能够简化为#abc。举例如下： 比如： 1background-color:#ff0000; 等价于： 1background-color:#f00; 比如： 1background-color:#112233; 等价于： 1background-color:#123; 但是，比如下面这个是无法简化的： 1background-color:#222333; 再比如，下面这个也是无法简化的： 1background-color:#123123; 几种常见的颜色简写可以记住。如下： 123456#000 黑#fff 白#f00 红#222 深灰#333 灰#ccc 浅灰 background-repeat属性（重要）background-repeat:no-repeat;设置背景图片是否重复及如何重复，默认平铺满。属性值可以是： no-repeat（不要平铺） repeat-x（横向平铺） repeat-y（纵向平铺） 这个属性在开发的时候也是经常用到的。我们通过设置不同的属性值来看一下效果吧： （1）不加这个属性时：（即默认时）（背景图片会被平铺满） PS：padding的区域也是有背景图的。 （2）属性值为no-repeat（不要平铺）时： （3）属性值为repeat-x（横向平铺）时： 其实这种属性的作用还是很广的。举个例子，设计师设计一张宽度只有1px、颜色纵向渐变的图片，然后我们通过这个属性将其进行水平方向的平铺，就可以看到整个页面都是渐变的了。 在搜索引擎上搜“平铺背景”，就可以发现，周期性的图片可以采用此种方法进行平铺。 （4）属性值为repeat-y（纵向平铺）时： background-position属性background-position属性指的是背景定位属性。公式如下： 在描述属性值的时候，有两种方式：用像素描述、用单词描述。下面分别介绍。 1、用像素值描述属性值： 格式如下： 1background-position:向右偏移量 向下偏移量; 属性值可以是正数，也可以是负数。比如：100px 200px、-50px -120px。 举例如下： 2、用单词描述属性值： 格式如下： 1background-position: 描述左右的词 描述上下的词; 描述左右的词：left、center、right 描述上下的词：top 、center、bottom 比如说，right center表示将图片放到右边的中间；center center表示将图片放到正中间。 比如说，bottom表示图片的底边和父亲底边贴齐（好好理解）。 位置属性有很多使用场景的。我们来举两个例子。 场景1：（大背景图） 打开“暗黑3 台湾”的官网https://tw.battle.net/d3/zh/，可以看到官网的效果是比较炫的： 检查网页后，找到网站背景图片的url：https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg。背景图如下： 实际上，我们是通过把这张图片作为网站的背景图来达到显示效果的。只需要给body标签加如下属性即可： 12345body&#123; background-image: url(/Users/smyhvae/Dropbox/img/20170812_1950.jpg); background-repeat: no-repeat; background-position: center top;&#125; 上方代码中，如果没加background-position这个属性，背景图会默认处于浏览器的左上角（显得很丑）；加了此属性之后，图片在水平方向就位于浏览器的中间了。 场景2：（通栏banner） 很多网站的首页都会有banner图（网站最上方的全屏大图叫做「通栏banner」），这种图要求横向的宽度特别大。比如说，设计师给你一张1920*465的超大banner图，如果我们把这个banner图作为img标签直接插入网页中，会有问题的：首先，图片不在网页的中间；其次，肯定会出现横向滚动条。如下图所示： 正确的做法是，将banner图作为div的背景图，这样的话，背景图超出div的部分，会自动移溢出。需要给div设置的属性如下： 123456div&#123; height: 465px; background-image: url(http://img.smyhvae.com/20170813_1053.jpg); background-position: center top; background-repeat: no-repeat;&#125; 上方代码中，我们给div设置height（高度为banner图的高度），不需要设置宽度（因为宽度会自动霸占整行）。效果如下： 上图可以看出，将banner图作为div的背景后，banner图会永远处于网页的正中间（水平方向来看）。 background-attachment属性 background-attachment:scroll; 设置背景图片是否固定。属性值可以是： fixed（背景就会被固定住，不会被滚动条滚走）。 scroll（与fixed属性相反，默认属性） background-attachment:fixed;的效果如下： background 综合属性background属性和border一样，是一个综合属性，可以将多个属性写在一起。(在盒子模型这篇文章中专门讲到border) 举例1: 1background:red url(1.jpg) no-repeat 100px 100px fixed; 等价于： 12345background-color:red;background-image:url(1.jpg);background-repeat:no-repeat;background-position:100px 100px;background-attachment:fixed; 以后，我们可以用小属性层叠掉大属性。 上面的属性中，可以任意省略其中的一部分。 比如说，对于下面这样的属性： 1background: blue url(images/wuyifan.jpg) no-repeat 100px 100px; 效果如下： PS：以后的CSS3内容中，我们会接触到更多的background属性： background-origin、background-clip、background-size（在CSS2.1背景图片是不能调整尺寸，IE9开始兼容）、多背景。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/02-CSS/01-CSS属性：字体属性和文本属性","date":"2021-08-06T01:17:25.691Z","updated":"2021-07-28T07:34:11.331Z","comments":true,"path":"2021/08/06/大前端/02-CSS/01-CSS属性：字体属性和文本属性/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/02-CSS/01-CSS%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/","excerpt":"","text":"本文最初于2015-10-04发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 本文重要内容 CSS的单位 字体属性 文本属性 定位属性：position、float、overflow等 CSS的单位html中的单位只有一种，那就是像素px，所以单位是可以省略的，但是在CSS中不一样。CSS中的单位是必须要写的，因为它没有默认单位。 绝对单位： 1 in=2.54cm=25.4mm=72pt=6pc。 各种单位的含义： in：英寸Inches (1 英寸 = 2.54 厘米) cm：厘米Centimeters mm：毫米Millimeters pt：点Points，或者叫英镑 (1点 = 1/72英寸) pc：皮卡Picas (1 皮卡 = 12 点) 相对单位：px：像素em：印刷单位相当于12个点%：百分比，相对周围的文字的大小 为什么说像素px是一个相对单位呢，这也很好理解。比如说，电脑屏幕的的尺寸是不变的，但是我们可以让其显示不同的分辨率，在不同的分辨率下，单个像素的长度肯定是不一样的啦。 百分比%这个相对单位要怎么用呢？这里也举个例子： 字体属性行高CSS中，所有的行，都有行高。盒子模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。 如下图所示： 上图中，我们设置行高为30px，30px * 5 = 150px，通过查看审查元素，这个p标签的高度果然为150px。而且我们发现，我们并没有给这个p标签设置高度，显然是内容将其撑高的。 垂直方向来看，文字在自己的行里是居中的。比如，文字是14px，行高是24px，那么padding就是5px： 为了严格保证字在行里面居中，我们的工程师有一个约定： 行高、字号，一般都是偶数。这样可以保证，它们的差一定偶数，就能够被2整除。 如何让单行文本垂直居中小技巧：如果一段文本只有一行，如果此时设置行高 = 盒子高，就可以保证单行文本垂直居中。这个很好理解。 上面这个小技巧，只适用于单行文本垂直居中，不适用于多行。如果想让多行文本垂直居中，还需要计算盒子的padding。计算方式如下： font字体属性css样式中，字体属性有以下几种： 12345678p&#123; font-size:50px; /*字体大小*/ line-height: 30px; /*行高*/ font-family:幼圆,黑体; /*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/ font-style:italic ; /*italic表示斜体，normal表示不倾斜*/ font-weight:bold; /*粗体：属性值写成bolder也可以*/ font-variant:small-caps; /*小写变大写*/&#125; 上面这些属性中，字号、行高、字体这三个属性是最常见的。我们继续看。 1、字号、行高、字体三大属性： （1）字号： 1font-size:14px; （2）行高： 1line-height:24px; （3）字体：（font-family就是“字体”，family是“家庭”的意思） 1font-family:&quot;宋体&quot;; 是否加粗属性以及上面这三个属性，我们可以连写：（是否加粗、字号 font-size、行高 line-height、字体 font-family） 格式： 12font: 加粗 字号/行高/ 字体 举例： 1font: 400 14px/24px “宋体”; PS：400是nomal，700是bold。 上面这几个属性可以连写，但是有一个要求，font属性连写至少要有字号和字体，否则连写是不生效的（相当于没有这一行代码）。 2、字体属性的说明： （1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置： 1font-family: &quot;华文彩云&quot;; 上方代码中，如果用户电脑里面没有这个字体，那么就会变成宋体。 页面中，中文我们只使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要切图。 （2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，隔开备选字体。如下：（可以备选多个） 1font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。 （3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体： 1font-family: &quot;Times New Roman&quot;,&quot;微软雅黑&quot;,&quot;宋体&quot;; 上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于smyhvae哈哈哈这段文字，smyhvae会采用Times New Roman字体，而哈哈哈会采用微软雅黑字体。 可是，如果我们把中文字体写在前面：(错误写法) 1font-family: &quot;微软雅黑&quot;,&quot;Times New Roman&quot;,&quot;宋体&quot;; 上方代码会导致，中文和英文都会采用微软雅黑字体。 （4）所有的中文字体，都有英语别名。 微软雅黑的英语别名： 1font-family: &quot;Microsoft YaHei&quot;; 宋体的英语别名： 1font-family: &quot;SimSun&quot;; 于是，当我们把字号、行高、字体这三个属性合二为一时，也可以写成： 1font:12px/30px &quot;Times New Roman&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;; （5）行高可以用百分比，表示字号的百分之多少。 一般来说，百分比都是大于100%的，因为行高一定要大于字号。 比如说， font:12px/200% “宋体”等价于font:12px/24px “宋体”。200%可以理解成word里面的2倍行高。 反过来， font:16px/48px “宋体”;等价于font:16px/300% “宋体”。 文本属性CSS样式中，常见的文本属性有以下几种： letter-spacing: 0.5cm ; 单个字母之间的间距 word-spacing: 1cm; 单词之间的间距 text-decoration: none; 字体修饰：none去掉下划线、underline下划线、line-through中划线、overline上划线、 text-transform: lowercase; 单词字体大小写。uppercase大写、lowercase小写 color:red; 字体颜色 text-align: center; 在当前容器中的对齐方式。属性值可以是：left、right、center（在当前容器的中间）、justify text-transform: lowercase; 单词的字体大小写。属性值可以是：uppercase（单词大写）、lowercase（单词小写）、capitalize（每个单词的首字母大写） 这里来一张表格的图片吧，一览无遗： 列表属性1234ul li&#123; list-style-image:url(images/2.gif) ; /*列表项前设置为图片*/ margin-left:80px; /*公有属性*/&#125; 另外还有一个简写属性叫做list-style，它的作用是：将上面的多个属性写在一个声明中。 我们来看一下list-style-image属性的效果： 给列表前面的图片加个边距吧，不然显示不完整： 这里来一张表格的图片吧，一览无遗： overflow属性：超出范围的内容要怎么处理overflow属性的属性值可以是： auto：浏览器自己解决。在必需时裁切对象多余的内容或显示滚动条。一般采用这个属性值。 visible：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。 hidden：不显示超过对象尺寸的内容。对象将以包含对象的 window 或 frame 的尺寸进行裁切，并且 clip 属性设置将失效。 scroll：总是显示滚动条。 针对上面的不同的属性值，我们来看一下效果：举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width: 100px; height: 100px; background-color: #00cc66; margin-right: 100px; float: left; &#125; #div1&#123; overflow:auto;/*超出的部分让浏览器自行解决*/ &#125; #div2&#123; overflow:visible;/*超出的部分会显示出来*/ &#125; #div3&#123; overflow:hidden;/*超出的部分将剪切掉*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;其实很简单 其实很自然 两个人的爱由两人分担 其实并不难 是你太悲观 隔着一道墙不跟谁分享 不想让你为难 你不再需要给我个答案&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果： 鼠标的属性cursor鼠标的属性cursor有以下几个属性值： auto：默认值。浏览器根据当前情况自动确定鼠标光标类型。 pointer：IE6.0，竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 hand：和pointer的作用一样：竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 比如说，我想让鼠标放在那个标签上时，光标显示手状，代码如下： 123p:hover&#123; cursor: pointer;&#125; 另外还有以下的属性：（不用记，需要的时候查一下就行了） all-scroll : IE6.0 有上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。 col-resize : IE6.0 有左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。 crosshair : 简单的十字线光标。 default : 客户端平台的默认光标。通常是一个箭头。 hand : 竖起一只手指的手形光标。就像通常用户将光标移到超链接上时那样。 move : 十字箭头光标。用于标示对象可被移动。 help : 带有问号标记的箭头。用于标示有帮助信息存在。 no-drop : IE6.0 带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。 not-allowed : IE6.0 禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。 progress : IE6.0 带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。 row-resize : IE6.0 有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。 text : 用于标示可编辑的水平文本的光标。通常是大写字母 I 的形状。 vertical-text : IE6.0 用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。 wait : 用于标示程序忙用户需要等待的光标。通常是沙漏或手表的形状。 *-resize : 用于标示对象可被改变尺寸方向的箭头光标。 w-resize | s-resize | n-resize | e-resize | ne-resize | sw-resize | se-resize | nw-resize url ( url ) : IE6.0 用户自定义光标。使用绝对或相对 url 地址指定光标文件(后缀为 .cur 或者 .ani )。 滤镜这里只举一个滤镜的例子吧。比如说让图片变成灰度图的效果，可以这样设置滤镜： 1&lt;img src=&quot;3.jpg&quot; style=&quot;filter:gray()&quot;&gt; 举例代码： 123456789101112&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;原始图片&lt;/td&gt; &lt;td&gt;图片加入黑白效果&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;img src=&quot;3.jpg&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;3.jpg&quot; style=&quot;filter:gray()&quot;&gt;&lt;/td&gt; /*滤镜：设置图片为灰白效果*/&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下：（IE有效果，google浏览器无效果） 延伸：滤镜本身是平面设计中的知识。如果你懂一点PS的话···打开PS看看吧： 爆料一下，表示博主有两年多的平面设计经验，我做设计的时间其实比写代码的时间要长，嘿嘿··· 导航栏的制作（本段内容请忽略）现在，我们利用float浮动属性来把无序列表做成一个简单的导航栏吧，效果如下： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul&#123; list-style: none;/*去掉列表前面的圆点*/ width: 420px; height: 60px; background-color: black;/*设置整个导航栏的背景为灰色*/ &#125; li&#123; float: left;/*平铺*/ margin-right: 30px; margin-top: 16px; &#125; a&#123; text-decoration: none;/*去掉超链的下划线*/ font-size: 20px; color: #BBBBBB;/*设置超链的字体为黑色*/ font-family:微软雅黑; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;博客园&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;新随笔&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;订阅&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 实现效果如下： 国庆这四天，连续写了四天的博客，白天和黑夜，从未停歇，只交替没交换，为的就是这每日一发。以后会不断更新的。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号：千古壹号（id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/01-html/02-html标签图文详解（二）","date":"2021-08-06T01:17:25.685Z","updated":"2021-07-28T07:34:11.330Z","comments":true,"path":"2021/08/06/大前端/01-html/02-html标签图文详解（二）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-html/02-html%E6%A0%87%E7%AD%BE%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"本文最初于2015-10-02发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 本文主要内容 列表标签：&lt;ul&gt;、&lt;OL&gt;、&lt;dl&gt; 表格标签：&lt;table&gt; 框架标签及内嵌框架&lt;iframe&gt; 表单标签：&lt;form&gt; 多媒体标签 滚动字幕标签：&lt;marquee&gt; 列表标签列表标签分为三种。 1、无序列表&lt;ul&gt;，无序列表中的每一项是&lt;li&gt;英文单词解释如下： ul：unordered list，“无序列表”的意思。 li：list item，“列表项”的意思。 例如： 12345&lt;ul&gt; &lt;li&gt;默认1&lt;/li&gt; &lt;li&gt;默认2&lt;/li&gt; &lt;li&gt;默认3&lt;/li&gt;&lt;/ul&gt; 效果： 注意： li不能单独存在，必须包裹在ul里面；反过来说，ul的“儿子”不能是别的东西，只能有li。 我们这里再次强调，ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。 属性： type=&quot;属性值&quot;。属性值可以选： disc(实心原点，默认)，square(实心方点)，circle(空心圆)。效果如下： 不光是&lt;ul&gt;标签有type属性，&lt;ul&gt;里面的&lt;li&gt;标签也有type属性（虽然说这种写法很少见）。效果如下： 注意：项目符号可以是图片，但是通过CSS设置标记的背景图片来实现(CSS中讲)。 当然了，列表之间是可以嵌套的。我们来举个例子：代码： 1234567891011121314151617 &lt;ul&gt;&lt;li&gt;&lt;b&gt;北京市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;海淀区&lt;/li&gt; &lt;li&gt;朝阳区&lt;/li&gt; &lt;li&gt;东城区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;广州市&lt;/b&gt; &lt;ul&gt; &lt;li&gt;天河区&lt;/li&gt; &lt;li&gt;越秀区&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/ul&gt; 效果： ul标签实际应用场景场景1 —— 导航条： 场景2 —— li里面放置的内容可能很多： 声明：ul的儿子，只能是li。但是li是一个容器级标签，li里面什么都能放，甚至可以再放一个ul。 2、有序列表&lt;OL&gt;，里面的每一项是&lt;li&gt;英文单词：Ordered List。 例如： 12345&lt;ol &gt; &lt;li&gt;呵呵哒1&lt;/li&gt; &lt;li&gt;呵呵哒2&lt;/li&gt; &lt;li&gt;呵呵哒3&lt;/li&gt;&lt;/ol&gt; 效果： 属性： type=&quot;属性值&quot;。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始。 举例： 1234567891011121314151617181920212223&lt;ol type=&quot;1&quot;&gt; &lt;li&gt;呵呵&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt;&lt;/ol&gt;&lt;ol type=&quot;a&quot;&gt; &lt;li&gt;嘿嘿&lt;/li&gt; &lt;li&gt;嘿嘿&lt;/li&gt; &lt;li&gt;呵呵&lt;/li&gt;&lt;/ol&gt;&lt;ol type=&quot;i&quot; start=&quot;4&quot;&gt; &lt;li&gt;哈哈&lt;/li&gt; &lt;li&gt;哈哈&lt;/li&gt; &lt;li&gt;哈哈&lt;/li&gt;&lt;/ol&gt;&lt;ol type=&quot;I&quot; start=&quot;10&quot;&gt; &lt;li&gt;么么&lt;/li&gt; &lt;li&gt;么么&lt;/li&gt; &lt;li&gt;么么&lt;/li&gt;&lt;/ol&gt; 效果如下： 和无序列表一样，有序列表也是可以嵌套的哦，这里就不举类似的例子了。 ol和ul就是语义不一样，怎么使用都是一样的。ol里面只能有li，li必须被ol包裹。li是容器级。 ol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下： 12345&lt;ul&gt; &lt;li&gt;1. 小苹果&lt;/li&gt; &lt;li&gt;2. 月亮之上&lt;/li&gt; &lt;li&gt;3. 最炫民族风&lt;/li&gt;&lt;/ul&gt; 3、定义列表&lt;dl&gt; 定义列表的作用非常大。 &lt;dl&gt;英文单词：definition list，没有属性。dl的子元素只能是dt和dd。 &lt;dt&gt;：definition title 列表的标题，这个标签是必须的 &lt;dd&gt;：definition description 列表的列表项，如果不需要它，可以不加 备注：dt、dd只能在dl里面；dl里面只能有dt、dd。 举例： 1234567891011121314&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;你若是觉得你有实力和我玩，良辰不介意奉陪到底&lt;/dd&gt; &lt;dd&gt;我会让你明白，我从不说空话&lt;/dd&gt; &lt;dd&gt;我是本地的，我有一百种方式让你呆不下去；而你，无可奈何&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;良辰最喜欢对那些自认能力出众的人出手&lt;/dd&gt; &lt;dd&gt;你可以继续我行我素，不过，你的日子不会很舒心&lt;/dd&gt; &lt;dd&gt;你只要记住，我叫叶良辰&lt;/dd&gt; &lt;dd&gt;不介意陪你玩玩&lt;/dd&gt; &lt;dd&gt;良辰必有重谢&lt;/dd&gt;&lt;/dl&gt; 效果： 上图可以看出，定义列表表达的语义是两层： （1）是一个列表，列出了几个dd项目 （2）每一个词儿都有自己的描述项。 备注：dd是描述dt的。 定义列表用法非常灵活，可以一个dt配很多dd： 123456789&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些： 123456789101112131415&lt;dl&gt; &lt;dt&gt;北京&lt;/dt&gt; &lt;dd&gt;国家首都，政治文化中心&lt;/dd&gt; &lt;dd&gt;污染很严重，PM2.0天天报表&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;上海&lt;/dt&gt; &lt;dd&gt;魔都，有外滩、东方明珠塔、黄浦江&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;广州&lt;/dt&gt; &lt;dd&gt;中国南大门，有珠江、小蛮腰&lt;/dd&gt;&lt;/dl&gt; 真实案例：（京东最下方） 上图中的结构如下： 12345678910111213141516171819202122&lt;dl&gt; &lt;dt&gt;购物指南&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;#&quot;&gt;购物流程&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;会员介绍&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;生活旅行/团购&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;大家电&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt; &lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;配送方式&lt;/dt&gt; &lt;dd&gt; &lt;a href=&quot;#&quot;&gt;上门自提&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;211限时达&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;配送服务查询&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;配送费收取标准&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;海外配送&lt;/a&gt; &lt;/dd&gt;&lt;/dl&gt; 京东商品分类如下： dt、dd都是容器级标签，想放什么都可以。所以，现在就应该更加清晰的知道：用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。 表格标签表格标签用&lt;table&gt;表示。一个表格&lt;table&gt;是由每行&lt;tr&gt;组成的，每行是由每个单元格&lt;td&gt;组成的。所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。 例如，一行的单元格： 12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 上面的表格中没有加文字，所以在生成的网页中什么都看不到。例如，3行4列的单元格： 1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果： 上图中的表格好像没看到边框呀，不急，接下来看看&lt;table&gt;标签的属性。 &lt;table&gt;的属性： border：边框。像素为单位。 style=&quot;border-collapse:collapse;&quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条） width：宽度。像素为单位。 height：高度。像素为单位。 bordercolor：表格的边框颜色。 align：表格的水平对齐方式。属性值可以填：left right center。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签&lt;td&gt;进行设置） cellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=&quot;rtl&quot;，那就指的是内容到右边那条线的距离。 cellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0 bgcolor=&quot;#99cc66&quot;：表格的背景颜色。 background=&quot;路径src/...&quot;：背景图片。背景图片的优先级大于背景颜色。 bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色 bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色这两个属性的目的是为了设置3D的效果。 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left）既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。 单元格带边框的效果： 备注：表格中很细表格边线的制作：CSS的写法： 1style=&quot;border-collapse:collapse;&quot; &lt;tr&gt;：行一个表格就是一行一行组成的嘛。属性： dir：公有属性，设置这一行单元格内容的排列方式。可以取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left） bgcolor：设置这一行的单元格的背景色。注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。 height：一行的高度 align=&quot;center&quot;：一行的内容水平居中显示，取值：left、center、right valign=&quot;center&quot;：一行的内容垂直居中，取值：top、middle、bottom ### ``：单元格 **属性：** - `align`：内容的横向对齐方式。属性值可以填：left right center。 如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。 - `valign`：内容的纵向对齐方式。属性值可以填：top middle bottom - `width`：绝对值或者相对值(%) - `height`：单元格的高度 - `bgcolor`：设置这个单元格的背景色。 - `background`：设置这个单元格的背景图片。 ### 单元格的合并 如果要将两个单元格合并，那肯定就要删掉一个单元格。 单元格的属性： - `colspan`：横向合并。例如`colspan=\"2\"`表示当前单元格在水平方向上要占据两个单元格的位置。 - `rowspan`：纵向合并。例如`rowspan=\"2\"`表示当前单元格在垂直方向上要占据两个单元格的位置。 效果举例：（横向合并） 效果举例：（纵向合并） &lt;th&gt;：加粗的单元格。相当于&lt;td&gt; + &lt;b&gt; 属性同&lt;td&gt;标签。 ### ``：表格的标题。使用时和`tr`标签并列 - 属性：`align`，表示标题相对于表格的位置。属性取值可以是：left、center、right、top、bottom 效果： 表格的&lt;thead&gt;标签、&lt;tbody&gt;标签、&lt;tfoot&gt;标签这三个标签有与没有的区别： 1、如果写了，那么这三个部分的代码顺序可以任意，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。 2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。 举例： 12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;/table&gt;&lt;/body&gt; 效果： 框架标签如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。 注意，框架标签不能放在&lt;body&gt;标签里面，因为&lt;body&gt;标签代表的只是一个页面，而框架标签代表的是多个页面。于是：&lt;frameset&gt;和&lt;body&gt;只能二选一。 框架的集合用&lt;frameset&gt;表示，然后在&lt;frameset&gt;集合里放入一个一个的框架&lt;frame&gt; &lt;frameset&gt;：框架的集合一个框架的集合可以包含多个框架或框架的集合。属性： rows：水平分割，将框架分为上下部分。写法有两种：1、绝对值写法：rows=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。2、相对值写法：rows=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。 cols：垂直分割，将框架分为左右部分。写法有两种：1、绝对值写法：cols=&quot;200,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。2、相对值写法：cols=&quot;30%,*&quot; 其中*代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。 效果： 上图中，如果删掉页面right.html，显示效果如下： &lt;frame&gt;：框架一个框架显示一个页面。属性： scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 noresize：不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的，这样的话，框架大小就不固定了。如果用了这个属性值，框架大小将固定。 举例： 1&lt;frame src=&quot;top.html&quot; noresize&gt;&lt;/frame&gt; bordercolor=&quot;#00FF00&quot;：给框架的边框定义颜色。这个属性在框架集合&lt;frameset&gt;中同样适用。颜色这个属性在IE浏览器中生效，但是在google浏览器中无效，不知道为啥。 frameborder=&quot;0&quot;或frameborder=&quot;1&quot;：隐藏或显示边框（框架线）。 name：给框架起一个名字。利用name这个属性，我们可以在框架里进行超链。举例： 效果： 内嵌框架内嵌框架用&lt;iframe&gt;表示。&lt;iframe&gt;是&lt;body&gt;的子标记。内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。属性： src=&quot;subframe/the_second.html&quot;：内嵌的那个页面 width=800：宽度 height=“150：高度 scrolling=&quot;no&quot;：是否需要滚动条。默认值是true。 name=&quot;mainFrame&quot;：窗口名称。公有属性。 效果： 内嵌框架举例：（在内嵌页面中切换显示不同的压面） 123456789101112&lt;body&gt; &lt;a href=&quot;文字页面.html&quot; target=&quot;myframe&quot;&gt;默认显示文字页面&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;图片页面.html&quot; target=&quot;myframe&quot;&gt;点击进入图片页面&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;表格页面.html&quot; target=&quot;myframe&quot;&gt;点击进入表格页面&lt;/a&gt;&lt;br&gt; &lt;iframe src=&quot;文字页面.html&quot; width=&quot;400&quot; height=&quot;400&quot; name=&quot;myframe&quot;&gt;&lt;/iframe&gt; &lt;br&gt; 嘿嘿&lt;/body&gt; 效果演示： 表单标签表单标签用&lt;form&gt;表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。 属性： name：表单的名称，用于JS来操作或控制表单时使用； id：表单的名称，用于JS来操作或控制表单时使用； action：指定表单数据的处理程序，一般是PHP，如：action=“login.php” method：表单数据的提交方式，一般取值：get(默认)和post 注意：表单和表格嵌套时，是在标记中套标记。 form标签里面的action属性和method属性，在《Ajax》课程上给大家讲解。稍微说一下：action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。 get提交和post提交的区别： GET方式：将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。 POST方式：将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。 Enctype：表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。 Application/x-www-form-urlencoded：默认加密方式，除了上传文件之外的数据都可以 Multipart/form-data：上传附件时，必须使用这种编码方式。 &lt;input&gt;：输入标签（文本框）用于接收用户输入。 1&lt;input type=&quot;text&quot; /&gt; 属性： **type=&quot;属性值&quot;**：文本类型。属性值可以是： text（默认） password：密码类型 radio：单选按钮，名字相同的按钮作为一组进行单选（单选按钮，天生是不能互斥的，如果想互斥，必须要有相同的name属性。name就是“名字”。）。非常像以前的收音机，按下去一个按钮，其他的就抬起来了。所以叫做radio。 checkbox：多选按钮，名字相同的按钮作为一组进行选择。 checked：将单选按钮或多选按钮默认处于选中状态。当&lt;input&gt;标签的type=&quot;radio&quot;时，可以用这个属性。属性值也是checked，可以省略。 hidden：隐藏框，在表单中包含不希望用户看见的信息 button：普通按钮，结合js代码进行使用。 submit：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。 reset：重置按钮，清空当前表单的内容，并设置为最初的默认值 image：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。 file：文件选择框。提示：如果要限制上传文件的类型，需要配合JS来实现验证。对上传文件的安全检查：一是扩展名的检查，二是文件数据内容的检查。 **value=&quot;内容&quot;**：文本框里的默认内容（已经被填好了的） size=&quot;50&quot;：表示文本框内可以显示五十个字符。一个英文或一个中文都算一个字符。注意size属性值的单位不是像素哦。 readonly：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。 disabled：文本框只读，不能编辑，光标点不进去。属性值可以不写。 备注：HTML5中，input的类型又增加了很多（比如date、color，但是都不兼容，所以我们是在专门的HTML5课程中学）。 举例： 1234567891011&lt;form&gt; 姓名：&lt;input value=&quot;呵呵&quot; &gt;逗比&lt;br&gt; 昵称：&lt;input value=&quot;哈哈&quot; readonly=&quot;&quot;&gt;&lt;br&gt; 名字：&lt;input type=&quot;text&quot; value=&quot;name&quot; disabled=&quot;&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; value=&quot;pwd&quot; size=&quot;50&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked=&quot;&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; &gt;女&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;eat&quot;&gt;吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;sleep&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;bat&quot;&gt;打豆豆&lt;/form&gt; 效果： 四种按钮的举例： 12345678&lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;&gt;&lt;br&gt; &lt;input type=&quot;reset&quot; value=&quot;重置按钮&quot;&gt;&lt;br&gt; &lt;input type=&quot;image&quot; value=&quot;图片按钮1&quot;&gt;&lt;br&gt; &lt;input type=&quot;image&quot; src=&quot;1.jpg&quot; width=&quot;800&quot; value=&quot;图片按钮2&quot;&gt;&lt;br&gt; &lt;input type=&quot;file&quot; value=&quot;文件选择框&quot;&gt;&lt;/form&gt; 前端开发工程师，只需要关心页面的美、样式、板式、交互。至于数据的保存、读取，都是后台工程师做的事情。 Node.js就是后台语言，到时候我们就知道怎么把表单存储到数据库中了。在Ajax课中会有PHP内容，涉及MySQL，Ajax课你就知道表单怎么真的被提交了。 效果： &lt;select&gt;：下拉列表标签&lt;select&gt;标签里面的每一项用&lt;option&gt;表示。select就是“选择”，option“选项”。 select标签和ul、ol、dl一样，都是组标签。 &lt;select&gt;标签的属性： multiple：可以对下拉列表中的选项进行多选。没有属性值。 size=&quot;3&quot;：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。 &lt;option&gt;标签的属性： selected：预选中。没有属性值。 举例： 1234567891011121314151617181920212223242526272829&lt;form&gt; &lt;select&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option selected=&quot;&quot;&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select size=&quot;3&quot;&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option&gt;高中&lt;/option&gt; &lt;option&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;select multiple=&quot;&quot;&gt; &lt;option&gt;小学&lt;/option&gt; &lt;option&gt;初中&lt;/option&gt; &lt;option selected=&quot;&quot;&gt;高中&lt;/option&gt; &lt;option selected=&quot;&quot;&gt;大学&lt;/option&gt; &lt;option&gt;研究生&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/form&gt; 效果： &lt;textare&gt;标签：多行文本输入框text就是“文本”，area就是“区域”。 属性： value：提交给服务器的值。 rows=&quot;4&quot;：指定文本区域的行数。 cols=&quot;20&quot;：指定文本区域的列数。 readonly：只读。 举例： 123&lt;form&gt; &lt;textarea name=&quot;txtInfo&quot; rows=&quot;4&quot; cols=&quot;20&quot;&gt;1、不爱摄影不懂设计的程序猿不是一个好的产品经理。&lt;/textarea&gt;&lt;/form&gt; 上方代码解释：textarea这个标签，是个标签对儿。对儿里面不用写东西。如果写的话，就是这个框的默认文字。 效果： 上图的红框部分表示，我在文本区域进行了换行，所以显示的效果也出现了空白。 表单的语义化比如，我们在注册一个网站的信息的时候，有一部分是必填信息，有一部分是选填信息，这个时候可以利用表单的语义化。举例： 123456789101112131415161718&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;账号信息&lt;/legend&gt; 姓名：&lt;input value=&quot;呵呵&quot; &gt;逗比&lt;br&gt; 密码：&lt;input type=&quot;password&quot; value=&quot;pwd&quot; size=&quot;50&quot;&gt;&lt;br&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;其他信息&lt;/legend&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked=&quot;&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; &gt;女&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;eat&quot;&gt;吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;sleep&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;bat&quot;&gt;打豆豆 &lt;/fieldset&gt;&lt;/form&gt; 效果： &lt;label&gt;标签我们先来看下面一段代码： 123&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 女 对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。 本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。 解决方法如下： 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nan&quot; /&gt; &lt;label for=&quot;nan&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nv&quot; /&gt; &lt;label for=&quot;nv&quot;&gt;女&lt;/label&gt; 上方代码中，input元素要有一个id，然后label标签有一个for属性，和id相同，那么这个label和input就有绑定关系了。 当然了，复选框也有label：（任何表单元素都有label） 12&lt;input type=&quot;checkbox&quot; id=&quot;kk&quot; /&gt;&lt;label for=&quot;kk&quot;&gt;10天内免登陆&lt;/label&gt; 多媒体标签声明：多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。上述格式视频一般文件较大，不利于网络下载播放。一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。Flash格式的视频兼容性非常好，Flash格式的文件很小。 &lt;bgsound&gt;标签：播放背景音乐属性： src=&quot;音乐文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 举例： 1234&lt;body&gt;&lt;bgsound src=&quot;王菲 - 清风徐来.mp3&quot;&gt;&lt;/bgsound&gt;&lt;/body&gt; 运行效果：打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。 &lt;embed&gt;标签：播放多媒体文件（音频、视频等）主要应用Netscape浏览器，它不是W3C规范。 备注：视频格式可以支持 mp4、wav等，但不是所有视频格式都支持。 属性： src=&quot;多媒体文件的路径&quot; loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。 autostart=&quot;false&quot;：打开网页时，禁止自动播放。默认值是true。 volume=&quot;100&quot;：设置默认的音量大小，测试发现这个值好像不起作用哦。 width：指Flash文件的宽度 height：指Flash文件的高度 quality：指Flash的播放质量，质量有高有低 hight low pluginspage：如果指定的Flash插件不存在，则从pluginspage指定的地方进行下载。 type：指定Flash的文件格式类型 wmode：指Flash的背景是否可以透明，取值：transparent是透明的 &lt;embed&gt;标签播放音频举例： 1234&lt;body&gt;&lt;embed src=&quot;王菲 - 清风徐来.mp3&quot;&gt;&lt;/embed&gt;&lt;/body&gt; IE 8中的运行效果： google浏览器中的运行效果： 注：在HTML5中新增了&lt;video&gt;标签播放视频。 &lt;object&gt;标签：播放多媒体文件（音频、视频等）主要应用IE浏览器，它是W3C规范。 属性： classid：指定Flash插件的ID号，一般存在于注册表中。 codebase：如果Flash插件不存在，则从codebase指定的地址下载。 &lt;param&gt;标签的主要作用：设置具体的详细参数。 总结：在网页中插入Flash时，为了同时兼容多种浏览器，需要将&lt;object&gt;标签和&lt;embed&gt;标签标记一起使用，但使用的顺序是：&lt;object&gt;中嵌套&lt;embed&gt;标记。举例： 123456&lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot; codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0&quot; width=&quot;778&quot; height=&quot;202&quot;&gt; &lt;param name=&quot;movie&quot; value=&quot;images/banner.swf&quot;&gt; &lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt; &lt;param name=&quot;wmode&quot; value=&quot;transparent&quot;&gt; &lt;embed src=&quot;images/banner.swf&quot; width=&quot;778&quot; height=&quot;202&quot; quality=&quot;high&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;&lt;/object&gt; &lt;marquee&gt;：滚动字幕标签如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。属性： direction=&quot;right&quot;：移动的目标方向。属性值可以是：left（从右向左移动，默认值）、right（从左向右移动）、up（从下向上移动）、down（从上向下移动）。 behavior=&quot;slide&quot;：行为方式。属性值可以是：slide（只移动一次）、scroll（循环移动，默认值）、alternate（循环移动）、。alternate和scroll属性值都是循环移动，区别在于：假设在direction=&quot;right&quot;的情况下，behavior=&quot;scroll&quot;表示从左到右、从左到右、从左到右···behavior=&quot;alternate&quot;表示从左到右、从右到左、从左到右··· scrollamount=&quot;30&quot;：移动的速度 loop=&quot;3&quot;: 循环多少圈。负值表示无限循环 scrolldelay=&quot;1000&quot;：移动一次休息多长时间。单位是毫秒。 举例： 1&lt;marquee behavior=&quot;alternate&quot; direction=&quot;down&quot; width=&quot;300&quot; height=&quot;200&quot; bgcolor=&quot;#8c5dc1&quot;&gt;我来了&lt;/marquee&gt; 效果： html废弃标签介绍HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。这些样式的标签，都已经被废弃。 2004年之前的东西： 1&lt;font size=&quot;9&quot; color=&quot;red&quot;&gt;哈哈&lt;/font&gt; 下面这些标签都是css钩子，而不是原意： 1234567&lt;b&gt;加粗&lt;/b&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;i&gt;倾斜&lt;/i&gt; &lt;del&gt;删除线&lt;/del&gt;&lt;em&gt;强调&lt;/em&gt;&lt;strong&gt;强调&lt;/strong&gt; 这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。 类似的还有水平线标签： 1&lt;hr /&gt; 换行标签： 1&lt;br /&gt; 但是，网页中99.9999%需要换行的时候，是因为另起了一个段落，所以要用p，而不要用&lt;br /&gt;。不到万不得已，不要用br标签。 标准的div+css页面，只会用到种类很少的标签： 1div p h1 span a img ul ol dl input 知道每个标签的特殊用法、属性。比如a标签，img的属性。 我的公众号想学习代码之外的技能？不妨关注我的微信公众号（千古壹号id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/01-html/01-html标签图文详解（一）","date":"2021-08-06T01:17:25.682Z","updated":"2021-07-28T07:34:11.330Z","comments":true,"path":"2021/08/06/大前端/01-html/01-html标签图文详解（一）/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/01-html/01-html%E6%A0%87%E7%AD%BE%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本文最初于2015-10-01发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 国庆节快乐，还在加班的童鞋，良辰必有重谢！ 本文主要内容 头标签 排版标签：&lt;p&gt; &nbsp;&nbsp;&nbsp; &lt;div&gt; &nbsp;&nbsp;&nbsp; &lt;span&gt;&nbsp;&nbsp;&nbsp;&lt;br&gt; &nbsp;&nbsp;&nbsp; &lt;hr&gt; &nbsp;&nbsp;&nbsp; &lt;center&gt; &nbsp;&nbsp;&nbsp; &lt;pre&gt; 字体标记：&lt;h1&gt;&nbsp;&nbsp;&nbsp; &lt;font&gt;&nbsp;&nbsp;&nbsp; &lt;b&gt;&nbsp;&nbsp;&nbsp; &lt;u&gt; &nbsp;&nbsp;&nbsp;&lt;sup&gt; &nbsp;&nbsp;&nbsp;&lt;sub&gt; 超链接 图片标签 前言web标准web标准介绍： w3c：万维网联盟组织，用来制定web标准的机构（组织） web标准：制作网页要遵循的规范。 web标准规范的分类：结构标准、表现标准、行为标准。 结构：html。表现：css。行为：JavaScript。 web标准总结： 结构标准：相当于人的身体。html就是用来制作网页的。 表现标准： 相当于人的衣服。css就是对网页进行美化的。 行为标准： 相当于人的动作。JS就是让网页动起来，具有生命力的。 浏览器介绍浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、猎豹浏览器、Safari和Opera等。如下图所示： 浏览器内核： 浏览器 内核 IE trident chrome / 欧鹏 blink 火狐 gecko Safari webkit PS：「浏览器内核」也就是浏览器所采用的「渲染引擎」，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。渲染引擎是兼容性问题出现的根本原因。 Sublime Text 的使用详情请移步至：Sublime Text使用技巧 一、HTML的介绍1、HTML的概述：html全称为HyperText Markup Language，译为超文本标记语言，不是一种编程语言，是一种描述性的标记语言，用于描述超文本中内容的显示方式。比如字体什么颜色，大小等。 超文本：音频，视频，图片称为超文本。 标记 ：&lt;英文单词或者字母&gt;称为标记，一个HTML页面都是由各种标记组成。 作用：HTML是负责描述文档语义的语言。 注意：HTML语言不是一个编程语言(有编译过程)，而是一个标记语言(没有编译过程)，HTML页面直接由浏览器解析执行。 HTML是负责描述文档语义的语言html中，除了语义，其他什么都没有。 html是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述文字的语义，这些标签在浏览器里面是看不到的，所以称为“超文本”，所以就是“超文本标记语言”了。所以，接下来，我们肯定要学习一堆html中的标签对儿，这些标签对儿能够给文本不同的语义。 比如，面试的时候问你，h1标签有什么作用？ 正确答案：给文本增加主标题的语义。 错误答案：给文字加粗、加黑、变大。 2、HTML的历史 我们专门来对XHTML做一个介绍。 XHTML介绍：XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。XHTML的主要目的是为了取代HTML，也可以理解为HTML的升级版。HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。XHTML与HTML4.0的标记基本上一样。XHTML是严格的、纯净的HTML。 我们稍后将对XHTML的编写规范进行介绍。 3、HTML的网络术语 网页 ：由各种标记组成的一个页面就叫网页。 主页(首页) : 一个网站的起始页面或者导航页面。 标记： &lt;p&gt;称为开始标记 ，&lt;/p&gt;称为结束标记，也叫标签。每个标签都规定好了特殊的含义。 元素：&lt;p&gt;内容&lt;/p&gt;称为元素. 属性：给每一个标签所做的辅助信息。 xhtml： 符合XML语法标准的HTML。 dhtml：dynamic，动态的。javascript + css + html合起来的页面就是一个dhtml。 http：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，ftp：文件传输协议。 4、HTML的编辑工具 NotePad：记事本。 EditPlus：语法高亮显示。技巧： 根据颜色判断单词是否出错 （不是100%）。不好的地方：没有代码提示。 UltraEdit：根据颜色判断单词是否出错，可以显示2进制数据。 Sublime Text：新一代的代码编辑器（用的人很多）。 dw(dreamweaver，专业工具) ：建立WEB站点和应用程序的专业工具。它将布局功能、开发工具、代码编辑组合在一起。有代码提示。 PS：后缀名不能决定文件格式，只能决定打开文件打开的方式。 5、计算机编码介绍计算机，不能直接存储文字，存储的是编码。 计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们定义一套规则来表示。假如：A用110表示，B用111表示等。 ASCII码：美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。 美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。 ANSI编码：每个国家为了显示本国的语言，都对ASCII码进行了扩展。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。日本的ANSI编码是JIS编码。台湾的ANSI编码是BIG5编码（繁体）。 GBK：对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。 Unicode编码(统一编码)：用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000 UTF-8(Unicode Transform Format)编码：根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。 毫无疑问，开发中，都用UTF-8编码吧，准没错。 中文能够使用的字符集两种： 第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语…… 第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。 字库规模： UTF-8（字全） &gt; gb2312（只有汉字） 重点1：避免乱码 我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码！（重点）。 当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)。 重点2：UTF-8和gb2312的比较 保存大小：UTF-8（更臃肿、加载更慢） &gt; gb2312 （更小巧，加载更快） 总结： UTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿； gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。 列出2个使用情形： 1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。 我们亲测： qq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。 新华网藏语频道，使用的是UTF-8，保证字符集的数量。 对了，我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到me标签中的charset属性即可。那么，我们为什么可以查看网页的源代码呢？因为这个打开的网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然剋以查看网页的源代码了。 6、HTML颜色介绍颜色表示： 纯单词表示：red、green、blue、orange、gray等 10进制表示：rgb(255,0,0) 16进制表示：#FF0000、#0000FF、#00FF00等 RGB色彩模式： 自然界中所有的颜色都可以用红、绿、蓝(RGB)这三种颜色波长的不同强度组合而得，这就是人们常说的三原色原理。 RGB三原色也叫加色模式，这是因为当我们把不同光的波长加到一起的时候，可以得到不同的混合色。例：红+绿=黄色，红+蓝＝紫色，绿+蓝=青 在数字视频中，对RGB三基色各进行8位编码就构成了大约1678万种颜色，这就是我们常说的真彩色。所有显示设备都采用的是RGB色彩模式。 RGB各有256级(0-255)亮度，256级的RGB色彩总共能组合出约1678万种色彩，即256×256×256=16777216。 二、HTML的规范 HTML是一个弱势语言 HTML不区分大小写 HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统) HTML的结构： 声明部分：主要作用是用来告诉浏览器这个页面使用的是哪个标准。是HTML5标准。 head部分：将页面的一些额外信息告诉服务器。不会显示在页面上。 body部分：我们所写的代码必须放在此标签內。 目前，IE浏览器是完全不支持H5的，支持最好的是Opera浏览器，可以支持95%以上；其次是google，可以支持一部分H5。 1、编写XHTML的规范：（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：&lt;h1&gt;&lt;font&gt;&lt;/font&gt;&lt;/h1&gt; （2）所有的标记都必须小写。 （3）所有的标记都必须关闭。 双边标记：&lt;span&gt;&lt;/span&gt; 单边标记：&lt;br&gt; 转成 &lt;br /&gt; &lt;hr&gt; 转成 &lt;hr /&gt;，还有&lt;img src=“URL” /&gt; （4）所有的属性值必须加引号。&lt;font color=&quot;red&quot;&gt;&lt;/font&gt; （5）所有的属性必须有值。&lt;hr noshade=&quot;noshade&quot;&gt;、&lt;input type=&quot;radio&quot; checked=&quot;checked&quot; /&gt; （6）XHTML文档开头必须要有DTD文档类型定义 2、HTML的基本语法特性（1）HTML对换行不敏感，对tab不敏感HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。 也就是说，HTML不是依靠缩进来表示嵌套的，就是看标签的包裹关系。但是，我们发现有良好的缩进，代码更易读。要求大家都正确缩进标签。 百度为了追求极致的显示速度，所以HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。如下图所示： （2）空白折叠现象HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。 举例如下： （3）标签要严格封闭标签不封闭是灾难性的。 标签不封闭的举例如下： 三、HTML结构详解 备注： 所有的浏览器默认情况下都会忽略空格和空行 每个标签都有私有属性。也都有公有属性。 html中表示长度的单位都是像素。HTML只有一种单位就是像素。 HTML标签通常是成对出现的（双边标记），比如 &lt;div&gt; 和 &lt;/div&gt;，也有单独呈现的标签（单边标记），如：&lt;br /&gt;、&lt;hr /&gt;和&lt;img src=“images/1.jpg” /&gt;等。 属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。 使用Emmet插件快速生成html的骨架在Sublime Text中安装Emmet插件。 新建html文件，输入html:xt，按Tab键后（或者按Ctrl+E），自动生成的代码如下： 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 新建html，输入html:5后，按 Tab键后，自动生成的代码如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1、文档声明头任何一个标准的HTML页面，第一行一定是一个以 1&lt;!DOCTYPE …… 开头的语句。这一行，就是文档声明头，DocType Declaration，简称DTD。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 HTML4.01有哪些规范呢？首先我们先确定一件事儿，我们现在学习的是HTML4.01这个版本，这个版本是IE6开始兼容的。HTML5是IE9开开始兼容的。但是IE6、7、8这些浏览器还不能过早的淘汰，所以这几年网页还是应该用HTML4.01来制作。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。 说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。 HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下面）： HTML4.01里面规定了普通和XHTML两大种规范。 HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？&lt;H1&gt;&lt;/H1&gt; 所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。 总结一下，HTML4.01一共有6种DTD，说白了，HTML第一行语句一共有6种： 下面对上图中的三种小规范进行解释： strict：表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。那怎么给文本增加下划线呢？今后的css将使用css属性来解决。那么，XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。 Transitional：表示“普通的”，这种模式就是没有一些别的规范。 Frameset：表示“框架”，在框架的页面使用。 在sublime输入的html:xt，x表示XHTML，t表示transitional。HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了（W3C自己打脸了）： 1&lt;!DOCTYPE html&gt; 2、头标签头标签都放在头部分之间。包括：&lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;link&gt; &lt;title&gt;：指定整个网页的标题，在浏览器最上方显示。 &lt;base&gt;：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标。 &lt;meta&gt;：提供有关页面的基本信息 &lt;body&gt;：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。 &lt;link&gt;：定义文档与外部资源的关系。 我们打开EditPlus软件，新建一个html文件，自动生成的代码如下： 1234567891011121314&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt; &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 上面的&lt;meta&gt;标签都不用记，但是另外还有一个&lt;meta&gt;标签是需要记住的： 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;http://www.baidu.com&quot;&gt; 上面这个标签的意思是说，3秒之后，自动跳转到百度页面。 我们接下来对各个头标签进行介绍。 （1）字符集 charset我们发现，在头标签中，有下面这种标签： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; 字符集用meta标签中的charset定义，meta表示“元”。“元”配置，就是表示基本的配置项目。 charset就是charactor set（即“字符集”），这里采用的是。这个meta不用背，用sublime生成就行。 浏览器就是通过meta来看网页是什么字符集的。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。 （2）定义“关键词”举例如下： 1&lt;meta name=&quot;Keywords&quot; content=&quot;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信&quot; /&gt; 这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。 （3）定义“页面描述”meta除了可以设置字符集，还可以设置关键字和页面描述。 我们把含有meta标签的这一行代码抽象一下： 1&lt;meta name=&quot; &quot; content=&quot; &quot;&gt; name即“名字”，content即“内容”。 只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做SEO（search engine optimization，搜索引擎优化）。 设置页面描述的举例： 1&lt;meta name=&quot;Description&quot; content=&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot; /&gt; 效果如下： （4）title标签1&lt;title&gt;网页的标题&lt;/title&gt; title也是有助于SEO搜索引擎优化的。 html的完整骨架：综上所述，html的比较完整的骨架是这样： 123456789101112&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;牛逼，很牛逼，特别牛逼&quot; /&gt; &lt;meta name=&quot;Description&quot; content=&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 面试题： 问：网页的head标签里面，表示的是页面的配置，有什么配置？ 答：字符集、关键词、页面描述、页面标题。（今后我们还能看见一些其他的配置：IE适配、视口、iPhone小图标等等） 3、&lt;body&gt;标签的属性其属性有： bgcolor：设置整个网页的背景颜色。 background：设置整个网页的背景图片。 text：设置网页中的文本颜色。 leftmargin：网页的左边距。IE浏览器默认是8个像素。 topmargin：网页的上边距。 rightmargin：网页的右边距。 bottommargin：网页的下边距。 &lt;body&gt;标签另外还有一些属性，这里用个例子来解释： 上方代码中，当我们对点我点我这几个字使用超链时，link属性表示默认显示的颜色、alink属性表示鼠标点击但是还没有松开时的颜色、vlink属性表示点击完成之后显示的颜色。效果如下： 接下来，我们讲一下&lt;body&gt;里的各种标签的属性。 一、排版标签注释标签1&lt;!-- 注释 --&gt; 段落标签&lt;p&gt;12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; 属性： align=&quot;属性值&quot;：对齐方式。属性值包括left center right。举例： 段落，是英语paragraph“段落”缩写。 HTML标签是分等级的，HTML将所有的标签分为两种： 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input） 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。 从学习p的第一天开始，就要死死记住：p标签是一个文本级标签，p里面只能放文字、图片、表单元素。其他的一律不能放。 错误写法：（尝试把 h 放到 p 里） 1234&lt;p&gt; 我是一个小段落 &lt;h1&gt;我是一级标题&lt;/h1&gt;&lt;/p&gt; 网页效果如下： 上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。 PS：Chrome浏览器是世界上HTML5支持最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。 块级标签 &lt;div&gt;和&lt;span&gt; div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。 CSS课程中你将知道，这两个东西，都是最最重要的“盒子”。 div：把标签中的内容作为一个块儿来对待(division)。必须单独占据一行。 div标签的属性： align=&quot;属性值&quot;：设置块儿的位置。属性值可选择：left、right、 center。 &lt;span&gt;和&lt;div&gt;唯一的区别在于：&lt;span&gt;是不换行的，而&lt;div&gt;是换行的。 如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。 效果举例： div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。 span也是表达“小区域、小跨度”的标签，但是是一个文本级的标签。就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。 span里面是放置小元素的，div里面放置大东西的。举例如下： span举例： 12345678&lt;p&gt; 简介简介简介简介简介简介简介简介 &lt;span&gt; &lt;a href=&quot;&quot;&gt;详细信息&lt;/a&gt; &lt;a href=&quot;&quot;&gt;购买&lt;/a&gt; &lt;/span&gt;&lt;/p&gt; div举例： 12345678910&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;guanggao&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dongxi&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 所以，我们亲切的称呼这种模式叫做“div+css”。div标签负责布局，负责结构，负责分块。css负责样式。 换行标签&lt;br&gt;（已废弃）当你打算结束一行，而又不想开始一个新段落时，&lt;br&gt; 标签就派上用场了。无论你将它置于何处，&lt;br&gt; 标签都会产生一个强制的换行。 1This &lt;br&gt; is a para&lt;br&gt;graph with line breaks 效果如下： 上图显示，**&lt;p&gt;标签和&lt;br&gt;标签的区别在于**：&lt;p&gt;标签会在段落的前后自动插入一个空行，而&lt;br&gt;标签没有空行；而且&lt;br&gt;标签没有属性。 注意&lt;br&gt; 没有结束标签，把&lt;br&gt;标签写为 &lt;br/&gt; 是经得起未来考验的做法，XHTML 和 XML 都接受在打开的标签内部来关闭标签的做法。 水平线标签&lt;hr&gt;（已废弃）水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。效果如下： 属性： align=&quot;属性值&quot;：设定线条置放位置。属性值可选择：left right center。 size=&quot;2&quot; ：设定线条粗细。以像素为单位，内定为2。 width=&quot;500&quot;或width=&quot;70%&quot;：设定线条长度。可以是绝对值（单位是像素）或相对值。如果设置为相对值的话，内定为100%。 color=&quot;#0000FF&quot;：设置线条颜色。 noshade：不要阴影，即设定线条为平面显示。若没有这个属性则表明线条具阴影或立体，这是内定值。属性效果演示： 内容居中标签 &lt;center&gt;此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。效果演示： 到了H5里面，center标签不建议使用。 预定义（预格式化）标签：&lt;pre&gt;含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行）说明：真正排网页过程中，&lt;pre&gt;标签几乎用不着。但在PHP中用于打印一个数组时使用。 效果演示： 上图中，好像红框部分的字体变小了，而且还出现了缩进，好吧， 这个其实是浏览器搞的鬼。为什么要有&lt;pre&gt;这个标签呢？答案是： 所有的浏览器默认情况下都会忽略空格和空行。 好吧，其实这个标签也用的比较少。 二、字体标签标题标题使用&lt;h1&gt;至&lt;h6&gt;标签进行定义。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题。具有align属性，属性值可以是：left、center、right。效果演示： 字体标签&lt;font&gt;（已废弃）属性： color=&quot;红色&quot;或color=&quot;#ff00cc&quot;或color=&quot;new rgb(0,0,255)&quot;：设置字体颜色。 设置方式：单词 \\ #ff00cc \\ rgb(0,0,255) size：设置字体大小。 取值范围只能是：1至7。取值时，如果取值大于7那就按照7来算，如果取值小于1那就按照1来算。如果想要更大的字体，那就只能通过css样式来解决。设置：用’+2’代表值是5 或直接给值 face=&quot;微软雅黑&quot;：设置字体类型。注意在写字体时，“微软雅黑”这个字不能写错。举例：1&lt;font face=&quot;微软雅黑&quot; color=&quot;#FF0000&quot; size=&quot;10&quot;&gt;vae&lt;/font&gt; 效果： 特殊字符（转义字符） &amp;nbsp;：空格 （non-breaking spacing，不断打空格） &amp;lt;：小于号（less than） &amp;gt;：大于号（greater than） &amp;amp;：符号&amp; &amp;quot;：双引号 &amp;apos;：单引号 &amp;copy;：版权© &amp;trade;：商标™ &amp;#32464;：文字绐。其实，#32464是汉字绐的unicode编码。 要求背诵的特殊字符有：&amp;nbsp;、&amp;lt;、&amp;gt;、&amp;copy;。 比如说，你想把&lt;p&gt;作为一个文本在页面上显示，直接写&lt;p&gt;是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到转义字符。应该这么写： 1这是一个HTML语言的&amp;lt;p&amp;gt;标签 正确的效果如下： 错误的效果如下： 其实我们只要记住前三个符号就行了，其他的在需要的时候查一下就行了。而且，EditPlus软件中是可以直接点击这些符号进行选择的： 来一张表格，方便需要的时候查询： 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 一些小标签/小标记 &lt;u&gt;：下划线标记 &lt;s&gt;或&lt;del&gt;：中划线标记（删除线） &lt;i&gt;或&lt;em&gt;：斜体标记 效果： 上面的这几个标签，常用于做一些小装饰、小图标。比如： 20180118_2340.png 这张图中，我们通过查看京东网站的代码发现，箭头处的小图标都是用的标签&lt;i&gt;。 div的主要目的是用来布局，而小装饰却可以用来 粗体标签&lt;b&gt;或&lt;strong&gt;（已废弃）效果： 上标&lt;sup&gt; 下标&lt;sub&gt;上小标这两个标签容易混淆，怎么记呢？这样记：b的意思是bottom：底部举例： 1O&lt;sup&gt;2&lt;/sup&gt; 5&lt;sub&gt;3&lt;/sub&gt; 效果： 三、超链接超链接有三种形式： 1、外部链接：链接到外部文件。举例： 1&lt;a href=&quot;02页面.html&quot;&gt;点击进入另外一个文件&lt;/a&gt; a是英语anchor“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。 href是英语hypertext reference超文本地址的缩写。读作“喝瑞夫”，不要读作“喝夫”。 效果： 当然，我们也可以直接点进链接，访问一个网址。举例如下； 1&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点我点我&lt;/a&gt; 2、锚链接：指给超链接起一个名字，作用是在本页面或者其他页面的的不同位置进行跳转。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就是利用到了锚链接。首先我们要创建一个锚点，也就是说，使用name属性或者id属性给那个特定的位置起个名字。效果如下： 上图中解释： 11行代码表示，顶部这个锚的名字叫做name1。然后在底部设置超链接，点击时将回到顶部（此时，网页中的url的末尾也出现了#name1）。注意上图中红框部分的#号不要忘记了，表示跳到名为name1的特定位置，这是规定。如果少了#号，点击之后，就会跳到name1这个文件或者name1这个文件夹中去。 如果我们将上图中的第28行代码写成： 1&lt;a href=&quot;a.html#name1&quot;&gt;回到顶部&lt;/a&gt; 那就表示，点击之后，跳转到a.html页面的name1锚点中去。 说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的。 3、邮件链接：代码举例： 1&lt;a href=&quot;mailto:smyhvae@163.com&quot;&gt;点击进入我的邮箱&lt;/a&gt; 效果：点击之后，会弹出outlook，作用不大。 超链接的属性 href：目标URL title：悬停文本。 name：主要用于设置一个锚点的名称。 target：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值： _self：在同一个网页中显示（默认值） _blank：在新的窗口中打开。 _parent：在父窗口中显示 _top：在顶级窗口中显示 title属性举例： 1&lt;a href=&quot;09_img.html&quot; title=&quot;很好看哦&quot;&gt;结婚照&lt;/a&gt; 效果如下： target属性举例： 1&lt;a href=&quot;1.html&quot; title=&quot;悬停文本&quot; target=&quot;_blank&quot;&gt;链接的内容&lt;/a&gt; blank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，没啥好解释的。也就是说，如果不写target=”_blank”那么就是在相同的标签页打开，如果写了target=”_blank”，就是在新的空白标签页中打开。 备注1：分清楚img和a标签的各自的属性区别如下： 12&lt;img src=&quot;1.jpg&quot; /&gt;&lt;a href=&quot;1.html&quot;&gt;&lt;/a&gt; 备注2：a是一个文本级的标签比如一个段落中的所有文字都能够被点击，那么应该是p包裹a： 123&lt;p&gt; &lt;a href=&quot;&quot;&gt;段落段落段落段落段落段落&lt;/a&gt;&lt;/p&gt; 而不是a包裹p： 12345&lt;a href=&quot;&quot;&gt; &lt;p&gt; 段落段落段落段落段落段落 &lt;/p&gt;&lt;/a&gt; a的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。 四、图片标签img: 代表的就是一张图片。是单边标记。 img是自封闭标签，也称为单标签。 能插入的图片类型： 能够插入的图片类型是：jpg(jpeg)、gif、png、bmp。类型和类型之间有什么区别，css课上讲。 不能往网页中插入的图片格式是：psd、ai HTML页面不是直接插入图片，而是插入图片的引用地址，所以也要把图片上传到服务器上。 src属性：图片的相对路径和绝对路径这里涉及到图片的一个属性： src属性：指图片的路径。 在写图片的路径时，有两种写法：相对路径、绝对路径 1、写法一：相对路径相对当前页面所在的路径。两个标记 . 和 .. 分表代表当前目录和父路径。 举例1： 12345&lt;!-- 当前目录中的图片 --&gt;&lt;img src=&quot;2.jpg&quot;&gt;&lt;img src=&quot;.\\2.jpg&quot;&gt;&lt;!-- 上一级目录中的图片 --&gt;&lt;img src=&quot;..\\2.jpg&quot;&gt; img 是image“图片”的简写，src 是英语source“资源”的缩写。 相对路径不会出现这种情况： 1aaa/../bbb/1.jpg ../要么不写，要么就写在开头。 举例2： 1&lt;img src=&quot;images/1.jpg&quot;&gt; 上方代码的意思是说，当前页面有一个并列的文件夹images，在文件夹images中存放了一张图片1.jpg效果： 相对路径的面试题。现有如下文件层级图： 问题：如果想在index.html中插入1.png，那么对应的img语句是？ 分析： 现在document是最大的文件夹，里面有两个文件夹work和photo。work中又有一个文件夹叫做myweb。myweb文件夹里面有index.html。 所以index.html在myweb文件夹里面，上一级就是work文件夹，上两级就是document文件夹。通过document文件夹当做一个中转站，进入photo文件夹，看到了1.png。 答案： 1&lt;img src=&quot;../../photo/1.png&quot; /&gt; 2、写法二：绝对路径绝对路径包括以下两种： （1）以盘符开始的绝对路径。举例： 1&lt;img src=&quot;C:\\Users\\smyhvae\\Desktop\\html\\images\\1.jpg&quot;&gt; （2）网络路径。举例： 1&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;&gt; 大家打开上面的img中的链接，扫一扫，可能有惊喜哦。 相对路径和绝对路径的总结相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。 问题：我的网页在C盘，图片却在D盘，能不能插入呢？ 答案： 用相对路径不能，用绝对路径也不能。 注意：可以使用file://来插入，但是这种方法，没有任何意义！因为服务器上没有所谓c盘、d盘。 下面的方法是行的，但是没有任何工程上的意义，这是因为服务器没有盘符，linux系统没有盘符： 1&lt;img src=&quot;file://C:\\Users\\Danny\\Pictures\\明星\\1.jpg&quot; alt=&quot;&quot; /&gt; 总结一下： 我们现在无论是在a标签、img标签，如果要用路径。只有两种路径能用，就是相对路径和绝对路径。 相对路径，就是../ image/ 这种路径。从自己出发，找到别人； 绝对路径，就是http://开头的路径。 绝对不允许使用file://开头的东西，这个是完全错误的！ img标签的其他属性 width：宽度 height：高度 Align：指图片的水平对齐方式，属性值可以是：left、center、right title：提示性文本。公有属性。也就是鼠标悬停时出现的文本。 border：给图片加边框（描边），单位是像素，边框的颜色是黑色 Hspace：指图片左右的边距 Vspace：指图片上下的边距 Alt：当图片显示不出来的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思。（有的浏览器不支持） 举例： 1&lt;img src=&quot;images/1.jpg&quot; width=&quot;300&quot; height=&quot;`188&quot; title=&quot;这是美女&quot;&gt; 效果： Alt属性效果演示： 图片的align属性：图片和周围文字的相对位置。属性取值可以是：bottom（默认）、center、top、left、right。我们来分别看一下这align属性的这几个属性值的区别。1、align=&quot;&quot;，图片和文字低端对齐。即默认情况下的显示效果： 2、align=&quot;center&quot;：图片和文字水平方向上居中对齐。显示效果： 3、align=&quot;top&quot;：图片与文字顶端对齐。显示效果： 4、align=&quot;left&quot;：图片在文字的左边。显示效果： 5、align=&quot;right&quot;：图片在文字的右边。显示效果： 注意事项：（1）如果要想保证图片等比例缩放，请只设置width和height中其中一个。（2）如果想实现图文混排的效果，请使用align属性，取值为left或right。 热点问题指的是对图片的局部区域加超链接。我们知道，如果给图片加一个超链接，那个点击这个图片的任意区域，都会跳转到新的位置。举例： 1&lt;a href=&quot;网页2.html&quot;&gt;&lt;img src=&quot;2.jpg&quot;&gt;&lt;/a&gt; 上方代码表明：给图片加一个超链接，那个点击这个图片的任意区域，都会跳转到新的位置。现在，我只想对图片的局部区域加超链接，该怎么做呢？这里的难点在于坐标的确定，此时需要用到Dreamweaver。 上图中，切换到“设计”标签，然后： 上图中，点击菜单栏插入-图像，导入图片： ，在图片上点击右键，选择属性，弹出属性面板： 上图中，我们可以利用红框部分的地图绘制需要添加超链接的区域。箭头处表示的是要链接到的文件。蓝框部分表示打开新页面的方式，蓝狂部分的new是没有下划线的，它和_blank的含义是一样的。 局部区域的热点设置完毕后，上图显示，红框部分就是多出的代码，也正是我们需要的代码。多出的代码如下： 1234&lt;img src=&quot;file:///C|/Users/smyhvae/Desktop/html/1.jpg&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;730&quot; usemap=&quot;#Map&quot;/&gt;&lt;map name=&quot;Map&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;227,374,63&quot; href=&quot;file:///C|/Users/smyhvae/Desktop/html/网页2.html&quot; target=&quot;_blank&quot;&gt;&lt;/map&gt; 上方代码中，第一行的usemap=&quot;#Map&quot;表示我要引用名为Map的地图。然后第02至第04行就给出了地图的定义。效果演示： 最后，送上妹子的近照一张。楼主已经仁至义尽了。 PS：美女图就不放在 GitHub 上了，这么多 star，放了也不合适。去我的博客园看吧~ 怎么？还没看够？且看下文：HTML标签—-图文详解（二） 我的公众号想学习代码之外的技能？不妨关注我的微信公众号（千古壹号id：qianguyihao）。 扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/whistle网络抓包","date":"2021-08-06T01:17:25.675Z","updated":"2021-07-28T07:34:11.329Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/whistle网络抓包/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/whistle%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/","excerpt":"","text":"手机设置代理连接好指定的wifi后，点击那个wifi里的设置，将「代理」那一项，设置为手动，然后输入ip（电脑上的ip）、端口号（8899）。然后就可以通过电脑上的whistle工具，查看手机的网页请求。 注意，要保证手机和电脑在同一个网络下。 捕获和拦截https请求whistle安装证书后，可以拦截 https 请求。但是，我现在又不想拦截https请求了，该怎么卸载证书呢？ 我发现，证书无法卸载，正确的操作是： 上图中，把红框部分，去掉勾选，就不捕获https了。谢谢azh童鞋。 参考链接： Android 手机如何设置http代理？ 使用 Whistle 对 iOS HTTPS 进行抓包 移动端调试神器:eruda 手机连接代理时，如何看console.log的日志信息? 现在，代码里有console.log，如果是在电脑浏览器上看，可以直接在控制台查看console.log的内容。但是，如果手机连接代理，在手机上打开网页的话，要怎么查看console.log的内容呢？具体做法如下： （1）在 whistle中，新建一个名叫Eruda H5的代理，代理中的内容是： 1http://xxx.com htmlAppend://&#123;eruda.html&#125; (2)新建一个values，里面的内容是： 1234&lt;script src=&quot;//cdn.bootcss.com/eruda/1.4.3/eruda.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; eruda.init()&lt;/script&gt; 然后就OK了。","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/iTerm2 + OhMyZsh + agnoster 搭建","date":"2021-08-06T01:17:25.673Z","updated":"2021-07-28T07:34:11.328Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/iTerm2 + OhMyZsh + agnoster 搭建/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/iTerm2%20+%20OhMyZsh%20+%20agnoster%20%E6%90%AD%E5%BB%BA/","excerpt":"","text":"推荐链接： https://www.jianshu.com/p/246b844f4449","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/iconMoon","date":"2021-08-06T01:17:25.671Z","updated":"2021-07-28T07:34:11.328Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/iconMoon/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/iconMoon/","excerpt":"","text":"iconMoon.md https://www.cnblogs.com/chinabin1993/p/8185398.html https://blog.csdn.net/web_harry/article/details/70310597 https://blog.csdn.net/qq_37261367/article/details/80012320","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/06-chrome浏览器","date":"2021-08-06T01:17:25.669Z","updated":"2021-07-28T07:34:11.328Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/06-chrome浏览器/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/06-chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"控制台的使用控制台查看源码控制台的Sources标签可以查看源码。按住快捷键「cmd + P」，可以根据文件名查找源码文件。 其他show user agent shadow DOM 把上图中的红框部分打钩。","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/05-Atom在前端的使用","date":"2021-08-06T01:17:25.667Z","updated":"2021-07-28T07:34:11.328Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/05-Atom在前端的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/05-Atom%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"常用插件 Emmet：快速生成HTML片段，比如输入ul&gt;li*3可以快速生成： 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 详细地址，Emmet教程 Snippets：快速生成 js 代码片段（用来处理代码片段的模板输出），详细地址 Tree View：文件浏览器，详细地址 file icons：文件识别图标，使用这个插件会让你的编辑器显示对应的图标，详细地址 language-javascript-jsx：jsx语法高亮 ，详细地址 language-vue：vue语法高亮，详细地址 linter-eslint：eslint插件，详细地址 vue-snippets：vue代码片段，详细地址 pigments：颜色显示器，详细地址 linter-eslint：语法检查 Atom-Beautify：代码格式化 参考链接：https://github.com/cucygh/JDFinance/blob/master/issue.md 插件无法安装的问题方法一：设置代理C:\\Users\\smyhvae\\.atom\\.apm目录下的.apmrc配置文件（没有就新建一个）,然后添加代理信息： 123strict-ssl=falsehttps-proxy=http://127.0.0.1:1080/http-proxy =http://127.0.0.1:1080/ 这里的 http://127.0.0.1:1080，是我自己的 Shadowsocks 代理，你需要设置成自己的可用代理。然后再执行： 1apm install --check 应该可以测试成功，祝好运~~ 参考链接： https://atom-china.org/t/atom/984 https://zhenyong.github.io/2016/08/03/starting-atom/ Markdown相关在编辑器中预览2018-06-JD日记.md Packages -&gt; Markdown Preview -&gt; Toggle Preview 快捷键：Shift + Ctrl + M 参考链接： 使用Atom打造无懈可击的Markdown编辑器 相关设置显示缩进线settings –&gt;Editor –&gt; Show Indent Guide","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/04-WebStorm的使用","date":"2021-08-06T01:17:25.665Z","updated":"2021-07-28T07:34:11.327Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/04-WebStorm的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/04-WebStorm%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WebStorm的简单设置1、主题修改：可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File–settings–apperance–theme”，主题选择Darcula： 2、导入第三方主题：系统提供的两种主题可能都不太好看，我们可以进入网站http://color-themes.com/来获取第三方主题，这里推荐两个主题，大家二选一即可： Sublime Material 上图中，在网站http://color-themes.com/中将主题下载之后，是一个jar包。那怎么导入到WebStorm呢？ 别着急，回到WebStorm，选择菜单栏“ File-Import Settings”，将下载好的jar包导入即可。 3、代码字体修改：选择菜单栏“File–settings–Editor–Font”： 上图中，点击红框部分，然后弹出如下界面： 我们在上图中修改代码的字体。 修改完之后发现 WebStorm 的一些默认字体（比如侧边栏的工程目录的字体）并没有发生变化，如果想改的话，也可以改（我个人一般是不改的）。 4、关闭更新：如下图所示： 5、快捷键习惯的修改：7、配置代码的自动提示：14、修改文件编码为UTF-8：WebStorm 2017.3.3版本的默认编码方式是 GBK，我们还是统一设置为UTF-8吧，不要坑队友哦： 新建一个空的项目配置完成后，可以开始新建一个项目文件夹（站点），项目通常包含如下内容： 首页：index.html 样式：css文件夹 index.css 相同样式：全局样式、公共样式。起名为：base.css（基本样式）或者 global.css (全局样式) 图片：images文件夹、文件 特效：js文件夹、js文件 步骤如下： （1）新建一个空的项目： （2）然后新建一个html文件： （3）新建一个空的文件夹，命名为css： 然后在这个css文件夹中，新建样式表：（比如index.css\\base.css） （4）最后新建一个images文件夹，用于存放土片。这样的话，一个基本的项目结构就搭建好了： 接下来，开始运用起你们的前端知识吧。 （5）如果要新建JS文件的话，操作如下： 使用技巧多光标编辑我们可以按住鼠标不松手，选中多个光标，然后同时编辑： 随时在浏览器中看代码效果20180118_1658.png 如上图所示，我们可以点击右上角的浏览器图标，在各个浏览器中看效果。 实时查看颜色写代码时如果想输入颜色，会自动提示颜色的预览。 点击最左侧的颜色预览，还能弹出调色板： 代码的自动补齐（1）在html文档中，输入div*10，按tab键后，弹出的效果如下： 12345678910&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; （2）在html文档中，输入如下部分： 1.search-logo+.search-input+.search-car+.search-moreA 按tab键后，弹出的效果如下： 1234&lt;div class=&quot;search-logo&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-input&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-car&quot;&gt;&lt;/div&gt;&lt;div class=&quot;search-moreA&quot;&gt;&lt;/div&gt; 你看，京东的搜索框就包含了这几个div： 20180122_1045.png （3）方法的注释： 方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 比如： 123456789/** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns &#123;Element|*|Node&#125; */function getFirstNode(ele)&#123; var node = ele.firstElementChild || ele.firstChild; return node;&#125; 常用快捷键标签环绕输入一段字符后，按住Ctrl + Alt + T，可以用标签将这段字符环绕： 选中正行中的文本比如下面这行： 12text-align: center; /*让 li 里面的文本水平方向居中*/ 如果直接按 【ctrl+C】的话，复制的是整行的内容，把前面的空格也包含进去了。如果不想复制空格，有另外一个办法：将光标放在行尾，然后按住【shift+home】，就能选中你想要的内容了。","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/04-Sublime Text在前端中的使用","date":"2021-08-06T01:17:25.663Z","updated":"2021-07-28T07:34:11.327Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/04-Sublime Text在前端中的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/04-Sublime%20Text%E5%9C%A8%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"新建文件时快速生成Html安装如下插件： FileHeader：自动创建文件开头模板，并且会根据最后的保存时间修改更新时间。官网链接。 CSS Format：css格式化。 Emmet：它能够让你在编辑器中书写CSS和HTML的缩写并且动态地拓展它，是一个能大幅度提高前端开发效率的一个工具。这个软件的安装过程比较久。官网教程。 开始使用： 新建文件，输入html:5，按[Ctrl + E] 或者 Tab 键， 参考链接：Sublime Text 新建文件快速生成Html【头部信息】和【代码补全】、【汉化】 常用插件SublimeCodeIntel：JavaScript代码自动提示（不好用）安装完成后，通过路径Perferences-&gt;Package Settings-&gt;SublimeCodeIntel-&gt;Setting - Defalut打开配置文件。 将 12&quot;codeintel_selected_catalogs&quot;: [&quot;jQuery&quot;] 改为： 1&quot;codeintel_selected_catalogs&quot;: [&quot;JavaScript&quot;] 保存后重启软件。 参考链接：# javascript complet：JavaScript代码自动提示 官网链接 GitHub链接 在google上搜关键字”sublime javascript complete”找到的。另外还搜到一个SublimeAllAutocomp lete JsFormat：JS代码格式化快捷键是：选中JS代码，然后按ctrl+alt+f。 或者，先用快捷键打开命令面板 “ctrl + shift + p”, 再输入 “Format: Javascript” 就可以使用格式化命令 Sublime Server我们如果右键在浏览器中打开html网页，其实是以文件路径的方式打开的，导致很多api无法操作。最好的办法是：将html在服务器上打开。 我们如果安装 Sublime Server，就可以让网页在本地的服务器上打开。 安装成功之后，使用步骤如下： （1）选择菜单栏”Tools –&gt; SublimeServer –&gt; Start SublimeServer”启动服务器。 （2）在html文档里，右键选择 “View in SublimeServer”。 如果想关闭服务器，直接把Sublime Text 整个软件关掉就好。其他的关闭方式容易导致软件卡死。 代码快速生成（1）&gt;符号的技巧： 输入ul&gt;li*9，然后按tab键，生成的代码如下；（符号&gt;是包含的关系） 123456789101112 &lt;div&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;/div&gt;&lt;/div&gt; sublime text 快捷键 Win快捷键 Mac快捷键 作用 备注 html:5+tab html结构代码 tab 补全标签代码 tab 补全标签代码 比如，在html文件中输入div，然后 按住tab键后，会自动生成&lt;div&gt;&lt;/div&gt;。 Ctrl + Shift + D Cmd + Shift + D 复制当前行到下一行 Ctrl+Shift+K 快速删除整行 Ctrl+鼠标左键单击 集体输入 Ctrl+H Option+Cmd+F 查找替换 Ctrl+/ 注释单行 Ctrl+Shift+/ 注释多行 Ctrl+L 快速选中整行，继续操作则继续选择下一行，效果和 Shift + ↓ 效果一样 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行 经常与上一个快捷键结合起来使用 Ctrl + Shift +【↑/↓ Ctrl + Cmd +↑/↓ 移动当前行 F11 全屏 推荐阅读 Sublime Text使用技巧 我自己整理的。 参考链接 像 Sublime Text 一样使用 Chrome DevTools","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/03-VS Code的使用积累","date":"2021-08-06T01:17:25.661Z","updated":"2021-07-28T07:34:11.327Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/03-VS Code的使用积累/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/03-VS%20Code%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"常见配置自动保存： 1&quot;files.autoSave&quot;: &quot;onFocusChange&quot; 参考链接：https://blog.csdn.net/WestLonly/article/details/78048049 在新的窗口中打开文件： 1&quot;workbench.editor.enablePreview&quot;: false, 常见操作如何查看代码结构 方法一：「Cmd + Shift + O」 方法二：安装插件Code Outline 参考链接：https://www.zhihu.com/question/264045094 在本地开启服务器12345# 安装npm install -g live-server# 启动live-server 参考链接：Visual Studio Code + live-server编辑和浏览HTML网页 常用插件方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。 方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入extension:install，回车，左侧即打开扩展安装的界面。 sftp：文件传输输入快捷键「ctrl+shift+P」，弹出指令窗口，输入sftp:config，回车，当前工作工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的是： host：服务器的IP地址 username：工作站自己的用户名 privateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件） remotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录 ignore：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号 举例如下：(注意，其中的注释不能保留) 123456789101112131415161718192021222324252627&#123; &quot;host&quot;: &quot;&quot;, //服务器ip &quot;port&quot;: 22, //端口，sftp模式是22 &quot;username&quot;: &quot;&quot;, //用户名 &quot;password&quot;: &quot;&quot;, //密码 &quot;protocol&quot;: &quot;sftp&quot;, //模式 &quot;agent&quot;: null, &quot;privateKeyPath&quot;: null, &quot;passphrase&quot;: null, &quot;passive&quot;: false, &quot;interactiveAuth&quot;: false, &quot;remotePath&quot;: &quot;/root/node/build/&quot;, //服务器上的文件地址 &quot;context&quot;: &quot;./server/build&quot;, //本地的文件地址 &quot;uploadOnSave&quot;: true, //监听保存并上传 &quot;syncMode&quot;: &quot;update&quot;, &quot;watcher&quot;: &#123; //监听外部文件 &quot;files&quot;: false, //外部文件的绝对路径 &quot;autoUpload&quot;: false, &quot;autoDelete&quot;: false &#125;, &quot;ignore&quot;: [ //忽略项 &quot;**/.vscode/**&quot;, &quot;**/.git/**&quot;, &quot;**/.DS_Store&quot; ]&#125; Sass FormatterSass 文件格式化。 Code Outline：显示代码结构安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构： 参考链接： https://www.zhihu.com/question/50273450 http://itopic.org/vscode.html https://github.com/varHarrie/varharrie.github.io/issues/10 vscode-fileheader：添加顶部注释模板(签名)（1）安装插件vscode -fileheader，并重启。 （2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。 默认的快捷键是：「Ctrl + option + I」。 参考链接： https://www.zhihu.com/question/62385647 Express在本地开启Node服务器： 然后在浏览器的地址栏输入http://localhost/ + 文件的相对路径，就可以通过服务器的形式打开这个文件。 Copy Relative Path 这个插件很有用，使用频率很高。 复制文件的相对路径：（相对于根路径而言） open in browser在浏览器中打开。 Auto Rename Tag适用于 JSX、Vue、HTML。在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键。 ###Project Manager 项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢。 highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。 所用了这个插件之后，VS Code自带的高亮就可以关掉了： 在用户设置里添加&quot;editor.selectionHighlight&quot;: false即可。 参考链接：vscode 选中后相同内容高亮插件推荐 highlight-words：全局高亮（跨文件多色彩）参考链接：Visual Studio Code全局高亮着色插件(跨文件多色彩)经验纪要 color-exchange：颜色格式转换【荐】安装完插件后，在css中输入颜色，然后按cmd + .，就能进行颜色的格式转换。 20181013_1450.png 我在写这一段时，安装的人还不多，赶紧上车。 Vue 相关的插件vetur：vue 文件的基本语法高亮安装完 vetur 后还需要加上这样一段配置下： 1234&quot;emmet.syntaxProfiles&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot;&#125; 参考链接： https://www.clarencep.com/2017/03/18/edit-vue-file-via-vscode/ https://github.com/varHarrie/varharrie.github.io/issues/10 参考链接 https://www.jianshu.com/p/0724921285d4 https://www.cnblogs.com/AmosLee94/p/8338013.html 常用快捷键 Win快捷键 Mac快捷键 作用 备注 Shift + Alt + F Shift + option + F 代码格式化 Ctrl + Shift + N 在当前行上面增加一行并跳至该行 Ctrl + Shift + D 复制当前行到下一行 如何同时打开多个窗口问题问题1 解决；You can kill the Microsoft.VSCode.Cpp.IntelliSense.Msvc process to save the file successfully. 也就是 IntelliSense 这个进程。 参考链接 能让你开发效率翻倍的 VSCode 插件配置（上） 某网友的VS Code 插件截图","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/03-GitHub的使用","date":"2021-08-06T01:17:25.659Z","updated":"2021-07-28T07:34:11.326Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/03-GitHub的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/03-GitHub%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GitHub的使用GitHub添加wiki参考链接： https://juejin.im/post/5a3216c8f265da43333e6b54 GitHub项目添加 licence参考链接： https://blog.csdn.net/qq_35246620/article/details/77647234","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/02-Git的使用","date":"2021-08-06T01:17:25.654Z","updated":"2021-07-28T07:34:11.326Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/02-Git的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/02-Git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"常见操作全局配置用户信息123git config --global user.name &quot;smyhvae&quot;git config --global user.email &quot;smyhvae@163.com&quot; 分支的合并场景：基于master分支的代码，开发一个新的特性如果你直接在master分支上开发这个新特性，是不好的，万一你在开发特性1的时候，领导突然又要叫你去开发特性2，就不好处理了。难道开发的两个特性都提交到master？一会儿提交特性1的commit，一会儿提交特性2的commit？这会导致commit记录很混乱。 所以，我给你的建议做法是：给每个特性都单独建一个的新的分支。 比如说，我专门给特性1建一个分支feature_item_recommend。具体做法如下： （1）基于master分支，创建一个新的分支，起名为feature_item_recommend： 123$ git checkout -b feature_item_recommendSwitched to a new branch &#x27;feature_item_recommend&#x27; 上面这行命令，相当于： 123$ git branch feature_item_recommend // 创建新的分支$ git checkout feature_item_recommend //切换到新的分支 （2）在新的分支feature_item_recommend上，完成开发工作，并 commit 、push。 （3）将分支feature_item_recommend上的开发进度合并到master分支： 1234$ git checkout master //切换到master分支$ git merge feature_item_recommend //将分支 feature_item_recommend 的开发进度合并到 master 分支 合并之后，master分支和feature_item_recommend分支会指向同一个位置。 （3）删除分支feature_item_recommend： 既然 特性1 开发完了，也放心地提交到master了，那我们就可以将这个分支删除了。 1git branch -d feature_item_recommend 注意，我们当前是处于master分支的位置，来删除feature_item_recommend分支。如果当前是处于feature_item_recommend分支，是没办法删除它自己的。 同理，当我转身去开发特性2的时候，也是采用同样的步骤。 合并分支时，如果存在分叉 比如说上面这张图中，最早的时候，master分支是位于C2节点。我基于C2节点，new出一个新的分支iss53，我在iss53上提交了好几个commit。 现在，我准备把iss53上的几个commit合并到master上，此时发现，master分支已经前进到C4了。那该怎么合并呢？ 合并的命令仍然是： 123$ git checkout master$ git merge iss53 解释： 这次合并的实现，并不同于简单的并入方式。这一次，我的开发历史是从更早的地方开始分叉的。 由于当前 master 分支所指向的commit (C4)并非想要并入分支（iss53）的直接祖先，Git 不得不进行一些处理。就此例而言，Git 会用两个分支的末端（C4 和C5）和它们的共同祖先（C2）进行一次简单的三方合并计算。 Git 没有简单地把分支指针右移，而是对三方合并的结果作一新的快照，并自动创建一个指向它的commit（C6）（如下图所示）。我们把这个特殊的commit 称作合并提交（mergecommit），因为它的祖先不止一个。 值得一提的是Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和CVS 或Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让Git 的合并操作比其他系统都要简单不少。 解决合并时发生的冲突 如果 feature1和feature2修改的是同一个文件中代码的同一个位置，那么，把feature1合并到feature2时，就会产生冲突。这个冲突需要人工解决。步骤如下： （1）手动修改文件：手动修改冲突的那个文件，决定到底要用哪个分支的代码。 （2）git add：解决好冲突后，输入git status，会提示Unmerged paths。这个时候，输入git add即可，表示：修改冲突成功，加入暂存区。 （3）git commit 提交。 然后，我们可以继续把 feature1 分支合并到 master分支，最后删除feature1、feature2。 注意：两个分支的同一个文件的不同地方合并时，git会自动合并，不会产生冲突。 比如分支feture1对index.html原来的第二行之前加入了一段代码。分支feature2对index.html在原来的最后一行的后面加入了一段代码。这个时候在对两个分支合并，git不会产生冲突，因为两个分支是修改同一文件的不同位置。git自动合并成功。不管是git自动合并成功，还是在人工解决冲突下合并成功，提交之前，都要对代码进行测试。 日常操作积累修改密码（曲线救国） 网上查了很久，没找到答案。最终，在cld童鞋的提示下，采取如下方式进行曲线救国。 12# 设置当前仓库的用户名为空git config user.name &quot;&quot; 然后，当我们再输入git pull等命令行时，就会被要求重新输入新的账号密码。此时，密码就可以修改成功了。最后，我们还要输入如下命令，还原当前仓库的用户名： 1git config user.name &quot;smyhvae&quot; 修改已经push的某次commit的作者信息已经push的记录，如果要修改作者信息的话，只能 通过–force命令。我反正是查了很久，但最终还是不敢用公司的仓库尝试。 参考链接： git 修改已提交的某一次的邮箱和用户信息 看最后一条答案。 修改 git repo 历史提交的 author 将 branch1的某个commit1合并到branch2当中切换到branch2中，然后执行如下命令： 1git cherry-pick commit1 20190118-修改GitHub已提交的用户名和邮箱参考链接：（亲测有效） 修改Git全部Commit提交记录的用户名Name和邮箱Email Mac 运行sh文件，也就是传说中的shell脚本 git客户端推荐20180623时，网上看了下Git客户端的推荐排名： SmartGit： 商业用途收费， 个人用户免费：s 上面的Git客户端我基本都用过了，我最推荐的一款Git客户端是：Tower 或者 Fork。 推荐书籍 《pro.git中文版》 推荐连接2018-06 聊下git pull –rebase","categories":[],"tags":[]},{"title":"","slug":"大前端/00-前端工具/01-VS Code的使用","date":"2021-08-06T01:17:25.652Z","updated":"2021-07-28T07:34:11.326Z","comments":true,"path":"2021/08/06/大前端/00-前端工具/01-VS Code的使用/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-VS%20Code%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言 本文最新内容将在GitHub上实时更新。 VS Code 本来是前端人员专用，但由于它实在是太好用了，于是，各种开发方向的码农也正在用 VS Code 作为他们的主力编程工具。甚至是一些写作的同学，也把 VS Code 作为 markdown 写作工具。 写下这篇文章，是顺势而为。 VS Code 的介绍VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做的很不错。 编辑器 与 IDEIDE和编辑器是有区别的： IDE ：对代码会有较好的智能提示，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。 编辑器：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。 需要注意的是，VS Code 的定位是编辑器，而非IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。 VS Code的一些补充 VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。 VS Code 的源代码以MIT协议开源。 VS Code 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。 有一点你可能不知道，VS Code 这个客户端软件是用 js 语言开发出来的（具体请自行查阅关键字Electron）。有句话说得好：能用 js 实现的功能，最终一定会用 js 实现。 前端利器之争： VS Code 与 WebStorm前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是VS Code还是 WebStorm （WebStorm 其实是 IntelliJ IDEA的定制版）？我来做个对比： 哪个更酷：显然 VS Code 更酷。 内存占用情况：根据我的观察，VS Code是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用的话，使用起来是不会有任何卡顿的感觉的。相比之下，IDEA 不仅非常占内存，而且还非常卡顿。 使用比例：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的前端团队有100人左右，绝大部分前端同学都在用 VS Code，妥妥的。 所以，如果你以后还问这个问题，那就真有些掉底了。 VS Code 的安装 VS Code 官网：https://code.visualstudio.com VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。 上图中，直接点击 download 下载安装即可。 VS Code快捷键VS Code用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。 掌握10%的内容，足矣应对90%的工作。熟练使用它们，你就已经很牛了。 移动光标 Mac快捷键 Win快捷键 作用 备注 Cmd + ← Fn + ← 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + → 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 根据上面的快捷键，我们可以举一反三。补充如下： 「方向键」：在单个字符之间移动光标 「option + 左右方向键」：在单词之间移动光标（很常用）。注：Win 快捷键是「Ctrl + 左右方向键」。 「Cmd + 左右方向键」：在整行之间移动光标（很常用）。注：Win 的快捷键是「Fn + 左右方向键」 「Cmd + Shift + \\」：在代码块之间移动光标。 删除操作 Mac快捷键 Win快捷键 作用 备注 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + delete 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 备注：上面所讲到的移动光标、删除操作的快捷键，在其他编辑器里，也是同样的操作。 编辑操作 Mac快捷键 Win快捷键 作用 备注 Cmd + Enter Ctrl + Enter 在当前行下面新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 JS语言相关 Mac快捷键 Win快捷键 作用 备注 Cmd + / Ctrl + / 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 跳转操作 Mac快捷键 Win快捷键 作用 备注 Ctrl + Tab Ctrl + Tab 在已经打开的文件之间进行跳转 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件 很常用 Ctrl + G Ctrl + G 跳转到指定行 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 搜索 Mac快捷键 Win快捷键 作用 备注 Cmd + F Ctrl + F 在当前文件中搜索，光标在搜索框里 Cmd + G F3 在当前文件中搜索，光标仍在编辑器里 Cmd + Shift + F Ctrl + Shift +F 全局搜索 很常用 多光标的使用技巧1：按住 「Option」键（windows 用户是按住「Alt」键） ，然后在页面中希望中现光标的位置点击鼠标。 技巧2：选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。 技巧3：选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。 工作区快捷键 Mac快捷键 Win快捷键 作用 备注 Cmd + B Ctrl + B 显示/隐藏侧边栏 很实用 Cmd + \\ Ctrl + \\ 创建多个编辑器 比较实用 Cmd + Option + 左右方向键 Ctrl + Pagedown/Pageup 在已经打开的文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的文件之间进行跳转 不如上面的快捷键实用 Cmd + J Ctrl + J 显示/隐藏控制台 自定义快捷键按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。 当然，你也可以选择菜单栏「偏好设置 –&gt; 键盘快捷方式」，进入快捷键的设置： 快捷键列表你可以点击 VS Code 左下角的齿轮按钮，效果如下： 上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了： VS Code 的常见设置项面包屑（Breadcrumb）打开 VS Code 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示： 上图中，将红框部分打钩即可。 设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示： 是否显示代码的行号VS Code 默认显示代码的行号。你可以在设置项里搜索 editor.lineNumbers修改设置，配置项如下： 我建议保留这个设置项，无需修改。 右侧是否显示代码的缩略图VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 editor.minimap进行设置，配置项如下： 将当前行代码高亮显示当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想高亮显示当前行的代码，你可以在设置项里搜索editor.renderLineHighlight进行设置。配置项如下： 我设置完之后，发现效果不是很明显。有待优化。 空格 or 制表符VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下tab 键后，编辑器就会识别成制表符。 常见的设置项如下： editor.detectIndentation：自动检测（默认开启）。截图如下： editor.insertSpaces：按 Tab 键时插入空格（默认）。截图如下： editor.tabSize：一个制表符默认等于四个空格。截图如下： 改完代码后立即自动保存改完代码后，默认不会自动保存。你可以在设置项里搜索files.autoSave，修改配置项如下： 上图中，我们将配置项修改为onFocusChange之后，那么，当光标离开该文件后，这个文件就会自动保存了。非常方便。 保存代码后，是否立即格式化保存代码后，默认不会立即进行代码的格式化。你可以在设置项里搜索editor.formatOnSave查看该配置项： 我觉得这个配置项保持默认就好，不用打钩。 新建文件后的默认文件类型当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。如果你想修改默认的文件类型，可以在设置项里搜索files.defaultLanguage，设置项如下： 上图中的红框部分，填入你期望的默认文件类型。我填的是html类型，你也可以填写成 javascript 或者 markdown，或者其他的语言类型。 删除文件时，是否弹出确认框当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索xplorer.confirmDelete。截图如下： 我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？ 命令面板的使用Mac用户按住快捷键 Cmd+Shift+P （Windows用户按住快捷键Ctrl+Shift+P），可以打开命令面板。效果如下： 如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。 字体设置在命令面板输入“字体”，可以进行字体的设置，效果如下： 当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。 快捷键设置在命令面板输入“快捷键”，就可以进入快捷键的设置。 大小写转换选中文本后，在命令面板中输入transfrom，就可以修改文本的大小写了。 VS Code 的常用技巧文件对比VS Code 默认支持对比两个文件的内容。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下： VS Code自带的对比功能并不够强大，我们可以安装插件compareit，进行更丰富的对比。比如说，安装完插件compareit之后，我们可以将「当前文件」与「剪切板」里的内容进行对比： 查找某个函数在哪些地方被调用了比如我已经在a.js文件里调用了 foo()函数。那么，如果我想知道foo()函数在其他文件中是否也被调用了，该怎么做呢？ 做法如下：在 a.js 文件里，选中foo()函数（或者将光标放置在foo()函数上），然后按住快捷键「Shift + F12」，就能看到 foo()函数在哪些地方被调用了，比较实用。 鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。 用鼠标单击文件的行号，可以选中当前行。 在某个行号的位置，上下移动鼠标，可以选中多行。 重构重构分很多种，我们来举几个例子。 1、命名重构： 当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。 2、方法重构： 选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。 在当前文件中搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + F（Win用户是Ctrl + F）：在当前文件中搜索，光标在搜索框里 Cmd + G（Win用户是 F3）：在当前文件中搜索，光标仍在编辑器里 但是，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示： 上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。 「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 editor.find.autoFindInSelection，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以自动只在这些内容里进行查找。该设置项如下图所示： 正常情况下，我建议这个设置项不用勾选。 全局搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + Shift + F（Win用户是Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下： 上图中，你可以点击红框部分，展开更多的配置项。 Git版本管理VS Code 自带了 Git 版本管理，如下图所示： 上图中，我们可以在这里进行常见的git 命令操作。如果你还不熟悉 Git版本管理，先去补补课吧。 与此同时，我建议安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是Git神器，码农必备。 将工作区放大/缩小我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。 如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +/-**」。windows用户是按下「ctrl +/-」 当我们在给别人演示代码的时候，这一招十分管用。 如果你想恢复默认的工作区大小，可以在命令面板输入重置缩放（英文是reset zoom） 创建多层子文件夹我们可以在新建文件夹的时候，如果直接输入aa/bb/cc，比如： 那么，就可以创建多层子文件夹，效果如下： .vscode 文件夹的作用如果你发现项目的根目录下有一个.vscode文件夹，说明这个文件夹代表的是当前项目的配置。 这个文件夹里可能包含以下集中文件： settings.json：工作空间设置。只针对当前项目有效。比如说，我可以在这里面要求当前项目的代码统一使用制表符，而不需要要求每一位码农去修改各自的配置文件。 sftp.json：ftp文件传输的配置。 自带终端我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 item2。 markdown语法支持VS Code自带 markdown 语法高亮，写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示： 你也可以在控制面板输入Markdown: 打开预览，直接全屏预览 markdown文件。 Emmet in VS CodeEmmet可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。 举个例子，我们在编辑器中输入缩写代码：ul&gt;li*6 ，然后按下 Tab 键，即可得到如下代码片段： 12345678&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。 插件扩展 / 插件推荐VS Code 有一个很强大的功能就是支持插件扩展。 上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。 我来列举几个常见的插件，这些插件都很实用。 GitLens我强烈建议你安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是Git神器，码农必备。如果你不知道，那真是out了。 GitLens 在 Git 管理上有很多强大的功能，比如： 将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。 查看某个 commit 的代码改动记录 查看不同的分支 可以将两个 commit 进行代码对比，甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。 RemoteHub不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。 RemoteHub插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。 这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。 TODO Highlight写代码过程中，突然发现一个Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个TODO注释。比如：（注意，一定要写成大写TODO，而不是小写的todo） 1//TODO:这里有个bug，我一会儿再收拾你 或者： 1//FIXME:我也不知道为啥， but it works only that way. 安装了插件 TODO Highlight之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。 Bracket Pair Colorizer 2：突出显示成对的括号【荐】Bracket Pair Colorizer 2插件：以不同颜色显示括号并用连线标注括号范围。 Rainbow Brackets：Rainbow Brackets插件：突出显示成对的括号。 indent-rainbow：突出显示缩进indent-rainbow插件：突出显示缩进。 安装完成后，效果如下图所示： sftp：文件传输如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。 安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入sftp:config，回车，当前工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的内容可以是： host：服务器的IP地址 username：工作站自己的用户名 privateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件） remotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录 ignore：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号 举例如下：(注意，其中的注释需要去掉) 123456789101112131415161718192021222324252627&#123; &quot;host&quot;: &quot;&quot;, //服务器ip &quot;port&quot;: 22, //端口，sftp模式是22 &quot;username&quot;: &quot;&quot;, //用户名 &quot;password&quot;: &quot;&quot;, //密码 &quot;protocol&quot;: &quot;sftp&quot;, //模式 &quot;agent&quot;: null, &quot;privateKeyPath&quot;: null, &quot;passphrase&quot;: null, &quot;passive&quot;: false, &quot;interactiveAuth&quot;: false, &quot;remotePath&quot;: &quot;/root/node/build/&quot;, //服务器上的文件地址 &quot;context&quot;: &quot;./server/build&quot;, //本地的文件地址 &quot;uploadOnSave&quot;: true, //监听保存并上传 &quot;syncMode&quot;: &quot;update&quot;, &quot;watcher&quot;: &#123; //监听外部文件 &quot;files&quot;: false, //外部文件的绝对路径 &quot;autoUpload&quot;: false, &quot;autoDelete&quot;: false &#125;, &quot;ignore&quot;: [ //忽略项 &quot;**/.vscode/**&quot;, &quot;**/.git/**&quot;, &quot;**/.DS_Store&quot; ]&#125; 颜色主题推荐： SynthWave ‘84SynthWave &#39;84 这个主题很酷。 Live Share：实时编码分享Live Share这个神奇的插件是由微软官方出品，它的作用是：实时编码分享。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是结对编程的神器啊。 安装方式： 打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮： 上图中，点击红框部分，登录后就可以分享你的工作空间了。 Settings Sync 地址：https://github.com/shanalikhan/code-settings-sync 作用：多台设备之间，同步 VS Code 配置。 vscode-pigmentscss颜色高亮显示。 vscode-syncing 地址：https://github.com/nonoroazoro/vscode-syncing 作用：多台设备之间，同步 VS Code 配置。 参考链接 https://segmentfault.com/a/1190000012811886 最后一段如果你有什么推荐的 VS Code 插件，欢迎留言。 同时，你也可以关注我在 GitHub 上的 前端入门项目，超级详细和真诚。","categories":[],"tags":[]},{"title":"","slug":"大前端/18-推荐链接/2019-推荐文章","date":"2021-08-06T01:17:25.647Z","updated":"2021-07-28T07:34:11.404Z","comments":true,"path":"2021/08/06/大前端/18-推荐链接/2019-推荐文章/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/18-%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/2019-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","excerpt":"","text":"积累平时看到的一些好的前端文章。 记录平时遇到的优质技术文章，按时间先后排序。 2019-05-11 《博客园美化教程大集合—-极致个性化你的专属博客（超详细，看这篇就够了）》 网上写图文教程的人，还真是贴心。","categories":[],"tags":[]},{"title":"","slug":"大前端/18-推荐链接/2018-推荐文章","date":"2021-08-06T01:17:25.645Z","updated":"2021-07-28T07:34:11.404Z","comments":true,"path":"2021/08/06/大前端/18-推荐链接/2018-推荐文章/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/18-%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/2018-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","excerpt":"","text":"积累平时看到的一些好的前端文章。 记录平时遇到的优质技术文章，按时间先后排序。 2017-01-20 阿里9年，我总结的前端架构演进3大阶段及团队管理心法 伟明的推荐，说是对前端开发的价值观形成有良好的影响。 2017-07-13 前端开发面试题 在逛公众号「前端大全」的时候发现的，然后顺着找到了对应的GitHub链接。面试题有答案哦。 2017-07-31 你可能不需要 Vuex 这篇文章里的流程图画得挺好看的，gif图也很小，只有200多kb。我发邮件问作者用的什么软件，很幸运的是，得到了作者的回复。答案是： 录制 GIF：licecap 画图：processon免费在线作图 2017-08-01 资深Web技术专家曹刘阳：2016年前端技术观察 有很多争议，知乎上都有人评论了。 2017-08-16 道阻且长啊TAT(前端面试总结) 作者毕业于华科，面的是前端的实习，还拿了不少offer：百度外卖，头条，美团，狗东，其他，最终在美团实习。我最初是在微信公众号上看到的文章。 hello。我看你拿了不少实习offer。有没有推荐的前端学习资料呀？比如说：网站、链接、书籍等。可否分享给我？如果内容较多，欢迎发表成博客。谢啦～～～ 2017-08-17 面试分享：一年经验初探阿里巴巴前端社招 在公众号「web前端课程」上看到的文章。作者经历了4面，也是厉害了。另外，作者在gihub上的博客也是出彩的。比如说下面这篇文章就值得推荐： 挖 “掘” 淘 “金” 之 前端闯关历险记学习资料汇总 作者搜集了几百篇在掘金上看到的好文章，让人惊叹。 2017-09-15 你所不知道的 CSS 滤镜技巧与细节 2017-09-19 适合程序员的写作技法 写作过程包括下面的部分： 需求 设计 实现 测试 交付 2018-01-09 翻译 | 像 JavaScript 一样思考 在MacTalk的小密圈里看到有人分享。 大前端公共知识杂谈 小白谈数据脱敏 2018-01-10 MAC全栈开发环境搭建指南 今天发现这个网址，感觉还不错。在里面发现了一个比较好的Sublime Text主题。 介绍几个上网+分流+图床工具 2018-01-12 张鑫旭 | 话说我为什么要闭关学习 作者闭关学习了半年的前端。 2018-01-17 你的简历能帮你争取到面试机会吗 漫话JavaScript与异步·第三话——Generator：化异步为同步 2017-01-19 一个三年工作经验的软件工程师的经验之谈 2018-01-22 前端程序员容易忽视的一些基础知识 2018-01-23 2018 前端趋势：更一致，更简单 2018-01-24推荐一个网站，名叫：web骇客。网址：http://www.webhek.com/ 比如： 电影里敲代码的样子：http://www.webhek.com/post/hackertyper.html 测试眼睛对颜色的敏感程度：http://www.webhek.com/post/color-test.html 2018-01-25 面试分享：一年经验初探阿里巴巴前端社招 一般阿里社招都是招3-5年的P6+高级工程师。面试官明知道作者只有一年工作经验，在面了这么多轮之后却来一句：“我们只要高工”。这是不是太欺负人了？ 2018-01-28 WEB前端工作五年了，我来告诉你如何系统的学习现在的JAVASCRIPT 2018-01-29 最棒的 JavaScript 学习指南（2018版） 我们为什么选择Vue.js而不是React 【长文慎入】通信十年—通信行业分析与跳槽之路 我在深圳南山写代码：是在改变世界还是养家糊口 2018-01-31 我所理解的前端 2018-02-02 开发人员的奋斗目标 2018-03-21 十倍效能提升——Web 基础研发体系的建立 2018-01-29长期写博客的人，最少能证明他是一个善于思考和总结的人。 这句话的来源：我依然坚持建议你开始写博客 | 写给我的 2017 2018-03-21 不谈面试题，谈谈招聘时我喜欢见到的特质 2018-04-16 Jerry和您聊聊Chrome开发者工具 2018-05-01 What makes a good front end engineer 2018-05-31 一个bit一个bit的进行 Base64 白话科普，看不懂算你输 2018-06-23 技术的热门度曲线 2018-07-03 浅谈XXE攻击 关于XXE攻击，这几天微信支付被爆出漏洞，使用微信支付的各个业务都在努力修补。 2018-12-01 零基础转行前端，一年工作经验，我如何入职蚂蚁金服","categories":[],"tags":[]},{"title":"","slug":"大前端/18-推荐链接/03-推荐网站","date":"2021-08-06T01:17:25.642Z","updated":"2021-07-28T07:34:11.404Z","comments":true,"path":"2021/08/06/大前端/18-推荐链接/03-推荐网站/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/18-%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/03-%E6%8E%A8%E8%8D%90%E7%BD%91%E7%AB%99/","excerpt":"","text":"2018-10-26 前端面试图谱：https://yuchengkai.cn/docs/zh/ 这个项目已经很全面了，是从面试的角度出发的。我自己的项目是，是从基础入门的角度出发的。可以起到互补的作用。 2018-12-07 css的各种效果实现：https://lhammer.cn/You-need-to-know-css/#/ css的各种效果实现（尤其是动画效果），关键时刻能救命。作者内化后输出，并贡献出来。这种也是颇为难得了。很有极客精神。 比如，我在这里面找到了「抖动效果」，很有帮助。 2018-12-17 github排行：http://githubrank.com/","categories":[],"tags":[]},{"title":"","slug":"大前端/18-推荐链接/01-2019年Web前端最新导航","date":"2021-08-06T01:17:25.639Z","updated":"2021-07-28T07:34:11.404Z","comments":true,"path":"2021/08/06/大前端/18-推荐链接/01-2019年Web前端最新导航/","link":"","permalink":"https://alloceee.github.io/2021/08/06/%E5%A4%A7%E5%89%8D%E7%AB%AF/18-%E6%8E%A8%E8%8D%90%E9%93%BE%E6%8E%A5/01-2019%E5%B9%B4Web%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E5%AF%BC%E8%88%AA/","excerpt":"","text":"本文的最新内容将在GitHub上实时更新。欢迎在GitHub上关注我，一起入门和进阶前端。 前言本文列出了很多与前端有关的常见网站、博客、工具等，整体来看比较权威。有些东西已经过时了，我就不列出来了。 学是一方面，也是最主要的方面；但还有一个作用，比如，“这个前端框架你都不知道啊”、“这个前端大牛你都没听说过啊” ，此时，这份清单就能起到作用了。如果你能把清单里列出的内容都了解下，逼格也会高很多。 技术社区 GitHub：https://github.com/ 高质量的内容创作和分享平台。 请记住，作为一个码农，GitHub 代表了你的名片。 stackoverflow：https://stackoverflow.com/ 遇到技术问题请先Google，很多答案都能在 stackoverflow 上找到。 技术博客 掘金：https://juejin.im/ 掘金已经被前端同学攻陷了。目前来看，国内的很多优质前端文章，都在掘金上。 如果你刚开始写前端博客，可以考虑在掘金上发文章。当然，文章最好在掘金、博客园、知乎上做同步。 博客园：https://www.cnblogs.com/ 一个很纯粹的技术博客平台。 知乎：https://www.zhihu.com/ 很多做技术的同学也开始玩知乎了，阿里的不少前端大牛在知乎上就非常活跃。 CSDN：https://www.csdn.net/ 广告太多，但奈何你这么老牌。 segmentfault：https://segmentfault.com/ 比较低调的技术博客平台。 GitHub 排名统计 GitHub 中国区排名：https://githuber.cn/search?language=JavaScript 这个网站虽然比较小众，但排名还是相对比较准的。 GitHub 中国区排名：http://githubrank.com/ 这个排名很久没更新了，早就不准了；而且还经常打不开。 GitHub 全球排名：https://gitstar-ranking.com/ 这个排名，就比较权威了。 GitHub trending（官网推荐）：https://github.com/trending 你的项目要是能上 GitHub trending，绝对火得一塌糊涂。 资讯 虎嗅网：https://www.huxiu.com/ 36氪：https://36kr.com/ 利器：https://liqi.io/ 采访优秀的创造者，邀请他们来分享工作时所使用的工具。 湾区日报：https://wanqu.co/ 每天推送 5 篇优质英文文章。 Solidot：https://www.solidot.org/ 品玩：https://www.pingwest.com/ 极客公园：http://www.geekpark.net/ 框架 Vue.js：https://cn.vuejs.org/ React：https://reactjs.org/ Angular：https://angular.cn/ AngularJS：https://angularjs.org/ Koa：https://koa.bootcss.com/ 基于 Node.js 平台的下一代 Web 开发框架。 Express：http://www.expressjs.com.cn/ 基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 Egg：https://eggjs.org/zh-cn/ Egg 继承于 Koa。 Koa 是一个非常优秀的框架，然而对于企业级应用来说，它还比较基础。而 Egg 选择了 Koa 作为其基础框架，在它的模型基础上，进一步对它进行了一些增强。 Electron：https://www.electronjs.cn/ Electron（原名为Atom Shell）是GitHub开发的一个开源js框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。 也就是说，我们可以用 js 语言开发客户端软件了。其实呢，VS Code 这个客户端软件就是用 js 语言写的。 Redux：https://www.redux.org.cn/ Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 ReactNative：https://reactnative.cn/ 使用JavaScript编写原生移动应用。 mpvue：http://mpvue.com/ 基于 Vue.js 的小程序开发框架。 UI框架 Bootstrap：http://www.bootcss.com/ ElementUI：http://element-cn.eleme.io/ 基于 Vue.js 的组件库。 iView：https://www.iviewui.com/ 一套基于 Vue.js 的高质量 UI 组件库。 Ant Design：https://ant.design 基于 React 的 UI 组件库，主要用于研发企业级中后台产品。官网推出了 Ant Design pro 作为示例，可以看看。 Ant Design Mobile：https://mobile.ant.design/ 一个基于 Preact / React / React Native 的 移动端 UI 组件库。 Ant Design of Vue：https://vue.ant.design/docs/vue/introduce-cn/ Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 类库 jQuery：http://jquery.com/ Zepto.js：https://zeptojs.com/ 可以理解成是移动端的 jQuery。 ECharts：https://echarts.baidu.com/ 使用 JavaScript 实现的开源可视化库。 CSS Sass：https://sass-lang.com/ Sass 是成熟、稳定、强大的 CSS 扩展语言。入门文档可以看：http://sass.bootcss.com/ Less：http://lesscss.org/ 给 CSS 加点料。入门文档可以看：https://less.bootcss.com/ Stylus：http://stylus-lang.com/ 构建 NPM：https://www.npmjs.com/ Yarn：https://yarnpkg.com/zh-Hans/ Webpack：https://webpack.js.org/ Gulp：https://www.gulpjs.com.cn/ Babel：https://babeljs.io/ ESLint：https://cn.eslint.org/ 可组装的JavaScript和JSX检查工具。 PostCSS：https://www.postcss.com.cn/ 用 JavaScript 工具和插件转换 CSS 代码的工具 调试抓包 whistle：https://wproxy.org/whistle/ 代理抓包工具，很好很强大。 Fiddler：https://www.telerik.com/fiddler 代理抓包工具。 Mock数据 Easy Mock：https://www.easy-mock.com 编辑器 &amp;&amp; IDE VS Code：https://code.visualstudio.com/ Sublime Text：https://www.sublimetext.com/ WebStorm：https://www.jetbrains.com/webstorm/ Atom：https://atom.io/ 编码规范 Bootstrap编码规范：https://codeguide.bootcss.com/ es6编程风格：http://es6.ruanyifeng.com/#docs/style Airbnb Javascript Style Guide：https://github.com/airbnb/javascript 静态站点搭建工具 Hexo：https://hexo.io/zh-cn/ VuePress：https://www.vuepress.cn/ GitBook：https://www.gitbook.com/ 设计工具 墨刀：原型设计工具。网址：https://modao.cc/ 蓝湖：一款产品文档和设计图的在线协作平台。网址：https://lanhuapp.com PxCook（像素大厨）：高效易用的自动标注工具。软件下载链接：https://www.fancynode.com.cn/pxcook 图标 Font Awesome：http://www.fontawesome.com.cn/ Iconfont：https://www.iconfont.cn/ icomoon：https://icomoon.io/ EasyIcon：https://www.easyicon.net/ icons8：https://icons8.cn/ IconStore：https://iconstore.co/ iconninja：http://www.iconninja.com/ 工具综合类 CanIUse：https://caniuse.com/ 浏览器兼容性查询。前端同学必须要知道。 国家企业信用信息公示系统：http://www.gsxt.gov.cn 通过这个网站，我们可以查到任何一家公司的基本信息（成立时间、法定代表人等）。如果你在这个网站上没有找到某公司的信息，放心吧，这个公司一定是个骗子。 ProcessOn：https://www.processon.com/ 在线制作流程图。推荐。 幕布：https://mubu.com 极简大纲笔记、一键生成思维导图。非常好用。 JSON格式化：http://www.bejson.com/ 草料二维码：https://cli.im/ 短链生成：http://www.sina.lt GitHub短网址：https://git.io/ 图片压缩：https://www.yasuotu.com/ 在线PS：https://www.photopea.com/ 图片在线裁剪：https://www.asqql.com/gifc/ 多数据源IP地址查询：https://haoip.cn/ Gif添加字幕：http://www.yingjingtu.com/ Photoshop的投影参数转换为 CSS代码：https://psd2css.mezw.com/ 将Photoshop设计文件图层中的混合选项参数快速转换为CSS3代码，以节省前端开发人员的时间和精力。 Get Emoji：https://emoji.svend.cc/ 图片转Ascii：http://picascii.com/ 视频转GIF：https://github.com/vvo/gifify OCR文字识别：https://app.xunjiepdf.com/ocr 图片类 图片转base64：http://imgbase64.duoshitong.com/ 团队 腾讯AlloyTeam：http://www.alloyteam.com/ 腾讯社交用户体验ISUX：https://isux.tencent.com/ 淘宝FED | 淘宝前端团队：http://taobaofed.org/ 阿里巴巴国际UED：http://www.aliued.com/ 京东 | 凹凸实验室：https://aotu.io/ 饿了么前端:https://zhuanlan.zhihu.com/ElemeFE 百度前端研发部FEX：http://fex.baidu.com/ 360 | 奇舞团：https://75team.com/ 知道创宇FED：https://knownsec-fed.com/ 前端大牛阮一峰（蚂蚁金服） GitHub：https://github.com/ruanyf 博客：http://www.ruanyifeng.com/blog/ 尤雨溪 GitHub：https://github.com/yyx990803 博客：http://blog.evanyou.me/ 知乎：https://www.zhihu.com/people/evanyou 玉伯 GitHub：https://github.com/lifesinger 博客：https://github.com/lifesinger/blog 知乎：https://www.zhihu.com/people/lifesinger 司徒正美（去哪儿） GitHub：https://github.com/RubyLouvre 博客：http://www.cnblogs.com/rubylouvre/ 知乎：https://www.zhihu.com/people/si-tu-zheng-mei 张鑫旭（腾讯） GitHub：https://github.com/zhangxinxu 博客：https://www.zhangxinxu.com/ 知乎：https://www.zhihu.com/people/iamzhangxinxu 迷渡 GitHub：https://github.com/justjavac 知乎：https://www.zhihu.com/people/justjavac.com 羡辙 | Ovilia GitHub：https://github.com/Ovilia 知乎：https://www.zhihu.com/people/ovilia 云谦（陈成） GitHub：https://github.com/sorrycc 博客：https://sorrycc.com/ 云谦装了啥：https://github.com/sorrycc/awesome-tools 偏右 GitHub：https://github.com/afc163 知乎：https://www.zhihu.com/people/afc163 黄峰达/Phodal Huang（ThoughtWorks） GitHub：https://github.com/phodal 博客：https://www.phodal.com/ 知乎：https://www.zhihu.com/people/phodal 贺师俊/Hax（百姓网） GitHub：https://github.com/hax 博客：http://johnhax.net/ 知乎：https://www.zhihu.com/people/he-shi-jun 大漠链接： GitHub：https://github.com/airen 大漠的GitHub上没啥东西。 博客：https://www.w3cplus.com 知乎：https://www.zhihu.com/people/w3cplus 介绍： 常用昵称“大漠”，W3CPlus创始人，目前就职于淘宝。对HTML5、CSS3和CSS处理器等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对CSS3和动画的研究，是国内最早研究和使用CSS3和CSS处理器技术的一批人。现在主要在探讨学习JavaScript、React和Vue相关技术知识。CSS、CSS处理器和Web动画中国布道者。2014年出版《图解CSS3：核心技术与案例实战》。 EGOIST 博客：https://egoist.sh/ GitHub：https://github.com/egoist 冴羽链接： GitHub：https://github.com/mqyqingfeng 博客：https://github.com/mqyqingfeng/Blog 知乎：https://www.zhihu.com/people/qing-feng-yi-yang 李靖/小胡子哥（淘宝网） GitHub：https://github.com/barretlee 博客：https://www.barretlee.com/ 知乎：https://www.zhihu.com/people/barretlee/ cangdu GitHub：https://github.com/bailicangdu Jackson Tian GitHub：https://github.com/JacksonTian 博客：http://jacksontian.org/ 题叶（饿了么、前 Teambition） GitHub：https://github.com/jiyinyiyong 博客：http://tiye.me/ 杨健（今日头条） GitHub：https://github.com/hardfist 知乎：https://www.zhihu.com/people/hardfist 流形 （阿里巴巴数据技术与产品部前端团队负责人） 知乎：https://www.zhihu.com/people/arcthur/ 总结如果你有发现新的内容，欢迎在 GitHub 上提交 issues。","categories":[],"tags":[]},{"title":"第12章：嵌入式系统设计","slug":"SystemArchitect/第12章：嵌入式系统设计","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-08T06:09:50.437Z","comments":true,"path":"2021/08/05/SystemArchitect/第12章：嵌入式系统设计/","link":"","permalink":"https://alloceee.github.io/2021/08/05/SystemArchitect/%E7%AC%AC12%E7%AB%A0%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"5.嵌入式数据库管理系统嵌入式系统的数据库系统称为嵌入式数据库系统或嵌入式实时数据库系统。 嵌入式系统必须能够在没有人工干预的情况下，长时间不间断地运行，因此要求高的可靠性。同时要求数据库操作具备可预知性，并且系统的大小和性能也都必须是可预知的，以保证系统的性能。嵌入式系统需要与底层硬件打交道，因此在数据管理时，也要有底层控制的能力，如什么时候会发生磁盘操作，磁盘操作的次数，如何控制等。底层控制的能力是决定数据库管理操作的关键。 嵌入式数据库管理系统一般只提供本机服务接口，为前端应用提供基本的数据支持。 ​ 通常，嵌入式数据库管理系统就是在嵌入式设备上使用的数据库管理系统。由于用到嵌入式数据库管理系统的多是移动信息设备，诸如掌上电脑、PDA、车载设备等移动通信设备，位置固定的嵌入式设备很少用到，所以，嵌入式数据库也称为移动数据库或嵌入式移动数据库。其作用主要是解决移动计算环境下数据的管理问题，移动数据库是移动计算环境中的分布式数据库。 5.1使用环境的特点（1）设备随时移动性，嵌入式数据库主要用于移动信息设备上，设备的位置经常随使用者一起移动。 （2）网络频繁断接，移动设备或移动终端在使用的过程中，位置经常发生变化，同时也受到使用方式、电源、无线通信及网络条件等因素的影响。所以，一般并不持续保持网络连接，而是经常主动或被动地间歇性断接和连接。 （3）网络条件多样化，由于移动信息设备位置的经常变化，所以移动信息设备同数据服务器在不同的时间可能通过不同的网络系统连接。这些网络在网络带宽、通信代价、网络延迟、服务质量等方面可能有所差异。 （4）通信能力不对称，由于受到移动设备的资源限制，移动设备与服务器之间的网络通信能力是非对称的。移动设备的发送能力都非常有限，使得数据服务器到移动设备的下行通信带宽和移动设备到数据服务器之间的上行带宽相差很大。 5.2系统组成与关键技术一个完整的嵌入式数据库管理系统由若干子系统组成，包括主数据库管理系统（嵌入式数据库管理系统）、同步服务器、嵌入式数据库管理系统、连接网络。 （1）嵌入式数据库管理系统。嵌入式数据库管理系统是一个功能独立的单用户数据库管理系统。它可以独立于同步服务器和主数据库管理系统运行，对嵌入式系统中的数据进行管理，也可以通过同步服务器连接到主服务器上，对主数据库中的数据进行操作，还可以通过多种方式进行数据同步。 （2）同步服务器。同步服务器是嵌入式数据库和主数据库之间的连接枢纽，保证嵌入式数据库和主数据库中数据的一致性。 （3）数据服务器。数据服务器的主数据库及数据库管理系统可以采用 Oracle 或 Sybase等大型通用数据库系统。 （4）连接网络。主数据库服务器和同步服务器之间一般通过高带宽、低延迟的固定网络进行连接。移动设备和同步服务器之间的连接根据设备的具体情况可以是无线局域网、红外连接、通用串行线或公众网等。 嵌入式移动数据库在应用中的关键 嵌入式移动数据库在实际应用中必须解决好数据的一致性（复制性）、高效的事务处理和数据的安全性等问题。 （1）数据的一致性。嵌入式移动数据库的一个显著特点是，移动数据终端之间及与同步服务器之间的连接是一种弱连接，即低带宽、长延迟、不稳定和经常性短接。为了支持用户在弱环境下对数据库的操作，现在普遍采用乐观复制方法（Optimistic Replication 或 Lazy Replication）允许用户对本地缓存上的数据副本进行操作。待网络重新连接后再与数据库服务器或其他移动数据终端交换数据修改信息，并通过冲突检测和协调来恢复数据的一致性。 （2）高效的事务处理。移动事务处理要在移动环境中频繁的、可预见的断接情况下进行。为了保证活动事务的顺利完成，必须设计和实现新的事务管理策略和算法。 根据网络连接情况来确定事务处理的优先级，网络连接速度高的事务请求优先处理； 根据操作时间来确定事务是否迁移，即长时间的事务操作将全部迁移到服务器上执行，无须保证网络的一直畅通； 根据数据量的大小来确定事务是上载执行还是下载数据副本执行后上载； 完善的日志记录策略； 事务处理过程中，网络断接处理时采用服务器发现机制还是采用客户端声明机制； 事务移动（如：位置相关查询）过程中的用户位置属性的实时更新。 （3）数据的安全性。许多应用领域的嵌入式设备是系统中数据管理或处理的关键设备，因此嵌入式设备上的数据库系统对存取权限的控制较严格。同时，许多嵌入式设备具有较高的移动性、便携性和非固定的工作环境，也带来潜在的不安全因素。此外，某些数据的个人隐私性又很高，因此在防止碰撞、磁场干扰、遗失、盗窃等方面对个人数据的安全性需要提供充分的保证。 保证数据安全的主要措施是： 对移动终端进行认证，防止非法终端的欺骗性接入； 对无线通信进行加密，防止数据信息泄漏； 对下载的数据副本加密存储，以防移动终端物理丢失后的数据泄密 移动数据库管理系统的特性 ​ 移动 DBMS 的计算环境是传统分布式 DBMS 的扩展，它可以看做客户端与固定服务器结点动态连接的分布式系统。因此移动计算环境中的数据库管理系统是一种动态分布式数据库管理系统。由于嵌入式移动数据库管理系统在移动计算的环境下应用在嵌入式操作系统之上，所以它有自己的特点和功能需求： （1）微核结构，便于实现嵌入式功能。考虑到嵌入式设备的资源有限，嵌入式移动 DBMS 应采用微型化技术实现，在满足应用的前提下紧缩其系统结构以满足嵌入式应用的需求。 （2）对标准 SQL 的支持。嵌入式移动 DBMS 应能提供对标准 SQL 的支持。支持SQL92 标准的子集，支持数据查询（连接查询、子查询、排序、分组等）、插入、更新、删除多种标准的 SQL 语句，充分满足嵌入式应用开发的需求。 （3）事务管理功能。嵌入式移动 DBMS 应具有事务处理功能，自动维护事务的完整性、原子性等特性；支持实体完整性和引用完整性。 （4）完善的数据同步机制。数据同步是嵌入式数据库最重要的特点。通过数据复制，可以将嵌入式数据库或主数据库的变化情况应用到对方，保证数据的一致性。 嵌入式移动数据库管理系统的数据同步机制应具有以下几个特点： 提供多种数据同步方式，具有上载同步、下载同步和完全同步 3 种同步方式； 具有完善的冲突检测机制和灵活的冲突解决方案，具有冲突日志记录功能； 支持快速同步，系统同步时，只传递变化的数据，节省了大量的同步时间； 支持表的水平分割和垂直分割复制，最大限度地降低了嵌入式数据库的大小； 支持异构数据源连接同步，可以用支持 ODBC 的异构数据源作为主数据库和嵌入式设备上的数据库进行数据同步； 具有主动同步的功能，允许用户对系统提供的同步事件自定义过程实现，提供了最大灵活度的同步过程 （5）支持多种连接协议。嵌入式移动 DBMS 应支持多种通信连接协议。可以通过串行通信、TCP/IP、红外传输、蓝牙等多种连接方式实现与嵌入式设备和数据库服务器的连接。 （6）完备的嵌入式数据库管理功能。嵌入式移动 DBMS 应具有自动恢复功能，基本无须人工干预进行嵌入式数据库管理并能够提供数据的备份和恢复，保证用户数据的安全可靠。 （7）平台无关性与支持多种嵌入式操作系统。嵌入式移动 DBMS 应能支持 Windows CE、Palm OS 等多种目前流行的嵌入式操作系统，这样才能使嵌入式移动数据库管理系统不受移动终端的限制。 （8）零管理特性。嵌入式数据库具有自动恢复功能，不需要人工干预就可以进行嵌入式数据库管理，并提供数据的备份与同步。 另外，一种理想的状态是用户只用一台移动终端（如手机）就能对与它相关的所有移动数据库进行数据操作和管理。这就要求前端系统具有通用性，而且要求移动数据库的接口有统一、规范的标准。前端管理系统在进行数据处理时自动生成统一的事务处理命令，提交当前所连接的数据服务器执行。这样就有效地增强了嵌入式移动数据库管理系统的通用性，扩大了嵌入式移动数据库的应用前景。 总之，在嵌入式移动数据库管理系统中还需要考虑诸多传统计算环境下不需要考虑的问题，如对断接操作的支持、对跨区长事务的支持、对位置相关查询的支持、对查询优化的特殊考虑及对提高有限资源的利用率和对系统效率的考虑等。为了有效地解决上述问题，诸如复制与缓存技术、移动事务处理、数据广播技术、移动查询处理与查询优化、位置相关的数据处理及查询技术、移动信息发布技术、移动 Agent 等技术仍在不断地发展和完善，会进一步促进嵌入式移动数据库管理系统的发展。 6.实时系统与嵌入式操作系统PCI（Peripheral ComponentInt Interconnect）总线标准是一种局部并行总线标准，常用来表示个人计算机中使用最为广泛的接口，几乎所有的主板产品行都带有这种插槽。 GUI(Graphical User Interface)常用来表示采用图形方式显示的计算机操作用户界面。 API(Application Programming Interface，应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，开发人员无须访问源码(或理解内部工作机制的细节)。 编程DSP芯片编程DSP芯片是一种具有特殊结构的微处理器，为了达到快速进行数字信号处理的目的，DSP芯片一般都采用特殊的软件硬件结构： （1）哈佛结构。 DSP采用了哈佛结构，将存储器空间划分成两个，分别存储程序和数据。它们有两组总线连接到处理器核，允许同时对它们进行访问，每个存储器独立编址，独立访问。这种安排将处理器的数据吞吐率加倍，更重要的是同时为处理器核提供数据与指令。在这种布局下，DSP得以实现单周期的MAC指令。 在哈佛结构中，由于程序和数据存储器在两个分开的空间中，因此取指和执行能完全重叠运行。 （2）流水线。 与哈佛结构相关，DSP芯片广泛采用2-6级流水线以减少指令执行时间，从而增强了处理器的处理能力。这可使指令执行能完全重叠，每个指令周期内，不同的指令都处于激活状态。 （3）独立地硬件乘法器。 在实现多媒体功能及数据信号处理的系统中，算法的实现和数字滤波都是计算密集型的应用。在这些场合，乘法运算是数字处理的重要组成部分，是各种算法实现的基本元素之一。乘法的执行速度越快，DSP处理器的性能越高。相比与一般的处理器需要30-40个指令周期，DSP芯片的特征就是有一个专用的硬件乘法器，乘法可以在一个周期内完成。 （4）特殊的DSP指令。 DSP的另一特征是采用特殊的指令，专为数字信号处理中的一些常用算法优化。这些特殊指令为一个典型的数字处理提供加速，可以大幅提高处理器的执行效率。使一些高速系统的实时数据处理成为可能。 （5）独立地DMA总线和控制器。 有一组或多组独立的DMA总线，与CPU的程序、数据总线并行工作。在不影响CPU工作的条件下，DMA的速度已经达到800MB/S以上。在这需要大数据量进行交换的场合可以减少CPU的开销，提高数据的吞吐率。提高系统的并行执行能力。 （6）多处理器接口。 使多个处理器可以很方便的并行或串行工作以提高处理速度。 （7）JTAP（Joint Test Action Group）标准测试接口（IEEE 1149标准接口）。 便于对DSP作片上的线仿真和多DSP条件下的调试。 （8）快速地指令周期。 哈佛结构，流水线操作，专用的硬件乘法器，特殊的DSP指令加上集成电路的优化设计，可是DSP芯片的指令周期在10ns以下。快速地指令周期可以使DSP芯片能够实时实现许多DSP应用。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"嵌入式系统设计","slug":"嵌入式系统设计","permalink":"https://alloceee.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"author":"Alloceee"},{"title":"MySQL分库分表","slug":"数据库/MySQL/MySQL分库分表","date":"2021-08-04T05:00:11.345Z","updated":"2021-08-05T06:55:07.262Z","comments":true,"path":"2021/08/04/数据库/MySQL/MySQL分库分表/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/","excerpt":"第一部分：实际网站发展过程中面临的问题 第二部分：有哪几种切分方式，垂直和水平的区别和适用面 第三部分：目前市面有的一些开源产品，技术，他们的优缺点是什么 第四部分：最重要的，为什么不建议水平分库分表，这能让你在规划前期谨慎对待，规避掉切分造成的问题","text":"第一部分：实际网站发展过程中面临的问题 第二部分：有哪几种切分方式，垂直和水平的区别和适用面 第三部分：目前市面有的一些开源产品，技术，他们的优缺点是什么 第四部分：最重要的，为什么不建议水平分库分表，这能让你在规划前期谨慎对待，规避掉切分造成的问题 名词解释库：database；表：table；分库分表：sharding 数据库架构演变刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们将数据库的写操作和读操作进行分离， 使用多个从库副本（Slaver Replication）负责读，使用主库（Master）负责写， 从库从主库同步更新数据，保持数据一致。架构上就是数据库主从同步。从库可以水平扩展，所以更多的读请求不成问题。 但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。 这时就需要用到分库分表（sharding），对写操作进行切分。 分库分表前的问题任何问题都是太大或者太小的问题，我们这里面对的数据量太大的问题。 用户请求量太大因为单服务器TPS，内存，IO都是有限的。解决方法：分散请求到多个服务器上；其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。 单库太大单个数据库处理能力有限；单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈 解决方法：切分成更多更小的库 单表太大CURD都成问题；索引膨胀，查询超时 解决方法：切分成多个数据集更小的表 分库分表的方式方法一般是垂直切分和水平切分，这是一种结果集描述的切分方式，是物理空间上的切分。我们从面临的问题，开始解决，阐述：首先是用户请求量太大，我们就堆机器搞定。 然后是单个库太大，这时我们要看是因为表多而导致数据多，还是因为单张表里面的数据多。如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。 如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表。分库分表的顺序应该是先垂直分，后水平分。因为垂直分更简单，更符合我们处理现实世界问题的方式。 垂直拆分 垂直分表 也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的，数据较大，长度较长（比如text类型字段）的拆分到“扩展表”。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。 垂直分库 垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Product一个库，订单Order一个库。切分后，要放在多个服务器上，而不是一个服务器上。为什么？我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之间，全部都是落到单一的库上的，这会放数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上，随着用户量增大，这会让单个数据库的处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上，随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧，所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。 数据库业务层面的拆分，和服务的治理，降级机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。 水平拆分 水平分表 针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。 水平分库分表 将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集中不同。水平分库分表能够有效地缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。 水平分库分表切分规则 a.RANGE 从0到10000一个表，10001到20000一个表； b.HASH取模 一个商场系统，一般都是将用户，订单作为主表，然后将和他们相关的作为附表，这样不会造成跨库事务之类的问题。取用户id，然后hash取模，分配到不同的数据库上。 c.地理区域 比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。 d.时间 按照时间切分，就是将6个月前，甚至一年前的数据切出来放到另外的一张表，因为随着时间流逝，这些表的数据被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。 分库分表后面临的问题事务支持分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 多库结果集合并（group by，order by）TODO 跨库joinTODO分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询就能够完成的业务，可能需要多次查询才能完成。粗略的解决方法：全局表：基础数据，所有库都拷贝一份。字段冗余：这样有些字段就不用join去查询了。系统层组装：分别查询出所有，然后组装起来，较复杂。 分库分表方案产品目前市面上的分库分表中间件相对较多，其中基于代理的方式的又MySQL Proxy和Amoeba，基于Hibernate框架的是Hiernate Shards，基于jdbc的有当当sharding-jdbc，基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding，通过重写spring的ibatis tamplate类的Cobar Client。 还有一些大公司的开源产品：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"}],"author":"Alloceee"},{"title":"","slug":"数据结构与算法/八种经典排序算法","date":"2021-08-04T03:20:11.441Z","updated":"2021-08-04T03:17:18.620Z","comments":true,"path":"2021/08/04/数据结构与算法/八种经典排序算法/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%AB%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言算法和数据结构是一个程序员的内功，所以经常在一些笔试中都会要求手写一些简单的排序算法，以此考验面试者的编程水平。下面我就简单介绍八种常见的排序算法，一起学习一下。 一、冒泡排序思路： 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数； 排除最大的数，接着下一轮继续相同的操作，确定第二大的数… 重复步骤1-3，直到排序完成。 动画演示： 实现代码： 1234567891011121314151617181920212223242526272829/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BubbleSort * @date 2020-09-05 21:38 **/public class BubbleSort extends BaseSort &#123; public static void main(String[] args) &#123; BubbleSort sort = new BubbleSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;//10万个数的数组，耗时：21554毫秒 平均时间复杂度：O(n²) 空间复杂度：O(1) 算法稳定性：稳定 二、插入排序思路： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在前面已排序的元素序列中，从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动画演示： 实现代码： 123456789101112131415161718192021222324252627282930313233/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name InsertSort * @date 2020-09-05 22:34 **/public class InsertSort extends BaseSort &#123; public static void main(String[] args) &#123; BaseSort sort = new InsertSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; nums.length - 1; i++) &#123; //当前值 int curr = nums[i + 1]; //上一个数的指针 int preIndex = i; //在数组中找到一个比当前遍历的数小的第一个数 while (preIndex &gt;= 0 &amp;&amp; curr &lt; nums[preIndex]) &#123; //把比当前遍历的数大的数字往后移动 nums[preIndex + 1] = nums[preIndex]; //需要插入的数的下标往前移动 preIndex--; &#125; //插入到这个数的后面 nums[preIndex + 1] = curr; &#125; &#125;&#125;//10万个数的数组，耗时：2051毫秒 平均时间复杂度：O(n²) 空间复杂度：O(1) 算法稳定性：稳定 三、选择排序思路： 第一轮，找到最小的元素，和数组第一个数交换位置。 第二轮，找到第二小的元素，和数组第二个数交换位置… 直到最后一个元素，排序完成。 动画演示： 实现代码： 12345678910111213141516171819202122232425262728/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class SelectSort extends BaseSort &#123; public static void main(String[] args) &#123; SelectSort sort = new SelectSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = nums[i]; nums[minIndex] = temp; nums[i] = nums[minIndex]; &#125; &#125; &#125;&#125;//10万个数的数组，耗时：8492毫秒 平均时间复杂度：O(n²) 算法空间复杂度：O(1) 算法稳定性：不稳定 四、希尔排序思路： 把数组分割成若干(h)个小组(一般数组长度length/2)，然后对每一个小组分别进行插入排序。每一轮分割的数组的个数逐步缩小，h/2-&gt;h/4-&gt;h/8，并且进行排序，保证有序。当h=1时，则数组排序完成。 动画演示： 实现代码： 123456789101112131415161718192021222324252627282930313233343536/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class ShellSort extends BaseSort &#123; public static void main(String[] args) &#123; ShellSort sort = new ShellSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; int length = nums.length; int temp; //步长 int gap = length / 2; while (gap &gt; 0) &#123; for (int i = gap; i &lt; length; i++) &#123; temp = nums[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; nums[preIndex] &gt; temp) &#123; nums[preIndex + gap] = nums[preIndex]; preIndex -= gap; &#125; nums[preIndex + gap] = temp; &#125; gap /= 2; &#125; &#125;&#125;//10万个数的数组，耗时：261毫秒 平均时间复杂度：O(nlog2n) 算法空间复杂度：O(1) 算法稳定性：稳定 五、快速排序快排，面试最喜欢问的排序算法。这是运用分治法的一种排序算法。 思路： 从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。 采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。 对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。 左右两边数列递归结束后，排序完成。 动画演示： 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name SelectSort * @date 2020-09-06 22:27 **/public class QuickSort extends BaseSort &#123; public static void main(String[] args) &#123; QuickSort sort = new QuickSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125; private void quickSort(int[] nums, int star, int end) &#123; if (star &gt; end) &#123; return; &#125; int i = star; int j = end; int key = nums[star]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt; key) &#123; j--; &#125; while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123; i++; &#125; if (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; nums[star] = nums[i]; nums[i] = key; quickSort(nums, star, i - 1); quickSort(nums, i + 1, end); &#125;&#125;//10万个数的数组，耗时：50毫秒 平均时间复杂度：O(nlogn) 算法空间复杂度：O(1) 算法稳定性：不稳定 六、归并排序归并排序是采用分治法的典型应用，而且是一种稳定的排序方式，不过需要使用到额外的空间。 思路： 把数组不断划分成子序列，划成长度只有2或者1的子序列。 然后利用临时数组，对子序列进行排序，合并，再把临时数组的值复制回原数组。 反复操作1~2步骤，直到排序完成。 归并排序的优点在于最好情况和最坏的情况的时间复杂度都是O(nlogn)，所以是比较稳定的排序方式。 动画演示： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name MergeSort * @date 2020-09-08 23:30 **/public class MergeSort extends BaseSort &#123; public static void main(String[] args) &#123; MergeSort sort = new MergeSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; //归并排序 mergeSort(0, nums.length - 1, nums, new int[nums.length]); &#125; private void mergeSort(int star, int end, int[] nums, int[] temp) &#123; //递归终止条件 if (star &gt;= end) &#123; return; &#125; int mid = star + (end - star) / 2; //左边进行归并排序 mergeSort(star, mid, nums, temp); //右边进行归并排序 mergeSort(mid + 1, end, nums, temp); //合并左右 merge(star, end, mid, nums, temp); &#125; private void merge(int star, int end, int mid, int[] nums, int[] temp) &#123; int index = 0; int i = star; int j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (nums[i] &gt; nums[j]) &#123; temp[index++] = nums[j++]; &#125; else &#123; temp[index++] = nums[i++]; &#125; &#125; while (i &lt;= mid) &#123; temp[index++] = nums[i++]; &#125; while (j &lt;= end) &#123; temp[index++] = nums[j++]; &#125; //把临时数组中已排序的数复制到nums数组中 if (index &gt;= 0) System.arraycopy(temp, 0, nums, star, index); &#125;&#125;//10万个数的数组，耗时：26毫秒 平均时间复杂度：O(nlogn) 算法空间复杂度：O(n) 算法稳定性：稳定 七、堆排序大顶堆概念：每个节点的值都大于或者等于它的左右子节点的值，所以顶点的数就是最大值。 思路： 对原数组构建成大顶堆。 交换头尾值，尾指针索引减一，固定最大值。 重新构建大顶堆。 重复步骤2~3，直到最后一个元素，排序完成。 构建大顶堆的思路，可以看代码注释。 动画演示： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HeapSort * @date 2020-09-08 23:34 **/public class HeapSort extends BaseSort &#123; public static void main(String[] args) &#123; HeapSort sort = new HeapSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; heapSort(nums); &#125; private void heapSort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; //构建大根堆 createTopHeap(nums); int size = nums.length; while (size &gt; 1) &#123; //大根堆的交换头尾值，固定最大值在末尾 swap(nums, 0, size - 1); //末尾的索引值往左减1 size--; //重新构建大根堆 updateHeap(nums, size); &#125; &#125; private void createTopHeap(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; //当前插入的索引 int currIndex = i; //父节点的索引 int parentIndex = (currIndex - 1) / 2; //如果当前遍历的值比父节点大的话，就交换值。然后继续往上层比较 while (nums[currIndex] &gt; nums[parentIndex]) &#123; //交换当前遍历的值与父节点的值 swap(nums, currIndex, parentIndex); //把父节点的索引指向当前遍历的索引 currIndex = parentIndex; //往上计算父节点索引 parentIndex = (currIndex - 1) / 2; &#125; &#125; &#125; private void updateHeap(int[] nums, int size) &#123; int index = 0; //左节点索引 int left = 2 * index + 1; //右节点索引 int right = 2 * index + 2; while (left &lt; size) &#123; //最大值的索引 int largestIndex; //如果右节点大于左节点，则最大值索引指向右子节点索引 if (right &lt; size &amp;&amp; nums[left] &lt; nums[right]) &#123; largestIndex = right; &#125; else &#123; largestIndex = left; &#125; //如果父节点大于最大值，则把父节点索引指向最大值索引 if (nums[index] &gt; nums[largestIndex]) &#123; largestIndex = index; &#125; //如果父节点索引指向最大值索引，证明已经是大根堆，退出循环 if (largestIndex == index) &#123; break; &#125; //如果不是大根堆，则交换父节点的值 swap(nums, largestIndex, index); //把最大值的索引变成父节点索引 index = largestIndex; //重新计算左节点索引 left = 2 * index + 1; //重新计算右节点索引 right = 2 * index + 2; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;//10万个数的数组，耗时：38毫秒 平均时间复杂度：O(nlogn) 算法空间复杂度：O(1) 算法稳定性：不稳定 八、桶排序思路： 找出最大值，最小值。 根据数组的长度，创建出若干个桶。 遍历数组的元素，根据元素的值放入到对应的桶中。 对每个桶的元素进行排序(可使用快排，插入排序等)。 按顺序合并每个桶的元素，排序完成。 对于数组中的元素分布均匀的情况，排序效率较高。相反的，如果分布不均匀，则会导致大部分的数落入到同一个桶中，使效率降低。 动画演示(来源于五分钟学算法，侵删)： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name BucketSort * @date 2020-09-08 23:37 **/public class BucketSort extends BaseSort &#123; public static void main(String[] args) &#123; BucketSort sort = new BucketSort(); sort.printNums(); &#125; @Override protected void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; bucketSort(nums); &#125; public void bucketSort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; //找出最大值，最小值 int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int num : nums) &#123; min = Math.min(min, num); max = Math.max(max, num); &#125; int length = nums.length; //桶的数量 int bucketCount = (max - min) / length + 1; int[][] bucketArrays = new int[bucketCount][]; //遍历数组，放入桶内 for (int i = 0; i &lt; length; i++) &#123; //找到桶的下标 int index = (nums[i] - min) / length; //添加到指定下标的桶里，并且使用插入排序排序 bucketArrays[index] = insertSortArrays(bucketArrays[index], nums[i]); &#125; int k = 0; //合并全部桶的 for (int[] bucketArray : bucketArrays) &#123; if (bucketArray == null || bucketArray.length == 0) &#123; continue; &#125; for (int i : bucketArray) &#123; //把值放回到nums数组中 nums[k++] = i; &#125; &#125; &#125; //每个桶使用插入排序进行排序 private int[] insertSortArrays(int[] arr, int num) &#123; if (arr == null || arr.length == 0) &#123; return new int[]&#123;num&#125;; &#125; //创建一个temp数组，长度是arr数组的长度+1 int[] temp = new int[arr.length + 1]; //把传进来的arr数组，复制到temp数组 for (int i = 0; i &lt; arr.length; i++) &#123; temp[i] = arr[i]; &#125; //找到一个位置，插入，形成新的有序的数组 int i; for (i = temp.length - 2; i &gt;= 0 &amp;&amp; temp[i] &gt; num; i--) &#123; temp[i + 1] = temp[i]; &#125; //插入需要添加的值 temp[i + 1] = num; //返回 return temp; &#125;&#125;//10万个数的数组，耗时：8750毫秒 平均时间复杂度：O(M+N) 算法空间复杂度：O(M+N) 算法稳定性：稳定(取决于桶内的排序算法，这里使用的是插入排序所以是稳定的)。 总结 动画演示来源于算法学习网站：https://visualgo.net 讲完这些排序算法后，可能有人会问学这些排序算法有什么用呢，难道就为了应付笔试面试？平时开发也没用得上这些。 我觉得我们应该换个角度来看，比如高中时我们学物理，化学，数学，那么多公式定理，现在也没怎么用得上，但是高中课本为什么要教这些呢？ 我的理解是：第一，普及一些常识性的问题。第二，锻炼思维，提高解决问题的能力。第三，为了区分人才。 回到学排序算法有什么用的问题上，实际上也一样。这些最基本的排序算法就是一些常识性的问题，作为开发者应该了解掌握。同时也锻炼了编程思维，其中包含有双指针，分治，递归等等的思想。最后在面试中体现出来的就是人才的划分，懂得这些基本的排序算法当然要比不懂的人要更有竞争力。 建议大家看完之后，能找时间动手写一下，加深理解。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"数据结构与算法/leetcode经典算法题分享(哈希表)","date":"2021-08-04T03:20:11.434Z","updated":"2021-08-04T03:17:18.617Z","comments":true,"path":"2021/08/04/数据结构与算法/leetcode经典算法题分享(哈希表)/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB(%E5%93%88%E5%B8%8C%E8%A1%A8)/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言本篇文章主要讲解leetcode上，关于哈希表(简单难度)的算法题目。 1. 两数之和题目： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 解法1(暴力解法)思路： 因为在数组中有两个整数的和等于目标值，很自然地我们就会想到一个个来尝试。我们知道目标值target和nums[i]，只需要找到nums[j]，然后返回new int[]&#123;i,j&#125;即可。 代码如下： 1234567891011public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; //由于数组中同一个元素不能使用两遍，所以j从i的下一个元素开始 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (target - nums[i] == nums[j]) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[]&#123;&#125;;&#125; 提交代码，结果如下： 按道理嵌套循环的话，时间应该会久一点，居然仅用了0ms，我也不太相信，但是提交了三四次也是这个结果，不管了，哈哈~ 假如我们想去掉嵌套循环，优化一下，怎么做呢？没错，就是今天的主角，哈希表！ 解法2(HashMap)思路： 创建一个Map集合，key是nums[i]元素的值，value是下标值i。当target - 当前遍历的元素的差值在map中存在时，就返回new int[]&#123;map.get(target-nums[i]),i&#125;。如果不在map集合中，就把元素值和元素下标存进map集合中。 代码如下： 123456789101112131415public int[] twoSum(int[] nums, int target) &#123; //map的key是nums[i]的值，value是下标i Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; //获取结果值与nums[i]的差值 int diff = target - nums[i]; //如果包含的话，返回结果 if (map.containsKey(diff)) &#123; return new int[]&#123;map.get(diff), i&#125;; &#125; else &#123; map.put(nums[i], i); &#125; &#125; return new int[]&#123;&#125;;&#125; 提交代码，结果如下： 349. 两个数组的交集题目： 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 实例2： 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4] 解法1(暴力解法)嵌套循环，比较两个数组中的元素，如果nums1[i] == nums2[j]的话，表示两个数组中都有的数字，则添加到HashSet(去重)，最后再把HashSet转换成数组输出。 代码如下： 123456789101112public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums1.length; i++) &#123; for (int j = 0; j &lt; nums2.length; j++) &#123; if (nums1[i] == nums2[j]) &#123; set.add(nums1[i]); &#125; &#125; &#125; //HashSet转换成数组输出 return set.stream().mapToInt(Integer::intValue).toArray();&#125; 提交代码，结果如下： 经典的击败5%的用户，这是很正常的结果，因为使用了嵌套循环，而且还要把HashSet转换成数组，非常耗费性能，那么有没有优化空间呢，答案是肯定有的。 解法2如果要判断一个整数是否包含在无序的数组中，只能从头遍历到尾。既然数组在判断时需要从头到尾遍历这么耗费性能，那我们能不能换一种数据结构，做到快速判断是否包含在其中呢，答案就是哈希表。HashSet的底层就是一个哈希表，所以我们把nums1的数全部存入一个HashSet中，然后再遍历nums2，判断nums中的元素是否包含在HashSet中即可。 代码如下： 1234567891011121314151617181920public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;(); for (int n1 : nums1) &#123; s1.add(n1); &#125; Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;(); for (int n2 : nums2) &#123; if (s1.contains(n2)) &#123; s2.add(n2); &#125; &#125; //把set集合转成数组，返回 int[] res = new int[s2.size()]; int i = 0; for (Integer num : s2) &#123; res[i] = num; i++; &#125; return res;&#125; 提交代码，结果如下： 350. 两个数组的交集II题目： 给定两个数组，编写一个函数来计算它们的交集。 示例1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例2： 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 解法1这道题是上面那道题的变形，不同在于输出结果不需要去重。因此我们不能使用HashSet存储，而要改用HashMap，key是数组中的元素，value是元素的个数。在判断是否包含在其中的时候，还要判断个数是否大于0，每添加一个元素到结果集中就从HashMap中减去一个元素的个数。 最后把结果集转成数组返回即可。 代码如下： 12345678910111213141516171819public int[] intersect(int[] nums1, int[] nums2) &#123; //key为num1的元素，value为元素出现的次数 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums1) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums2) &#123; if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) &#123; list.add(num); map.put(num, map.get(num) - 1); &#125; &#125; int[] res = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++) &#123; res[i] = list.get(i); &#125; return res;&#125; 提交代码，结果如下： 771. 宝石与石头题目： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例1： 12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例2： 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 解法1(HashSet)这也是一个很典型的使用哈希表判断是否包含在集合中的题目。思路还是跟前面判断交集的一样，先把其中一个字符串遍历每个字符，放进HashSet，然后再遍历另一个字符串，判断是否包含在其中，包含则数量加一。最后返回结果。 代码如下： 12345678910111213public int numJewelsInStones(String jewels, String stones) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (char j : jewels.toCharArray()) &#123; set.add(j); &#125; int count = 0; for (char s : stones.toCharArray()) &#123; if(set.contains(s))&#123; count++; &#125; &#125; return count;&#125; 提交代码，结果如下： 解法2(简化版哈希表)上面的解法执行用时2ms已经很快了，但是如果细心想一下，其实没必要使用HashSet集合，因为题目已经告诉我们只有字母，因此我们大可以使用一个数组模拟一个哈希表，优化一下。 代码如下： 123456789101112131415161718public int numJewelsInStones(String jewels, String stones) &#123; //大写字母&#x27;A&#x27;的ASCII码是65，小写字母&#x27;z&#x27;的ASCII码是122 //所以使用一个长度58的数组已经足够 boolean[] bools = new boolean[58]; for (char j : jewels.toCharArray()) &#123; //类似哈希映射，把对应下标标记为true bools[j - &#x27;A&#x27;] = true; &#125; int count = 0; for (char s : stones.toCharArray()) &#123; boolean bool = bools[s - &#x27;A&#x27;]; //如果对应下标为true，则是宝石 if (bool) &#123; count++; &#125; &#125; return count;&#125; 提交代码，结果如下： 387. 字符串中的第一个唯一字符题目： 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： 12345s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2 提示：你可以假定该字符串只包含小写字母。 解法1(HashMap)我们可以遍历两次，第一次遍历使用HashMap记录字符出现的次数，第二次遍历找出只出现一次的字符，返回它的索引。 代码如下： 1234567891011121314public int firstUniqChar(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] chars = s.toCharArray(); for (char c : chars) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; for (int i = 0; i &lt; chars.length; i++) &#123; Integer count = map.get(chars[i]); if (count == 1) &#123; return i; &#125; &#125; return -1;&#125; 提交代码，结果如下： 解法2显然解法1耗时过长，不是很理想。怎么优化呢，要抓住题目给的提示，只包含小写字母。既然只含有小写字母，那么我们就可以简化哈希表，使用一个数组代替。 代码如下： 12345678910111213public int firstUniqChar(String s) &#123; int[] hash = new int[26]; char[] chars = s.toCharArray(); for (char ch : chars) &#123; hash[ch - &#x27;a&#x27;]++; &#125; for (int i = 0; i &lt; chars.length; i++) &#123; if (hash[chars[i] - &#x27;a&#x27;] == 1) &#123; return i; &#125; &#125; return -1;&#125; 提交代码，结果如下： 1365. 有多少小于当前数字的数字给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。 以数组形式返回答案。 示例1： 12345678输入：nums = [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。 示例2： 12输入：nums = [6,5,4,8]输出：[2,1,0,3] 示例3： 12输入：nums = [7,7,7,7]输出：[0,0,0,0] 提示： 2 &lt;= nums.length &lt;= 500 0 &lt;= nums[i] &lt;= 100 解法1(暴力法)暴力法思路很简单粗暴，就是拿每一个元素跟数组中除了自身之外的每一个元素对比，只要元素大于数组中其他的数就计数加一，最后把计数收集起来就是结果。 代码如下： 12345678910111213141516171819202122public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] res = new int[nums.length]; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; for (int j = 0; j &lt; nums.length; j++) &#123; //排除跟自己对比 if (i == j) &#123; continue; &#125; //如果元素本身比其他数要大，计数+1 if (num &gt; nums[j]) &#123; count++; &#125; &#125; //收集计数 res[i] = count; //计数器归0 count = 0; &#125; return res;&#125; 提交代码，结果如下： 解法2明显解法1使用了嵌套循环，导致耗时太多，结果不太理想。优化代码前，我们可以先看看提示0 &lt;= nums[i] &lt;= 100，也就是说元素的值在0到100范围内。我们可以使用一个101长度的数组统计元素出现的次数，当我们要计算有多少少于该元素的数字时，就只需要该元素前面所有元素出现的次数即可。 代码如下： 1234567891011121314151617181920public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] hash = new int[101]; //使用数组统计数字出现的次数 for (int num : nums) &#123; //元素值相当于下标，类似于哈希映射 hash[num]++; &#125; int[] res = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; //计数 int count = 0; //统计在该元素前的所有元素(也就是小于该元素的数字)出现的次数 for (int j = nums[i] - 1; j &gt;= 0; j--) &#123; //计数器累加，j就是统计哈希表的下标 count += hash[j]; &#125; res[i] = count; &#125; return res;&#125; 提交代码，结果如下： 389. 找不同题目： 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例1： 123输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;输出：&quot;e&quot;解释：&#x27;e&#x27; 是那个被添加的字母。 示例2： 12输入：s = &quot;&quot;, t = &quot;y&quot;输出：&quot;y&quot; 示例3： 12输入：s = &quot;a&quot;, t = &quot;aa&quot;输出：&quot;a&quot; 提示： 0 &lt;= s.length &lt;= 1000 t.length == s.length + 1 s 和 t 只包含小写字母 解法1(HashMap)使用HashMap记录字符串s中每一个字符出现的次数，然后遍历字符串t，通过字符获取字符出现的次数，次数大于0就减一，次数等于0则表示是添加的字母，返回该字母。 代码如下： 123456789101112131415public char findTheDifference(String s, String t) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : s.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; for (char c : t.toCharArray()) &#123; Integer count = map.getOrDefault(c, 0); if (count &gt; 0) &#123; map.put(c, count - 1); &#125; else &#123; return c; &#125; &#125; return &#x27; &#x27;;&#125; 提交代码，结果如下： 解法2关键是抓住提示，字符串s和t只包含小写字母，所以我们还是可以使用数组简化HashMap。小写字母只有26个，所以我们创建一个26长度的int数组，统计s字符串中字符出现的次数。其他逻辑和解法1一样即可。 代码如下： 1234567891011121314public char findTheDifference(String s, String t) &#123; int[] hash = new int[26]; for (char c : s.toCharArray()) &#123; hash[c - &#x27;a&#x27;]++; &#125; for (char c : t.toCharArray()) &#123; if (hash[c - &#x27;a&#x27;] &gt; 0) &#123; hash[c - &#x27;a&#x27;]--; &#125; else &#123; return c; &#125; &#125; return &#x27; &#x27;;&#125; 提交代码，结果如下： 解法3(排序法)把两个字符串转成字符数组，然后对两个数组排序。对排序好的数组进行遍历对比，只要出现不相等的字符，就是要返回的字符。 代码如下： 1234567891011121314151617public char findTheDifference(String s, String t) &#123; char[] sChars = s.toCharArray(); char[] tChars = t.toCharArray(); Arrays.sort(sChars); Arrays.sort(tChars); int length = Math.min(sChars.length, tChars.length); int i = 0; while (i &lt; length) &#123; char sChar = sChars[i]; char tChar = tChars[i]; if (sChar != tChar) &#123; return tChar; &#125; i++; &#125; return tChars[tChars.length - 1];&#125; 提交代码，结果如下： 效率虽然没有哈希表快，但是也是一种不错的解题思路。 217. 存在重复元素题目： 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例1： 12输入: [1,2,3,1]输出: true 示例2： 12输入: [1,2,3,4]输出: false 示例3： 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解法1假如使用嵌套循环，是会超出时间限制的，所以不能考虑用暴力法。一般来说，判断一个元素是否包含在其中肯定是HashSet最快，所以我们可以用HashSet容纳元素，然后判断一下是否包含，包含则返回true，不包含则继续装入，如果遍历结束都没有返回true，则返回false。 代码如下： 1234567891011public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; if (!set.contains(num)) &#123; set.add(num); &#125; else &#123; return true; &#125; &#125; return false;&#125; 提交代码，结果如下： 解法2其实HashSet本身就有去重的效果，我们把所有的元素装入到HashSet中，如果有重复的元素则长度和原来的长度不相等。 代码如下： 1234567public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; set.add(num); &#125; return set.size() != nums.length;&#125; 提交代码，结果如下： 409. 最长回文串题目： 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例1： 12345678输入:&quot;abccccdd&quot;输出:7解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 解法1回文字符串就是从左往右读和从右往左读都是一样的字符串，也就是左右对称的字符串。要做到左右对称，其实很简单，只要是偶数个相同的字符就可以，比如有两个”a”，左右两端各放一个就对称了。 所以我们用一个HashMap来统计字符出现的次数，然后遍历，判断如果是偶数就累加字母出现的次数，如果是奇数就减一让他变成偶数再累加，最后就得到答案res，但是还没大功告成，因为中点插进一个字母，他还是对称的，所以最后要判断一下累加的长度是否等于原来的字符串长度，再决定要不要再加上一个字母的长度。 代码如下： 1234567891011121314151617181920public int longestPalindrome(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); //统计字符出现的次数 for (char c : s.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int res = 0; for (Character key : map.keySet()) &#123; Integer val = map.get(key); //如果是奇数次，减一成为偶数，再累加 if (val % 2 != 0) &#123; res += (val - 1); &#125; else &#123; //如果是偶数次，直接累加 res += val; &#125; &#125; int length = s.length(); return res == length ? length : (res + 1);&#125; 提交代码，结果如下： 解法2(优化)题目说明是包含大写字母和小写字母，所以我们还是可以使用数组来代替HashMap，以此提高代码的执行效率。我们只需要一个长度为128的数组来统计字符出现的次数，代替HashMap。其他逻辑不变即可。 代码如下： 12345678910111213141516public int longestPalindrome(String s) &#123; int[] hash = new int[128]; for (char c : s.toCharArray()) &#123; hash[c - &#x27;A&#x27;]++; &#125; int res = 0; for (int count : hash) &#123; if (count % 2 != 0) &#123; res += (count - 1); &#125; else &#123; res += count; &#125; &#125; int length = s.length(); return res == length ? length : (res + 1);&#125; 提交代码，结果如下： 204. 计数质数统计所有小于非负整数 n 的质数的数量。 示例1： 123输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例2： 12输入：n = 0输出：0 示例3： 12输入：n = 1输出：0 解法1(暴力法)其实这是一个很经典的数学问题，比如要判断223是不是质数，最粗暴的方法就是，223对(2到222)进行取余，每次取余的余数都不为0，那就是质数。但是如果n的值非常大，那就会超过时间限制。 代码如下： 12345678910111213141516171819202122232425262728public int countPrimes(int n) &#123; int count = 0; for (int i = 0; i &lt; n; i++) &#123; //判断是否是质数，是质数则计数+1 if (isPrimes(i)) &#123; count++; &#125; &#125; return count;&#125;//判断一个数是否是质数private boolean isPrimes(int num) &#123; if (num &lt;= 1) &#123; return false; &#125; if (num == 2) &#123; return true; &#125; //循环取余，只要有一次返回余数为0则是非质数 for (int i = 2; i &lt; num; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; //如果余数都不为0则是质数 return true;&#125; 提交代码，结果如下： 解法2不如反向思维一下，我们使用一个boolean[]数组记录每个数是否是质数，然后从2开始找出非质数都标记成true，标记完成之后就可以统计质数的数量是多少了。 12345678910111213141516public int countPrimes(int n) &#123; boolean[] booleans = new boolean[n]; for (int i = 2; i &lt; n; i++) &#123; for (int j = 2; j * i &lt; n; j++) &#123; booleans[i * j] = true; &#125; &#125; int count = 0; //从2开始统计 for (int i = 2; i &lt; booleans.length; i++) &#123; if (!booleans[i]) &#123; count++; &#125; &#125; return count;&#125; 提交代码，结果如下： 其实上面的代码还可以优化一下，不需要遍历两次，把统计和标记放在一个循环即可。代码如下： 12345678910111213public int countPrimes(int n) &#123; int count = 0; boolean[] booleans = new boolean[n]; for (int i = 2; i &lt; n; i++) &#123; if (!booleans[i]) &#123; for (int j = 2; j * i &lt; n; j++) &#123; booleans[i * j] = true; &#125; count++; &#125; &#125; return count;&#125; 提交代码，结果如下： 解法3万万没想到，这个题目还有0ms的题解！这是我在提交记录中一不留神看到的，截图给大伙看看。 然后我点开代码一看，好家伙，震惊我一整年！ 1234567891011121314151617181920212223242526public int countPrimes(int n) &#123; switch (n) &#123; case 0: return 0; case 1: return 0; case 2: return 0; case 3: return 1; case 4: return 2; case 5: return 2; case 6: return 3; case 7: return 3; case 8: return 4; case 9: return 4; case 10: return 4; case 11: return 4; case 12: return 5; case 13: return 5; case 14: return 6; case 15: return 6; case 10000: return 1229; case 499979: return 41537; case 999983: return 78497; case 1500000: return 114155; case 5000000: return 348513; default: return -1; &#125;&#125; 我当然不相信这是能通过的啦，于是复制了这段代码提交试试，没想到还真行呀！ 总结哈希表的算法题中有很多问题其实在实际项目中也会遇到，比如找出两个集合的交集，找出集合中重复的元素等等，所以做一做算法题对我们的编码能力会有很大的提升。 这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"数据结构与算法/leetcode算法题分享(字符串)","date":"2021-08-04T03:20:11.427Z","updated":"2021-08-04T03:17:18.613Z","comments":true,"path":"2021/08/04/数据结构与算法/leetcode算法题分享(字符串)/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E4%BA%AB(%E5%AD%97%E7%AC%A6%E4%B8%B2)/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言很多人做leetcode题目找不到方向，或者说很难持之以恒，我这里推荐一种方法，从简单难度开始刷，刷完这个标签的简单难度，再换一个标签，这样循序渐进，把做题的量慢慢提高，还有难度逐渐加大。对于初学者，最重要是趁热打铁，而不是东打一枪西放一炮，趁热打铁才能形成做题的思路。 还有一个问题是，一开始做题往往我们没有思路，只会想到暴力解法，效率只有惨淡的5%，遇到这种情况是很正常的，因为还没开始形成解题的思维。我们可以先看看题解，看完思路再自己写，千万不要照抄，要自己想出来才能锻炼编程能力。 所谓talking is cheap, show me code，那么我们就从字符串开始吧！ 20. 有效的括号题目： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。 解题思路： 这道题可以应用于校验JSON格式的括号是否正确。从题目上可以知道有效的括号是有左括号，也会有相同类型的右括号，并且按照正确的顺序闭合。 那么应该采取什么方法校验呢？我马上想到的是通过成对成对地删除有效的括号，从最里面一直往外层删除，最后能删除完，变成空字符串就代表是有效括号返回true，否则返回false。 代码如下： 12345678910111213141516171819202122232425262728293031323334public boolean isValid(String s) &#123; if (s == null) &#123; return false; &#125; if (&quot;&quot;.equals(s)) &#123; return true; &#125; //去掉空格字符 s = s.replace(&quot; &quot;, &quot;&quot;); //如果是长度是奇数，直接返回false if (s.length() % 2 != 0) &#123; return false; &#125; //如果长度等于0表示是有效的括号，返回true，否则返回false return dealString(s) == 0;&#125;private int dealString(String s) &#123; if (s.length() == 0) &#123; return 0; &#125; for (int i = 0; i &lt; s.length() - 1; i++) &#123; //获取相邻的两个字符 String str = String.valueOf(s.charAt(i)) + s.charAt(i + 1); if (&quot;&#123;&#125;&quot;.equals(str) || &quot;[]&quot;.equals(str) || &quot;()&quot;.equals(str)) &#123; //如果是有效的括号就删除 int index = s.indexOf(str); s = s.substring(0, index) + s.substring(index + 2); //删除后的字符串，再递归继续删除 return dealString(s); &#125; &#125; return s.length();&#125; 一写完代码，感觉思路清晰，代码整洁，还使用了递归，简直so easy！ 然而一运行…成年人的崩溃就在一瞬间！ 为什么会这么低的效率呢，其实想想就知道，我每次遍历字符串就只删一个有效的括号，如果出现类似这种”[[{}{}{}{}{}{}]]”，就会遍历非常多次！所以不能这样玩！ 怎么删效率比较高呢？最好是不要重复去遍历，一次遍历删完效率是最高的。 关键是怎么找到最里层的有效括号，其实就是找到第一个右括号，然后判断左边的括号是否能匹配，能匹配的话就是最里层的有效括号，然后删除掉。删除后，因为字符串的长度变短了两位，所以我们把指针往左边移动两位即可。这样遍历下来，就只会遍历一次。最后还是判断字符串的长度。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean isValid(String s) &#123; if (s == null) &#123; return false; &#125; if (&quot;&quot;.equals(s)) &#123; return true; &#125; //去掉空格字符 s = s.replace(&quot; &quot;, &quot;&quot;); //如果是长度是奇数，直接返回false if (s.length() % 2 != 0) &#123; return false; &#125; StringBuilder toCheck = new StringBuilder(s); for (int i = 0; i &lt; toCheck.length(); i++) &#123; //获取当前的字符 char current = toCheck.charAt(i); //判断是右边的括号才进行处理 if (current == &#x27;)&#x27; || current == &#x27;]&#x27; || current == &#x27;&#125;&#x27;) &#123; //如果第一个符号就是右括号，直接返回false if (i == 0) &#123; return false; &#125; //如果右边的括号和左边相邻的括号可以匹配，直接删除，并且指针往左边移动两位 if (isPair(toCheck.charAt(i - 1), current)) &#123; toCheck.delete(i - 1, i + 1); i -= 2; &#125; &#125; &#125; return toCheck.length() == 0;&#125;private boolean isPair(char a, char b) &#123; if (b == &#x27;)&#x27;) &#123; return a == &#x27;(&#x27;; &#125; if (b == &#x27;]&#x27;) &#123; return a == &#x27;[&#x27;; &#125; if (b == &#x27;&#125;&#x27;) &#123; return a == &#x27;&#123;&#x27;; &#125; return false;&#125; 执行用时2ms，还不错，那么这题就算pass了！ 当然除了我说的这种方式之外，题解里有大佬是使用栈来解决，大家有兴趣可以看看。 344. 反转字符串题目： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 解题思路： 一看到这道题，直呼是送分题，这反转字符串不就是JavaAPI就有了吗，于是乎直接大胆的，两行代码搞定，好家伙！一下子重拾回作为程序员的信心！ 代码如下： 1234public void reverseString(char[] s) &#123; char[] chars = new StringBuilder(new String(s)).reverse().toString().toCharArray(); System.arraycopy(chars, 0, s, 0, chars.length);&#125; 但是效率呢？成年人的崩溃往往就在一瞬间！ 用了2ms，仅仅击败了9.82%的用户，证明有更快的解法。 而且题目要求原地修改输入数组、使用 O(1) 的额外空间解决，所以上面的解法不符合题目要求。如果不使用额外空间，最直接的方式马上想到头尾交换，第二位跟倒数第二位交换，一直交换到中间，最后整个char[]数组就反转过来了。 代码如下： 1234567891011121314151617181920public void reverseString(char[] s) &#123; //如果长度小于2，直接返回 if (s.length &lt; 2) &#123; return; &#125; //右边索引，从末尾开始 int r = s.length - 1; //左边索引，从0开始 int l = 0; //如果左边的索引值小于右边的索引值就循环，否则跳出循环 while (l &lt; r) &#123; //交换值 char temp = s[l]; s[l] = s[r]; s[r] = temp; //左右索引向中间移动 l++; r--; &#125;&#125; 这个效率不用芜湖，已经起飞了！上面那个算法其实就是双指针，应该是比较简单高效的解法之一了。 387.字符串中的第一个唯一字符题目： 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： 12345s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2 提示：你可以假定该字符串只包含小写字母。 解题思路： 一看到不重复，二话不说直接想到HashMap，什么？还有顺序，那就用LinkedHashMap，key保存字符，value保存出现的次数，遍历完字符串之后，找出第一个不重复的字符即可。 不多哔哔，上代码！ 123456789101112131415161718192021222324public int firstUniqChar(String s) &#123; char[] chars = s.toCharArray(); Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); //统计出现的次数 for (Character ch : chars) &#123; Integer count = map.get(ch); if (count == null) &#123; map.put(ch, 1); &#125; else &#123; count++; map.put(ch, count); &#125; &#125; //找出第一个出现不重复的字符 for (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123; Integer count = entry.getValue(); if (count == 1) &#123; Character ch = entry.getKey(); //返回下标 return s.indexOf(ch); &#125; &#125; return -1;&#125; 看看效率如何？38ms！成年人的崩溃往往就在一瞬间… 思路是没错的，用哈希表解决，但是没有利用上提示，提示说只有小写字母，小写字母只有26个，所以使用一个长度为26的数组作为哈希表即可，使用Map集合的话，put方法里面的逻辑非常多，会浪费性能。 所以我们把Map集合改成长度为26的数组即可，上代码： 1234567891011121314151617public int firstUniqChar(String s) &#123; char[] chars = s.toCharArray(); int[] hashArray = new int[26]; //统计字符出现的次数 for (Character ch : chars) &#123; hashArray[ch - &#x27;a&#x27;]++; &#125; //找出只出现一次的字符，然后返回下标 for (int i = 0; i &lt; chars.length; i++) &#123; Character ch = chars[i]; int count = hashArray[ch - &#x27;a&#x27;]; if (count == 1) &#123; return i; &#125; &#125; return -1;&#125; 不用说，效率肯定提升数倍，7ms！ 125.验证回文串题目： 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 解题思路： 什么是回文串呢，就是一个字符串从左往右读，然后从右往左读都是一样的，比如”aabaa”，也就是把字符串反转过来跟原来的字符串是相等的，就称为回文串。 题目说只考虑字母和数字字符，并且忽略大小写，然后验证是不是回文串。很简单啦，遍历字符串，然后根据题目过滤出字母和数字字符，然后拼接出新的字符串，最后反转对比一下，如果相等就返回true，不相等就返回false。 不多哔哔，直接上代码！ 12345678910111213141516public boolean isPalindrome(String s) &#123; StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) &#123; //只拼接数字和字母的字符 if (Character.isDigit(c) || Character.isLetter(c)) &#123; //如果是字母则全部转为小写 if (Character.isLetter(c)) &#123; c = Character.toLowerCase(c); &#125; sb.append(c); &#125; &#125; //反转字符串，验证是否是回文串 String s1 = sb.toString(); return s1.equals(sb.reverse().toString());&#125; 居然用时7ms，我不能接受！ 其实判断回文串根本没必要遍历完整个字符串，可以一边遍历一边判断的！ 因为是对称的，所以利用双指针，一个指针从左往右，一个指针从右往左，左右两边取值，对比符合条件(数字或者字母)的字符，如果中途发现不相等直接返回false，如果遍历完都是相等的话，那就返回true。 废话不多说，直接看代码。 123456789101112131415161718192021222324252627282930public boolean isPalindrome(String s) &#123; char[] chars = s.toCharArray(); int leftIndex = 0; int rightIndex = chars.length - 1; char left; char right; while (leftIndex &lt; rightIndex) &#123; //过滤掉不是数字或者字母的字符 while (leftIndex &lt; rightIndex &amp;&amp; !Character.isLetterOrDigit(chars[leftIndex])) &#123; leftIndex++; &#125; //左边索引的值 left = chars[leftIndex]; //过滤掉不是数字或者字母的字符 while (leftIndex &lt; rightIndex &amp;&amp; !Character.isLetterOrDigit(chars[rightIndex])) &#123; rightIndex--; &#125; //右边索引的值 right = chars[rightIndex]; //如果不相等则返回false if (Character.toLowerCase(left) != Character.toLowerCase(right)) &#123; return false; &#125; else &#123; //如果相等则继续比较，左指针往右移，右指针往左移 leftIndex++; rightIndex--; &#125; &#125; return true;&#125; 桀桀桀，双指针的威力竟恐怖如斯！ 总结上面这四道题，表面看起来好像有点难度，实际上就是Paper Tiger(纸老虎)，没什么好怕的，做多了之后自然就有思路了。对于初学者，不要怕使用暴力解法，先用暴力解法找找感觉，找找思路，然后看看能不能优化一下暴力解法。 上面讲了四道关于字符串的算法题，因为不可能一篇文章讲完所有的题目，所以如果希望提高自己的编程能力，还需要自己到leetcode上做一做。 这篇文章就讲到这里，最后感谢大家的阅读，希望能给大家带来一些启发。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"缓存服务/深入探索redis的五种数据类型","date":"2021-08-04T03:20:11.390Z","updated":"2021-08-04T03:17:18.633Z","comments":true,"path":"2021/08/04/缓存服务/深入探索redis的五种数据类型/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2redis%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言Redis是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value的NoSQL数据库。 一般来说，我们都是使用关系型数据库MySQL来存储数据，但是面对着流量高峰，会对MySQL造成巨大的压力，导致数据库性能很差，这时就要使用缓存中间件来降低数据库的压力，这是Redis最常见的使用场景。除了作为缓存使用之外，Redis还有很多使用场景，比如分布式锁，计数，队列等等。 所以Redis对于程序员来说可以算得上是必修课。 安装Redis安装Redis很简单，因为网上教程很多，这里就不再详细讲解，推荐看菜鸟教程：https://www.runoob.com/redis/redis-install.html Redis的特点要用好Redis，首先要明白它的特点： 读写速度快。redis官网测试读写能到10万左右每秒。速度快的原因这里简单说一下，第一是因为数据存储在内存中，我们知道机器访问内存的速度是远远大于访问磁盘的，其次是Redis采用单线程的架构，避免了上下文的切换和多线程带来的竞争，也就不存在加锁释放锁的操作，减少了CPU的消耗，第三点是采用了非阻塞IO多路复用机制。 数据结构丰富。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构。这也是这篇文章要讲的。 支持持久化。Redis提供了RDB和AOF两种持久化策略，能最大限度地保证Redis服务器宕机重启后数据不会丢失。 支持高可用。可以使用主从复制，并且提供哨兵机制，保证服务器的高可用。 客户端语言多。因为Redis受到社区和各大公司的广泛认可，所以客户端语言涵盖了所有的主流编程语言，比如Java，C，C++，PHP，NodeJS等等。 Redis的数据结构下面我们就学习Redis的数据结构，也是使用Redis要知道的最基础的知识。 Redis是一个Key-Value型的内存数据库，它所有的key都是字符串，而value常见的数据类型有五种：string，list，set，zset，hash。 Redis的这些数据结构，在底层都是使用redisObject来进行表示。redisObject中有三个重要的属性，分别是type、 encoding 和 ptr。 type表示保存的value的类型。通常有以下几种，也就是常见的五种数据结构： 字符串 REDIS_STRING 列表 REDIS_LIST 集合 REDIS_SET 有序集合 REDIS_ZSET 字典 REDIS_HASH encoding表示保存的value的编码，通常有以下几种： 12345678#define REDIS_ENCODING_RAW 0 // 编码为字符串#define REDIS_ENCODING_INT 1 // 编码为整数#define REDIS_ENCODING_HT 2 // 编码为哈希表#define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap#define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表#define REDIS_ENCODING_ZIPLIST 5 // 编码为压缩列表#define REDIS_ENCODING_INTSET 6 // 编码为整数集合#define REDIS_ENCODING_SKIPLIST 7 // 编码为跳跃表 ptr是一个指针，指向实际保存的value的数据结构。 这里要特别说明一下的是，数据类型和编码方式是有一定关系的，所以数据类型和编码方式是可以确定底层采用什么数据结构存储数据的。 string(字符串)这是redis中最常用的数据类型，字符串对象的 encoding 有三种，分别是：int、raw、embstr。 常用的命令有常用命令: set、get、decr、incr、mget 等。 我们知道Redis是用C语言开发的，但是底层存储不是使用C语言的字符串类型，而是自己开发了一种数据类型SDS进行存储，SDS即Simple Dynamic String ，是一种动态字符串。我们可以在github找到源码。 12345struct sdshdr&#123; int len;/*字符串长度*/ int free;/*未使用的字节长度*/ char buf[];/*保存字符串的字节数组*/&#125; SDS与C语言的字符串有什么区别呢？ C语言获取字符串长度是从头到尾遍历，时间复杂度是O(n)，而SDS有len属性记录字符串长度，时间复杂度为O(1)。 避免缓冲区溢出。SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。 空间预分配。当SDS需要进行扩展时，Redis会为SDS分配好内存，并且根据特定的算法分配多余的free空间，避免了连续执行字符串添加带来的内存分配的消耗。 惰性释放。如果需要缩短字符串，不会立即回收多余的内存空间，而是用free记录剩余的空间，以备下次扩展时使用，避免了再次分配内存的消耗。 二进制安全。c语言在存储字符串时采用N+1的字符串数组，末尾使用’\\0’标识字符串的结束，如果我们存储的字符串中间出现’\\0’，那就会导致识别出错。而SDS因为记录了字符串的长度len，则没有这个问题。 字符串类型的应用是非常广泛的，比如可以把对象转成JSON字符串存储到Redis中作为缓存，也可以使用decr、incr命令用于计数器的实现，又或者是用setnx命令为基础实现分布式锁等等。 需要注意的是：Redis 规定了字符串的长度不得超过 512 MB。 hash(字典)哈希对象的编码有两种，分别是：ziplist、hashtable。 当哈希对象保存的键值对数量小于 512，并且所有键值对的长度都小于 64 字节时，使用ziplist(压缩列表)存储；否则使用 hashtable 存储。 Redis中的hashtable跟Java中的HashMap类似，都是通过”数组+链表”的实现方式解决部分的哈希冲突。直接看源码定义。 123456789101112131415161718192021222324252627282930typedf struct dict&#123; dictType *type;//类型特定函数，包括一些自定义函数，这些函数使得key和value能够存储 void *private;//私有数据 dictht ht[2];//两张hash表 int rehashidx;//rehash索引，字典没有进行rehash时，此值为-1 unsigned long iterators; //正在迭代的迭代器数量&#125;dict;typedef struct dictht&#123; //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值 //总是等于 size-1 unsigned long sizemask; //该哈希表已有节点的数量 unsigned long used; &#125;dictht;typedf struct dictEntry&#123; void *key;//键 union&#123; void val; unit64_t u64; int64_t s64; double d; &#125;v;//值 struct dictEntry *next；//指向下一个节点的指针&#125;dictEntry; 我们再看一个结构图就比较清楚了。 下面讲一下扩容和收缩。当哈希表保存的键值太多或者太少时，就会通过rehash来进行相应的扩容和收缩。 扩容和收缩的过程： 1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。 2、重新利用哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。 3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。 在redis中执行扩容和收缩的规则是： 服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF (持久化)命令，并且负载因子大于等于1。 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF (持久化)命令，并且负载因子大于等于5。 负载因子 = 哈希表已保存节点数量 / 哈希表大小。 渐进式rehash 什么是渐进式，也就是说扩容和收缩不是一次性，集中式地完成，而是通过多次逐渐地完成的。为什么要采用这种方式呢？如果是几十个键值，那么rehash当然可以瞬间完成，如果是几十万，几百万的键值要一次性进行rehash，势必会导致redis性能严重下降，自然而然地redis开发者就想到采用渐进式rehash。过程如下： 在rehash时，会使用rehashidx字段保存迁移的进度，rehashidx为0表示迁移开始。 在迁移过程中ht[0]和ht[1]会同时保存数据，ht[0]指向旧哈希表，ht[1]指向新哈希表，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]的元素迁移到ht[1]中。 随着字典操作的不断执行，最终会在某个时间节点，ht[0]的所有键值都会被迁移到ht[1]中，rehashidx设置为-1，代表迁移完成。如果没有执行字典操作，redis也会通过定时任务去判断rehash是否完成，没有完成则继续rehash。 rehash完成后，ht[0]指向的旧表会被释放, 之后会将新表的持有权转交给ht[0], 再重置ht[1]指向NULL。 渐进式rehash的优缺点： 优点是把rehash操作分散到每一个字典操作和定时函数上，避免了一次性集中式rehash带来的服务器压力。 缺点是在rehash期间需要使用两个hash表，占用内存稍大。 hash类型的常用命令有：hget、hset、hgetall 等。 list(链表)列表对象的编码有两种，分别是：ziplist、linkedlist。当列表的长度小于 512，并且所有元素的长度都小于 64 字节时，使用ziplist存储；否则使用 linkedlist 存储。 Redis中的linkedlist类似于Java中的LinkedList，是一个链表，底层的实现原理也和LinkedList类似。这意味着list的插入和删除操作效率会比较快，时间复杂度是O(1)。我们看源码： 12345678910111213141516171819typedef struct listNode &#123; struct listNode *prev; struct listNode *next; void *value;&#125; listNode;typedef struct listIter &#123; listNode *next; int direction;&#125; listIter;typedef struct list &#123; listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len;&#125; list; 我们可以看到，listNode就是链表中的节点元素，通过prev和next组成双向链表。 list则记录了头结点head，尾结点tail，还有链表长度len，match函数用于比较两个节点的值是否相等，操作起来更加方便。 list类型常用的命令有：lpush、rpush、lpop、rpop、lrange等。 set(集合)set类型的特点很简单，无序，不重复，跟Java的HashSet类似。它的编码有两种，分别是intset和hashtable。如果value可以转成整数值，并且长度不超过512的话就使用intset存储，否则采用hashtable。 hashtable在前面讲hash类型时已经讲过，这里的set集合采用的hashtable几乎一样，只是哈希表的value都是NULL。这个不难理解，比如用Java中的HashMap实现一个HashSet，我们只用HashMap的key就是了。 我们讲一讲intset，先看源码。 1234567typedef struct intset&#123; uint32_t encoding;//编码方式 uint32_t length;//集合包含的元素数量 int8_t contents[];//保存元素的数组&#125;intset; encoding有三种，分别是INTSET_ENC_INT16、INSET_ENC_INT32、INSET_ENC_INT64，代表着整数值的取值范围。Redis会根据添加进来的元素的大小，选择不同的类型进行存储，可以尽可能地节省内存空间。 length记录集合有多少个元素，这样获取元素个数的时间复杂度就是O(1)。 contents，存储数据的数组，数组按照从小到大有序排列，不包含任何重复项。 这里我们可能会提出疑问，如果一开始存的是INTSET_ENC_INT16(范围在-32,768~32,767)，如果这时添加了一个40000的数，怎么升级为INSET_ENC_INT32呢？ 升级过程是这样的： 1、根据新元素的类型扩展数组contents的空间。 2、从尾部将数据插入。 3、根据新的编码格式重置之前的值，因为这时的contents存在着两种编码的值。从插入的数据的位置，也就是尾部，从后到前将之前的数据按照新的编码格式进行移动和设置。从后到前调整是为了防止数据被覆盖。 升级的优点在于，根据存储的数据大小选择合适的编码方式，节省了内存。 缺点在于，升级会消耗系统资源。而且升级是不可逆的，也就是一旦对数组进行升级，编码就会一直保持升级后的状态。 set数据类型常用的命令有：sadd、spop、smembers、sunion等等。 Redis为set类型提供了求交集，并集，差集的操作，可以非常方便地实现譬如共同关注、共同爱好、共同好友等功能。 zset(有序集合)zset是Redis中比较有特色的数据类型，它和set一样是不可重复的，区别在于多了score值，用来代表排序的权重。也就是当你需要一个有序的，不可重复的集合列表时，就可以考虑使用这种数据类型。 zset的编码有两种，分别是：ziplist、skiplist。当zset的长度小于 128，并且所有元素的长度都小于 64 字节时，使用ziplist存储；否则使用 skiplist 存储。 这里要讲一下skiplist，也就是跳跃表。它的底层实现比较复杂，这里简单地提一下。 跳跃表的数据结构如上图所示，为什么要设计成这样呢？好处在于查询的时候，可以减少时间复杂度，如果是一个链表，我们要插入并且保持有序的话，那就要从头结点开始遍历，遍历到合适的位置然后插入，如果这样性能肯定是不理想的。 所以问题的关键在于能不能像使用二分查找一样定位到插入的点，答案就是使用跳跃表。比如我们要插入38，那么查找的过程就是这样。 首先从L4层，查询87，需要查询1次。 然后到L3层，查询到在-&gt;24-&gt;87之间，需要查询2次。 然后到L2层，查询-&gt;48，需要查询1次。 然后到L1层，查询-&gt;37-&gt;48，查询2次。确定在37-&gt;48之间是插入点。 有没有发现经过L4，L3，L2层的查询后已经跳过了很多节点，当到了L1层遍历时已经把范围缩小了很多。这就是跳跃表的优势。这种方式有点类似于二分查找，所以他的时间复杂度为**O(logN)**。 其实生活中也有这种例子，类似于快递填写的地址是省-&gt;市-&gt;区-&gt;镇-&gt;街，当快递公司在送快递时就根据地址层层缩小范围，最终锁定在一个很小的区域去搜索，提高了效率。 zet常用的命令有：zadd、zrange、zrem、zcard等。 zset的特点非常适合应用于开发排行榜的功能，比如三天阅读排行榜，游戏排行榜等等。 总结Redis能够受到社区的认可，并且在互联网中如此欢迎，除了速度快之外，很大原因也跟丰富的数据类型有关，而且很多数据类型的底层实现也是会考虑到内存空间的使用，尽可能地节省内存空间。 其实很多人是知道Redis常用的五种数据类型，但是对于底层的实现，就没有深入去研究，当然我以前也是没有深入的。那么在面试时就没有产生差异化，要从面试中脱颖而出最重要就是要跟普通程序员不一样，这样才能突出自身的价值。所以深入学习Redis的数据结构还是很有用的。 希望这篇文章能让大家对Redis有更深入的理解，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"缓存服务/布隆过滤器","date":"2021-08-04T03:20:11.383Z","updated":"2021-08-04T03:17:18.630Z","comments":true,"path":"2021/08/04/缓存服务/布隆过滤器/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 概念布隆过滤器(BloomFilter)是由一个叫“布隆”的小伙子在1970年提出的，它是一个很长的二进制向量，主要用于判断一个元素是否在一个集合中。 原理在介绍原理之前，要先讲一下Hash函数的概念。 我们在Java中的HashMap，HashSet其实也接触过hashcode()这个函数，哈希函数是可以将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为哈希值。 哈希函数有以下特点： 如果根据同一个哈希函数得到的哈希值不同，那么这两个哈希值的原始输入值肯定不同。 如果根据同一个哈希函数得到的两个哈希值相等，两个哈希值的原始输入值有可能相等，有可能不相等。 布隆过滤器是由一个很长的二进制向量和一系列的哈希函数组成。那么布隆过滤器是怎么判断一个元素是否在一个集合中的呢？ 假设布隆过滤器的底层存储结构是一个长度为16的位数组，初始状态时，它的所有位置都设置为0。 当有变量添加到布隆过滤器中，通过K个映射函数将变量映射到位数组的K个点，并把这K个点的值设置为1(假设有三个映射函数)。 查询某个变量是否存在的时候，我们只需要通过同样的K个映射函数，找到对应的K个点，判断K个点上的值是否全都是1，如果全都是1则表示很可能存在，如果K个点上有任何一个是0则表示一定不存在。 特性第一个问题，为什么说全都是1的情况是很可能存在，而不是一定存在呢？ 还记得前面说的哈希函数的特点，根据同一个哈希函数得到相同的哈希值，输入值不一定相等。类似于Java中两个对象的hashcode相等，但是不一定相等的道理。说白了，映射函数得到位数组上映射点全都是1，不一定是要查询的这个变量之前存进来时设置的，也有可能是其他变量映射的点。 所以这里引出了布隆过滤器的其中一个特点，存在一定的误判。 第二个问题，布隆过滤器能不能删除元素呢？ 答案是不能的。因为在位数组上的同一个点有可能有多个输入值映射，如果删除了会影响布隆过滤器里其他元素的判断结果。 如上图，如果删除obj1，把4,7,15置为0，那么判断obj2是否存在时就会导致因为映射点7是0，结果判断obj2是不存在的，结果出错。 这是第二个特点，不能删除布隆过滤器里的元素。 优缺点优点： 在空间和时间方面，都有着巨大的优势。因为不是存完整的数据，是一个二进制向量，能节省大量的内存空间，时间复杂度方面，是根据映射函数查询，假设有K个映射函数，那么时间复杂度就是O(K)。 因为存的不是元素本身，而是二进制向量，所以在一些对保密性要求严格的场景有一定优势。 缺点： 存在一定的误判。存进布隆过滤器里的元素越多，误判率越高。 不能删除布隆过滤器里的元素。随着使用的时间越来越长，因为不能删除，存进里面的元素越来越多，占用内存越来越多，误判率越来越高，最后不得不重置。 应用于缓存穿透用于缓解缓存穿透。缓存穿透的问题主要是因为传进来的key在Redis中是不存在的，那么就会直接打在DB上，造成DB压力增大。 针对这种情况，可以在Redis前加上布隆过滤器，预先把数据库中的数据加入到布隆过滤器中，因为布隆过滤器的底层数据结构是一个二进制向量，所以占用的空间并不是很大。在查询Redis之前先通过布隆过滤器判断是否存在，如果不存在就直接返回，如果存在的话，按照原来的流程还是查询Redis，Redis不存在则查询DB。 这里主要利用的是布隆过滤器判断结果是不存在的话就一定不存在这一个特点，但是由于布隆过滤器有一定的误判，所以并不能说完全解决缓存穿透，但是能很大程度缓解缓存穿透的问题。 布隆过滤器插件我们知道布隆过滤器的底层原理之后，理论上是可以自己 在Redis4.0后，官方提供了布隆过滤器的插件功能，布隆过滤器可以作为一个插件加载到Redis服务器直接使用。 首先安装Redis，网上有很多安装教程，这里就不多赘述。这里我用的是Redis6.0.10版本。安装完Redis之后，下载插件，使用git命令拉取： 1git clone https://github.com/RedisBloom/RedisBloom.git 拉取下来之后会得到一个RedisBloom的项目。 然后cd到文件夹/RedisBloom，使用make命令编译。 编译完成后生成一个redisbloom.so文件。 在启动Redis时，加载布隆过滤器模块到服务器中即可。 1./src/redis-server --loadmodule /usr/local/RedisBloom/redisbloom.so 最后使用客户端测试一下。 12345678910redis-6.0.10]$ ./src/redis-cli 127.0.0.1:6379&gt; bf.add user sam(integer) 1127.0.0.1:6379&gt; bf.add user jack(integer) 1127.0.0.1:6379&gt; bf.exists user jack(integer) 1127.0.0.1:6379&gt; bf.exists user tom(integer) 0 布隆过滤器的基本指令如下： bf.add 添加元素到布隆过滤器 bf.exists 判断元素是否在布隆过滤器 bf.madd 添加多个元素到布隆过滤器 bf.mexists 判断多个元素是否在布隆过滤器 123456127.0.0.1:6379&gt; bf.madd user mike rose1) (integer) 12) (integer) 1127.0.0.1:6379&gt; bf.mexists user blue mike1) (integer) 02) (integer) 1 在实际开发中，一般都是使用Java程序操作Redis，不太可能直接使用命令行判断，Java程序怎么操作呢？ 首先引入依赖，我使用的是SpringBoot2.0，所以引入依赖是3.15.0。 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.15.0&lt;/version&gt;&lt;/dependency&gt; 接着写个main方法示范一下。 123456789101112131415161718public static void main(String[] args) throws Exception &#123; Config config = new Config(); config.useSingleServer().setAddress(&quot;redis://192.168.0.109:6379&quot;); RedissonClient client = Redisson.create(config); RBloomFilter&lt;String&gt; bloomFilter = client.getBloomFilter(&quot;user&quot;); //尝试初始化，预计元素55000000，期望误判率0.03 bloomFilter.tryInit(55000000L, 0.03); //添加元素到布隆过滤器中 bloomFilter.add(&quot;tom&quot;); bloomFilter.add(&quot;mike&quot;); bloomFilter.add(&quot;rose&quot;); bloomFilter.add(&quot;blue&quot;); System.out.println(&quot;布隆过滤器元素总数为：&quot; + bloomFilter.count());//布隆过滤器元素总数为：4 System.out.println(&quot;是否包含tom：&quot; + bloomFilter.contains(&quot;tom&quot;));//是否包含tom：true System.out.println(&quot;是否包含lei：&quot; + bloomFilter.contains(&quot;lei&quot;));//是否包含lei：false client.shutdown();&#125; 总结布隆过滤器有着明显的优缺点，所以在使用的时候需要充分地考虑场景，还是那句话，没有最好的技术，看菜下饭才是硬道理。除了在缓存穿透中使用之外，其实还可以使用于元素去重，web拦截器等等。 这篇文章就讲到这里，感谢大家的阅读，希望看完之后能有所收获。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"缓存服务/基于Redis实现分布式锁","date":"2021-08-04T03:20:11.376Z","updated":"2021-08-04T03:17:18.628Z","comments":true,"path":"2021/08/04/缓存服务/基于Redis实现分布式锁/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言如果在一个分布式系统中，我们从数据库中读取一个数据，然后修改保存，这种情况很容易遇到并发问题。因为读取和更新保存不是一个原子操作，在并发时就会导致数据的不正确。这种场景其实并不少见，比如电商秒杀活动，库存数量的更新就会遇到。如果是单机应用，直接使用本地锁就可以避免。如果是分布式应用，本地锁派不上用场，这时就需要引入分布式锁来解决。 由此可见分布式锁的目的其实很简单，就是为了保证多台服务器在执行某一段代码时保证只有一台服务器执行。 为了保证分布式锁的可用性，至少要确保锁的实现要同时满足以下几点： 互斥性。在任何时刻，保证只有一个客户端持有锁。 不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。 保证上锁和解锁都是同一个客户端。 一般来说，实现分布式锁的方式有以下几种： 使用MySQL，基于唯一索引。 使用ZooKeeper，基于临时有序节点。 使用Redis，基于setnx命令。 本篇文章主要讲解Redis的实现方式。 实现思路Redis实现分布式锁主要利用Redis的setnx命令。setnx是SET if not exists(如果不存在，则 SET)的简写。 123456789101112127.0.0.1:6379&gt; setnx lock value1 #在键lock不存在的情况下，将键key的值设置为value1(integer) 1127.0.0.1:6379&gt; setnx lock value2 #试图覆盖lock的值，返回0表示失败(integer) 0127.0.0.1:6379&gt; get lock #获取lock的值，验证没有被覆盖&quot;value1&quot;127.0.0.1:6379&gt; del lock #删除lock的值，删除成功(integer) 1127.0.0.1:6379&gt; setnx lock value2 #再使用setnx命令设置，返回0表示成功(integer) 1127.0.0.1:6379&gt; get lock #获取lock的值，验证设置成功&quot;value2&quot; 上面这几个命令就是最基本的用来完成分布式锁的命令。 加锁：使用setnx key value命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。 解锁：使用del命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过setnx命令进行加锁。 key的值可以根据业务设置，比如是用户中心使用的，可以命令为USER_REDIS_LOCK，value可以使用uuid保证唯一，用于标识加锁的客户端。保证加锁和解锁都是同一个客户端。 那么接下来就可以写一段很简单的加锁代码： 123456789101112131415161718192021222324private static Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);private static final Long SUCCESS = 1L;/** * 加锁 */public boolean tryLock(String key, String requestId) &#123; //使用setnx命令。 //不存在则保存返回1，加锁成功。如果已经存在则返回0，加锁失败。 return SUCCESS.equals(jedis.setnx(key, requestId));&#125;//删除key的lua脚本，先比较requestId是否相等，相等则删除private static final String DEL_SCRIPT = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;/** * 解锁 */public boolean unLock(String key, String requestId) &#123; //删除成功表示解锁成功 Long result = (Long) jedis.eval(DEL_SCRIPT, Collections.singletonList(key), Collections.singletonList(requestId)); return SUCCESS.equals(result);&#125; 问题一这仅仅满足上述的第一个条件和第三个条件，保证上锁和解锁都是同一个客户端，也保证只有一个客户端持有锁。 但是第二点没法保证，因为如果一个客户端持有锁的期间突然崩溃了，就会导致无法解锁，最后导致出现死锁的现象。 所以要有个超时的机制，在设置key的值时，需要加上有效时间，如果有效时间过期了，就会自动失效，就不会出现死锁。然后加锁的代码就会变成这样。 1234567public boolean tryLock(String key, String requestId, int expireTime) &#123; //使用jedis的api，保证原子性 //NX 不存在则操作 EX 设置有效期，单位是秒 String result = jedis.set(key, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime); //返回OK则表示加锁成功 return &quot;OK&quot;.equals(result);&#125; 但是聪明的同学肯定会问，有效时间设置多长，假如我的业务操作比有效时间长，我的业务代码还没执行完就自动给我解锁了，不就完蛋了吗。 这个问题就有点棘手了，在网上也有很多讨论，第一种解决方法就是靠程序员自己去把握，预估一下业务代码需要执行的时间，然后设置有效期时间比执行时间长一些，保证不会因为自动解锁影响到客户端业务代码的执行。 但是这并不是万全之策，比如网络抖动这种情况是无法预测的，也有可能导致业务代码执行的时间变长，所以并不安全。 有一种方法比较靠谱一点，就是给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。 问题二但是聪明的同学可能又会问，你这个锁只能加一次，不可重入。可重入锁意思是在外层使用锁之后，内层仍然可以使用，那么可重入锁的实现思路又是怎么样的呢？ 在Redisson实现可重入锁的思路，使用Redis的哈希表存储可重入次数，当加锁成功后，使用hset命令，value(重入次数)则是1。 12345&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; +&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot; +&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +&quot;return nil; &quot; +&quot;end; &quot; 如果同一个客户端再次加锁成功，则使用hincrby自增加一。 123456&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +&quot;return nil; &quot; +&quot;end; &quot; +&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot; 解锁时，先判断可重复次数是否大于0，大于0则减一，否则删除键值，释放锁资源。 1234567891011121314151617protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123; return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot; +&quot;return nil;&quot; +&quot;end; &quot; +&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot; +&quot;if (counter &gt; 0) then &quot; +&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot; +&quot;return 0; &quot; +&quot;else &quot; +&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot; +&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot; +&quot;return 1; &quot;+&quot;end; &quot; +&quot;return nil;&quot;,Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));&#125; 为了保证操作原子性，加锁和解锁操作都是使用lua脚本执行。 问题三上面的加锁方法是加锁后立即返回加锁结果，如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能。所以需要利用发布订阅的机制进行优化。 步骤如下： 当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。 当持有锁的客户端释放锁的时候，发布锁释放的消息。 当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。 总结以上的实现思路仅仅考虑在单机版Redis上，如果是集群版Redis需要考虑的问题还要再多一点。Redis由于他的高性能读写能力，所以在并发高的场景下使用Redis分布式锁会多一点。 问题一，二，三其实就是redis分布式锁不断改良发展的过程，第一个问题是设置有效期防止死锁，并且引入守护线程给锁续期，第二个问题是支持可重入锁，第三个问题是加锁失败后阻塞等待，等锁释放后再次尝试加锁。Redisson框架解决这三个问题的思路也非常值得学习。 这篇文章就写到这里了，非常感谢大家的阅读，希望看完之后能得到一些启发和收获。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"缓存服务/Redis-缓存雪崩、缓存击穿、缓存穿透","date":"2021-08-04T03:20:11.368Z","updated":"2021-08-04T03:17:18.626Z","comments":true,"path":"2021/08/04/缓存服务/Redis-缓存雪崩、缓存击穿、缓存穿透/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言Redis作为目前使用最广泛的缓存，相信大家都不陌生。但是使用缓存并没有这么简单，还要考虑缓存雪崩，缓存击穿，缓存穿透的问题，什么是缓存雪崩，击穿，穿透呢，出现这些问题又怎么解决呢，接下来学习一下吧。 缓存雪崩什么是缓存雪崩？ 当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。 分析： 造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？ 解决方案： 1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。 如果真的发生了缓存雪崩，有没有什么兜底的措施？ 2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。 3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。 4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。 缓存击穿什么是缓存击穿？ 其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。 分析： 关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。 解决方案： 1、上面说过了，如果业务允许的话，对于热点的key可以设置永不过期的key。 2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。 缓存穿透什么是缓存穿透？ 我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。 分析： 关键在于在Redis查不到key值，这和缓存击穿有根本的区别，区别在于缓存穿透的情况是传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。 解决方案： 1、把无效的Key存进Redis中。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=”null”，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。 2、使用布隆过滤器。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。 总结这三个问题在使用Redis的时候是肯定会遇到的，而且是非常致命性的问题，所以在日常开发中一定要注意，每次使用Redis时，都要对其保持严谨的态度。还有一个需要注意的是要做好熔断，一旦出现缓存雪崩，击穿，穿透这种情况，至少还有熔断机制保护数据库不会被打死。 那么这篇文章就讲到这里了，感谢大家的阅读，希望看完之后能有所收获。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"分布式/日志集中分析平台ELK","date":"2021-08-04T03:20:11.343Z","updated":"2021-08-04T03:17:18.535Z","comments":true,"path":"2021/08/04/分布式/日志集中分析平台ELK/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%97%A5%E5%BF%97%E9%9B%86%E4%B8%AD%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0ELK/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 概述我们都知道，在生产环境中经常会遇到很多异常，报错信息，需要查看日志信息排查错误。现在的系统大多比较复杂，即使是一个服务背后也是一个集群的机器在运行，如果逐台机器去查看日志显然是很费力的，也不现实。 如果能把日志全部收集到一个平台，然后像百度，谷歌一样通过关键字搜索出相关的日志，岂不快哉。于是就有了集中式日志系统。ELK就是其中一款使用最多的开源产品。 一、什么是ELKELK其实是Elasticsearch，Logstash 和 Kibana三个产品的首字母缩写，这三款都是开源产品。 ElasticSearch(简称ES)，是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。 Logstash，是一个数据收集引擎，主要用于进行数据收集、解析，并将数据发送给ES。支持的数据源包括本地文件、ElasticSearch、MySQL、Kafka等等。 Kibana，为 Elasticsearch 提供了分析和 Web 可视化界面，并生成各种维度表格、图形。 二、搭建ELK环境依赖：CentOS7.5，JDK1.8，ElasticSearch7.9.3，Logstash 7.9.3，Kibana7.9.3。 2.1 安装ElasticSearch首先，到官网下载安装包，然后使用tar -zxvf命令解压。 找到config目录下的elasticsearch.yml文件，修改配置： 12345678910cluster.name: es-applicationnode.name: node-1#对所有IP开放network.host: 0.0.0.0#HTTP端口号http.port: 9200#elasticsearch数据文件存放目录path.data: /usr/elasticsearch-7.9.3/data#elasticsearch日志文件存放目录path.logs: /usr/elasticsearch-7.9.3/logs 配置完之后，因为ElasticSearch使用非root用户启动，所以创建一个用户。 123456# 创建用户useradd yehongzhi# 设置密码passwd yehongzhi# 赋予用户权限chown -R yehongzhi:yehongzhi /usr/elasticsearch-7.9.3/ 然后切换用户，启动： 1234# 切换用户su yehongzhi# 启动 -d表示后台启动./bin/elasticsearch -d 使用命令netstat -nltp查看端口号： 访问http://192.168.0.109:9200/可以看到如下信息，表示安装成功。 2.2 安装Logstash首先在官网下载安装压缩包，然后解压，找到/config目录下的logstash-sample.conf文件，修改配置： 1234567891011121314input &#123; file&#123; path =&gt; [&#x27;/usr/local/user/*.log&#x27;] type =&gt; &#x27;user_log&#x27; start_position =&gt; &quot;beginning&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;http://192.168.0.109:9200&quot;] index =&gt; &quot;user-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125; input表示输入源，output表示输出，还可以配置filter过滤，架构如下： 配置完之后，要有数据源，也就是日志文件，准备一个user.jar应用程序，然后后台启动，并且输出到日志文件user.log中，命令如下： 1nohup java -jar user.jar &gt;/usr/local/user/user.log &amp; 接着再后台启动Logstash，命令如下： 1nohup ./bin/logstash -f /usr/logstash-7.9.3/config/logstash-sample.conf &amp; 启动完之后，使用jps命令，可以看到两个进程在运行： 2.3 安装Kibana首先还是到官网下载压缩包，然后解压，找到/config目录下的kibana.yml文件，修改配置： 123server.port: 5601server.host: &quot;192.168.0.111&quot;elasticsearch.hosts: [&quot;http://192.168.0.109:9200&quot;] 和elasticSearch一样，不能使用root用户启动，需要创建一个用户： 123456# 创建用户useradd kibana# 设置密码passwd kibana# 赋予用户权限chown -R kibana:kibana /usr/kibana/ 然后使用命令启动： 123456#切换用户su kibana#非后台启动，关闭shell窗口即退出./bin/kibana#后台启动nohup ./bin/kibana &amp; 启动后在浏览器打开http://192.168.0.111:5601，可以看到kibana的web交互界面： 2.4 效果展示全部启动成功后，整个过程应该是这样，我们看一下： 浏览器打开http://192.168.0.111:5601，到管理界面，点击“Index Management”可以看到，有一个user-2020.10.31的索引。 点击Index Patterns菜单栏，然后创建，命名为user-*。 最后，就可以到Discover栏进行选择，选择user-*的Index Pattern，然后搜索关键字，就找到相关的日志了！ 三、改进优化上面只是用到了核心的三个组件简单搭建的ELK，实际上是有缺陷的。如果Logstash需要添加插件，那就全部服务器的Logstash都要添加插件，扩展性差。所以就有了FileBeat，占用资源少，只负责采集日志，不做其他的事情，这样就轻量级，把Logstash抽出来，做一些滤处理之类的工作。 FileBeat也是官方推荐用的日志采集器，首先下载Linux安装压缩包： 1https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.9.3-linux-x86_64.tar.gz 下载完成后，解压。然后修改filebeat.yml配置文件： 12345678910111213#输入源filebeat.inputs:- type: log enabled: true paths: - /usr/local/user/*.log#输出，Logstash的服务器地址output.logstash: hosts: [&quot;192.168.0.110:5044&quot;]#输出，如果直接输出到ElasticSearch则填写这个#output.elasticsearch: #hosts: [&quot;localhost:9200&quot;] #protocol: &quot;https&quot; 然后Logstash的配置文件logstash-sample.conf，也要改一下： 1234567#输入源改成beatsinput &#123; beats &#123; port =&gt; 5044 codec =&gt; &quot;json&quot; &#125;&#125; 然后启动FileBeat： 12#后台启动命令nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp; 再启动Logstash： 12#后台启动命令nohup ./bin/logstash -f /usr/logstash-7.9.3/config/logstash-sample.conf &amp; 怎么判断启动成功呢，看Logstash应用的/logs目录下的logstash-plain.log日志文件： 写在最后目前，很多互联网公司都是采用ELK来做日志集中式系统，原因很简单：开源、插件多、易扩展、支持数据源多、社区活跃、开箱即用等等。我见过有一个公司在上面的架构中还会加多一个Kafka的集群，主要是基于日志数据量比较大的考虑。但是呢，基本的三大组件ElasticSearch，Logstash，Kibana是不能少的。 希望这篇文章能帮助大家对ELK有一些初步的认识，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"分布式/skywalking调用链追踪","date":"2021-08-04T03:20:11.323Z","updated":"2021-08-04T03:17:18.529Z","comments":true,"path":"2021/08/04/分布式/skywalking调用链追踪/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%88%86%E5%B8%83%E5%BC%8F/skywalking%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%BD%E8%B8%AA/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 概述**skywalking**又是一个优秀的国产开源框架，2015年由个人吴晟（华为开发者）开源 ， 2017年加入Apache孵化器。 skywalking是分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案（官网介绍）。 一、OpenTracing规范OpenTracing是一种分布式系统链路跟踪的设计原则、规范、标准。 类似JDBC的规范，主要为了提供一套标准的JDBC API。OpenTracing也是一样，是为了统一提供一套链路追踪的标准API，所制定的一种规范。 OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 类似于JDBC的规范由各个数据库厂商实现一样，OpenTracing规范也是有很多实现的产品，下面介绍一下落地的产品。 1.1 实现OpenTracing的产品Jaeger：Jaeger是由Uber公司开源发布的，受到Dapper和OpenZipkin启发。后端使用Go语言，前端(用户界面)使用React 。优点是上传采用的是udp传输，效率高速度快。缺点就是丢包，影响了整条调用链，而且不支持告警和JVM监控。 Zipkin：SpringCloud官方推荐，可以与SpringCloud有良好集成，实现方式是拦截请求，发送(http)数据到zipkin服务。缺点在于不支持告警，不支持JVM监控，通信方式使用Http请求向Zipkin上报信息，比较耗性能。 SkyWalking：国人(吴晟)开发，支持dubbo，SpringCloud，SpringBoot集成，代码无侵入，通信方式采用GRPC，性能较好，实现方式是java探针，支持告警，支持JVM监控，支持全局调用统计等等，功能较完善。缺点是依赖较多，需要ElasticSearch，JDK环境，Nacos注册中心等。 1.2 skywalking的特点 比较重要的特点，我觉得是轻量高效，对代码无侵入性。对于微服务，支持dubbo，SpringBoot，SpringCloud集成。 二、安装部署环境：CentOS 7.5，MySQL 5.7.26，Nacos 1.3.1（注册中心），JDK 1.8，skywalking 8.1.0。 除了skywalking之外，其他需要用到的组件我就不介绍怎么安装了，比较简单。安装skywalking其实很简单，下面一步一步来讲解。 第一步，下载。在官网下载即可，选择8.1.0版本，如果要使用ES作为存储仓库，那就要选择es7的版本。 第二步，解压。找到config目录下的application.yml文件，然后修改配置。 需要修改的配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041cluster: selector: $&#123;SW_CLUSTER:nacos&#125; #单机模式 standalone: #使用nacos作为注册中心 nacos: # 注册到nacos的服务名 serviceName: $&#123;SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;&#125; #nacos服务端的地址 hostPort: $&#123;SW_CLUSTER_NACOS_HOST_PORT:192.168.0.105:8848&#125; # Nacos Configuration namespace命名空间 namespace: $&#123;SW_CLUSTER_NACOS_NAMESPACE:&quot;public&quot;&#125;core: selector: $&#123;SW_CORE:default&#125; default: #skywalking服务端的REST绑定的IP restHost: $&#123;SW_CORE_REST_HOST:192.168.0.107&#125; #skywalking服务端的REST调用的端口 restPort: $&#123;SW_CORE_REST_PORT:12800&#125; #skywalking服务端GRPC通信绑定的IP gRPCHost: $&#123;SW_CORE_GRPC_HOST:192.168.0.107&#125; #skywalking服务端GRPC通信绑定的端口 gRPCPort: $&#123;SW_CORE_GRPC_PORT:11800&#125;storage: #选择使用mysql selector: $&#123;SW_STORAGE:mysql&#125; #默认使用h2，不会持久化，重启skyWalking之前的数据会丢失 h2: driver: $&#123;SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource&#125; url: $&#123;SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db&#125; user: $&#123;SW_STORAGE_H2_USER:sa&#125; metadataQueryMaxSize: $&#123;SW_STORAGE_H2_QUERY_MAX_SIZE:5000&#125; #使用mysql作为持久化存储的仓库 mysql: properties: #数据库连接地址 jdbcUrl: $&#123;SW_JDBC_URL:&quot;jdbc:mysql://192.168.0.107:3306/swtest&quot;&#125; #用户名 dataSource.user: $&#123;SW_DATA_SOURCE_USER:yehongzhi&#125; #密码 dataSource.password: $&#123;SW_DATA_SOURCE_PASSWORD:Yehongzhi520.&#125; 默认是web管理界面是8080端口，如果要修改端口号，可以修改webapp目录下的webapp.yml。 123#web管理界面的端口server: port: 8080 第三步，添加mysql数据驱动包。因为在lib目录下是没有mysql数据驱动包的，所以修改完配置启动是会报错，启动失败的。为什么作者不提前在lib目录下放一个数据驱动包呢，还要我们手动去添加。网上貌似没有这个问题的讨论，我的理解是因为框架不知道你用的是什么版本的mysql数据库，所以不知道放什么版本的数据库驱动包，使用者用的是什么版本的mysql，就自己放对应的数据库驱动包。 我这里用的是5.7.26版本的mysql，所以我下载了一个8.0.17的驱动包，添加到/oap-libs目录下。 第三步，启动。在/bin目录上一级，直接使用./bin/startup.sh启动即可。启动之后，可以使用jps命令查看进程，可以看到这两个java程序在运行状态。 打开配置的Nacos控制台，可以看到服务列表注册了名为“SkyWalking_OAP_Cluster”的服务。 可以看到mysql建了很多表。 说明启动成功了，打开配置对应的地址http://192.168.0.109:8080/，可以看到skywalking的web界面。 三、整合SpringCloud工程整合其实很简单，不需要引入依赖，也不需要添加任何代码，我们只需要在启动jar包时配置参数即可。 1234567-javaagent:D:\\apache-skywalking-apm-bin-es7\\agent\\skywalking-agent.jar-Dskywalking.agent.service_name=consumer-Dskywalking.collector.backend_service=192.168.0.109:11800#解释一下上面这三个参数的意思#-javaagent:填的是skywalking-agent.jar的本地磁盘的路径#-Dskywalking.agent.service_name：在skywalking上显示的服务名#-Dskywalking.collector.backend_service：skywalking的collector服务的IP及端口 我们一般用IDEA开发就这样设置即可。 接下来我按照这个配置，启动一个Consumer工程和Provider工程，并且注册到Nacos注册中心。 然后使用Consumer工程的接口调用Provider工程的接口，可以看到调用链的效果。 非常清晰地看到服务之间调用的情况，耗时等等。其他还有很多功能就不一一介绍了，读者可以自己探索一下。 四、谈谈架构设计可能前面还有一些疑问，比如为什么要设置GRPC的端口号，设置存储仓库为mysql，启动之后有两个java进程等等。不妨看看架构，一切问题都明白了。首先看官网的一张架构图。 可以看到主要有四个部分。 上面的Agent ：负责从应用中，收集tracing(调用链数据)和metric(指标)，发送给 SkyWalking OAP 服务器。目前支持 SkyWalking、Zikpin、Jaeger 等提供的 Tracing 数据信息。而我们目前采用的是，SkyWalking Agent 收集 SkyWalking Tracing 数据，传递给SkyWalking OAP 服务器。 中间的SkyWalking OAP：负责接收 Agent 发送的 Tracing 和Metric的数据信息，然后进行分析(Analysis Core) ，存储到外部存储器( Storage )，最终提供查询( Query )功能。 左边的SkyWalking UI：负责提供web控制台，查看链路，查看各种指标，性能等等。 右边的Storage：数据存储。目前支持ES、MySQL、H2等多种存储器。 总结这篇文章就介绍到这里，这里仅仅只是入门，简单使用Skywalking，实际上里面还有很多功能我没有介绍，有兴趣的同学可以按照上面的教程安装部署，然后自己探索一下。 在现在微服务架构比较流行的环境下，如果没有一个调用链追踪框架，会导致很难排查线上服务调用的问题。skywalking是目前发展势头最快的技术框架的技术框架，因为对代码是无侵入性的，所以目前很多公司都采用Skywalking。 这篇文章就讲到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"分布式/3千字带你搞懂XXL-JOB任务调度平台","date":"2021-08-04T03:20:11.318Z","updated":"2021-08-04T03:17:18.523Z","comments":true,"path":"2021/08/04/分布式/3千字带你搞懂XXL-JOB任务调度平台/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%88%86%E5%B8%83%E5%BC%8F/3%E5%8D%83%E5%AD%97%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82XXL-JOB%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、概述在平时的业务场景中，经常有一些场景需要使用定时任务，比如： 时间驱动的场景：某个时间点发送优惠券，发送短信等等。 批量处理数据：批量统计上个月的账单，统计上个月销售数据等等。 固定频率的场景：每隔5分钟需要执行一次。 所以定时任务在平时开发中并不少见，而且对于现在快速消费的时代，每天都需要发送各种推送，消息都需要依赖定时任务去完成，应用非常广泛。 二、为什么需要任务调度平台在Java中，传统的定时任务实现方案，比如Timer，Quartz等都或多或少存在一些问题： 不支持集群、不支持统计、没有管理平台、没有失败报警、没有监控等等 而且在现在分布式的架构中，有一些场景需要分布式任务调度： 同一个服务多个实例的任务存在互斥时，需要统一的调度。 任务调度需要支持高可用、监控、故障告警。 需要统一管理和追踪各个服务节点任务调度的结果，需要记录保存任务属性信息等。 显然传统的定时任务已经不满足现在的分布式架构，所以需要一个分布式任务调度平台，目前比较主流的是elasticjob和xxl-job。 elasticjob由当当网开源，目前github有6.5k的Star，使用的公司在官网登记有76家。 跟xxl-job不同的是，elasticjob是采用zookeeper实现分布式协调，实现任务高可用以及分片。 三、为什么选择XXL-JOB实际上更多公司选择xxl-job，目前xxl-job的github上有15.7k个star，登记公司有348个。毫无疑问elasticjob和xxl-job都是非常优秀的技术框架，接下来我们进一步对比讨论，探索一下为什么更多公司会选择xxl-job。 首先先介绍一下xxl-job，这是出自大众点评许雪里(xxl就是作者名字的拼音首字母)的开源项目，官网上介绍这是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。跟elasticjob不同，xxl-job环境依赖于mysql，不用ZooKeeper，这也是最大的不同。 elasticjob的初衷是为了面对高并发复杂的业务，即使是在业务量大，服务器多的时候也能做好任务调度，尽可能的利用服务器的资源。使用ZooKeeper使其具有高可用、一致性的，而且还具有良好的扩展性。官网上写elasticjob是无中心化的，通过ZooKeeper的选举机制选举出主服务器，如果主服务器挂了，会重新选举新的主服务器。因此elasticjob具有良好的扩展性和可用性，但是使用和运维有一定的复杂。 xxl-job则相反，是通过一个中心式的调度平台，调度多个执行器执行任务，调度中心通过DB锁保证集群分布式调度的一致性，这样扩展执行器会增大DB的压力，但是如果实际上这里数据库只是负责任务的调度执行。但是如果没有大量的执行器的话和任务的情况，是不会造成数据库压力的。实际上大部分公司任务数，执行器并不多(虽然面试经常会问一些高并发的问题)。 相对来说，xxl-job中心式的调度平台轻量级，开箱即用，操作简易，上手快，与SpringBoot有非常好的集成，而且监控界面就集成在调度中心，界面又简洁，对于企业维护起来成本不高，还有失败的邮件告警等等。这就使很多企业选择xxl-job做调度平台。 四、安装4.1 拉取源码搭建xxl-job很简单，有docker拉取镜像部署和源码编译两种方式，docker部署的方式比较简单，我就讲源码编译的方式。首先到github拉取xxl-job源码到本地。 4.2 导入IDEA拉取源码下来后，可以看到项目结构，如下： 导入到IDEA，配置一下Maven，下载相关的jar包，稍等一下后，就可以看到这样的项目： 4.3 初始化数据库前面讲过xxl-job需要依赖mysql，所以需要初始化数据库，在xxl-job\\doc\\db路径下找到tables_xxl_job.sql文件。在mysql上运行sql文件。 4.4 配置文件接着就改一下配置文件，在admin项目下找到application.properties文件。 1234567891011121314151617181920212223### 调度中心JDBC链接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.jdbc.Driver### 报警邮箱spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### 调度中心通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；xxl.job.logretentiondays=10 4.5 编译运行简单一点直接跑admin项目的main方法启动也行。 如果部署在服务器呢，那我们需要打包成jar包，在IDEA利用Maven插件打包。 然后在xxl-job\\xxl-job-admin\\target路径下，找到jar包。 然后就得到jar包了，使用java -jar命令就可以启动了。 到这里就已经完成了！打开浏览器，输入http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。 永远的HelloWord部署了调度中心之后，需要往调度中心注册执行器，添加调度任务。接下来就参考xxl-job写一个简单的例子。 首先创建一个SpringBoot项目，名字叫”xxljob-demo”，添加依赖。 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 官网的demo是2.2.1，中央maven仓库还没有，所以就用2.2.0 --&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接着修改application.properties。 123456789101112131415161718192021# web portserver.port=8081# log configlogging.config=classpath:logback.xmlspring.application.name=xxljob-demo### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-demo### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=10 接着写一个配置类XxlJobConfig。 1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125;&#125; 接着编写一个任务类XxlJobDemoHandler，使用Bean模式。 123456789101112131415@Componentpublic class XxlJobDemoHandler &#123; /** * Bean模式，一个方法为一个任务 * 1、在Spring Bean实例中，开发Job方法，方式格式要求为 &quot;public ReturnT&lt;String&gt; execute(String param)&quot; * 2、为Job方法添加注解 &quot;@XxlJob(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 3、执行日志：需要通过 &quot;XxlJobLogger.log&quot; 打印执行日志； */ @XxlJob(&quot;demoJobHandler&quot;) public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception &#123; XxlJobLogger.log(&quot;java, Hello World~~~&quot;); XxlJobLogger.log(&quot;param:&quot; + param); return ReturnT.SUCCESS; &#125;&#125; 在resources目录下，添加logback.xml文件。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=&quot;log.path&quot; value=&quot;/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log&quot;/&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;appender-ref ref=&quot;file&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 写完之后启动服务，然后可以打开管理界面，找到执行器管理，添加执行器。 接着到任务管理，添加任务。 最后我们可以到任务管理去测试一下，运行demoJobHandler。 点击保存后，会立即执行。点击查看日志，可以看到任务执行的历史日志记录。 打开刚刚执行的执行日志，我们可以看到，运行成功。 这就是简单的Demo演示，非常简单，上手也快。 谈谈架构设计下面简单地说一下xxl-job的架构，我们先看官网提供的一张架构图来分析。 从架构图可以看出，分别有调度中心和执行器两大组成部分 调度中心。负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。支持可视化界面，可以在调度中心对任务进行新增，更新，删除，会实时生效。支持监控调度结果，查看执行日志，查看调度任务统计报表，任务失败告警等等。 执行器。负责接收调度请求，执行调度任务的业务逻辑。执行器启动后需要注册到调度中心。接收调度中心的发出的执行请求，终止请求，日志请求等等。 接下来我们看一下xxl-job的工作原理。 任务执行器根据配置的调度中心的地址，自动注册到调度中心。 达到任务触发条件，调度中心下发任务。 执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中。 执行器的回调线程消费内存队列中的执行结果，主动上报给调度中心。 当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情。 絮叨看完以上的内容，基本算入门了。实际上，xxl-job还有很多功能，要深入学习，还需要到官网去研究探索。最好就是自己在本地搭建一个xxl-job来玩玩，动手实践是学得最快的学习方式。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"并发编程的艺术/面试官问我什么是JMM","date":"2021-08-04T03:20:11.231Z","updated":"2021-08-04T03:17:18.582Z","comments":true,"path":"2021/08/04/并发编程的艺术/面试官问我什么是JMM/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E4%BB%80%E4%B9%88%E6%98%AFJMM/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 面试官：讲讲什么是JMM你要是整这个我可就不困了。 JMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。 Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。 不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。 如果听起来抽象的话，我可以画张图给你看看，会直观一点： 每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。 温馨提醒一下，这里有些人会把Java内存模型误解为Java内存结构，然后答到堆，栈，GC垃圾回收，最后和面试官想问的问题相差甚远。实际上一般问到Java内存模型都是想问多线程，Java并发相关的问题。 面试官：那JMM定义了什么这个简单，整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。 原子性原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。 面试官拿笔写了段代码，下面这几句代码能保证原子性吗？ 1234int i = 2;int j = i;i++;i = i + 1; 第一句是基本类型赋值操作，必定是原子性操作。 第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。 第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。 JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。 可见性可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。 除了volatile关键字之外，final和synchronized也能实现可见性。 synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。 final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。 有序性在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别： volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。 synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。 面试官：给我讲一下八种内存交互操作吧好的，面试官，内存交互操作有8种，我画张图给你看吧： lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。 read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。 load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。 use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。 store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。 write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 我再补充一下JMM对8种内存交互操作制定的规则吧： 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。 不允许线程将没有assign的数据从工作内存同步到主内存。 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。 面试官：讲一下volatile关键字吧内心：这可以重头戏呀，可不能出岔子~ 很多并发编程都使用了volatile关键字，主要的作用包括两点： 保证线程间变量的可见性。 禁止CPU进行指令重排序。 可见性volatile修饰的变量，当一个线程改变了该变量的值，其他线程是立即可见的。普通变量则需要重新读取才能获得最新值。 volatile保证可见性的流程大概就是这个一个过程： volatile一定能保证线程安全吗先说结论吧，volatile不能一定能保证线程安全。 怎么证明呢，我们看下面一段代码的运行结果就知道了： 1234567891011121314151617181920212223242526272829303132333435/** * @author Ye Hongzhi 公众号：java技术爱好者 **/public class VolatileTest extends Thread &#123; private static volatile int count = 0; public static void main(String[] args) throws Exception &#123; Vector&lt;Thread&gt; threads = new Vector&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; VolatileTest thread = new VolatileTest(); threads.add(thread); thread.start(); &#125; //等待子线程全部完成 for (Thread thread : threads) &#123; thread.join(); &#125; //输出结果，正确结果应该是1000，实际却是984 System.out.println(count);//984 &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; //休眠500毫秒 Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; count++; &#125; &#125;&#125; 为什么volatile不能保证线程安全？ 很简单呀，可见性不能保证操作的原子性，前面说过了count++不是原子性操作，会当做三步，先读取count的值，然后+1，最后赋值回去count变量。需要保证线程安全的话，需要使用synchronized关键字或者lock锁，给count++这段代码上锁： 123private static synchronized void add() &#123; count++;&#125; 禁止指令重排序首先要讲一下as-if-serial语义，不管怎么重排序，（单线程）程序的执行结果不能被改变。 为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。 重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。整个过程如下所示： 指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。 所以在多线程环境下，就需要禁止指令重排序。 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 下面举个例子： 123456789101112private static int a;//非volatile修饰变量private static int b;//非volatile修饰变量private static volatile int k;//volatile修饰变量private void hello() &#123; a = 1; //语句1 b = 2; //语句2 k = 3; //语句3 a = 4; //语句4 b = 5; //语句5 //以下省略...&#125; 变量a，b是非volatile修饰的变量，k则使用volatile修饰。所以语句3不能放在语句1、2前，也不能放在语句4、5后。但是语句1、2的顺序是不能保证的，同理，语句4、5也不能保证顺序。 并且，执行到语句3的时候，语句1，2是肯定执行完毕的，而且语句1,2的执行结果对于语句3,4,5是可见的。 volatile禁止指令重排序的原理是什么首先要讲一下内存屏障，内存屏障可以分为以下几类： LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。 在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。 大概的原理就是这样。 面试官：讲得还不错，基本上都讲到了，时间也不早了，今天的面试就到这吧，回去等通知吧~ 啊？就这？ 总结要学习并发编程，java内存模型是第一站了。原子性，有序性，可见性这三大特征几乎贯穿了并发编程，可谓是基础知识。对于后面要深入学习起到铺垫作用。 在这篇文章中，如果面试的话，重点是Java内存模型(JMM)的工作方式，三大特征，还有volatile关键字。为什么喜欢问volatile关键字呢，因为volatile关键字可以扯出很多东西，比如可见性，有序性，还有内存屏障等等。可以一针见血地看出面试者的技术水平，毕竟面试官也想高效地筛选出符合要求的人才嘛。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"并发编程的艺术/死磕synchronized关键字底层原理","date":"2021-08-04T03:20:11.226Z","updated":"2021-08-04T03:17:18.581Z","comments":true,"path":"2021/08/04/并发编程的艺术/死磕synchronized关键字底层原理/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E6%AD%BB%E7%A3%95synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言作为Java程序员，我们都知道在多线程的情况下，为了保证线程安全，经常会使用synchronized和Lock锁。Lock锁之前写过一篇《不得不学的AQS》，已经详细讲解过Lock锁的底层原理。这次我们讲一下日常开发中常用的关键字synchronized，想要用得好，底层原理必须要搞明白。 synchronized是JDK自带的一个关键字，在JDK1.5之前是一个重量级锁，所以从性能上考虑大部分人会选择Lock锁，不过毕竟是JDK自带的关键字，所以在JDK1.6后对它进行优化，引入了偏向锁，轻量级锁，自旋锁等概念。 一、synchronized的使用方式在语法上，要使用synchronized关键字，需要把任意一个非null对象作为”锁”对象，也就是需要一个对象监视器（Object Monitor）。总的来说有三种用法： 1.1 作用在实例方法修饰实例方法，相当于对当前实例对象this加锁，this作为对象监视器。 123public synchronized void hello()&#123; System.out.println(&quot;hello world&quot;);&#125; 1.2 作用在静态方法修饰静态方法，相当于对当前类的Class对象加锁，当前类的Class对象作为对象监视器。 123public synchronized static void helloStatic()&#123; System.out.println(&quot;hello world static&quot;);&#125; 1.3 修饰代码块指定加锁对象，对给定对象加锁，括号括起来的对象就是对象监视器。 123456public void test()&#123; SynchronizedTest test = new SynchronizedTest(); synchronized (test)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 二、synchronized锁的原理在讲原理前，我们先讲一下Java对象的构成。在JVM中，对象在内存中分为三块区域：对象头，实例数据和对齐填充。如图所示： 对象头： Mark Word，用于存储对象自身运行时的数据，如哈希码(Hash Code)，GC分代年龄，锁状态标志，偏向线程ID、偏向时间戳等信息，它会根据对象的状态复用自己的存储空间。它是实现轻量级锁和偏向锁的关键。 类型指针，对象会指向它的类的元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。 Array length，如果对象是一个数组，还必须记录数组长度的数据。 实例数据： 存放类的属性数据信息，包括父类的属性信息。 对齐填充： 由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。 2.1 同步代码块原理为了看底层实现原理，使用javap -v xxx.class命令进行反编译。 这是使用同步代码块被标志的地方就是刚刚提到的对象头，它会关联一个monitor对象，也就是括号括起来的对象。 1、monitorenter，如果当前monitor的进入数为0时，线程就会进入monitor，并且把进入数+1，那么该线程就是monitor的拥有者(owner)。 2、如果该线程已经是monitor的拥有者，又重新进入，就会把进入数再次+1。也就是可重入的。 3、monitorexit，执行monitorexit的线程必须是monitor的拥有者，指令执行后，monitor的进入数减1，如果减1后进入数为0，则该线程会退出monitor。其他被阻塞的线程就可以尝试去获取monitor的所有权。 monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁； 总的来说，synchronized的底层原理是通过monitor对象来完成的。 2.2 同步方法原理比如说使用synchronized修饰的实例方法。 123public synchronized void hello()&#123; System.out.println(&quot;hello world&quot;);&#125; 同理使用javap -v反编译。 可以看到多了一个标志位ACC_SYNCHRONIZED，作用就是一旦执行到这个方法时，就会先判断是否有标志位，如果有这个标志位，就会先尝试获取monitor，获取成功才能执行方法，方法执行完成后再释放monitor。在方法执行期间，其他线程都无法获取同一个monitor。归根结底还是对monitor对象的争夺，只是同步方法是一种隐式的方式来实现。 2.3 Monitor上面经常提到monitor，它内置在每一个对象中，任何一个对象都有一个monitor与之关联，synchronized在JVM里的实现就是基于进入和退出monitor来实现的，底层则是通过成对的MonitorEnter和MonitorExit指令来实现，因此每一个Java对象都有成为Monitor的潜质。所以我们可以理解monitor是一个同步工具。 三、synchronized锁的优化前面讲过JDK1.5之前，synchronized是属于重量级锁，重量级需要依赖于底层操作系统的Mutex Lock实现，然后操作系统需要切换用户态和内核态，这种切换的消耗非常大，所以性能相对来说并不好。 既然我们都知道性能不好，JDK的开发人员肯定也是知道的，于是在JDK1.6后开始对synchronized进行优化，增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。锁的等级从无锁，偏向锁，轻量级锁，重量级锁逐步升级，并且是单向的，不会出现锁的降级。 3.1 自适应性自旋锁在说自适应自旋锁之前，先讲自旋锁。上面已经讲过，当线程没有获得monitor对象的所有权时，就会进入阻塞，当持有锁的线程释放了锁，当前线程才可以再去竞争锁，但是如果按照这样的规则，就会浪费大量的性能在阻塞和唤醒的切换上，特别是线程占用锁的时间很短的话。 为了避免阻塞和唤醒的切换，在没有获得锁的时候就不进入阻塞，而是不断地循环检测锁是否被释放，这就是自旋。在占用锁的时间短的情况下，自旋锁表现的性能是很高的。 但是又有问题，由于线程是一直在循环检测锁的状态，就会占用cpu资源，如果线程占用锁的时间比较长，那么自旋的次数就会变多，占用cpu时间变长导致性能变差，当然我们也可以通过参数-XX:PreBlockSpin设置自旋锁的自旋次数，当自旋一定的次数(时间)后就挂起，但是设置的自旋次数是多少比较合适呢？ 如果设置次数少了或者多了都会导致性能受到影响，而且占用锁的时间在业务高峰期和正常时期也有区别，所以在JDK1.6引入了自适应性自旋锁。 自适应性自旋锁的意思是，自旋的次数不是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 表现是如果此次自旋成功了，很有可能下一次也能成功，于是允许自旋的次数就会更多，反过来说，如果很少有线程能够自旋成功，很有可能下一次也是失败，则自旋次数就更少。这样能最大化利用资源，随着程序运行和性能监控信息的不断完善，虚拟机对锁的状况预测会越来越准确，也就变得越来越智能。 3.2 锁消除锁消除是一种锁的优化策略，这种优化更加彻底，在JVM编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。这种优化策略可以消除没有必要的锁，节省毫无意义的请求锁时间。比如StringBuffer的append()方法，就是使用synchronized进行加锁的。 12345public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125; 如果在实例方法中StringBuffer作为局部变量使用append()方法，StringBuffer是不可能存在共享资源竞争的，因此会自动将其锁消除。例如： 123456public String add(String s1, String s2) &#123; //sb属于不可能共享的资源,JVM会自动消除内部的锁 StringBuffer sb = new StringBuffer(); sb.append(s1).append(s2); return sb.toString();&#125; 3.3 锁粗化如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。意思是将多个连续加锁、解锁的操作连接在一起，扩展成为一个范围更大的锁。 3.4 偏向锁偏向锁是JDK1.6引入的一个重要的概念，JDK的开发人员经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。也就是说在很多时候我们是假设有多线程的场景，但是实际上却是单线程的。所以偏向锁是在单线程执行代码块时使用的机制。 原理是什么呢，我们前面提到锁的争夺实际上是Monitor对象的争夺，还有每个对象都有一个对象头，对象头是由Mark Word和Klass pointer 组成的。一旦有线程持有了这个锁对象，标志位修改为1，就进入偏向模式，同时会把这个线程的ID记录在对象的Mark Word中，当同一个线程再次进入时，就不再进行同步操作，这样就省去了大量的锁申请的操作，从而提高了性能。 一旦有多个线程开始竞争锁的话呢？那么偏向锁并不会一下子升级为重量级锁，而是先升级为轻量级锁。 3.5 轻量级锁如果获取偏向锁失败，也就是有多个线程竞争锁的话，就会升级为JDK1.6引入的轻量级锁，Mark Word 的结构也变为轻量级锁的结构。 执行同步代码块之前，JVM会在线程的栈帧中创建一个锁记录（Lock Record），并将Mark Word拷贝复制到锁记录中。然后尝试通过CAS操作将Mark Word中的锁记录的指针，指向创建的Lock Record。如果成功表示获取锁状态成功，如果失败，则进入自旋获取锁状态。 自旋锁的原理在上面已经讲过了，如果自旋获取锁也失败了，则升级为重量级锁，也就是把线程阻塞起来，等待唤醒。 3.6 重量级锁重量级锁就是一个悲观锁了，但是其实不是最坏的锁，因为升级到重量级锁，是因为线程占用锁的时间长(自旋获取失败)，锁竞争激烈的场景，在这种情况下，让线程进入阻塞状态，进入阻塞队列，能减少cpu消耗。所以说在不同的场景使用最佳的解决方案才是最好的技术。synchronized在不同的场景会自动选择不同的锁，这样一个升级锁的策略就体现出了这点。 3.7 小结偏向锁：适用于单线程执行。 轻量级锁：适用于锁竞争较不激烈的情况。 重量级锁：适用于锁竞争激烈的情况。 四、Lock锁与synchronized的区别我们看一下他们的区别： synchronized是Java语法的一个关键字，加锁的过程是在JVM底层进行。Lock是一个类，是JDK应用层面的，在JUC包里有丰富的API。 synchronized在加锁和解锁操作上都是自动完成的，Lock锁需要我们手动加锁和解锁。 Lock锁有丰富的API能知道线程是否获取锁成功，而synchronized不能。 synchronized能修饰方法和代码块，Lock锁只能锁住代码块。 Lock锁有丰富的API，可根据不同的场景，在使用上更加灵活。 synchronized是非公平锁，而Lock锁既有非公平锁也有公平锁，可以由开发者通过参数控制。 个人觉得在锁竞争不是很激烈的场景，使用synchronized，语义清晰，实现简单，JDK1.6后引入了偏向锁，轻量级锁等概念后，性能也能保证。而在锁竞争激烈，复杂的场景下，则使用Lock锁会更灵活一点，性能也较稳定。 总结学习synchronized关键字的底层原理不是钻牛角尖，其实是从底层原理上知道了synchronized在什么场景使用会有什么样的效果，我们都知道没有最好的技术，只有最适合的技术，所以在学完之后，希望对大家有所帮助，写出更加高效的代码。所谓不积跬步无以至千里，一步一个脚印，哪怕现在还是菜鸟，总有一天也会成为雄鹰。 那么这篇文章就写到这里了，感谢大家的阅读，希望看完后能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"并发编程的艺术/并发编程里的悲观锁和乐观锁","date":"2021-08-04T03:20:11.221Z","updated":"2021-08-04T03:17:18.578Z","comments":true,"path":"2021/08/04/并发编程的艺术/并发编程里的悲观锁和乐观锁/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8C%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 悲观锁悲观锁是平时开发中经常用到的一种锁，比如ReentrantLock和synchronized等就是这种思想的体现，它总是假设别的线程在拿线程的时候都会修改数据，所以每次拿到数据的时候都会上锁，这样别的线程想拿这个数据就会被阻塞。如图所示： synchronized是悲观锁的一种实现，一般我们都会有这样使用： 12345678910111213141516private static Object monitor = new Object();public static void main(String[] args) throws Exception &#123; //锁一段代码块 synchronized (monitor)&#123; &#125;&#125;//锁实例方法，锁对象是this，即该类实例本身public synchronized void doSome()&#123;&#125;//锁静态方法，锁对象是该类，即XXX.classpublic synchronized static void add()&#123;&#125; 我们以最简单的同步代码块来分析，其实就是将synchronized作用于一个给定的实例对象monitor，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有monitor实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行synchronized内包裹的代码块。 从上面的分析中可以看出，悲观锁是独占和排他的，只要操作资源都会对资源进行加锁。假设读多写少的情况下，使用悲观锁的效果就不是很好。这时就引出了接下来要讲的乐观锁。 乐观锁乐观锁，顾名思义它总是假设最好的情况，线程每次去拿数据时都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。如图所示： 一般乐观锁在java中是通过无锁编程实现的，最常见的就是CAS算法，比如Java并发包中的原子类的递增操作就是通过CAS算法实现的。 CAS算法，其实就是Compare And Swap(比较与交换)的意思。目的就是将内存的值更新为需要的值，但是有个条件，内存值必须与期待的原内存值相同。展开来说，我们有三个变量，内存值M，期望的内存值E，更新值U，只有当M==E时，才会将M更新为U。 CAS算法实现的乐观锁在很多地方有应用，比如并发包的原子类AtomicInteger类。在自增的时候就使用到CAS算法。 12345678910111213141516171819202122public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;//var1 是this指针//var2 是偏移量//var4 是自增量public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; //获取内存，称之为期待的内存值E var5 = this.getIntVolatile(var1, var2); //var5 + var4的结果是更新值U //这里使用JNI方法，每个线程将自己内存中的内存值M与var5期望值比较， //如果相同则更新为var5 + var4，返回true跳出循环。 //如果不相同，则把内存值M更新为最新的内存值，然后自旋，直到更新成功为止 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); //返回更新后的值 return var5;&#125;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 所以可以看出CAS算法其实是无锁的。好处是在读多写少的情况下，性能是比较好的。那么CAS算法的缺点其实也是很明显的。 ABA问题。线程C将内存值A改成了B后，又改成了A，而线程D会认为内存值A没有改变过，这个问题就称为ABA问题。解决办法很简单，在变量前面加上版本号，每次变量更新的时候变量的**版本号都+1**，即A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A。 在写多读少的情况下，也就是频繁更新数据，那么会导致其他线程经常更新失败，那么就会进入自旋，自旋时会占用CPU资源。如果资源竞争激烈，多线程自旋的时间长，导致消耗资源。 使用场景在读多写少的场景下，更新时很少发生冲突，使用乐观锁，减少了上锁和释放锁的开销，可以有效地提升系统的性能。 相反，在写多读少的场景下，如果使用乐观锁会导致更新时经常产生冲突，然后线程会循环重试，这样会增大CPU的消耗。在这种情况下，建议可以使用悲观锁。 总结在日常的开发中，悲观锁和乐观锁应该是见得最多，用得最多的锁，比如最常见的synchronized和ReentrantLock是悲观锁，并发包中的原子类和ConcurrentHashMap则用了乐观锁。锁的实现并不复杂，关键是搞懂这两种锁的思想，这样才能在合适的地方使用合适的锁。 这篇文章就讲到这里了，希望看完后能有所收获，感谢你的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"并发编程的艺术/多线程开发，先学会线程池吧","date":"2021-08-04T03:20:11.215Z","updated":"2021-08-04T03:17:18.576Z","comments":true,"path":"2021/08/04/并发编程的艺术/多线程开发，先学会线程池吧/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%EF%BC%8C%E5%85%88%E5%AD%A6%E4%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%A7/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言在实际开发场景中，我们经常要使用多线程开发应用，比如实现异步操作，或者为了提高程序的效率等等。但是以前我见过有实习生在使用的时候是直接new Runable()，然后start()。没有使用线程池，可能很多初学者对线程池在多线程开发中没有足够的认识，所以我写一篇文章讲讲线程池，希望对大家有所启发。 一、什么是线程池线程池借鉴了”池化”技术的思想，线程池能够对线程的生命周期进行管理，对线程重复利用，并且能够以一种简单的方式将任务的提交与执行相解耦。 举个例子来说，线程就像是某个公司的客服小姐姐，每天都要接很多客户的电话，如果同时有1000个客户打电话进来咨询，按正常的逻辑，那就需要1000个客服小姐姐，但是在现实中往往需要考虑成本问题，招这么多人费用太多了，于是就可以这样优化，可以招100个人成立一个客服中心，如果同时超过100个人则提示让客户等待，等有空闲的客服小姐姐时就去响应客户。实现效益最大化。这就是一个池化技术在现实生活中类似的例子。 二、为什么使用线程池一种技术的出现，肯定是要解决存在的问题。如果不用线程池，会怎么样呢？很简单，需要时创建线程，线程跑完销毁，如果频繁去做这两个动作，就会造成比较大的资源消耗。所以线程池主要就是解决这个问题。 因此在《java并发编程的艺术》书中就提到以下几点： 降低资源消耗。通过重复使用已创建的线程，降低线程创建和销毁造成的资源消耗。 提高响应速度。当有任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。使用线程池可以进行统一的分配，调优和监控。 三、Executor创建线程池主要使用ThreadPoolExecutor这个类，所以我们先看一张类图。 一般来说，遵守面向接口编程的思想，我们都喜欢使用ExecutorService接口接收线程池实例。如下： 1234public static void main(String[] args) throws Exception &#123; //创建线程池 ExecutorService executor = new ThreadPoolExecutor(10, 10, 1, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10));&#125; 这里可以看到创建线程池是使用ThreadPoolExecutor构造器来创建。构造器的参数有什么意义呢，继续往下看。 3.1 七个关键参数123456789101112131415161718/*** corePoolSize 核心线程数* maximumPoolSize 最大线程数* keepAliveTime 线程存活时间* unit keepAliveTime的时间单位，有日，小时，分钟，秒等等* workQueue 工作队列* threadFactory 线程工厂，用于创建线程* handler 饱和策略*/public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; //省略...&#125; 那么这7个参数，在线程池工作时，起到什么作用呢？直接看一张图就明白了。 这里有两个参数需要讲解一下，工作队列workQueue和饱和策略handler。 工作队列的类是BlockingQueue，是一个接口，我们先看看类图，看一下有哪些子类可以使用。 可以看到有很多实现的子类，功能也各有不同。下面讲几个有代表性的。 DelayQueue是无界的队列，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。 LinkedBlockingDeque是基于双向链表实现的双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作（添加或删除）；并且该阻塞队列是支持线程安全。可以指定队列的容量，如果不指定默认容量大小是Integer.MAX_VALUE。 ArrayBlockingQueue是基于数组实现的有界阻塞队列，此队列按先进先出的原则对元素进行排序。新元素插入到队列的尾部，获取元素的操作则从队列的头部进行。 PriorityBlockingQueue是带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素(规则可以通过实现Comparable接口自己制定)，内部是使用平衡二叉树实现的，遍历不保证有序。 饱和策略只要看RejectedExecutionHandler接口，以及其实现子类。 饱和策略主要有四种，如果要自定义饱和策略也很简单，实现RejectedExecutionHandler接口，重写rejectedExecution()方法即可。下面介绍JDK里的四种饱和策略。 AbortPolicy，直接抛出异常，简单粗暴。 CallerRunsPolicy，在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。 DiscardPolicy，什么都不做，既不抛出异常，也不会执行。 DiscardOldestPolicy，当任务被拒绝添加时，会抛弃任务队列中最旧的任务(也就是最先加入队列的任务)，再把这个新任务添加进去。 3.2 ExecutorsExecutors类提供了四种线程池，根据使用不同的参数去new ThreadPoolExecutor实现。简单介绍一下。 第一种是newFixedThreadPool，这是创建固定大小的线程池，核心线程数和最大线程数都设置相同的值，使用LinkedBlockingQueue作为工作队列，当corePoolSize满了之后就加入到LinkedBlockingQueue队列中。LinkedBlockingQueue默认大小为Integer.MAX_VALUE，所以会有OOM的风险。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 第二种是newSingleThreadExecutor，创建线程数为1的线程池，并且使用了LinkedBlockingQueue，核心线程数和最大线程数都为1，满了就放入队列中，执行完了就从队列取一个。也就是创建了一个具有缓冲队列的单线程的线程池。跟上面的问题一样，队列的容量默认是Integer.MAX_VALUE，也会有OOM的风险。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 第三种是newCachedThreadPool，创建可缓冲的线程池，没有大小限制。核心线程数是0，最大线程数是Integer.MAX_VALUE，所以当有新任务时，任务会放入SynchronousQueue队列中，SynchronousQueue只能存放大小为1，所以会立刻新起线程。如果在工作线程在指定时间(60秒)空闲，则会自动终止。 123456public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; 第四种是newScheduledThreadPool，支持定时及周期性任务执行的线程池。 12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 3.3 使用规范在阿里java开发规范中，是强制不允许使用Executors创建线程池，我们不妨看看。 假如有人头铁不信，那我们写一段代码模拟一下。 1234567891011121314151617public class ThreadTest &#123; private static AtomicInteger num = new AtomicInteger(); public static void main(String[] args) throws Exception &#123; //创建线程池 ExecutorService executor = Executors.newCachedThreadPool(); while (true) &#123; executor.execute(() -&gt; &#123; try &#123; System.out.println(&quot;线程数：&quot; + num.incrementAndGet()); Thread.sleep(10000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125;&#125; 然后设置JVM的参数-Xms5M -Xmx5M，运行一小段时间，就会看到报错了。 第二个问题是线程数的设置，设置多少线程数比较合适呢？ 如果是cpu密集型的应用，cpu密集的意思是执行的任务大部分时间是在做计算和逻辑判断，这种情况显然不能设置太多的线程数，否则花在线程之间的切换时间就变多，效率就会变得低下。所以一般这种情况设置线程数为cpu核数+1即可。 cpu核数可以通过Runtime获取。 1Runtime.getRuntime().availableProcessors() 如果是IO密集型的应用，IO密集的意思是执行的任务需要执行大量的IO操作，比如网络IO，磁盘IO，对CPU的使用率较低，因为在IO操作的特点需要等待，那么就可以把CPU切换到其他线程。所以可以设置线程数为CPU核数的两倍+1。 絮叨经过学习之后，我们就要养成使用多线程不能直接new一个Thread，然后start()，要有使用线程池的意识。其次要理解线程池参数的意义，根据实际情况去设置。 并发编程往往是实际开发中比较容易出问题，希望看完这篇文章能减少一些不必要的错误。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"并发编程的艺术/五千字详细讲解并发编程的AQS","date":"2021-08-04T03:20:11.210Z","updated":"2021-08-04T03:17:18.570Z","comments":true,"path":"2021/08/04/并发编程的艺术/五千字详细讲解并发编程的AQS/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E4%BA%94%E5%8D%83%E5%AD%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84AQS/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、什么是AQS谈到并发编程，不得不说AQS(AbstractQueuedSynchronizer)，这可谓是Doug Lea老爷子的大作之一。AQS即是抽象队列同步器，是用来构建Lock锁和同步组件的基础框架，很多我们熟知的锁和同步组件都是基于AQS构建，比如ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore。 实际上AQS是一个抽象类，我们不妨先看一下源码： 1234567891011121314151617181920public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; //头结点 private transient volatile Node head; //尾节点 private transient volatile Node tail; //共享状态 private volatile int state; //内部类，构建链表的Node节点 static final class Node &#123; volatile Node prev; volatile Node next; volatile Thread thread; &#125;&#125;//AbstractQueuedSynchronizer的父类public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; //占用锁的线程 private transient Thread exclusiveOwnerThread;&#125; 由源码可以看出AQS是有以下几个部分组成的： 1.1 state共享变量AQS中里一个很重要的字段state，表示同步状态，是由volatile修饰的，用于展示当前临界资源的获锁情况。通过getState()，setState()，compareAndSetState()三个方法进行维护。 123456789101112private volatile int state;protected final int getState() &#123; return state;&#125;protected final void setState(int newState) &#123; state = newState;&#125;//CAS操作protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 关于state的几个要点： 使用volatile修饰，保证多线程间的可见性。 getState()、setState()、compareAndSetState()使用final修饰，限制子类不能对其重写。 compareAndSetState()采用乐观锁思想的CAS算法，保证原子性操作。 1.2 CLH队列AQS里另一个重要的概念就是CLH队列，它是一个双向链表队列，其内部由head和tail分别记录头结点和尾结点，队列的元素类型是Node。 简单讲一下这个队列的作用，就是当一个线程获取同步状态(state)失败时，AQS会将此线程以及等待的状态等信息封装成Node加入到队列中，同时阻塞该线程，等待后续的被唤醒。 队列的元素就是一个个的Node节点，下面讲一下Node节点的组成： 123456789101112131415161718192021222324static final class Node &#123; //共享模式下的等待标记 static final Node SHARED = new Node(); //独占模式下的等待标记 static final Node EXCLUSIVE = null; //表示当前节点的线程因为超时或者中断被取消 static final int CANCELLED = 1; //表示当前节点的后续节点的线程需要运行，也就是通过unpark操作 static final int SIGNAL = -1; //表示当前节点在condition队列中 static final int CONDITION = -2; //共享模式下起作用，表示后续的节点会传播唤醒的操作 static final int PROPAGATE = -3; //状态，包括上面的四种状态值，初始值为0，一般是节点的初始状态 volatile int waitStatus; //上一个节点的引用 volatile Node prev; //下一个节点的引用 volatile Node next; //保存在当前节点的线程引用 volatile Thread thread; //condition队列的后续节点 Node nextWaiter;&#125; 1.3 exclusiveOwnerThreadAQS通过继承AbstractOwnableSynchronizer类，拥有的属性。表示独占模式下同步器的持有者。 二、AQS的实现原理AQS有两种模式，分别是独占式和共享式。 2.1 独占式同一时刻仅有一个线程持有同步状态，也就是其他线程只有在占有的线程释放后才能竞争，比如ReentrantLock。下面从源码切入，梳理独占式的实现思路。 首先看acquire()方法，这是AQS在独占模式下获取同步状态的方法。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 先讲这个方法的总体思路： tryAcquire()尝试直接去获取资源，如果成功则直接返回。 如果失败则调用addWaiter()方法把当前线程包装成Node(状态为EXCLUSIVE，标记为独占模式)插入到CLH队列末尾。 然后acquireQueued()方法使线程阻塞在等待队列中获取资源，一直获取到资源后才返回，如果在整个等待过程中被中断过，则返回true，否则返回false。 线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 我们展开来分析，看tryAcquire()方法，尝试获取资源，成功返回true，失败返回false。 1234//直接抛出异常，这是由子类进行实现的方法，体现了模板模式的思想protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 为什么没有具体实现呢，其实这是模板模式的思想。这个方法是尝试获取资源，但是获取资源的方式有很多种实现，比如公平锁有公平锁的获取方式，非公平锁有非公平锁的获取方式(后面会讲，别急)。所以这里是一个没有具体实现的方法，需要由子类去实现。 接着看addWaiter()方法，这个方法的作用是把当前线程包装成Node添加到队列中。 12345678910111213141516171819private Node addWaiter(Node mode) &#123; //把当前线程包装成Node节点 Node node = new Node(Thread.currentThread(), mode); //获取到尾结点 Node pred = tail; //判断尾结点是否为null，如果不为空，那就证明队列已经初始化了 if (pred != null) &#123; //已经初始化了，就直接把Node节点添加到队列的末尾 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; //返回包含当前线程的节点Node return node; &#125; &#125; //如果队列没有初始化，那就调用enq()方法 enq(node); return node;&#125; 接着我们看enq()方法，就是一个自旋的操作，把传进来的node添加到队列最后，如果队列没有初始化则进行初始化。 123456789101112131415161718192021222324private Node enq(final Node node) &#123; //自旋操作，也就是死循环，只有加入队列成功才会return for (;;) &#123; //把尾结点赋值给t Node t = tail; //如果为空，证明没有初始化，进行初始化 if (t == null) &#123; // Must initialize //创建一个空的Node节点，并且设置为头结点 if (compareAndSetHead(new Node())) //然后把头结点赋值给尾结点 tail = head; &#125; else &#123; //如果是第一次循环为空，就已经创建了一个一个Node，那么第二次循环就不会为空了 //如果尾结点不为空，就把传进来的node节点的前驱节点指向尾结点 node.prev = t; //cas原子性操作，把传进来的node节点设置为尾结点 if (compareAndSetTail(t, node)) &#123; //把原来的尾结点的后驱节点指向传进来的node节点 t.next = node; return t; &#125; &#125; &#125;&#125; 接着我们再把思路跳回去顶层的方法，看acquireQueued()方法。 1234567891011121314151617181920212223242526272829//在队列中的节点node通过acquireQueued()方法获取资源，忽略中断。final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; //自旋的操作，一个死循环 for (;;) &#123; //获取传进来的node节点的前驱节点，赋值给p final Node p = node.predecessor(); //如果p是头结点，node节点就是第二个节点，则再次去尝试获取资源 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //tryAcquire(arg)获取资源成功的话，则把node节点设置为头结点 setHead(node); //把原来的头结点p的后驱节点设置为null，等待GC垃圾回收 p.next = null; // help GC failed = false; return interrupted; &#125; //如果p不是头结点，或者tryAcquire()获取资源失败，判断是否可以被park，也就是把线程阻塞起来 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())//&amp;&amp;前面如果返回true，将当前线程阻塞并检查是否被中断 //如果阻塞过程中被中断，则置interrupted标志位为true。 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 最后是selfInterrupt()方法，自我中断。 123static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 过程记不住没关系，下面画张图来总结一下，其实很简单。 2.2 共享式即共享资源可以被多个线程同时占有，直到共享资源被占用完毕。比如ReadWriteLock和CountdownLatch。下面我们从源码去分析其实现原理。 首先还是看最顶层的acquireShared()方法。 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 这段代码很简单，首先调用tryAcquireShared()方法，tryAcquireShared返回是一个int数值，当返回值大于等于0的时候，说明获得成功获取锁，方法结束，否则返回负数，表示获取同步状态失败，执行doAcquireShared方法。 tryAcquireShared()方法是一个模板方法由子类去重写，意思是需要如何获取同步资源由实现类去定义，AQS只是一个框架。 那么就看如果获取资源失败，执行的doAcquireShared()方法。 12345678910111213141516171819202122232425262728293031323334private void doAcquireShared(int arg) &#123; //调用addWaiter()方法，把当前线程包装成Node，标志为共享式，插入到队列中 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前节点node的前驱节点 final Node p = node.predecessor(); //前驱节点是否是头结点 if (p == head) &#123; //如果前驱节点是头结点，则调用tryAcquireShared()获取同步资源 int r = tryAcquireShared(arg); //r&gt;=0表示获取同步资源成功，只有获取成功，才会执行到return退出for循环 if (r &gt;= 0) &#123; //设置node为头结点 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; //判断是否可以被park，跟独占式的逻辑一样返回true，则进行park操作，阻塞线程 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这段逻辑基本上跟独占式的逻辑差不多，不同的地方在于入队的Node是标志为SHARED共享式的，获取同步资源的方式是tryAcquireShared()方法。 三、AQS的模板模式模板模式在AQS中的应用可谓是一大精髓，在上文中有提到的tryAcquireShared()和tryAcquire()都是很重要的模板方法。一般使用AQS往往都是使用一个内部类继承AQS，然后重写相应的模板方法。 AQS已经把一些常用的，比如入队，出队，CAS操作等等构建了一个框架，使用者只需要实现获取资源，释放资源的，因为很多锁，还有同步器，其实就是获取资源和释放资源的方式有比较大的区别。 那么我们看一下模板方法有哪些。 3.1 tryAcquire()tryAcquire()方法，独占式获取同步资源，返回true表示获取同步资源成功，false表示获取失败。 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 3.2 tryRelease()tryRelease()方法，独占式使用，tryRelease()的返回值来判断该线程是否已经完成释放资源，子类来决定是否能成功释放锁。 123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 3.3 tryAcquireShared()tryAcquireShared()方法，共享式获取同步资源，返回大于等于0表示获取资源成功，返回小于0表示失败。 123protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 3.4 tryReleaseShared()tryReleaseShared()方法，共享式尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 123protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 3.5 isHeldExclusively()isHeldExclusively()方法，该线程是否正在独占资源。只有用到condition才需要去实现它。 123protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException();&#125; 四、认识ReentrantLockReentrantLock是一个很经典的使用AQS的案例，不妨以此为切入点来继续深入。ReentrantLock的特性有很多，首先它是一个悲观锁，其次有两种模式分别是公平锁和非公平锁，最后它是重入锁，也就是能够对共享资源重复加锁。 AQS通常是使用内部类实现，所以不难想象在ReentrantLock类里有两个内部类，我们看一张类图。 FairSync是公平锁的实现，NonfairSync则是非公平锁的实现。通过构造器传入的boolean值进行判断。 12345678public ReentrantLock(boolean fair) &#123; //true则使用公平锁，false则使用非公平锁 sync = fair ? new FairSync() : new NonfairSync();&#125;//默认是非公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125; 公平锁是遵循FIFO（先进先出）原则的，先到的线程会优先获取资源，后到的线程会进行排队等待，能保证每个线程都能拿到锁，不会存在有线程饿死的情况。 非公平锁是则不遵守先进先出的原则，会出现有线程插队的情况，不能保证每个线程都能拿到锁，会存在有线程饿死的情况。 下面我们从源码分析去找出这两种锁的区别。 五、源码分析ReentrantLock5.1 上锁ReentrantLock是通过lock()方法上锁，所以看lock()方法。 123public void lock() &#123; sync.lock();&#125; sync就是NonfairSync或者FairSync。 1234//这里就是调用AQS的acquire()方法，获取同步资源final void lock() &#123; acquire(1);&#125; acquire()方法前面已经解析过了，主要看FairSync的tryAcquire()方法。 123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获取同步状态 int c = getState(); //判断同步状态是否为0 if (c == 0) &#123; //关键在这里，公平锁会判断是否需要排队 if (!hasQueuedPredecessors() &amp;&amp; //如果不需要排队，则直接cas操作更新同步状态为1 compareAndSetState(0, acquires)) &#123; //设置占用锁的线程为当前线程 setExclusiveOwnerThread(current); //返回true，表示上锁成功 return true; &#125; &#125; //判断当前线程是否是拥有锁的线程，主要是可重入锁的逻辑 else if (current == getExclusiveOwnerThread()) &#123; //如果是当前线程，则同步状态+1 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); //设置同步状态 setState(nextc); return true; &#125; //以上情况都不是，则返回false，表示上锁失败。上锁失败根据AQS的框架设计，会入队排队 return false;&#125; 如果是非公平锁NonfairSync的tryAcquire()，我们继续分析。 123456789101112131415161718192021222324252627protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;//非公平式获取锁final boolean nonfairTryAcquire(int acquires) &#123; //这段跟公平锁是一样的操作 final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //关键在这里，不再判断是否需要排队，而是直接去更新同步状态，通俗点讲就是插队 if (compareAndSetState(0, acquires)) &#123; //如果获取同步状态成功，则设置占用锁的线程为当前线程 setExclusiveOwnerThread(current); //返回true表示获取锁成功 return true; &#125; &#125; //以下逻辑跟公平锁的逻辑一样 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 其实很明显了，关键的区别就在于尝试获取锁的时候，公平锁会判断是否需要排队再去更新同步状态，非公平锁是直接就更新同步，不判断是否需要排队。 从性能上来说，公平锁的性能是比非公平锁要差的，因为公平锁要遵守FIFO(先进先出)的原则，这就会增加了上下文切换与等待线程的状态变换时间。 非公平锁的缺点也是很明显的，因为允许插队，这就会存在有线程饿死的情况。 5.2 解锁解锁对应的方法就是unlock()。 1234567891011121314151617public void unlock() &#123; //调用AQS中的release()方法 sync.release(1);&#125;//这是AQS框架定义的release()方法public final boolean release(int arg) &#123; //当前锁是不是没有被线程持有,返回true表示该锁没有被任何线程持有 if (tryRelease(arg)) &#123; //获取头结点h Node h = head; //判断头结点是否为null并且waitStatus不是初始化节点状态，解除线程挂起状态 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 关键在于tryRelease()，这就不需要分公平锁和非公平锁的情况，只需要考虑可重入的逻辑。 12345678910111213141516protected final boolean tryRelease(int releases) &#123; //减少可重入的次数 int c = getState() - releases; //如果当前线程不是持有锁的线程，抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state if (c == 0) &#123; //状态为0，表示持有线程被全部释放，设置为true free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 总结JUC可谓是学习java的一个难点，而学习AQS其实关键在于并发的思维，因为需要考虑的情况很多，其次需要理解模板模式的思想，这才能理解为什么AQS作为一个框架的作用。ReentrantLock这个类我觉得是理解AQS一个很好的切入点，看懂了之后再去看AQS的其他应用类应该会轻松很多。 那么这篇文章就讲到这里了，希望看完能有所收获，感谢你的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"必学的优秀技术框架/从设计模式的角度剖析Mybatis源码","date":"2021-08-04T03:20:11.194Z","updated":"2021-08-04T03:17:18.609Z","comments":true,"path":"2021/08/04/必学的优秀技术框架/从设计模式的角度剖析Mybatis源码/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/%E4%BB%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90Mybatis%E6%BA%90%E7%A0%81/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 概述Mybatis是一个比较主流的ORM框架，所以在日常工作中接触得很多。我比较喜欢看优秀框架的源码，因为能写出这种框架的作者肯定有其独特之处。如果能看懂源码的一些巧妙构思，一定是受益匪浅的。 所谓万事开头难，看源码也要找到切入的点。设计模式无疑是源码分析一个很好的切入点，废话不多说，那么我们就开始吧。 工厂模式工厂模式属于创建型模式。工厂模式的作用是把创建对象的逻辑封装起来，提供一个接口给外部创建对象，降低类与类之间的耦合。 在Mybatis中，用到工厂模式主要在DataSourceFactory。这是一个负责创建DataSource数据源的工厂。DataSourceFactory是一个接口，有不同的子类实现，根据不同的配置，生成不同的DataSourceFactory实现类。类图如下： 接着我们看一下DataSourceFactory的源码： 1234567public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; DataSourceFactory接口定义了两个抽象方法，怎么工作的呢，其实是跟dataSource标签的属性type有关。 12345678910&lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- type属性是关键属性 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;dataSource.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;dataSource.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;dataSource.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;dataSource.password&#125;&quot;/&gt; &lt;/dataSource&gt;&lt;/environment&gt; Mybatis内置的type有三种配置，分别是UNPOOLED，POOLED，JNDI。 UNPOOLED，这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED，这种数据源的使用“池“的思想，避免了创建新的连接实例时所必需的初始化和认证时间。 JNDI，这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 接着看XMLConfigBuilder的dataSourceElement()方法。 1234567891011121314private DataSourceFactory dataSourceElement(XNode context) throws Exception &#123; if (context != null) &#123; //读取配置文件中dataSource标签的属性type String type = context.getStringAttribute(&quot;type&quot;); Properties props = context.getChildrenAsProperties(); //根据type属性的值，返回不同的子类，使用接口DataSourceFactory接收，体现了面向接口编程的思想 DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance(); //设置属性值，比如数据库的url，username，password等等 factory.setProperties(props); //返回factory return factory; &#125; throw new BuilderException(&quot;Environment declaration requires a DataSourceFactory.&quot;);&#125; 获得DataSourceFactory之后，就通过getDataSource()方法获取数据源，完事了。 123456789101112131415161718192021private void environmentsElement(XNode context) throws Exception &#123; if (context != null) &#123; if (environment == null) &#123; environment = context.getStringAttribute(&quot;default&quot;); &#125; //这里for循环主要是配置文件可以配置多个数据源 for (XNode child : context.getChildren()) &#123; String id = child.getStringAttribute(&quot;id&quot;); if (isSpecifiedEnvironment(id)) &#123; TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;)); DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;)); //dsFactory调动getDataSource()方法，创建dataSource对象 DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); configuration.setEnvironment(environmentBuilder.build()); &#125; &#125; &#125;&#125; Mybatis使用工厂模式来创建DataSourceFactory，可以做到通过配置去使用不同的DataSourceFactory创建DataSource，非常灵活。在Mybatis中使用到工厂模式还有很多地方，比如SqlSessionFactory，这里就不再展开了，有兴趣的可以自己探索一下。 单例模式单例模式属于创建型设计模式，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。保证在应用中只有单一对象被创建。 Mybatis中用到单例模式的地方有很多，这里举个例子是ErrorContext类。这是一个用于记录该线程的执行环境错误信息，所以是在线程范围内的单例。 1234567891011121314151617181920public class ErrorContext &#123; //使用ThreadLocal保存每个线程中的单例对象 private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;(); //私有化构造器 private ErrorContext() &#123; &#125; //向外提供唯一的接口获取单例对象 public static ErrorContext instance() &#123; //从LOCAL中取出context对象 ErrorContext context = LOCAL.get(); if (context == null) &#123; //如果为null，new一个 context = new ErrorContext(); //放入到LOCAL中保存 LOCAL.set(context); &#125; //如果不为null，直接返回 return context; &#125;&#125; 建造者模式建造者模式也是属于创建型模式，主要是在创建一个复杂对象时使用，通过一步一步构造最终的对象，将一个复杂对象的构建与它的表示分离。 在Mybatis中，使用到建造者模式的地方体现在ParameterMapping类，这是用于参数映射的一个类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ParameterMapping &#123; private Configuration configuration; private String property; private ParameterMode mode; private Class&lt;?&gt; javaType = Object.class; private JdbcType jdbcType; private Integer numericScale; private TypeHandler&lt;?&gt; typeHandler; private String resultMapId; private String jdbcTypeName; private String expression; //私有化构造器 private ParameterMapping() &#123; &#125; //通过内部类Builder创建对象 public static class Builder &#123; //初始化ParameterMapping实例 private ParameterMapping parameterMapping = new ParameterMapping(); //通过构造器初始化ParameterMapping的一些成员变量 public Builder(Configuration configuration, String property, TypeHandler&lt;?&gt; typeHandler) &#123; parameterMapping.configuration = configuration; parameterMapping.property = property; parameterMapping.typeHandler = typeHandler; parameterMapping.mode = ParameterMode.IN; &#125; public Builder(Configuration configuration, String property, Class&lt;?&gt; javaType) &#123; parameterMapping.configuration = configuration; parameterMapping.property = property; parameterMapping.javaType = javaType; parameterMapping.mode = ParameterMode.IN; &#125; //设置parameterMapping的mode public Builder mode(ParameterMode mode) &#123; parameterMapping.mode = mode; return this; &#125; //设置parameterMapping的javaType public Builder javaType(Class&lt;?&gt; javaType) &#123; parameterMapping.javaType = javaType; return this; &#125; //设置parameterMapping的jdbcType public Builder jdbcType(JdbcType jdbcType) &#123; parameterMapping.jdbcType = jdbcType; return this; &#125; //设置parameterMapping的numericScale public Builder numericScale(Integer numericScale) &#123; parameterMapping.numericScale = numericScale; return this; &#125; //设置parameterMapping的resultMapId public Builder resultMapId(String resultMapId) &#123; parameterMapping.resultMapId = resultMapId; return this; &#125; //设置parameterMapping的typeHandler public Builder typeHandler(TypeHandler&lt;?&gt; typeHandler) &#123; parameterMapping.typeHandler = typeHandler; return this; &#125; //设置parameterMapping的jdbcTypeName public Builder jdbcTypeName(String jdbcTypeName) &#123; parameterMapping.jdbcTypeName = jdbcTypeName; return this; &#125; //设置parameterMapping的expression public Builder expression(String expression) &#123; parameterMapping.expression = expression; return this; &#125; //通过build()方法创建对象，返回 public ParameterMapping build() &#123; resolveTypeHandler(); validate(); return parameterMapping; &#125; &#125;&#125; 在SqlSourceBuilder类的buildParameterMapping()方法中可以看到建造者模式的实战应用： 1234567891011121314151617181920212223242526272829303132333435363738394041//根据参数content，构建parameterMapping实例private ParameterMapping buildParameterMapping(String content) &#123; //属性值的Map集合 Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content); String property = propertiesMap.get(&quot;property&quot;); Class&lt;?&gt; propertyType; //省略... //创建一个ParameterMapping.Builder对象 ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType); //省略... //这里遍历Map集合，把属性值设置到ParameterMapping对象中，并创建 for (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) &#123; String name = entry.getKey(); String value = entry.getValue(); if (&quot;javaType&quot;.equals(name)) &#123; javaType = resolveClass(value); builder.javaType(javaType); &#125; else if (&quot;jdbcType&quot;.equals(name)) &#123; builder.jdbcType(resolveJdbcType(value)); &#125; else if (&quot;mode&quot;.equals(name)) &#123; builder.mode(resolveParameterMode(value)); &#125; else if (&quot;numericScale&quot;.equals(name)) &#123; builder.numericScale(Integer.valueOf(value)); &#125; else if (&quot;resultMap&quot;.equals(name)) &#123; builder.resultMapId(value); &#125; else if (&quot;typeHandler&quot;.equals(name)) &#123; typeHandlerAlias = value; &#125; else if (&quot;jdbcTypeName&quot;.equals(name)) &#123; builder.jdbcTypeName(value); &#125; else if (&quot;property&quot;.equals(name)) &#123; // Do Nothing &#125; else if (&quot;expression&quot;.equals(name)) &#123; //抛出异常Expression based parameters are not supported yet &#125; else &#123; //抛出异常 &#125; &#125; //省略... //创建ParameterMapping对象，并返回 return builder.build();&#125; 模板模式模板模式是一种行为型模式，一般用在一些比较通用的方法中，定义一个抽象类，编写一个算法的骨架，将一些步骤延迟到子类。就像是请假条一样，开头和结尾都是写好的模板，中间的请假的原因(内容)由请假人(子类)去补充完整，这样可以提高代码的复用。 在Mybatis中，模板模式体现在Executor和BaseExecutor这两个类中。首先看张类图： Executor是一个接口，从命名上可以看出是用来执行SQL语句的对象。下面有一个BaseExecutor的抽象类，这就是用来定义模板方法的。再下面有三个实现类，**SimpleExecutor(简单执行器)，ReuseExecutor(重用执行器)，BatchExecutor(批量执行器)**。实现类就是用来填充模板中间的内容的。 执行器在执行JDBC操作的前后往往有很多需要处理的工作都是相同的，比如查询的时候使用缓存，更新时需要清除缓存等等，所以就很适合使用模板模式。 接着我们看BaseExecutor抽象类的源码，一看就明白了，其实就定义了一个骨架。 123456789101112131415161718192021222324252627public abstract class BaseExecutor implements Executor &#123; //查询操作 private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); //上面的代码是固定的 try &#123; //这段代码不同的子类有不同的实现，所以是调用抽象方法doQuery() list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); //下面的代码也是固定的 &#125; finally &#123; //清除缓存 localCache.removeObject(key); &#125; //添加到缓存中 localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; //返回结果 return list; &#125; //抽象方法，由子类去实现 protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;&#125; 那么就有疑问了，一开始如果都不设置的话，默认使用哪个子类的实现。很简单，直接跟着源码去顺藤摸瓜，我们就看到了。 1234public class Configuration &#123; //默认是SIMPLE，也就是SimpleExecutor protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;&#125; 其实模板模式很简单就能“认出来”，我的理解就是，**抽象类里定义具(具体的方法)，具体方法再调抽(抽象方法)**。那十有八九就是模板模式了。 代理模式代理模式属于结构型模式，代理模式的定义说的很抽象，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 其实代理模式可以简单理解为中介的作用，比如一手房东只关心收租，其他的水电费结算，带人看房这些杂七杂八的东西他不想关心，就交给中介（二手房东），租客要租房就给钱中介，一手房东收钱就找中介，这个中介就是所谓的代理者。 回到Mybatis框架中，SqlSession类就用到代理模式，SqlSession是操作数据库一个会话对象，我们用户一般通过SqlSession做增删改查，但是如果每次做增删改都开启事务，关闭事务，显然是很麻烦，所以就可以交给代理类来完成这个工作，如果没有开启事务，由代理类自动开启事务。 Mybatis在这里是使用JDK动态代理，所以SqlSession是一个接口。 12345678910111213141516171819202122232425public interface SqlSession extends Closeable &#123; &lt;T&gt; T selectOne(String statement); &lt;E&gt; List&lt;E&gt; selectList(String statement); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey); &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement); void select(String statement, Object parameter, ResultHandler handler); int insert(String statement); int update(String statement); int delete(String statement); void commit(); void rollback(); //省略...&#125; 我们知道动态代理要有一个实现InvocationHandler接口的类，这个类在SqlSessionManager里，是一个内部类，叫做SqlSessionInterceptor，在这个类里做相关的处理。 12345678910111213141516171819202122232425262728293031323334353637383940private class SqlSessionInterceptor implements InvocationHandler &#123; public SqlSessionInterceptor() &#123; // Prevent Synthetic Access &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //获取SqlSession对象，localSqlSession是一个ThreadLocal，所以是每个线程有自己的sqlSession final SqlSession sqlSession = SqlSessionManager.this.localSqlSession.get(); //如果不为null if (sqlSession != null) &#123; try &#123; //执行方法，返回结果 return method.invoke(sqlSession, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; //如果sqlsession为null &#125; else &#123; //打开session final SqlSession autoSqlSession = openSession(); try &#123; //执行Sqlsession的方法，获得结果 final Object result = method.invoke(autoSqlSession, args); //commit提交事务 autoSqlSession.commit(); //返回结果 return result; &#125; catch (Throwable t) &#123; //rollback回滚事务 autoSqlSession.rollback(); //抛出异常 throw ExceptionUtil.unwrapThrowable(t); &#125; finally &#123; //关闭sqlsession autoSqlSession.close(); &#125; &#125; &#125;&#125; 然后通过构造器去初始化，提供静态方法返回这个SqlSessionManager实例，请看源码。 123456789101112131415161718192021222324252627282930313233//实现了SqlSessionFactory，SqlSession接口public class SqlSessionManager implements SqlSessionFactory, SqlSession &#123; private final SqlSessionFactory sqlSessionFactory; //代理类sqlSessionProxy private final SqlSession sqlSessionProxy; private SqlSessionManager(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; //初始化代理类 this.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[]&#123;SqlSession.class&#125;, new SqlSessionInterceptor()); &#125; //提供一个静态方法给外部获取SqlSessionManager类，可以用SqlSession接收 public static SqlSessionManager newInstance(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionManager(sqlSessionFactory); &#125; //重写selectOne方法，使用代理类去执行 @Override public &lt;T&gt; T selectOne(String statement) &#123; return sqlSessionProxy.&lt;T&gt; selectOne(statement); &#125; //重写insert方法，使用代理类去执行 @Override public int insert(String statement) &#123; return sqlSessionProxy.insert(statement); &#125; //省略...&#125; 这就是Mybatis使用代理模式的一个例子，其实也不是很复杂，还是能看懂的。 但是上面这种方式一般很少用，我们一般都是使用Mapper接口的方式，其实Mapper接口的方式也是使用了代理模式，接下来再继续看。直接看MapperProxy类。 12345678910111213141516171819202122232425262728293031323334353637//实现了InvocationHandler接口public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; //代理类做的什么事情，看这个方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //省略... //获取mapperMethod对象 final MapperMethod mapperMethod = cachedMapperMethod(method); //执行方法。根据Mapper.xml配置文件的配置进行执行，返回结果 return mapperMethod.execute(sqlSession, args); &#125; private MapperMethod cachedMapperMethod(Method method) &#123; //从methodCache取出mapperMethod MapperMethod mapperMethod = methodCache.get(method); //为null if (mapperMethod == null) &#123; //new一个。这里已经把Mapper.xml的一些配置都封装好了 mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); //然后put进methodCache methodCache.put(method, mapperMethod); &#125; //返回mapperMethod return mapperMethod; &#125;&#125; mapperMethod的execute()方法的作用就是根据Mapper接口的方法名找到Mapper.xml文件的sql的Id，然后执行相应的操作，返回结果。内部的代码比较长，但是思路就是这样，这里就不展开了。 所以我们平时用的时候，TbCommodityInfoMapper接口假设是这样定义了一个list()方法。 1234public interface TbCommodityInfoMapper &#123; //查询TbCommodityInfo列表 List&lt;TbCommodityInfo&gt; list();&#125; 那个在TbCommodityInfoMapper.xml就要对应有一个id为list的配置。 1234567&lt;!-- 命名空间也要和接口的全限定名一致 --&gt;&lt;mapper namespace=&quot;io.github.yehongzhi.commodity.mapper.TbCommodityInfoMapper&quot;&gt; &lt;!-- 必须要有一个对应的属性id为list的sql配置 --&gt; &lt;select id=&quot;list&quot; resultType=&quot;tbCommodityInfo&quot;&gt; select `id`, `commodity_name`, `commodity_price`, `description`, `number` from tb_commodity_info &lt;/select&gt;&lt;/mapper&gt; 然后在MapperProxyFactory类，使用工厂模式提供获取代理类。 1234567891011121314151617181920public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); //通过构造器初始化mapperInterface public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; @SuppressWarnings(&quot;unchecked&quot;) protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; //通过这个方法，获取Mapper接口的代理类 public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125; 那个这个getMapper的方法就在SqlSession的子类中被调用。 1234@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return getConfiguration().getMapper(type, this);&#125; 最终用户就是这样使用，这里是纯Mybatis，没有集成Spring的写法。 12345678910public class Test &#123; public static void main(String[] args) &#123; //获取SqlSession对象 SqlSession sqlSession = SqlSessionFactoryUtils.openSqlSession(); //再获取Mapper接口的代理类 TbCommodityInfoMapper tbCommodityInfoMapper = sqlSession.getMapper(TbCommodityInfoMapper.class); //通过代理类去执行相应的方法 List&lt;TbCommodityInfo&gt; commodityInfoList = tbCommodityInfoMapper.list(); &#125;&#125; 所以代理模式可以说是Mybatis核心的设计模式，用的是非常巧妙。 装饰器模式装饰器模式属于结构型模式，使用装饰类包装对象，动态地给对象添加一些额外的职责。那么在Mybatis中，哪个地方会使用到装饰器模式呢？ 没错了，就是缓存。Mybatis有一级缓存和二级缓存的功能，一级缓存默认是打开的，范围在SqlSession中生效，二级缓存需要手动配置打开，范围在全局Configuration，在每个namespace中配置。二级缓存的类型有以下几种，请看配置。 1234567891011121314151617&lt;mapper namespace=&quot;io.github.yehongzhi.commodity.mapper.TbCommodityInfoMapper&quot;&gt; &lt;!-- eviction:代表的是缓存回收策略，目前MyBatis提供以下策略。 (1) LRU,最近最少使用的，一处最长时间不用的对象 (2) FIFO,先进先出，按对象进入缓存的顺序来移除他们 (3) SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象 (4) WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU，移除最长时间不用的对形象 flushInterval:刷新间隔时间，单位为毫秒，这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存。 size:引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是1024个对象 readOnly:只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存 --&gt; &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;100000&quot; readOnly=&quot;true&quot; size=&quot;1024&quot;/&gt; &lt;select id=&quot;list&quot; resultMap=&quot;base_column&quot;&gt; select `id`, `commodity_name`, `commodity_price`, `description`, `number` from tb_commodity_info &lt;/select&gt;&lt;/mapper&gt; 所以这个场景已经很清晰了，也就是在一级缓存的基础上，再添加二级缓存，也就符合装饰器模式的那句话，动态给对象添加职责功能。怎么做呢，我们不妨先看Cache类的类图。 先看Cache接口，其实就定义了一些接口方法。 12345678910111213141516public interface Cache &#123; String getId(); void putObject(Object key, Object value); Object getObject(Object key); Object removeObject(Object key); void clear(); int getSize(); ReadWriteLock getReadWriteLock();&#125; 然后再看PerpetualCache类，这是Cache接口最基本的实现，二级缓存要扩展就在这个类上面再去包装来实现扩展。其实就是一个HashMap，再简单包装一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PerpetualCache implements Cache &#123; private final String id; //成员变量cache，创建一个HashMap private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); public PerpetualCache(String id) &#123; this.id = id; &#125; @Override public String getId() &#123; return id; &#125; @Override public int getSize() &#123; return cache.size(); &#125; @Override public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; @Override public Object getObject(Object key) &#123; return cache.get(key); &#125; @Override public Object removeObject(Object key) &#123; return cache.remove(key); &#125; @Override public void clear() &#123; cache.clear(); &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return null; &#125; //省略...&#125; 那么我们再看二级缓存的一个代表性的类LruCache。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class LruCache implements Cache &#123; //一级缓存，保存在这个成员变量中 private final Cache delegate; //实际上这是一个LinkedHashMap，利用LinkedHashMap的LRU算法实现缓存的LRU private Map&lt;Object, Object&gt; keyMap; private Object eldestKey; //构造器缓存对象，初始化 public LruCache(Cache delegate) &#123; this.delegate = delegate; setSize(1024); &#125; //初始化keyMap，重写removeEldestEntry方法，实现LUR算法 public void setSize(final int size) &#123; keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123; private static final long serialVersionUID = 4267176411845948333L; @Override protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123; boolean tooBig = size() &gt; size; //每次put进来时，eldestKey都是最老的key if (tooBig) &#123; eldestKey = eldest.getKey(); &#125; return tooBig; &#125; &#125;; &#125; @Override public void putObject(Object key, Object value) &#123; //保存进缓存 delegate.putObject(key, value); //这里就是删除掉不常用的值 cycleKeyList(key); &#125; @Override public Object getObject(Object key) &#123; keyMap.get(key); //touch return delegate.getObject(key); &#125; private void cycleKeyList(Object key) &#123; keyMap.put(key, key); if (eldestKey != null) &#123; //删除掉Map中最老的key delegate.removeObject(eldestKey); eldestKey = null; &#125; &#125;&#125; 关键在于成员变量delegate，这在其他的二级缓存装饰类中都定义了。这个是为了保存PerpetualCache这个基础缓存类的。所以这也就是说二级缓存是在PerpetualCache为基础扩展的。再继续看就更加明白了。 直接看创建SqlSessionFactory的builder方法，一直追踪下去，就可以找到MapperBuilderAssistant类的useNewCache方法。 1234567891011121314151617181920212223242526272829public class MapperBuilderAssistant extends BaseBuilder &#123; //当前Mapper.xml的命名空间 private String currentNamespace; public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass, Class&lt;? extends Cache&gt; evictionClass, Long flushInterval, Integer size, boolean readWrite, boolean blocking, Properties props) &#123; Cache cache = new CacheBuilder(currentNamespace) //设置基础缓存 .implementation(valueOrDefault(typeClass, PerpetualCache.class)) //添加缓存装饰类 .addDecorator(valueOrDefault(evictionClass, LruCache.class)) .clearInterval(flushInterval) .size(size) .readWrite(readWrite) .blocking(blocking) .properties(props) //创建缓存 .build(); //把缓存添加到configuration，所以二级缓存是configuration范围的 configuration.addCache(cache); currentCache = cache; return cache; &#125;&#125; 再看CacheBuilder的build方法，更加清晰了。 123456789101112131415161718192021222324252627282930313233343536public class CacheBuilder &#123; private Class&lt;? extends Cache&gt; implementation; private final List&lt;Class&lt;? extends Cache&gt;&gt; decorators; public Cache build() &#123; setDefaultImplementations(); Cache cache = newBaseCacheInstance(implementation, id); setCacheProperties(cache); // issue #352, do not apply decorators to custom caches if (PerpetualCache.class.equals(cache.getClass())) &#123; //遍历装饰器类 for (Class&lt;? extends Cache&gt; decorator : decorators) &#123; //在cache上添加二级缓存 cache = newCacheDecoratorInstance(decorator, cache); setCacheProperties(cache); &#125; cache = setStandardDecorators(cache); &#125; else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123; cache = new LoggingCache(cache); &#125; //返回缓存 return cache; &#125; private void setDefaultImplementations() &#123; if (implementation == null) &#123; //如果为空，初始化为PerpetualCache implementation = PerpetualCache.class; //如果装饰器类为空，默认用LruCache if (decorators.isEmpty()) &#123; decorators.add(LruCache.class); &#125; &#125; &#125;&#125; 所以我们大概可以想到二级缓存就像千层饼一样，一层一层地包装起来。最后debug模式验证一下。 在执行查询的时候你就会看到真的是千层饼一样，一层一层的。看CachingExecutor类的query方法。 最后在调用Cache的putObject方法时就会一层一层从外到内地调用，实现为对象动态扩展功能的装饰器模式。 装饰器模式在Mybatis中的应用就讲到这里了，有什么不懂的，可以关注公众号java技术爱好者，加我微信提问。 总结这篇文章就介绍了Mybatis中用到的6种设计模式，分别是工厂模式，单例模式，模板模式，建造者模式，代理模式，还有装饰器模式。实际上Mybatis除了我讲的这些之外，还有很多我没有提到的，比如组合模式，适配器模式等等，有兴趣自己去研究一下吧。 因为现在很多面试动不动就问有看过什么框架的源码，实际上看源码是好的，但是不能盲目入手，因为很多框架是运用了大量的设计模式，如果对设计模式没有一定的认识，很容易看不懂，看懵。所以对于还没有设计模式基础的同学，建议先看设计模式，然后再去学习源码，这样才能循序渐进地提升自身实力。 这篇文章就讲到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"必学的优秀技术框架/spring有哪些设计模式","date":"2021-08-04T03:20:11.186Z","updated":"2021-08-04T03:17:18.600Z","comments":true,"path":"2021/08/04/必学的优秀技术框架/spring有哪些设计模式/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/spring%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 概述一个优秀的框架肯定离不开各种设计模式的运用，Spring框架也不例外。因为网上很多文章比较散乱，所以想总结一下在Spring中用到的设计模式，希望大家看完之后能对spring有更深层次的理解。 工厂模式工厂模式我们都知道是把创建对象交给工厂，以此来降低类与类之间的耦合。工厂模式在Spring中的应用非常广泛，这里举的例子是ApplicationContext和BeanFactory，这也是Spring的IOC容器的基础。 首先看BeanFactory，这是最底层的接口。 123456789101112public interface BeanFactory &#123; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; //省略...&#125; ApplicationContext则是扩展类，也是一个接口，他的作用是当容器启动时，一次性创建所有的bean。 12345678910111213141516public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123; @Nullable String getId(); String getApplicationName(); String getDisplayName(); long getStartupDate(); @Nullable ApplicationContext getParent(); AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;&#125; ApplicationContext有三个实现类，分别是： ClassPathXmlApplication：从类路径ClassPath中寻找指定的XML配置文件，找到并装载ApplicationContext的实例化工作。 FileSystemXMLApplicationContext：从指定的文件系统路径中寻找指定的XML配置文件，找到并装载ApplicationContext的实例化工作。 XMLWebApplicationContext：从Web系统中的XML文件载入Bean定义的信息，Web应用寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。 因此这几个类的关系我们清楚了，类图就是这样： 在哪里初始化呢，这讲起来有些复杂，就不展开细讲，提一下。主要看AbstractApplicationContext类的refresh()方法。 123456789101112131415@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //省略... try &#123; //省略... //初始化所有的单实例 Bean(没有配置赖加载的) finishBeanFactoryInitialization(beanFactory); &#125;catch (BeansException ex) &#123; //省略... &#125;finally &#123; //省略... &#125; &#125;&#125; 单例模式在系统中，有很多对象我们都只需要一个，比如线程池、Spring的上下文对象，日志对象等等。单例模式的好处在于对一些重量级的对象，省略了创建对象花费的时间，减少了系统的开销，第二点是使用单例可以减少new操作的次数，减少了GC线程回收内存的压力。 实际上，在Spring中的Bean默认的作用域就是singleton(单例)的。如何实现的呢？ 主要看DefaultSingletonBeanRegistry的getSingleton()方法： 1234567891011121314151617181920212223242526272829303132333435public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123; /** 保存单例Objects的缓存集合ConcurrentHashMap，key：beanName --&gt; value：bean实例 */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;Bean name must not be null&quot;); synchronized (this.singletonObjects) &#123; //检查缓存中是否有实例，如果缓存中有实例，直接返回 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; //省略... try &#123; //通过singletonFactory获取单例 singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; //省略... if (newSingleton) &#123; addSingleton(beanName, singletonObject); &#125; &#125; //返回实例 return singletonObject; &#125; &#125; protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; this.singletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125;&#125; 从源码中可以看出，是通过ConcurrentHashMap的方式，如果在Map中存在则直接返回，如果不存在则创建，并且put进Map集合中，并且整段逻辑是使用同步代码块包住的，所以是线程安全的。 策略模式策略模式，简单来说就是封装好一组策略算法，外部客户端根据不同的条件选择不同的策略算法解决问题。这在很多框架，还有日常开发都会用到的一种设计模式。在Spring中，我这里举的例子是Resource类，这是所有资源访问类所实现的接口。 针对不同的访问资源的方式，Spring定义了不同的Resource类的实现类。我们看一张类图： 简单介绍一下Resource的实现类： UrlResource：访问网络资源的实现类。 ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类。 ByteArrayResource：访问字节数组资源的实现类。 PathResource：访问文件路径资源的实现类。 ClassPathResource：访问类加载路径里资源的实现类。 写一段伪代码来示范一下Resource类的使用： 12345678910111213141516171819202122232425262728@RequestMapping(value = &quot;/resource&quot;, method = RequestMethod.GET)public String resource(@RequestParam(name = &quot;type&quot;) String type, @RequestParam(name = &quot;arg&quot;) String arg) throws Exception &#123; Resource resource; //这里可以优化为通过工厂模式，根据type创建Resource的实现类 if (&quot;classpath&quot;.equals(type)) &#123; //classpath下的资源 resource = new ClassPathResource(arg); &#125; else if (&quot;file&quot;.equals(type)) &#123; //本地文件系统的资源 resource = new PathResource(arg); &#125; else if (&quot;url&quot;.equals(type)) &#123; //网络资源 resource = new UrlResource(arg); &#125; else &#123; return &quot;fail&quot;; &#125; InputStream is = resource.getInputStream(); ByteArrayOutputStream os = new ByteArrayOutputStream(); int i; while ((i = is.read()) != -1) &#123; os.write(i); &#125; String result = new String(os.toByteArray(), StandardCharsets.UTF_8); is.close(); os.close(); return &quot;type:&quot; + type + &quot;,arg:&quot; + arg + &quot;\\r\\n&quot; + result;&#125; 这就是策略模式的思想，通过外部条件使用不同的算法解决问题。其实很简单，因为每个实现类的getInputStream()方法都不一样，我们看ClassPathResource的源码，是通过类加载器加载资源： 12345678910111213141516171819202122232425262728293031public class ClassPathResource extends AbstractFileResolvingResource &#123; private final String path; @Nullable private ClassLoader classLoader; @Nullable private Class&lt;?&gt; clazz; @Override public InputStream getInputStream() throws IOException &#123; InputStream is; //通过类加载器加载类路径下的资源 if (this.clazz != null) &#123; is = this.clazz.getResourceAsStream(this.path); &#125; else if (this.classLoader != null) &#123; is = this.classLoader.getResourceAsStream(this.path); &#125; else &#123; is = ClassLoader.getSystemResourceAsStream(this.path); &#125; //如果输入流is为null，则报错 if (is == null) &#123; throw new FileNotFoundException(getDescription() + &quot; cannot be opened because it does not exist&quot;); &#125; //返回InputStream return is; &#125;&#125; 再看UrlResource的源码，获取InputStream的实现又是另一种策略。 1234567891011121314151617181920212223242526public class UrlResource extends AbstractFileResolvingResource &#123; @Nullable private final URI uri; private final URL url; private final URL cleanedUrl; @Override public InputStream getInputStream() throws IOException &#123; //获取连接 URLConnection con = this.url.openConnection(); ResourceUtils.useCachesIfNecessary(con); try &#123; //获取输入流，并返回 return con.getInputStream(); &#125; catch (IOException ex) &#123; // Close the HTTP connection (if applicable). if (con instanceof HttpURLConnection) &#123; ((HttpURLConnection) con).disconnect(); &#125; throw ex; &#125; &#125;&#125; 代理模式Spring除了IOC(控制反转)之外的另一个核心就是AOP(面向切面编程)。AOP能够将与业务无关的，却被业务模块所共同调用的逻辑(比如日志，权限控制等等)封装起来，减少系统重复代码，降低系统之间的耦合，有利于系统的维护和扩展。 Spring AOP主要是基于动态代理实现的，如果要代理的类，实现了某个接口，则使用JDK动态代理，如果没有实现接口则使用Cglib动态代理。 我们看DefaultAopProxyFactory的createAopProxy()方法，Spring通过此方法创建动态代理类： 123456789101112131415161718public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123; @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; + &quot;Either an interface or a target is required for proxy creation.&quot;); &#125; if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125; &#125;&#125; JDK动态代理和Cglib动态代理的区别： JDK动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。 Cglib动态代理即使被代理的类没有实现接口，也可以使用，因为Cglib动态代理是使用继承被代理类的方式进行扩展。 Cglib动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被final修饰的话，就不能进行代理。 从源码中可以看出，Spring会先判断是否实现了接口，如果实现了接口就使用JDK动态代理，如果没有实现接口则使用Cglib动态代理，也可以通过配置，强制使用Cglib动态代理，配置如下： 1&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 模板模式模板模式在Spring中用得太多了，它定义一个算法的骨架，而将一些步骤延迟到子类中。 一般定义一个抽象类为骨架，子类重写抽象类中的模板方法实现算法骨架中特定的步骤。模板模式可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。 Spring中的事务管理器就运用模板模式的设计，首先看PlatformTransactionManager类。这是最底层的接口，定义提交和回滚的方法。 1234567public interface PlatformTransactionManager &#123; TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125; 毫无意外，使用了抽象类作为骨架，接着看AbstractPlatformTransactionManager类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic final void commit(TransactionStatus status) throws TransactionException &#123; //省略... DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status; if (defStatus.isLocalRollbackOnly()) &#123; //省略... //调用processRollback() processRollback(defStatus, false); return; &#125; if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123; //省略... //调用processRollback() processRollback(defStatus, true); return; &#125; //调用processCommit() processCommit(defStatus);&#125;//这个方法定义了骨架，里面会调用一个doRollback()的模板方法private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123; if (status.hasSavepoint()) &#123; //省略... &#125; else if (status.isNewTransaction()) &#123; //调用doRollback()模板方法 doRollback(status); &#125; else &#123; //省略... &#125; //省略了很多代码...&#125;private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123; //省略... if (status.hasSavepoint()) &#123; //省略... &#125; else if (status.isNewTransaction()) &#123; //省略... //调用doCommit()模板方法 doCommit(status); &#125; else if (isFailEarlyOnGlobalRollbackOnly()) &#123; unexpectedRollback = status.isGlobalRollbackOnly(); &#125; //省略了很多代码...&#125;//模板方法doRollback()，把重要的步骤延迟到子类去实现protected abstract void doRollback(DefaultTransactionStatus status) throws TransactionException;//模板方法doCommit()，把重要的步骤延迟到子类去实现protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException; 模板方法则由各种事务管理器的实现类去实现，也就是把骨架中重要的doRollback()延迟到子类。一般来说，Spring默认是使用的事务管理器的实现类是DataSourceTransactionManager。 1234567891011121314151617181920212223242526272829303132333435//通过继承AbstractPlatformTransactionManager抽象类public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean &#123; //重写doCommit()方法，实现具体commit的逻辑 @Override protected void doCommit(DefaultTransactionStatus status) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction(); Connection con = txObject.getConnectionHolder().getConnection(); if (status.isDebug()) &#123; logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;); &#125; try &#123; con.commit(); &#125; catch (SQLException ex) &#123; throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, ex); &#125; &#125; //重写doRollback()方法，实现具体的rollback的逻辑 @Override protected void doRollback(DefaultTransactionStatus status) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction(); Connection con = txObject.getConnectionHolder().getConnection(); if (status.isDebug()) &#123; logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;); &#125; try &#123; con.rollback(); &#125; catch (SQLException ex) &#123; throw new TransactionSystemException(&quot;Could not roll back JDBC transaction&quot;, ex); &#125; &#125;&#125; 如果你是用Hibernate框架，Hibernate也有自身的实现，这就体现了设计模式的开闭原则，通过继承或者组合的方式进行扩展，而不是直接修改类的代码。Hibernate的事务管理器则是HibernateTransactionManager。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class HibernateTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, BeanFactoryAware, InitializingBean &#123; //重写doCommit()方法，实现Hibernate的具体commit的逻辑 @Override protected void doCommit(DefaultTransactionStatus status) &#123; HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction(); Transaction hibTx = txObject.getSessionHolder().getTransaction(); Assert.state(hibTx != null, &quot;No Hibernate transaction&quot;); if (status.isDebug()) &#123; logger.debug(&quot;Committing Hibernate transaction on Session [&quot; + txObject.getSessionHolder().getSession() + &quot;]&quot;); &#125; try &#123; hibTx.commit(); &#125; catch (org.hibernate.TransactionException ex) &#123; throw new TransactionSystemException(&quot;Could not commit Hibernate transaction&quot;, ex); &#125; //省略... &#125; //重写doRollback()方法，实现Hibernate的具体rollback的逻辑 @Override protected void doRollback(DefaultTransactionStatus status) &#123; HibernateTransactionObject txObject = (HibernateTransactionObject) status.getTransaction(); Transaction hibTx = txObject.getSessionHolder().getTransaction(); Assert.state(hibTx != null, &quot;No Hibernate transaction&quot;); //省略... try &#123; hibTx.rollback(); &#125; catch (org.hibernate.TransactionException ex) &#123; throw new TransactionSystemException(&quot;Could not roll back Hibernate transaction&quot;, ex); &#125; //省略... finally &#123; if (!txObject.isNewSession() &amp;&amp; !this.hibernateManagedSession) &#123; txObject.getSessionHolder().getSession().clear(); &#125; &#125; &#125;&#125; 其实模板模式在日常开发中也经常用，比如一个方法中，前后代码都一样，只有中间有一部分操作不同，就可以使用模板模式进行优化代码，这可以大大地减少冗余的代码，非常实用。 适配器模式与责任链模式适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作，将一个类的接口，转换成客户期望的另外一个接口。 在SpringAOP中有一个很重要的功能就是使用的 Advice（通知） 来增强被代理类的功能，Advice主要有MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice这几种。每个Advice都有对应的拦截器，如下所示： Spring需要将每个 Advice 都封装成对应的拦截器类型返回给容器，所以需要使用适配器模式对 Advice 进行转换。对应的就有三个适配器，我们看个类图： 适配器在Spring中是怎么把通知类和拦截类进行转换的呢，我们先看适配器的接口。定义了两个方法，分别是supportsAdvice()和getInterceptor()。 123456public interface AdvisorAdapter &#123; //判断通知类是否匹配 boolean supportsAdvice(Advice advice); //传入通知类，返回对应的拦截类 MethodInterceptor getInterceptor(Advisor advisor);&#125; 其实很简单，可以看出转换的方法就是getInterceptor()，通过supportsAdvice()进行判断。我们看前置通知的适配器的实现类MethodBeforeAdviceAdapter。 12345678910111213class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123; //判断是否匹配MethodBeforeAdvice通知类 @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof MethodBeforeAdvice); &#125; //传入MethodBeforeAdvice，转换为MethodBeforeAdviceInterceptor拦截类 @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); &#125;&#125; getInterceptor()方法中，调用了对应的拦截类的构造器创建对应的拦截器返回，传入通知类advice作为参数。接着我们看拦截器MethodBeforeAdviceInterceptor。 123456789101112131415161718public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123; //成员变量，通知类 private MethodBeforeAdvice advice; //定义了有参构造器，外部通过有参构造器创建MethodBeforeAdviceInterceptor public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123; Assert.notNull(advice, &quot;Advice must not be null&quot;); this.advice = advice; &#125; //当调用拦截器的invoke方法时，就调用通知类的before()方法，实现前置通知 @Override public Object invoke(MethodInvocation mi) throws Throwable &#123; //调用通知类的before()方法，实现前置通知 this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() ); return mi.proceed(); &#125;&#125; 那么在哪里初始化这些适配器呢，我们看DefaultAdvisorAdapterRegistry()。 12345678910111213141516171819202122232425262728293031323334353637383940public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable &#123; private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3); public DefaultAdvisorAdapterRegistry() &#123; //初始化适配器，添加到adapters集合，也就是注册 registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); registerAdvisorAdapter(new AfterReturningAdviceAdapter()); registerAdvisorAdapter(new ThrowsAdviceAdapter()); &#125; @Override public void registerAdvisorAdapter(AdvisorAdapter adapter) &#123; this.adapters.add(adapter); &#125; //获取所有的拦截器 @Override public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor) advice); &#125; //遍历adapters集合 for (AdvisorAdapter adapter : this.adapters) &#123; //调用supportsAdvice()方法，判断入参的advisor是否有匹配的适配器 if (adapter.supportsAdvice(advice)) &#123; //如果匹配，则调用getInterceptor()转换成对应的拦截器，添加到interceptors集合中 interceptors.add(adapter.getInterceptor(advisor)); &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; //返回拦截器集合 return interceptors.toArray(new MethodInterceptor[0]); &#125; &#125; 适配器模式在这里就是把通知类转为拦截类，转为拦截类之后，就添加到拦截器集合中。添加到拦截器集合之后，就用到了责任链模式，在ReflectiveMethodInvocation类被调用，我们看JDK动态代理JdkDynamicAopProxy的invoke()方法。 12345678910111213141516@Override@Nullablepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; MethodInvocation invocation; //这里就是获取拦截器集合，最后就会调用到上文说的getInterceptors() List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); if (chain.isEmpty()) &#123; //省略... &#125;else &#123; //创建一个MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); //调用proceed()方法，底层会通过指针遍历拦截器集合，然后实现前置通知等功能 retVal = invocation.proceed(); &#125; //省略...&#125; 最后就在ReflectiveMethodInvocation里调用proceed()方法，proceed()方法是一个递归的方法，通过指针控制递归的结束。这是很典型的责任链模式。 1234567891011121314151617181920212223242526272829303132333435363738public class ReflectiveMethodInvocation implements ProxyMethodInvocation, Cloneable &#123; protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers; //指针 private int currentInterceptorIndex = -1; protected ReflectiveMethodInvocation(Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, @Nullable Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers) &#123; //省略... //拦截器的集合 this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers; &#125; @Override @Nullable public Object proceed() throws Throwable &#123; // We start with an index of -1 and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; //递归结束 return invokeJoinpoint(); &#125; //获取拦截器，并且当前的指针+1 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; //匹配失败，跳过，递归下一个 return proceed(); &#125; &#125; else &#123; //匹配拦截器，强转为拦截器，然后执行invoke()方法，然后就会调用拦截器里的成员变量的before()，afterReturning()等等，实现前置通知，后置通知，异常通知 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125; &#125;&#125; 这里可能没学过责任链模式的同学会看得有点晕，但是学过责任链模式应该很容易看懂，这其实跟SpringMVC的拦截器的逻辑实现几乎一样的。 观察者模式观察者模式是一种对象行为型模式，当一个对象发生变化时，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。 事件角色在Spring事件驱动模型中，首先有事件角色ApplicationEvent，这是一个抽象类，抽象类下有四个实现类代表四种事件。 ContextStartedEvent：ApplicationContext启动后触发的事件。 ContextStoppedEvent：ApplicationContext停止后触发的事件。 ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件。 ContextClosedEvent：ApplicationContext关闭后触发的事件。 事件发布者有了事件之后，需要有个发布者发布事件，发布者对应的类是ApplicationEventPublisher。 123456789@FunctionalInterfacepublic interface ApplicationEventPublisher &#123; default void publishEvent(ApplicationEvent event) &#123; publishEvent((Object) event); &#125; void publishEvent(Object event);&#125; @FunctionalInterface表示这是一个函数式接口，函数式接口只有一个抽象方法。ApplicationContext类又继承了 ApplicationEventPublisher类，所以我们可以使用ApplicationContext发布事件。 事件监听者发布事件后需要有事件的监听者，事件监听者通过实现接口ApplicationListener来定义，这是一个函数式接口，并且带有泛型，要求E参数是ApplicationEvent的子类。 12345@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; void onApplicationEvent(E event);&#125; 下面我们演示一下怎么使用，首先继承抽象类ApplicationEvent定义一个事件角色PayApplicationEvent。 12345678910111213public class PayApplicationEvent extends ApplicationEvent &#123; private String message; public PayApplicationEvent(Object source, String message) &#123; super(source); this.message = message; &#125; public String getMessage() &#123; return message; &#125;&#125; 接着定义一个PayApplicationEvent事件的监听者PayListener。 123456789@Componentpublic class PayListener implements ApplicationListener&lt;PayApplicationEvent&gt; &#123; @Override public void onApplicationEvent(PayApplicationEvent event) &#123; String message = event.getMessage(); System.out.println(&quot;监听到PayApplicationEvent事件，消息为：&quot; + message); &#125;&#125; 最后我们使用ApplicationContext发布事件。 123456789@SpringBootApplicationpublic class SpringmvcApplication &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext applicationContext = SpringApplication.run(SpringmvcApplication.class, args); applicationContext.publishEvent(new PayApplicationEvent(applicationContext,&quot;成功支付100元！&quot;)); &#125;&#125; 启动之后我们可以看到控制台打印： 絮叨实际上，Spring中使用到的设计模式在源码中随处可见，并不止我列举的这些，所以Spring的源码非常值得去阅读和学习，受益良多。反过来看，如果不会设计模式，读起源码来也是非常费劲的，所以我建议还是先学会设计模式再去学习源码。 希望大家看完之后，能对Spring有更深入的了解，那么这篇文章就讲到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"必学的优秀技术框架/SpringBoot启动类启动流程","date":"2021-08-04T03:20:11.174Z","updated":"2021-08-04T03:17:18.592Z","comments":true,"path":"2021/08/04/必学的优秀技术框架/SpringBoot启动类启动流程/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言SpringBoot一开始最让我印象深刻的就是通过一个启动类就能启动应用。在SpringBoot以前，启动应用虽然也不麻烦，但是还是有点繁琐，要打包成war包，又要配置tomcat，tomcat又有一个server.xml文件去配置。 然而SpringBoot则内置了tomcat，通过启动类启动，配置也集中在一个application.yml中，简直不要太舒服。好奇心驱动，于是我很想搞清楚启动类的启动过程，那么开始吧。 一、启动类首先我们看最常见的启动类写法。 123456@SpringBootApplicationpublic class SpringmvcApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringmvcApplication.class, args); &#125;&#125; 把启动类分解一下，实际上就是两部分： @SpringBootApplication注解 一个main()方法，里面调用SpringApplication.run()方法。 二、@SpringBootApplication首先看@SpringBootApplication注解的源码。 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 很明显，@SpringBootApplication注解由三个注解组合而成，分别是： @ComponentScan @EnableAutoConfiguration @SpringBootConfiguration 2.1 @ComponentScan1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123; &#125; 这个注解的作用是告诉Spring扫描哪个包下面类，加载符合条件的组件(比如贴有@Component和@Repository等的类)或者bean的定义。 所以有一个basePackages的属性，如果默认不写，则从声明@ComponentScan所在类的package进行扫描。 所以启动类最好定义在Root package下，因为一般我们在使用@SpringBootApplication时，都不指定basePackages的。 2.2 @EnableAutoConfiguration123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; &#125; 这是一个复合注解，看起来很多注解，实际上关键在@Import注解，它会加载AutoConfigurationImportSelector类，然后就会触发这个类的selectImports()方法。根据返回的String数组(配置类的Class的名称)加载配置类。 12345678910111213public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; //返回的String[]数组，是配置类Class的类名 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); //返回配置类的类名 return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;&#125; 我们一直点下去，就可以找到最后的幕后英雄，就是SpringFactoriesLoader类，通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类。 这里使用了spring.factories文件的方式加载配置类，提供了很好的扩展性。 所以@EnableAutoConfiguration注解的作用其实就是开启自动配置，自动配置主要则依靠这种加载方式来实现。 2.3 @SpringBootConfiguration@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 2.4 小结我们在这里画张图把@SpringBootApplication注解包含的三个注解分别解释一下。 三、SpringApplication类接下来讲main方法里执行的这句代码，这是SpringApplication类的静态方法run()。 12345678910111213141516//启动类的main方法public static void main(String[] args) &#123; SpringApplication.run(SpringmvcApplication.class, args);&#125;//启动类调的run方法public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; //调的是下面的，参数是数组的run方法 return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);&#125;//和上面的方法区别在于第一个参数是一个数组public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; //实际上new一个SpringApplication实例，调的是一个实例方法run() return new SpringApplication(primarySources).run(args);&#125; 通过上面的源码，发现实际上最后调的并不是静态方法，而是实例方法，需要new一个SpringApplication实例，这个构造器还带有一个primarySources的参数。所以我们直接定位到构造器。 12345678910111213141516171819202122232425262728293031public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; //断言primarySources不能为null，如果为null，抛出异常提示 Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); //启动类传入的Class this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //判断当前项目类型，有三种：NONE、SERVLET、REACTIVE this.webApplicationType = WebApplicationType.deduceFromClasspath(); //设置ApplicationContextInitializer setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //设置监听器 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //判断主类，初始化入口类 this.mainApplicationClass = deduceMainApplicationClass();&#125;//判断主类private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125; 以上就是创建SpringApplication实例做的事情，下面用张图来表示一下。 创建了SpringApplication实例之后，就完成了SpringApplication类的初始化工作，这个实例里包括监听器、初始化器，项目应用类型，启动类集合，类加载器。如图所示。 得到SpringApplication实例后，接下来就调用实例方法run()。继续看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public ConfigurableApplicationContext run(String... args) &#123; //创建计时器 StopWatch stopWatch = new StopWatch(); //开始计时 stopWatch.start(); //定义上下文对象 ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); //Headless模式设置 configureHeadlessProperty(); //加载SpringApplicationRunListeners监听器 SpringApplicationRunListeners listeners = getRunListeners(args); //发送ApplicationStartingEvent事件 listeners.starting(); try &#123; //封装ApplicationArguments对象 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //配置环境模块 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //根据环境信息配置要忽略的bean信息 configureIgnoreBeanInfo(environment); //打印Banner标志 Banner printedBanner = printBanner(environment); //创建ApplicationContext应用上下文 context = createApplicationContext(); //加载SpringBootExceptionReporter exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //ApplicationContext基本属性配置 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新上下文 refreshContext(context); //刷新后的操作，由子类去扩展 afterRefresh(context, applicationArguments); //计时结束 stopWatch.stop(); //打印日志 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; //发送ApplicationStartedEvent事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕 listeners.started(context); //查找容器中注册有CommandLineRunner或者ApplicationRunner的bean，遍历并执行run方法 callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; //发送ApplicationFailedEvent事件，标志SpringBoot启动失败 handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; //发送ApplicationReadyEvent事件，标志SpringApplication已经正在运行，即已经成功启动，可以接收服务请求。 listeners.running(context); &#125; catch (Throwable ex) &#123; //报告异常，但是不发送任何事件 handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; 结合注释和源码，其实很清晰了，为了加深印象，画张图看一下整个流程。 总结表面启动类看起来就一个@SpringBootApplication注解，一个run()方法。其实是经过高度封装后的结果。我们可以从这个分析中学到很多东西。比如使用了spring.factories文件来完成自动配置，提高了扩展性。在启动时使用观察者模式，以事件发布的形式通知，降低耦合，易于扩展等等。 那么SpringBoot的启动类分析就讲到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"必学的优秀技术框架/mybatis-plus全解","date":"2021-08-04T03:20:11.169Z","updated":"2021-08-04T03:17:18.598Z","comments":true,"path":"2021/08/04/必学的优秀技术框架/mybatis-plus全解/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/mybatis-plus%E5%85%A8%E8%A7%A3/","excerpt":"","text":"前言mybatis相信都不陌生，目前互联网公司大部分都使用mybatis作为持久层框架，无他，因为可以直接在xml文件中编写SQL语句操作数据库，灵活。但是我们在使用的时候，也会发现有很多增删改查的SQL是每个表都会有的基本操作，如果每个表都写一套增删改查的SQL显然是非常耗时耗力的。 于是乎，就有了mybatis-plus这个框架。正如官网所说，mybatis-plus是为简化开发而生。 mybatis-plus有以下特点： 只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。 只需简单配置，即可快速进行单表CRUD操作，节省大量时间。 代码生成，物理分页，性能分析等功能一应俱全。 一、整合mybatis-plus这里用的是SpringBoot2.5.2做演示。首先导入依赖： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 引入 mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 然后在application.properties文件配置数据库信息： 123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user?createDatabaseIfNotExist=truespring.datasource.username=rootspring.datasource.password=root123456#mapper.xml文件路径地址mybatis-plus.mapper-locations=classpath:mapper/*Mapper.xml 在启动类加上扫描注解： 1234567@SpringBootApplication@MapperScan(basePackages = &quot;com.yehongzhi.mydemo.mapper&quot;)public class MydemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MydemoApplication.class, args); &#125;&#125; 其实这样就完成了，但是我们要建个表进行测试。 1234567891011CREATE TABLE `user` ( `id` char(36) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;ID&#x27;, `name` varchar(255) DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;, `age` int(3) DEFAULT NULL COMMENT &#x27;年龄&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 初始化4条数据INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#x27;1345fc0985b111eba0e488d7f66fdab8&#x27;, &#x27;观辰&#x27;, &#x27;20&#x27;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#x27;d47561e885b011eba0e488d7f66fdab8&#x27;, &#x27;姚大秋&#x27;, &#x27;30&#x27;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#x27;ef2741fe87f011eba0e488d7f66fdab8&#x27;, &#x27;周星驰&#x27;, &#x27;60&#x27;);INSERT INTO `user`.`user` (`id`, `name`, `age`) VALUES (&#x27;ff784f6b85b011eba0e488d7f66fdab8&#x27;, &#x27;李嘉晟&#x27;, &#x27;33&#x27;); 建了表之后，再创建一个User实体类对应： 123456789101112//表名@TableName(&quot;user&quot;)public class User &#123; //主键 @TableId(type = IdType.UUID) private String id; //姓名 private String name; //年龄 private Integer age; //getter、setter方法&#125; 接着创建UserMapper接口类,，然后继承BaseMapper： 1234@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; 创建一个UserMapper.xml与UserMapper对应： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yehongzhi.mydemo.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; 最后我们写一个UserService接口，查询user表： 12345678910@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public List&lt;User&gt; getList() &#123; return userMapper.selectList(null); &#125;&#125; 启动项目，测试是没问题的： 二、CRUD操作整合完了之后，按照mybatis-plus的官方说明，是有简单的单表CRUD操作功能。 这些单表的CRUD操作其实都放在BaseMapper里面了，所以当我们继承了BaseMapper类之后，就会获得mybatis-plus的增强特性，其中就包括单表的CRUD操作。 1、insert操作BaseMapper直接提供一个insert()方法，传一个实体类。 12345678910@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public int insertOne(User user) &#123; return userMapper.insert(user); &#125;&#125; 接着在Controller调用，因为在User类上面贴了注解@TableId，所以会自动生成ID。 123456@TableName(&quot;user&quot;)public class User &#123; @TableId(type = IdType.UUID) private String id; //省略...&#125; Controller层代码： 12345678910@RequestMapping(&quot;/insert&quot;)public String insertUser(@RequestParam(name = &quot;name&quot;) String name, @RequestParam(name = &quot;age&quot;) Integer age) &#123; User user = new User(); user.setName(name); user.setAge(age); //在实体类使用了@TableId注解，ID会自动生成 int i = userService.insertOne(user); return i == 1 ? &quot;success&quot; : &quot;fail&quot;;&#125; 2、update操作BaseMapper直接提供一个updateById()方法，传一个实体类。 1234@Overridepublic int updateOne(User user) &#123; return userMapper.updateById(user);&#125; Controller层代码： 1234567891011@RequestMapping(&quot;/update&quot;)public String updateUser(@RequestParam(name = &quot;id&quot;) String id, @RequestParam(name = &quot;name&quot;,required = false) String name, @RequestParam(name = &quot;age&quot;,required = false) Integer age) &#123; User user = new User(); user.setId(id); user.setName(name); user.setAge(age); int i = userService.updateOne(user); return i == 1 ? &quot;success&quot; : &quot;fail&quot;;&#125; 3、delete操作BaseMapper直接提供一个deleteById()方法，传主键值。 1234@Overridepublic int deleteOne(String id) &#123; return userMapper.deleteById(id);&#125; Controller层代码： 12345@RequestMapping(&quot;/delete&quot;)public String deleteUser(@RequestParam(name = &quot;id&quot;) String id) &#123; int i = userService.deleteOne(id); return i == 1 ? &quot;success&quot; : &quot;fail&quot;;&#125; 除此之外，还有批量删除deleteBatchIds方法，传主键值的集合： 1234@Overridepublic int deleteBatch(List&lt;String&gt; ids)&#123; return userMapper.deleteBatchIds(ids);&#125; Controller层代码： 123456@RequestMapping(&quot;/deleteBatch&quot;)public String deleteBatchUser(@RequestParam(name = &quot;ids&quot;) String ids) &#123; List&lt;String&gt; list = Arrays.asList(ids.split(&quot;,&quot;)); int i = userService.deleteBatch(list); return i == list.size() ? &quot;success&quot; : &quot;fail&quot;;&#125; 三、条件构造器(Wrapper)条件构造器在Mybatis-plus各种方法中都有出现，比如： 1234567Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper);int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); Wrapper通俗点理解就是定义where语句后面的查询条件，是Mybatis-Plus里功能比较强大的工具。Wrapper是一个抽象类，下面有很多子类，我们先看个类图混个眼熟。 常用的子类实现有四个，分别是： QueryWrapper UpdateWrapper LambdaQueryWrapper LambdaUpdateWrapper QueryWrapper主要用于生成where条件，举个例子，我们用name查询user表： 1234567public List&lt;User&gt; queryUserByName(String name) &#123; //相当于：SELECT * FROM user WHERE name = ? QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //eq()表示相等 queryWrapper.eq(&quot;name&quot;, name); return userMapper.selectList(queryWrapper);&#125; 我们看日志打印： 12345==&gt; Preparing: SELECT id,name,age FROM user WHERE name = ?==&gt; Parameters: 姚大秋(String)&lt;== Columns: id, name, age&lt;== Row: d47561e885b011eba0e488d7f66fdab8, 姚大秋, 30&lt;== Total: 1 假如我们要like查询，可以这样写： 123456public List&lt;User&gt; queryUserLikeName(String name) &#123; //相当于：SELECT * FROM user WHERE name like %#&#123;name&#125;% QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;,name); return userMapper.selectList(queryWrapper);&#125; 假如要查询年龄大于30岁，可以这样： 12345678910public List&lt;User&gt; queryUserGtByAge(int age) &#123; //相当于：SELECT * FROM user WHERE age &gt; ? QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.gt(&quot;age&quot;, age); //小于是lt() //大于等于是ge() //小于等于是le() //范围的话，则使用between() return userMapper.selectList(queryWrapper);&#125; 如果要查询某个字段不为空，可以这样： 1234567public List&lt;User&gt; queryUserByNameNotNull() &#123; //相当于：SELECT * FROM user WHERE name IS NOT NULL QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNotNull(&quot;name&quot;); //查询某个字段为空，则使用isNull() return userMapper.selectList(queryWrapper);&#125; 如果使用IN查询，可以这样： 1234567public List&lt;User&gt; queryUserByIds(List&lt;String&gt; ids) &#123; //相当于：SELECT * FROM user WHERE name IN (&#x27;id1&#x27;,&#x27;id2&#x27;); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.in(&quot;id&quot;, ids); //相反也提供了notIn()方法 return userMapper.selectList(queryWrapper);&#125; 如果需要排序，可以这样写： 1234567public List&lt;User&gt; queryUserOrderByAge() &#123; //相当于：SELECT * FROM user ORDER BY age ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByAsc(&quot;age&quot;); //相反的，如果降序则使用orderByDesc()方法 return userMapper.selectList(queryWrapper);&#125; 如果需要子查询，可以这样写： 123456public List&lt;User&gt; queryUserInSql() &#123; //相当于：SELECT * FROM user WHERE id IN (SELECT id FROM user WHERE age &gt; 30) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.inSql(&quot;id&quot;,&quot;select id from user where age &gt; 30&quot;); return userMapper.selectList(queryWrapper);&#125; 大部分的方法都是源自AbstractWrapper抽象类，除此之外还有很多功能，这里就不一一介绍下去了，有兴趣的可以到官网的条件构造器慢慢探索。 UpdateWrapperUpdateWrapper也是AbstractWrapper抽象类的子类实现，所以上述的设置条件的方法都有，不同的是，UpdateWrapper会有set()和setSql()设置更新的值。举个例子： 12345678public int updateUserNameById(String id, String name) &#123; //相当于：UPDATE user SET name = ? where id = ? UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper.eq(&quot;id&quot;, id); //设置set关键字后面的语句，相当于set name = #&#123;name&#125; userUpdateWrapper.set(&quot;name&quot;, name); return userMapper.update(new User(), userUpdateWrapper);&#125; setSql()就是设置SET关键字后面拼接的部分SQL语句，举个例子： 1234567public int updateUserBySql(String id, String name) &#123; //相当于：UPDATE user SET name = ? where id = ? UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper.setSql(&quot;name = &#x27;&quot; + name + &quot;&#x27;&quot;); userUpdateWrapper.eq(&quot;id&quot;, id); return userMapper.update(new User(), userUpdateWrapper);&#125; setSql()就是纯粹的SQL语句拼接，我们可以看到SET后面接的是name=’大D’，而不是占位符会有SQL注入的风险。 123==&gt; Preparing: UPDATE user SET name = &#x27;大D&#x27; WHERE id = ?==&gt; Parameters: d47561e885b011eba0e488d7f66fdab8(String)&lt;== Updates: 1 LambdaQueryWrapper用LambdaQueryWrapper的好处在于消除硬编码，比如QueryWrapper在查询name=?时，需要这样写： 123QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//使用&quot;name&quot;字符串，就是硬编码queryWrapper.eq(&quot;name&quot;, name); 如果换成LambdaQueryWrapper就可以这样写： 123456public List&lt;User&gt; lambdaQueryUserByName(String name) &#123; //相当于：SELECT id,name,age FROM user WHERE name = ? LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new QueryWrapper&lt;User&gt;().lambda(); lambdaQueryWrapper.eq(User::getName, name); return userMapper.selectList(lambdaQueryWrapper);&#125; 再比如使用模糊查询，可以这样写： 12345public List&lt;User&gt; lambdaQueryUserLikeName(String name) &#123; LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new QueryWrapper&lt;User&gt;().lambda(); lambdaQueryWrapper.like(User::getName, name); return userMapper.selectList(lambdaQueryWrapper);&#125; LambdaUpdateWrapper跟上面差不多，LambdaUpdateWrapper也可以消除硬编码： 1234567public int lambdaUpdateUserNameById(String id, String name) &#123; //相当于：UPDATE user SET name=? WHERE id = ? LambdaUpdateWrapper&lt;User&gt; lambdaUpdateWrapper = new UpdateWrapper&lt;User&gt;().lambda(); lambdaUpdateWrapper.set(User::getName, name); lambdaUpdateWrapper.eq(User::getId, id); return userMapper.update(new User(), lambdaUpdateWrapper);&#125; 分页查询Mybatis-plus提供了分页插件支持分页查询，只需要几个步骤即可实现。 首先添加一个配置类： 1234567@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 第二步，在UserMapper类里定义分页查询方法： 12345@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; //分页查询方法 IPage&lt;User&gt; selectPageByName(Page&lt;User&gt; page, @Param(&quot;name&quot;) String name);&#125; 对应的UserMapper.xml方法： 123&lt;select id=&quot;selectPageByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.yehongzhi.mydemo.model.User&quot;&gt; select * from `user` where name = #&#123;name&#125;&lt;/select&gt; 第三步，在userService里调用： 12345678public IPage&lt;User&gt; selectPageByName(long pageNo, long pageSize, String name) &#123; Page&lt;User&gt; page = new Page&lt;&gt;(); //设置当前页码 page.setCurrent(pageNo); //设置每页显示数 page.setSize(pageSize); return userMapper.selectPageByName(page, name);&#125; 最后写个Controller接口测试： 123456@RequestMapping(&quot;/queryPage/ByName&quot;)public IPage&lt;User&gt; selectPageByName(@RequestParam(&quot;pageNo&quot;) long pageNo, @RequestParam(&quot;pageSize&quot;) long pageSize, @RequestParam(&quot;name&quot;) String name) &#123; return userService.selectPageByName(pageNo, pageSize, name);&#125; 查看控制台日志： 123456789==&gt; Preparing: SELECT COUNT(1) FROM `user` WHERE name = ?==&gt; Parameters: 杜琪峰(String)&lt;== Columns: COUNT(1)&lt;== Row: 1==&gt; Preparing: select * from `user` where name = ? LIMIT ?,?==&gt; Parameters: 杜琪峰(String), 0(Long), 10(Long)&lt;== Columns: id, name, age&lt;== Row: d47561e885b011eba0e488d7f66fdab8, 杜琪峰, 30&lt;== Total: 1 分页查询成功！ 自定义主键生成器有时在实际开发中，可能会遇到，Mybatis-plus提供的主键生成策略并不能满足，需要自定义主键ID生成策略，怎么设置呢？ 很简单，根据官网的说明，我们先定义一个主键生成器： 1234567891011121314@Componentpublic class SnowflakeKeyGenerator implements IdentifierGenerator &#123; //自己实现的一个雪花ID生成工具类 @Resource private SnowflakeIdWorker snowflakeIdWorker; @Override public Number nextId(Object entity) &#123; //使用雪花ID生成器，生成一个雪花ID long nextId = snowflakeIdWorker.nextId(); System.out.println(String.format(&quot;使用自定义ID生成器，生成雪花ID:%s&quot;, nextId)); return nextId; &#125;&#125; 然后我们在需要使用该自定义ID生成器的实体类上面加上注解属性： 12345678@TableName(&quot;user&quot;)public class User &#123; //属性设置为：IdType.ASSIGN_ID @TableId(type = IdType.ASSIGN_ID) private String id; //省略...&#125; 接着测试一下，我们可以看到控制台有打印日志： 总结除了上面介绍的功能之外，Mybatis-plus还有很多功能，比如：代码生成器、扩展等等。这里就不再一一介绍了，实际上我们掌握上面介绍的CRUD、条件构造器、分页查询、自定义主键策略，基本上已经足够日常的开发。 当然如果你觉得会用还不够，还想要看懂框架的源码实现，那没问题。下一篇文章，我就讲讲框架的源码分析，敬请期待， 非常感谢你的阅读，希望这篇文章能给到你帮助和启发。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"必学的优秀技术框架/5千字的SpringMVC总结，我觉得你会需要","date":"2021-08-04T03:20:11.164Z","updated":"2021-08-04T03:17:18.585Z","comments":true,"path":"2021/08/04/必学的优秀技术框架/5千字的SpringMVC总结，我觉得你会需要/","link":"","permalink":"https://alloceee.github.io/2021/08/04/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/5%E5%8D%83%E5%AD%97%E7%9A%84SpringMVC%E6%80%BB%E7%BB%93%EF%BC%8C%E6%88%91%E8%A7%89%E5%BE%97%E4%BD%A0%E4%BC%9A%E9%9C%80%E8%A6%81/","excerpt":"","text":"思维导图 微信公众号已开启：【java技术爱好者】，还没关注的记得关注哦~ 文章已收录到我的Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 概述SpringMVC再熟悉不过的框架了，因为现在最火的SpringBoot的内置MVC框架就是SpringMVC。我写这篇文章的动机是想通过回顾总结一下，重新认识SpringMVC，所谓温故而知新嘛。 为了了解SpringMVC，先看一个流程示意图： 从流程图中，我们可以看到： 接收前端传过来Request请求。 根据映射路径找到对应的处理器处理请求，处理完成之后返回ModelAndView。 进行视图解析，视图渲染，返回响应结果。 总结就是：参数接收，定义映射路径，页面跳转，返回响应结果。 当然这只是最基本的核心功能，除此之外还可以定义拦截器，全局异常处理，文件上传下载等等。 一、搭建项目在以前的老项目中，因为还没有SpringBoot，没有自动配置，所以需要使用web.xml文件去定义一个DispatcherServlet。现在互联网应用基本上都使用SpringBoot，所以我就直接使用SpringBoot进行演示。很简单，引入依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 二、定义Controller使用SpringMVC定义Controller处理器，总共有五种方式。 2.1 实现Controller接口早期的SpringMVC是通过这种方式定义： 12345678910111213/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name DemoController * @date 2020-08-25 22:28 **/@org.springframework.stereotype.Controller(&quot;/demo/controller&quot;)public class DemoController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //业务处理 return null; &#125;&#125; 2.2 实现HttpRequestHandler接口跟第一种方式差不多，也是通过实现接口的方式： 123456789101112/** * @author Ye Hongzhi 公众号：java技术爱好者 * @name HttpDemoController * @date 2020-08-25 22:45 **/@Controller(&quot;/http/controller&quot;)public class HttpDemoController implements HttpRequestHandler&#123; @Override public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; //业务处理 &#125;&#125; 2.3 实现Servlet接口这种方式已经不推荐使用了，不过从这里可以看出SpringMVC的底层使用的还是Servlet。 12345678910111213141516171819202122232425@Controller(&quot;/servlet/controller&quot;)public class ServletDemoController implements Servlet &#123; //以下是Servlet生命周期方法 @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 因为不推荐使用这种方式，所以默认是不加载这种适配器的，需要加上： 123456789@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Bean public SimpleServletHandlerAdapter simpleServletHandlerAdapter() &#123; return new SimpleServletHandlerAdapter(); &#125;&#125; 2.4 使用@RequestMapping这种方式是最常用的，因为上面那些方式定义需要使用一个类定义一个路径，就会导致产生很多类。使用注解就相对轻量级一些。 123456789@Controller@RequestMapping(&quot;/requestMapping/controller&quot;)public class RequestMappingController &#123; @RequestMapping(&quot;/demo&quot;) public String demo() &#123; return &quot;HelloWord&quot;; &#125;&#125; 2.4.1 支持Restful风格而且支持Restful风格，使用method属性定义对资源的操作方式： 1234567891011121314151617181920212223@RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET) public String get() &#123; //查询 return &quot;get&quot;; &#125; @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST) public String post() &#123; //创建 return &quot;post&quot;; &#125; @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.PUT) public String put() &#123; //更新 return &quot;put&quot;; &#125; @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.DELETE) public String del() &#123; //删除 return &quot;post&quot;; &#125; 2.4.2 支持Ant风格1234567891011121314151617//匹配 /antA 或者 /antB 等URL @RequestMapping(&quot;/ant?&quot;) public String ant() &#123; return &quot;ant&quot;; &#125; //匹配 /ant/a/create 或者 /ant/b/create 等URL @RequestMapping(&quot;/ant/*/create&quot;) public String antCreate() &#123; return &quot;antCreate&quot;; &#125; //匹配 /ant/create 或者 /ant/a/b/create 等URL @RequestMapping(&quot;/ant/**/create&quot;) public String antAllCreate() &#123; return &quot;antAllCreate&quot;; &#125; 2.5 使用HandlerFunction最后一种是使用HandlerFunction函数式接口，这是Spring5.0后引入的方式，主要用于做响应式接口的开发，也就是Webflux的开发。 有兴趣的可以网上搜索相关资料学习，这个讲起来可能要很大篇幅，这里就不赘述了。 三、接收参数定义完Controller之后，需要接收前端传入的参数，怎么接收呢。 3.1 接收普通参数在@RequestMapping映射方法上写上接收参数名即可： 12345@RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.POST)public String post(Integer id, String name, int money) &#123; System.out.println(&quot;id:&quot; + id + &quot;,name:&quot; + name + &quot;,money:&quot; + money); return &quot;post&quot;;&#125; 3.2 @RequestParam参数名绑定如果不想使用形参名称作为参数名称，可以使用@RequestParam进行参数名称绑定： 12345678910/** * value: 参数名 * required: 是否request中必须包含此参数，默认是true。 * defaultValue: 默认参数值 */ @RequestMapping(value = &quot;/restful&quot;, method = RequestMethod.GET) public String get(@RequestParam(value = &quot;userId&quot;, required = false, defaultValue = &quot;0&quot;) String id) &#123; System.out.println(&quot;id:&quot; + id); return &quot;get&quot;; &#125; 3.3 @PathVariable路径参数通过@PathVariable将URL中的占位符{xxx}参数映射到操作方法的入参。演示代码如下： 12345@RequestMapping(value = &quot;/restful/&#123;id&#125;&quot;, method = RequestMethod.GET)public String search(@PathVariable(&quot;id&quot;) String id) &#123; System.out.println(&quot;id:&quot; + id); return &quot;search&quot;;&#125; 3.4 @RequestHeader绑定请求头属性获取请求头的信息怎么获取呢？ 使用@RequestHeader注解，用法和@RequestParam类似： 1234@RequestMapping(&quot;/head&quot;) public String head(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage) &#123; return acceptLanguage; &#125; 3.5 @CookieValue绑定请求的Cookie值获取Request中Cookie的值： 1234@RequestMapping(&quot;/cookie&quot;) public String cookie(@CookieValue(&quot;_ga&quot;) String _ga) &#123; return _ga; &#125; 3.6 绑定请求参数到POJO对象定义了一个User实体类： 123456public class User &#123; private String id; private String name; private Integer age; //getter、setter方法&#125; 定义一个@RequestMapping操作方法： 1234@RequestMapping(&quot;/body&quot;) public String body(User user) &#123; return user.toString(); &#125; 只要请求参数与属性名相同自动填充到user对象中： 3.6.1 支持级联属性现在多了一个Address类存储地址信息： 12345public class Address &#123; private String id; private String name; //getter、setter方法&#125; 在User中加上address属性： 1234567public class User &#123; private String id; private String name; private Integer age; private Address address; //getter、setter方法&#125; 传参时只要传入address.name、address.id即会自动填充： 3.6.2 @InitBinder解决接收多对象时属性名冲突如果有两个POJO对象拥有相同的属性名，不就产生冲突了吗？比如刚刚的user和address，其中他们都有id和name这两个属性，如果同时接收，就会冲突： 12345//user和address都有id和name这两个属性 @RequestMapping(value = &quot;/twoBody&quot;, method = RequestMethod.POST) public String twoBody(User user, Address address) &#123; return user.toString() + &quot;,&quot; + address.toString(); &#125; 这时就可以使用@InitBinder绑定参数名称： 123456789@InitBinder(&quot;user&quot;) public void initBindUser(WebDataBinder webDataBinder) &#123; webDataBinder.setFieldDefaultPrefix(&quot;u.&quot;); &#125; @InitBinder(&quot;address&quot;) public void initBindAddress(WebDataBinder webDataBinder) &#123; webDataBinder.setFieldDefaultPrefix(&quot;addr.&quot;); &#125; 3.6.3 @Requestbody自动解析JSON字符串封装到对象前端传入一个json字符串，自动转换成pojo对象，演示代码： 1234@RequestMapping(value = &quot;/requestBody&quot;, method = RequestMethod.POST) public String requestBody(@RequestBody User user) &#123; return user.toString(); &#125; 注意的是，要使用POST请求，发送端的Content-Type设置为application/json，数据是json字符串： 甚至有一些人喜欢用一个Map接收： 但是千万不要用Map接收，否则会造成代码很难维护，后面的老哥估计看不懂你这个Map里面有什么数据，所以最好还是定义一个POJO对象。 四、参数类型转换实际上，SpringMVC框架本身就内置了很多类型转换器，比如你传入字符串的数字，接收的入参定为int，long类型，都会自动帮你转换。 就在包org.springframework.core.convert.converter下，如图所示： 有的时候如果内置的类型转换器不足够满足业务需求呢，怎么扩展呢，很简单，看我操作。什么是Java技术爱好者(战术后仰)。 首先有样学样，内置的转换器实现Converter接口，我也实现： 1234567891011121314public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try &#123; //String转换成Date类型 return sdf.parse(source); &#125; catch (Exception e) &#123; //类型转换错误 e.printStackTrace(); &#125; return null; &#125;&#125; 接着把转换器注册到Spring容器中： 12345678@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport &#123; @Override protected void addFormatters(FormatterRegistry registry) &#123; //添加类型转换器 registry.addConverter(new StringToDateConverter()); &#125;&#125; 接着看测试，所有的日期字符串，都自动被转换成Date类型了，非常方便： 五、页面跳转在前后端未分离之前，页面跳转的工作都是由后端控制，采用JSP进行展示数据。虽然现在互联网项目几乎不会再使用JSP，但是我觉得还是需要学习一下，因为有些旧项目还是会用JSP，或者需要重构。 如果你在RequestMapping方法中直接返回一个字符串是不会跳转到指定的JSP页面的，需要做一些配置。 第一步，加入解析jsp的Maven配置。 123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;7.0.59&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 第二步，添加视图解析器。 1234567891011@Configurationpublic class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Bean public InternalResourceViewResolver viewResolver() &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix(&quot;/&quot;); viewResolver.setSuffix(&quot;.jsp&quot;); viewResolver.setViewClass(JstlView.class); return viewResolver; &#125;&#125; 第三步，设置IDEA的配置。 第四步，创建jsp页面。 第五步，创建Controller控制器。 12345678@Controller@RequestMapping(&quot;/view&quot;)public class ViewController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() throws Exception &#123; return &quot;hello&quot;; &#125;&#125; 这样就完成了，启动项目，访问/view/hello就看到了： 就是这么简单，对吧 六、@ResponseBody如果采用前后端分离，页面跳转不需要后端控制了，后端只需要返回json即可，怎么返回呢？ 使用@ResponseBody注解即可，这个注解会把对象自动转成json数据返回。 @ResponseBody注解可以放在类或者方法上，源码如下： 123456//用在类、方法上@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ResponseBody &#123;&#125; 演示一下： 123456789@RequestMapping(&quot;/userList&quot;)@ResponseBodypublic List&lt;User&gt; userList() throws Exception &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(&quot;1&quot;,&quot;姚大秋&quot;,18)); list.add(new User(&quot;2&quot;,&quot;李星星&quot;,18)); list.add(new User(&quot;3&quot;,&quot;冬敏&quot;,18)); return list;&#125; 测试一下/view/userList： 七、@ModelAttribute@ModelAttribute用法比较多，下面一一讲解。 7.1 用在无返回值的方法上在Controller类中，在执行所有的RequestMapping方法前都会先执行@ModelAttribute注解的方法。 12345678910111213141516@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController &#123; //先执行这个方法 @ModelAttribute public void modelAttribute(Model model)&#123; //在request域中放入数据 model.addAttribute(&quot;userName&quot;,&quot;公众号：java技术爱好者&quot;); &#125; @RequestMapping(&quot;/index&quot;) public String index()&#123; //跳转到inex.jsp页面 return &quot;index&quot;; &#125;&#125; index.jsp页面如下： 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 获取到userName属性值 --&gt;&lt;h1&gt;$&#123;userName&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 相当于一个Controller的拦截器一样，在执行RequestMapping方法前先执行@ModelAttribute注解的方法。所以要慎用。 启动项目，访问/modelAttribute/index可以看到： 即使在index()方法中没有放入userName属性值，jsp页面也能获取到，因为在执行index()方法之前的modelAttribute()方法已经放入了。 7.2 放在有返回值的方法上其实调用顺序是一样，也是在RequestMapping方法前执行，不同的在于，方法的返回值直接帮你放入到Request域中。 1234567891011//放在有参数的方法上@ModelAttributepublic User userAttribute() &#123; //相当于model.addAttribute(&quot;user&quot;,new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18)); return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);&#125;@RequestMapping(&quot;/user&quot;)public String user() &#123; return &quot;user&quot;;&#125; 创建一个user.jsp: 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ID:$&#123;user.id&#125;&lt;/h1&gt;&lt;h1&gt;名称:$&#123;user.name&#125;&lt;/h1&gt;&lt;h1&gt;年龄:$&#123;user.age&#125;岁&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试一下： 放入Request域中的属性值默认是类名的首字母小写驼峰写法，如果你想自定义呢？很简单，可以这样写： 1234567891011//自定义属性名为&quot;u&quot;@ModelAttribute(&quot;u&quot;)public User userAttribute() &#123; return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);&#125;/**JSP就要改成这样写：&lt;h1&gt;ID:$&#123;u.id&#125;&lt;/h1&gt;&lt;h1&gt;名称:$&#123;u.name&#125;&lt;/h1&gt;&lt;h1&gt;年龄:$&#123;u.age&#125;岁&lt;/h1&gt;*/ 7.3 放在RequestMapping方法上12345678910@Controller@RequestMapping(&quot;/modelAttribute&quot;)public class ModelAttributeController &#123; @RequestMapping(&quot;/jojo&quot;) @ModelAttribute(&quot;attributeName&quot;) public String jojo() &#123; return &quot;JOJO！我不做人了！&quot;; &#125;&#125; 这种情况下RequestMapping方法的返回的值就不是JSP视图了。而是把返回值放入Request域中的属性值，属性名为attributeName。视图则是RequestMapping注解上的URL，所以创建一个对应的JSP页面： 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;$&#123;attributeName&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试一下： 7.4 放在方法入参上放在入参上，意思是从前面的Model中提取出对应的属性值，当做入参传入方法中使用。如下所示： 1234567891011@ModelAttribute(&quot;u&quot;)public User userAttribute() &#123; return new User(&quot;1&quot;, &quot;Java技术爱好者&quot;, 18);&#125;@RequestMapping(&quot;/java&quot;)public String user1(@ModelAttribute(&quot;u&quot;) User user) &#123; //拿到@ModelAttribute(&quot;u&quot;)方法返回的值，打印出来 System.out.println(&quot;user:&quot; + user); return &quot;java&quot;;&#125; 测试一下： 八、拦截器拦截器算重点内容了，很多时候都要用拦截器，比如登录校验，权限校验等等。SpringMVC怎么添加拦截器呢？ 很简单，实现HandlerInterceptor接口，接口有三个方法需要重写。 preHandle()：在业务处理器处理请求之前被调用。预处理。 postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。 afterCompletion()：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）； 自定义的拦截器，实现的接口HandlerInterceptor： 123456789101112131415161718192021public class DemoInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //预处理，返回true则继续执行。如果需要登录校验，校验不通过返回false即可，通过则返回true。 System.out.println(&quot;执行preHandle()方法&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; //后处理 System.out.println(&quot;执行postHandle()方法&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //在DispatcherServlet完全处理完请求后被调用 System.out.println(&quot;执行afterCompletion()方法&quot;); &#125;&#125; 然后把拦截器添加到Spring容器中： 12345678@Configurationpublic class ConverterConfig extends WebMvcConfigurationSupport &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new DemoInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; /**代表所有路径，测试一下： 九、全局异常处理SpringMVC本身就对一些异常进行了全局处理，所以有内置的异常处理器，在哪里呢？ 看HandlerExceptionResolver接口的类图就知道了： 从类图可以看出有四种异常处理器： DefaultHandlerExceptionResolver，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。 SimpleMappingExceptionResolver，简单映射异常处理器。通过配置异常类和view的关系来解析异常。 ResponseStatusExceptionResolver，状态码异常处理器。解析带有@ResponseStatus注释类型的异常。 ExceptionHandlerExceptionResolver，注解形式的异常处理器。对@ExceptionHandler注解的方法进行异常解析。 第一个默认的异常处理器是内置的异常处理器，对一些常见的异常处理，一般来说不用管它。后面的三个才是需要注意的，是用来扩展的。 9.1 SimpleMappingExceptionResolver翻译过来就是简单映射异常处理器。用途是，我们可以指定某种异常，当抛出这种异常之后跳转到指定的页面。请看演示。 第一步，添加spring-config.xml文件，放在resources目录下，文件名见文知意即可： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 定义默认的异常处理页面 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt; &lt;!-- 定义异常处理页面用来获取异常信息的属性名，默认名为exception --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- 异常，err表示err.jsp页面 --&gt; &lt;prop key=&quot;java.lang.Exception&quot;&gt;err&lt;/prop&gt; &lt;!-- 可配置多个prop --&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 第二步，在启动类加载xml文件： 123456789@SpringBootApplication@ImportResource(&quot;classpath:spring-config.xml&quot;)public class SpringmvcApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringmvcApplication.class, args); &#125;&#125; 第三步，在webapp目录下创建一个err.jsp页面： 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;异常页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;出现异常，这是一张500页面&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt; 这样就完成了，写一个接口测试一下： 123456789101112@Controller@RequestMapping(&quot;/exception&quot;)public class ExceptionController &#123; @RequestMapping(&quot;/index&quot;) public String index(String msg) throws Exception &#123; if (&quot;null&quot;.equals(msg)) &#123; //抛出空指针异常 throw new NullPointerException(); &#125; return &quot;index&quot;; &#125;&#125; 效果如下： 这种异常处理器，在现在前后端分离的项目中几乎已经看不到了。 9.2 ResponseStatusExceptionResolver这种异常处理器主要用于处理带有@ResponseStatus注释的异常。请看演示代码： 自定义一个异常类，并且使用@ResponseStatus注解修饰： 1234//HttpStatus枚举有所有的状态码，这里返回一个400的响应码@ResponseStatus(value = HttpStatus.BAD_REQUEST)public class DefinedException extends Exception&#123;&#125; 写一个Controller接口进行测试： 1234567@RequestMapping(&quot;/defined&quot;)public String defined(String msg) throws Exception &#123; if (&quot;defined&quot;.equals(msg)) &#123; throw new DefinedException(); &#125; return &quot;index&quot;;&#125; 启动项目，测试一下，效果如下： 9.3 ExceptionHandlerExceptionResolver注解形式的异常处理器，这是用得最多的。使用起来非常简单方便。 第一步，定义自定义异常BaseException： 12345public class BaseException extends Exception &#123; public BaseException(String message) &#123; super(message); &#125;&#125; 第二步，定义一个错误提示实体类ErrorInfo： 12345678public class ErrorInfo &#123; public static final Integer OK = 0; public static final Integer ERROR = -1; private Integer code; private String message; private String url; //getter、setter&#125; 第三步，定义全局异常处理类GlobalExceptionHandler： 123456789101112131415//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler &#123; //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理 @ExceptionHandler(BaseException.class) public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception &#123; ErrorInfo r = new ErrorInfo(); r.setMessage(e.getMessage()); r.setCode(ErrorInfo.ERROR); r.setUrl(req.getRequestURL().toString()); return r; &#125;&#125; 完成之后，写一个测试接口： 1234567@RequestMapping(&quot;/base&quot;)public String base(String msg) throws Exception &#123; if (&quot;base&quot;.equals(msg)) &#123; throw new BaseException(&quot;测试抛出BaseException异常，欧耶！&quot;); &#125; return &quot;index&quot;;&#125; 启动项目，测试： 絮叨SpringMVC的功能实际上肯定还不止我写的这些，不过学会上面这些之后，基本上已经可以应对日常的工作了。 如果要再深入一些，最好是看看SpringMVC源码，我之前写过三篇，责任链模式与SpringMVC拦截器，适配器模式与SpringMVC，全局异常处理源码分析。有兴趣可以关注公众号看看我的历史文章。 微信公众号已开启：【java技术爱好者】，没关注的同学记得关注哦~ 坚持原创，持续输出兼具广度和深度的技术文章。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"SpringCloud微服务架构/SpringCloud微服务系列之注册中心","date":"2021-08-04T03:20:11.144Z","updated":"2021-08-04T03:17:18.512Z","comments":true,"path":"2021/08/04/SpringCloud微服务架构/SpringCloud微服务系列之注册中心/","link":"","permalink":"https://alloceee.github.io/2021/08/04/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、前言伴随着Eurka2.0版本已停止维护，开始要考虑使用微服务新一代的开源的注册中心替代Eureka。 目前据我了解，Consul和Nacos是比较流行的两种替代方案。这篇文章就介绍一下这两种注册中心在微服务中的简单使用，希望对读者有所帮助。 二、注册中心的作用注册中心在微服务的架构中相当于一个“服务的通讯录”。当一个服务启动时，需要向注册中心注册服务，注册中心保存了所有服务的服务名称和服务地址的映射关系。当服务A想调用服务D时，则从注册中心获取服务D的服务地址，然后调用。 我画张图给大家描述会更清楚一点，大概如下： 可能会有人问，为什么不直接通过服务地址调用服务D呢，还要从注册中心去获取服务D的服务地址。因为一个服务背后是不止一台机器的，比如服务D可能在实际生产中是由三台机器支持的，对外只暴露一个服务名称，这样可以避免写死服务的IP地址在代码中(写在配置文件里)，在服务扩展时就非常方便了。 除了服务注册之外，注册中心还提供服务订阅，当有新的服务注册时，注册中心会实时推送到各个服务。 还有服务健康监测，可以在管理界面看到注册中心中的服务的状态。 三、Consul由Go语言开发，支持多数据中心分布式高可用的服务发布和服务注册，采用ralt算法保证服务的一致性，且支持健康检查。 3.1 安装(win10版)第一步，上官网下载安装包。 第二步，解压zip包，并配置环境变量。 第三步，唱跳rap篮球键ctrl+R，cmd，输入命令consul： 这就安装成功了，超简单！输入consul -version验证一下，会显示版本号： 第四步，启动。输入命令consul.exe agent -dev本地启动： 第五步，在浏览器中输入http://localhost:8500打开管理界面。 3.2 服务注册接下来就需要创建两个服务，分别是订单(order)和用户(user)，注册到consul。下面我就演示其中一个user服务。 首先创建一个SpringBoot工程，Maven配置如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;io.github.yehongzhi&lt;/groupId&gt;&lt;artifactId&gt;user&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 健康监测的包 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- spring-cloud-consul服务治理的jar包 --&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后yml配置文件如下： 1234567891011121314151617server: port: 8601spring: application: name: user cloud: consul: port: 8500 host: 127.0.0.1 discovery: service-name: user instance-id: $&#123;spring.application.name&#125;:$&#123;spring.cloud.consul.host&#125;:$&#123;server.port&#125; health-check-path: /actuator/health health-check-interval: 10s prefer-ip-address: true heartbeat: enabled: true 在启动类加上开启服务注册的注解： 12345678@SpringBootApplication@EnableDiscoveryClientpublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class, args); &#125;&#125; 最后启动项目即可，我这里启动两个user，端口号分别是8601，8602： 3.3 服务调用再创建一个订单项目(order)，和user配置类似，注册服务到consul中。 下面演示一下用order服务调用user服务，首先定义user的接口： 12345678910111213@RestController@RequestMapping(&quot;/mall/user&quot;)public class UserController &#123; @RequestMapping(&quot;/list&quot;) public Map&lt;String, Object&gt; list() throws Exception &#123; Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;(); userMap.put(&quot;1号佳丽&quot;, &quot;李嘉欣&quot;); userMap.put(&quot;2号佳丽&quot;, &quot;袁咏仪&quot;); userMap.put(&quot;3号佳丽&quot;, &quot;张敏&quot;); userMap.put(&quot;4号佳丽&quot;, &quot;张曼玉&quot;); return userMap; &#125;&#125; 接着在order服务调用user服务，使用RestTemplate的方式： 12345678910111213141516@RestController@RequestMapping(&quot;/mall/order&quot;)public class OrderController &#123; @Resource private LoadBalancerClient loadBalancerClient; @RequestMapping(&quot;/callUser&quot;) public String list() throws Exception &#123; //从注册中心中获取user服务实例，包括服务的IP，端口号等信息 ServiceInstance instance = loadBalancerClient.choose(&quot;user&quot;); //调用user服务 String userList = new RestTemplate().getForObject(instance.getUri().toString() + &quot;/mall/user/list&quot;, String.class); return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + userList; &#125;&#125; 启动两个user服务，一个order服务，调用order的接口，可以看到结果： 负载均衡默认是轮询访问，所以交替调用8601和8602的user服务。 consul的简单入门就讲到这里了，除了服务治理之外，consul还可以用于做配置中心，读者有兴趣可以自己探索一下。我这里用的是dev模式，相当于单机模式，仅用于学习，实际生产的话肯定是集群模式，后面如果有时间我再专门写一篇演示一下consul集群的搭建。 下面讲另一款注册中心，阿里出品的Nacos。 四、Nacos以下介绍来源于官网： Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 总结就是，Nacos提供三种功能：服务发现及管理、动态配置服务、动态DNS服务。 我这里主要讲服务发现，也就是作为注册中心的功能。 4.1 安装首先下载安装包，目前稳定版是1.3.1，推荐在Linux或者Mac系统上使用，我懒得开虚拟机，所以我就直接在win系统安装。 我这里仅用于学习，使用单机模式，官网上介绍，双击startup.cmd文件启动即可。 实际上，会报错。 这个错误，我发现github上有人提出来，再后面加个参数就可以了。 但是又有人说后面的版本已经优化了，没有这个错误。反正如果遇到的话，就加个参数启动吧。完整命令是startup.cmd -m standalone。 如果不想在启动命令后面加参数，可以配置mysql(版本要求：5.6.5+)，初始化mysql数据库，数据库初始化文件：nacos-mysql.sql。 修改conf/application.properties文件配置： 1234db.num=1db.url.0=jdbc:mysql://数据库地址:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCdb.user=账号db.password=密码 启动成功，命令行窗口可以看到以下提示： 启动成功后，可以在浏览器打开http://localhost:8848/nacos/，进入管理界面。账号密码默认都是nacos。 4.2 服务注册接下来还是一样，创建两个服务注册到nacos，为了跟前面的区分，项目名后缀加上”nacos”。首先添加maven配置，如下： 12345678910111213141516171819202122232425262728293031323334&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt;&lt;!-- SpringWeb依赖 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动类加上注解@EnableDiscoveryClient。 1234567@SpringBootApplication@EnableDiscoveryClientpublic class UsernacosApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UsernacosApplication.class, args); &#125;&#125; 配置文件application.properties文件加上配置。 123server.port=8070spring.application.name=usernacosspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 创建一个UserController接口，提供给其他微服务调用。 1234567891011121314@RestController@RequestMapping(&quot;/mall/userNacos&quot;)public class UserController &#123; @RequestMapping(&quot;/list&quot;) public Map&lt;String, Object&gt; list() &#123; Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;(); userMap.put(&quot;周杰伦&quot;, &quot;爱在西元前&quot;); userMap.put(&quot;张学友&quot;, &quot;只想一生跟你走&quot;); userMap.put(&quot;刘德华&quot;, &quot;忘情水&quot;); userMap.put(&quot;陈奕迅&quot;, &quot;K歌之王&quot;); userMap.put(&quot;卫兰&quot;, &quot;就算世界没有童话&quot;); return userMap; &#125;&#125; 运行启动类的main方法，可以看到注册中心多了一个usernacos服务。 4.3 服务调用相同的配置和方法，再创建一个ordernacos服务，作为消费者。 12345678910111213141516@RestController@RequestMapping(&quot;/mall/orderNacos&quot;)public class OrderController &#123; @Resource private LoadBalancerClient loadBalancerClient; @RequestMapping(&quot;/callUser&quot;) public String callUser() &#123; ServiceInstance instance = loadBalancerClient.choose(&quot;usernacos&quot;); String url = instance.getUri().toString() + &quot;/mall/userNacos/list&quot;; RestTemplate restTemplate = new RestTemplate(); //调用usernacos服务 String result = restTemplate.getForObject(url, String.class); return &quot;调用&quot; + instance.getServiceId() + &quot;服务，端口号：&quot; + instance.getPort() + &quot;,返回结果：&quot; + result; &#125;&#125; 启动2个usernacos服务，1个ordernacos服务。 测试接口http://localhost:8170/mall/orderNacos/callUser，order能顺利调用user，默认负载均衡策略也是轮询机制。 五、总结国内用的比较多的是Nacos，我觉得原因有几点： 因为阿里目前用的就是Nacos，经历过双十一，各种秒杀活动等高并发场景的验证。 文档比较齐全，关键有中文文档，对于国内很多英文水平不是很好的开发者看起来真的很爽。 很多从阿里出来的程序员，把阿里的技术带到了各个中小型互联网公司，一般技术选型肯定选自己熟悉的嘛。 管理界面有中(英)文版本，易于操作。 还有社区比较活跃，很多问题可以在网上找到解决方案。 这篇文章主要介绍了SpringCloud微服务关于注册中心的两种流行的实现方案，接下来还会继续介绍其他关于微服务的组件，敬请期待。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"SpringCloud微服务架构/SpringCloud微服务系列之OpenFeign","date":"2021-08-04T03:20:11.138Z","updated":"2021-08-04T03:17:18.509Z","comments":true,"path":"2021/08/04/SpringCloud微服务架构/SpringCloud微服务系列之OpenFeign/","link":"","permalink":"https://alloceee.github.io/2021/08/04/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97%E4%B9%8BOpenFeign/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言目前在SpringCloud技术栈中，调用服务用得最多的就是OpenFeign，所以这篇文章讲一下OpenFeign，希望对大家有所帮助。 一、构建工程使用Nacos作为注册中心，不会搭建Nacos的话，可以参考上一篇注册中心的文章。 首先父工程parent引入依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- SpringCloud nacos服务发现的依赖 --&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 搭建提供者provider工程和消费者consumer工程。 provider工程继承父工程的pom文件，编写启动类如下： 1234567@SpringBootApplication@EnableDiscoveryClient//注册中心public class ProviderApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; provider工程的配置文件如下： 12345678910server: port: 8080spring: application: name: provider cloud: nacos: discovery: server-addr: 127.0.0.1:8848 service: $&#123;spring.application.name&#125; 提供接口，Controller如下： 1234567891011@RestControllerpublic class ProviderController &#123; @RequestMapping(&quot;/provider/list&quot;) public List&lt;String&gt; list() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java技术爱好者&quot;); list.add(&quot;SpringCloud&quot;); list.add(&quot;没有人比我更懂了&quot;); return list; &#125;&#125; 消费者consumer工程也继承parent的pom文件，加上Feign依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;!-- 版本在parent的pom文件中指定了 --&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写启动类，如下： 123456789@SpringBootApplication@EnableDiscoveryClient//开启feign接口扫描，指定扫描的包@EnableFeignClients(basePackages = &#123;&quot;com.yehongzhi.springcloud&quot;&#125;)public class ConsumerApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 环境搭建完成后，接下来讲两种实现使用方式。 二、声明式这种很简单，消费者consumer工程增加一个ProviderClient接口。 12345678@FeignClient(name = &quot;provider&quot;)//会扫描指定包下，标记FeignClient注解的接口//会根据服务名，从注册中心找到对应的IP地址public interface ProviderClient &#123; //这里跟提供者接口的URL一致 @RequestMapping(&quot;/provider/list&quot;) String list();&#125; 然后再用消费者工程的ConsumerController接口来测试。 123456789101112@RestControllerpublic class ConsumerController &#123; //引入Feign客户端 @Resource private ProviderClient providerClient; @RequestMapping(&quot;/consumer/callProvider&quot;) public String callProvider() &#123; //使用Feign客户端调用其他服务的接口 return providerClient.list(); &#125;&#125; 最后我们启动提供者工程，消费者工程，注册中心，测试。 然后调用消费者的ConsumerController接口。 三、继承式细心的同学可能发现，其实声明式会写多一次提供者接口的定义，也就是有重复的代码，既然有重复的定义，那我们就可以抽取出来，所以就有了继承式。 第一步，创建一个普通的Maven项目api工程，把接口定义在api中。 第二步，服务提供者工程的ProviderController实现Provider接口。 1234567891011@RestControllerpublic class ProviderController implements ProviderApi &#123; public String list() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java技术爱好者&quot;); list.add(&quot;SpringCloud&quot;); list.add(&quot;没有人比我更懂了&quot;); return list.toString(); &#125;&#125; 第三步，消费者工程的ProviderClient无需定义，只需要继承ProviderApi，然后加上@FeignClient即可。 123@FeignClient(name = &quot;provider&quot;)public interface ProviderClient extends ProviderApi &#123;&#125; 其他不用变了，最后启动服务提供者，消费者，注册中心测试一下。 测试成功！上面继承式的好处就在于，只需要在api工程定义一次接口，服务提供者去实现具体的逻辑，消费者则继承接口贴个注解即可，非常方便快捷。 缺点就在于如果有人动了api的接口，则会导致很多服务消费者、提供者出现报错，耦合性比较强。api工程相当于一个公共的工程，消费者和服务者都会依赖此工程，所以一般要求不能随便删api上面的接口。 四、Feign的相关配置下面讲一下Feign的一些常用的相关配置。 4.1 请求超时设置Feign底层其实还是使用Ribbon，默认是1秒。所以超过1秒就报错。 接下来试验一下。我在服务提供者的接口加上一段休眠1.5秒的代码，然后用消费者去消费。 12345678910111213141516@RestControllerpublic class ProviderController implements ProviderApi &#123; public String list() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;java技术爱好者&quot;); list.add(&quot;SpringCloud&quot;); list.add(&quot;没有人比我更懂了&quot;); try &#123; //休眠1.5秒 Thread.sleep(1500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list.toString(); &#125;&#125; 消费者调用后，由于超过1秒，可以看到控制台报错。 如果想调整超时时间，可以在消费者这边，加上配置： 123ribbon: ReadTimeout: 5000 #请求时间5秒 ConnectTimeout: 5000 #连接时间5秒 为了显示出效果，我们在消费者的代码里加上耗时计算： 1234567891011121314@RestControllerpublic class ConsumerController &#123; @Resource private ProviderClient providerClient; @RequestMapping(&quot;/consumer/callProvider&quot;) public String callProvider() throws Exception &#123; long star = System.currentTimeMillis(); String list = providerClient.list(); long end = System.currentTimeMillis(); return &quot;响应结果：&quot; + list + &quot;,耗时：&quot; + (end - star) / 1000 + &quot;秒&quot;; &#125;&#125; 最后启动测试，可以看到，超过1秒也能请求成功。 4.2 日志打印功能首先需要配置Feign的打印日志的级别。 12345678910111213@Configurationpublic class FeignConfig &#123; /** * NONE：默认的，不显示任何日志 * BASIC：仅记录请求方法、URL、响应状态码及执行时间 * HEADERS：出了BASIC中定义的信息之外，还有请求和响应的头信息 * FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元素 */ @Bean public Logger.Level feginLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125; 第二步，需要设置打印的Feign接口。Feign为每个客户端创建一个logger。默认情况下，logger的名称是Feigh接口的完整类名。需要注意的是，Feign的日志打印只会对DEBUG级别做出响应。 1234#与server同级logging: level: com.yehongzhi.springcloud.consumer.feign.ProviderClient: debug 设置完成后，控制台可以看到详细的请求信息。 4.3 Feign实现熔断openFeign实际上是已经引入了hystrix的相关jar包，所以可以直接使用，设置超时时间，超时后调用FallBack方法，实现熔断机制。 首先在消费者工程添加Maven依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 第二步，在配置中开启熔断机制，添加超时时间。 1234567891011#默认是不支持的，所以这里要开启，设置为truefeign: hystrix: enabled: truehystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 3000 第三步，编写FallBack类。 12345678//ProviderClient是贴了@FeignClient注解的接口@Componentpublic class ProviderClientFallBack implements ProviderClient &#123; @Override public String list() &#123; return Arrays.asList(&quot;调用fallBack接口&quot;, &quot;返回未知结果&quot;).toString(); &#125;&#125; 第四步，在对应的Feign接口添加fallback属性。 12345//fallback属性，填写刚刚编写的FallBack回调类@Component@FeignClient(name = &quot;provider&quot;, fallback = ProviderClientFallBack.class)public interface ProviderClient extends ProviderApi &#123;&#125; 最后可以测试一下，超过设置的3秒，则会熔断，调用FallBack方法返回。 4.4 设置负载均衡前面说过OpenFeign底层是使用Ribbon，Ribbon是负责做负载均衡的组件。所以是可以通过配置设置负载均衡的策略。 默认的是轮询策略。如果要换成其他策略，比如随机，怎么换呢。 很简单，改一下配置即可： 123456789#服务名称provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重#NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #配置规则 最空闲连接策略 总结OpenFeign把RestTemplete，Ribbon，Hystrix糅合在了一起，在使用时就可以更加方便，优雅地完成整个服务的暴露，调用等。避免做一些重复的复制粘贴接口URL，或者重复定义接口等。还是非常值得去学习的。 以前我在的公司搭建的SpringCloud微服务就没有使用Feign，架构师自己写了一个AOP代理类进行服务调用，超时时间5秒写死在代码里，当时有个微服务接口要上传文件，总是超时，又改不了超时时间，一超时就调熔断方法返回服务请求超时，导致非常痛苦。 如果当时使用Feign，插拔式，可配置的方式，也许就没那么麻烦了。 那么feign就讲到这里了，上面所有例子的代码都上传Github了： https://github.com/yehongzhi/example 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/超详细canal入门","date":"2021-08-04T03:20:11.120Z","updated":"2021-08-04T03:17:18.502Z","comments":true,"path":"2021/08/04/MySQL数据库/超详细canal入门/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B6%85%E8%AF%A6%E7%BB%86canal%E5%85%A5%E9%97%A8/","excerpt":"","text":"思维导图 本文章已收录到个人博客网站(我爱B站)：me.lovebilibili.com 前言我们都知道一个系统最重要的是数据，数据是保存在数据库里。但是很多时候不单止要保存在数据库中，还要同步保存到Elastic Search、HBase、Redis等等。 这时我注意到阿里开源的框架Canal，他可以很方便地同步数据库的增量数据到其他的存储应用。所以在这里总结一下，分享给各位读者参考~ 一、什么是canal我们先看官网的介绍 canal，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。 这句介绍有几个关键字：增量日志，增量数据订阅和消费。 这里我们可以简单地把canal理解为一个用来同步增量数据的一个工具。 接下来我们看一张官网提供的示意图： canal的工作原理就是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。 二、canal能做什么以下参考canal官网。 与其问canal能做什么，不如说数据同步有什么作用。 但是canal的数据同步不是全量的，而是增量。基于binary log增量订阅和消费，canal可以做： 数据库镜像 数据库实时备份 索引构建和实时维护 业务cache(缓存)刷新 带业务逻辑的增量数据处理 三、如何搭建canal3.1 首先有一个MySQL服务器当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x 我的Linux服务器安装的MySQL服务器是5.7版本。 MySQL的安装这里就不演示了，比较简单，网上也有很多教程。 然后在MySQL中需要创建一个用户，并授权： 12345-- 使用命令登录：mysql -u root -p-- 创建用户 用户名：canal 密码：Canal@123456create user &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;Canal@123456&#x27;;-- 授权 *.*表示所有库grant SELECT, REPLICATION SLAVE, REPLICATION CLIENT on *.* to &#x27;canal&#x27;@&#x27;%&#x27; identified by &#x27;Canal@123456&#x27;; 下一步在MySQL配置文件my.cnf设置如下信息： 1234567[mysqld]# 打开binloglog-bin=mysql-bin# 选择ROW(行)模式binlog-format=ROW# 配置MySQL replaction需要定义，不要和canal的slaveId重复server_id=1 改了配置文件之后，重启MySQL，使用命令查看是否打开binlog模式： 查看binlog日志文件列表： 查看当前正在写入的binlog文件： MySQL服务器这边就搞定了，很简单。 3.2 安装canal去官网下载页面进行下载：https://github.com/alibaba/canal/releases 我这里下载的是1.1.4的版本： 解压canal.deployer-1.1.4.tar.gz，我们可以看到里面有四个文件夹： 接着打开配置文件conf/example/instance.properties，配置信息如下： 123456789101112131415161718192021222324252627## mysql serverId , v1.0.26+ will autoGen## v1.0.26版本后会自动生成slaveId，所以可以不用配置# canal.instance.mysql.slaveId=0# 数据库地址canal.instance.master.address=127.0.0.1:3306# binlog日志名称canal.instance.master.journal.name=mysql-bin.000001# mysql主库链接时起始的binlog偏移量canal.instance.master.position=154# mysql主库链接时起始的binlog的时间戳canal.instance.master.timestamp=canal.instance.master.gtid=# username/password# 在MySQL服务器授权的账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@123456# 字符集canal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false# table regex .*\\\\..*表示监听所有表 也可以写具体的表名，用，隔开canal.instance.filter.regex=.*\\\\..*# mysql 数据解析表的黑名单，多个表用，隔开canal.instance.filter.black.regex= 我这里用的是win10系统，所以在bin目录下找到startup.bat启动： 启动就报错，坑呀： 要修改一下启动的脚本startup.bat： 然后再启动脚本： 这就启动成功了。 Java客户端操作首先引入maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;1.1.4&lt;/version&gt;&lt;/dependency&gt; 然后创建一个canal项目，使用SpringBoot构建，如图所示： 在CannalClient类使用Spring Bean的生命周期函数afterPropertiesSet()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Componentpublic class CannalClient implements InitializingBean &#123; private final static int BATCH_SIZE = 1000; @Override public void afterPropertiesSet() throws Exception &#123; // 创建链接 CanalConnector connector = CanalConnectors.newSingleConnector(new InetSocketAddress(&quot;127.0.0.1&quot;, 11111), &quot;example&quot;, &quot;&quot;, &quot;&quot;); try &#123; //打开连接 connector.connect(); //订阅数据库表,全部表 connector.subscribe(&quot;.*\\\\..*&quot;); //回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿 connector.rollback(); while (true) &#123; // 获取指定数量的数据 Message message = connector.getWithoutAck(BATCH_SIZE); //获取批量ID long batchId = message.getId(); //获取批量的数量 int size = message.getEntries().size(); //如果没有数据 if (batchId == -1 || size == 0) &#123; try &#123; //线程休眠2秒 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; //如果有数据,处理数据 printEntry(message.getEntries()); &#125; //进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。 connector.ack(batchId); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; connector.disconnect(); &#125; &#125; /** * 打印canal server解析binlog获得的实体类信息 */ private static void printEntry(List&lt;Entry&gt; entrys) &#123; for (Entry entry : entrys) &#123; if (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123; //开启/关闭事务的实体类型，跳过 continue; &#125; //RowChange对象，包含了一行数据变化的所有特征 //比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等 RowChange rowChage; try &#123; rowChage = RowChange.parseFrom(entry.getStoreValue()); &#125; catch (Exception e) &#123; throw new RuntimeException(&quot;ERROR ## parser of eromanga-event has an error , data:&quot; + entry.toString(), e); &#125; //获取操作类型：insert/update/delete类型 EventType eventType = rowChage.getEventType(); //打印Header信息 System.out.println(String.format(&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;, entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(), entry.getHeader().getSchemaName(), entry.getHeader().getTableName(), eventType)); //判断是否是DDL语句 if (rowChage.getIsDdl()) &#123; System.out.println(&quot;================》;isDdl: true,sql:&quot; + rowChage.getSql()); &#125; //获取RowChange对象里的每一行数据，打印出来 for (RowData rowData : rowChage.getRowDatasList()) &#123; //如果是删除语句 if (eventType == EventType.DELETE) &#123; printColumn(rowData.getBeforeColumnsList()); //如果是新增语句 &#125; else if (eventType == EventType.INSERT) &#123; printColumn(rowData.getAfterColumnsList()); //如果是更新的语句 &#125; else &#123; //变更前的数据 System.out.println(&quot;-------&gt;; before&quot;); printColumn(rowData.getBeforeColumnsList()); //变更后的数据 System.out.println(&quot;-------&gt;; after&quot;); printColumn(rowData.getAfterColumnsList()); &#125; &#125; &#125; &#125; private static void printColumn(List&lt;Column&gt; columns) &#123; for (Column column : columns) &#123; System.out.println(column.getName() + &quot; : &quot; + column.getValue() + &quot; update=&quot; + column.getUpdated()); &#125; &#125;&#125; 以上就完成了Java客户端的代码。这里不做具体的处理，仅仅是打印，先有个直观的感受。 最后我们开始测试，首先启动MySQL、Canal Server，还有刚刚写的Spring Boot项目。然后创建表： 12345678CREATE TABLE `tb_commodity_info` ( `id` varchar(32) NOT NULL, `commodity_name` varchar(512) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `commodity_price` varchar(36) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品价格&#x27;, `number` int(10) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品数量&#x27;, `description` varchar(2048) DEFAULT &#x27;&#x27; COMMENT &#x27;商品描述&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;商品信息表&#x27;; 然后我们在控制台就可以看到如下信息： 如果新增一条数据到表中： 1INSERT INTO tb_commodity_info VALUES(&#x27;3e71a81fd80711eaaed600163e046cc3&#x27;,&#x27;叉烧包&#x27;,&#x27;3.99&#x27;,3,&#x27;又大又香的叉烧包，老人小孩都喜欢&#x27;); 控制台可以看到如下信息： 总结canal的好处在于对业务代码没有侵入，因为是基于监听binlog日志去进行同步数据的。实时性也能做到准实时，其实是很多企业一种比较常见的数据同步的方案。 通过上面的学习之后，我们应该都明白canal是什么，它的原理，还有用法。实际上这仅仅只是入门，因为实际项目中我们不是这样玩的… 实际项目我们是配置MQ模式，配合RocketMQ或者Kafka，canal会把数据发送到MQ的topic中，然后通过消息队列的消费者进行处理。 Canal的部署也是支持集群的，需要配合ZooKeeper进行集群管理。 Canal还有一个简单的Web管理界面。 下一篇就讲一下集群部署Canal，配合使用Kafka，同步数据到Redis。 参考资料：Canal官网 絮叨上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 如果你觉得这篇文章对你有用，点个赞吧~ 你的点赞是我创作的最大动力~ 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/要精通SQL优化？那就学一学explain吧","date":"2021-08-04T03:20:11.108Z","updated":"2021-08-04T03:17:18.499Z","comments":true,"path":"2021/08/04/MySQL数据库/要精通SQL优化？那就学一学explain吧/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%A6%81%E7%B2%BE%E9%80%9ASQL%E4%BC%98%E5%8C%96%EF%BC%9F%E9%82%A3%E5%B0%B1%E5%AD%A6%E4%B8%80%E5%AD%A6explain%E5%90%A7/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi 前言在MySQL中，我们知道加索引能提高查询效率，这基本上算是常识了。但是有时候，我们加了索引还是觉得SQL查询效率低下，我想看看有没有使用到索引，扫描了多少行，表的加载顺序等等，怎么查看呢？其实MySQL自带的SQL分析神器Explain执行计划就能完成以上的事情！ Explain有哪些信息先确认一下试验的MySQL版本，这里使用的是5.7.31版本。 只需要在SQL语句前加上explain关键字就可以查看执行计划，执行计划包括以下信息：id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra，总共12个字段信息。 然后创建三个表： 123456789101112131415161718CREATE TABLE `tb_student` ( `id` int(10) NOT NULL AUTO_INCREMENT, `name` varchar(36) NOT NULL, PRIMARY KEY (`id`), KEY `index_name` (`name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;学生表&#x27;;CREATE TABLE `tb_class` ( `id` INT(10) primary key not null auto_increment, `name` VARCHAR(36) NOT NULL, `stu_id` INT(10) NOT NULL, `tea_id` INT(10) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;班级表&#x27;;CREATE TABLE `tb_teacher` ( `id` INT(10) primary key not null auto_increment, `name` VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;教师表&#x27;; Explain执行计划详解explain的使用很简单，只需要在SQL语句前加上关键字explain即可，关键是怎么看explain执行后返回的字段信息，这才是重点。 一、idSELECT识别符。这是SELECT的查询序列号。SQL执行的顺序的标识，SQL从大到小的执行。id列有以下几个注意点： id相同时，执行顺序由上至下。 id不同时，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。 1EXPLAIN SELECT * FROM `tb_student` WHERE id IN (SELECT stu_id FROM tb_class WHERE tea_id IN(SELECT id FROM tb_teacher WHERE `name` = &#x27;马老师&#x27;)); 根据原则，当id不同时，SQL从大到小执行，id相同则从上到下执行。 二、select_type表示select查询的类型，用于区分各种复杂的查询，例如普通查询，联合查询，子查询等等。 SIMPLE表示最简单的查询操作，也就是查询SQL语句中没有子查询、union等操作。 PRIMARY当查询语句中包含复杂查询的子部分，表示复杂查询中最外层的 select。 SUBQUERY当 select 或 where 中包含有子查询，该子查询被标记为SUBQUERY。 DERIVED在SQL语句中包含在from子句中的子查询。 UNION表示在union中的第二个和随后的select语句。 UNION RESULT代表从union的临时表中读取数据。 1EXPLAIN SELECT u.`name` FROM ((SELECT s.id,s.`name` FROM `tb_student` s) UNION (SELECT t.id,t.`name` FROM tb_teacher t)) AS u; &lt;union2,3&gt;代表是id为2和3的select查询的结果进行union操作。 MATERIALIZEDMATERIALIZED表示物化子查询，子查询来自视图。 三、table表示输出结果集的表的表名，并不一定是真实存在的表，也有可能是别名，临时表等等。 四、partitions表示SQL语句查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表则会显示分区表命中的分区情况。 五、type需要重点关注的一个字段信息，表示查询使用了哪种类型，在 SQL优化中是一个非常重要的指标，依次从优到差分别是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。 system和const单表中最多有一条匹配行，查询效率最高，所以这个匹配行的其他列的值可以被优化器在当前查询中当作常量来处理。通常出现在根据主键或者唯一索引进行的查询，system是const的特例，表里只有一条元组匹配时（系统表）为system。 eq_refprimary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录，所以这种类型常出现在多表的join查询。 ref相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，可能会找到多个符合条件的行。 range使用索引选择行，仅检索给定范围内的行。一般来说是针对一个有索引的字段，给定范围检索数据，通常出现在where语句中使用 bettween...and、&lt;、&gt;、&lt;=、in 等条件查询 。 index扫描全表索引，通常比ALL要快一些。 ALL全表扫描，MySQL遍历全表来找到匹配行，性能最差。 六、possible_keys表示在查询中可能使用到的索引来查找，别列出的索引并不一定是最终查询数据所用到的索引。 七、key跟possible_keys有所区别，key表示查询中实际使用到的索引，若没有使用到索引则显示为NULL。 八、key_len表示查询用到的索引key的长度(字节数)。如果单列索引，那么就会把整个索引长度计算进去，如果是联合索引，不是所有的列都用到，那么就只计算实际用到的列，因此可以根据key_len来判断联合索引是否生效。 九、ref显示了哪些列或常量被用于查找索引列上的值。常见的值有：const，func，null，字段名。 十、rowsmysql估算要找到我们所需的记录，需要读取的行数。可以通过这个数据很直观的显示 SQL 性能的好坏，一般情况下 rows 值越小越好。 十一、filtered指返回结果的行占需要读到的行(rows列的值)的百分比，一般来说越大越好。 十二、Extra表示额外的信息。此字段能够给出让我们深入理解执行计划进一步的细节信息。 Using index说明在select查询中使用了覆盖索引。覆盖索引的好处是一条SQL通过索引就可以返回我们需要的数据。 Using where查询时没使用到索引，然后通过where条件过滤获取到所需的数据。 Using temporary表示在查询时，MySQL需要创建一个临时表来保存结果。临时表一般会比较影响性能，应该尽量避免。 有时候使用DISTINCT去重时也会产生Using temporary。 Using filesort我们知道索引除了查询中能起作用外，排序也是能起到作用的，所以当SQL中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL不得不选择相应的排序算法来实现，这时就会出现Using filesort，应该尽量避免使用Using filesort。 总结一般优化SQL语句第一步是要知道这条SQL语句有哪些需要优化的，explain执行计划就相当于一面镜子，能把详细的执行情况给开发者列出来。所以说善用explain执行计划，能解决80%的SQL优化问题。 explain的信息中，一般我们要关心的是type，看是什么级别，如果是在互联网公司一般需要在range以上的级别，接着关心的是Extra，有没有出现filesort或者using template，一旦出现就要想办法避免，接着再看key使用的是什么索引，还有看filtered筛选比是多少。 这篇文章就讲到这里了，希望大家看完之后能对SQL优化有更深入的理解，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/必须了解的mysql三种log","date":"2021-08-04T03:20:11.101Z","updated":"2021-08-04T03:17:18.498Z","comments":true,"path":"2021/08/04/MySQL数据库/必须了解的mysql三种log/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84mysql%E4%B8%89%E7%A7%8Dlog/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言大家有没有想过为什么MySQL数据库可以实现主从复制，实现持久化，实现回滚的呢？其实关键在于MySQL里的三种log，分别是： binlog redo log undo log 这三种log也是面试经常会问的问题，下面我们一起来探讨一下吧。 一、binlogbinlog应该是日常中听的最多的关于mysql中的log。 那么什么是binlog呢？ binlog是用于记录数据库表结构和表数据变更的二进制日志，比如insert、update、delete、create、truncate等等操作，不会记录select、show操作，因为没有对数据本身发生变更。 binlog文件长什么样子呢？ 使用mysqlbinlog命令可以查看。 会记录下每条变更的sql语句，还有执行开始时间，结束时间，事务id等等信息。 如何查看binlog是否打开，如果没打开怎么设置？ 使用命令show variables like &#39;%log_bin%&#39;;查看binlog是否打开。 如果像上图一样，没有开启binlog，那怎么开启呢？ 找到my.cnf配置文件，增加下面配置(mysql版本5.7.31)： 1234# 打开binloglog-bin=mysql-bin# 选择ROW(行)模式binlog-format=ROW 修改后，重启mysql，配置生效。 执行SHOW MASTER STATUS;可以查看当前写入的binlog文件名。 binlog用来干嘛的呢？ 第一，用于主从复制。一般在公司中做一主二从的结构时，就需要master节点打开binlog日志，从机订阅binlog日志的信息，因为binlog日志记录了数据库数据的变更，所以当master发生数据变更时，从机也能随着master节点的数据变更而变更，做到主从复制的效果。 第二，用于数据恢复。因为binlog记录了数据库的变更，所以可以用于数据恢复。我们看到上面图中有个字段叫Position，这个参数是用于记录binlog日志的指针。当我们需要恢复数据时，只要指定**–start-position和–stop-position，或者指定–start-datetime和–stop-datetime**，那么就可以恢复指定区间的数据。 二、redo log假设有一条update语句： 1UPDATE `user` SET `name`=&#x27;刘德华&#x27; WHERE `id`=&#x27;1&#x27;; 我们想象一下mysql修改数据的步骤，肯定是先把id=’1’的数据查出来，然后修改名称为’刘德华’。再深层一点，mysql是使用页作为存储结构，所以MySQL会先把这条记录所在的页加载到内存中，然后对记录进行修改。但是我们都知道mysql支持持久化，最终数据都是存在于磁盘中。 假设需要修改的数据加载到内存中，并且修改成功了，但是还没来得及刷到磁盘中，这时数据库宕机了，那么这次修改成功后的数据就丢失了。 为了避免出现这种问题，MySQL引入了redo log。 如图所示，当执行数据变更操作时，首先把数据也加载到内存中，然后在内存中进行更新，更新完成后写入到redo log buffer中，然后由redo log buffer在写入到redo log file中。 redo log file记录着xxx页做了xxx修改，所以即使mysql发生宕机，也可以通过redo log进行数据恢复，也就是说在内存中更新成功后，即使没有刷新到磁盘中，但也不会因为宕机而导致数据丢失。 redo log与事务机制是如何配合工作的？ 如图所示： 第1-3步骤就是把数据变更，然后写入到内存中。 第4步记录到redo log中，然后把记录置为prepare(准备)状态。 第5，6步提交事务，提交事务之后，第7步把记录状态改成commit(提交)状态。 保证了事务与redo log的一致性。 binlog和redo log都可以数据恢复，有什么区别？ redo log是恢复在内存更新后，还没来得及刷到磁盘的数据。 binlog是存储所有数据变更的情况，理论上只要记录在binlog上的数据，都可以恢复。 举个例子，假如不小心整个数据库的数据被删除了，能使用redo log文件恢复数据吗？ 不可以使用redo log文件恢复，只能使用binlog文件恢复。因为redo log文件不会存储历史所有的数据的变更，当内存数据刷新到磁盘中，redo log的数据就失效了，也就是redo log文件内容是会被覆盖的。 binlog又是在什么时候记录的呢？ 答，在提交事务的时候。 三、undo logundo log的作用主要用于回滚，mysql数据库的事务的原子性就是通过undo log实现的。我们都知道原子性是指对数据库的一系列操作，要么全部成功，要么全部失败。 undo log主要存储的是数据的逻辑变化日志，比如说我们要insert一条数据，那么undo log就会生成一条对应的delete日志。简单点说，undo log记录的是数据修改之前的数据，因为需要支持回滚。 那么当需要回滚时，只需要利用undo log的日志就可以恢复到修改前的数据。 undo log另一个作用是实现多版本控制(MVCC)，undo记录中包含了记录更改前的镜像，如果更改数据的事务未提交，对于隔离级别大于等于read commit的事务而言，不应该返回更改后数据，而应该返回老版本的数据。 总结学完之后，我们知道这三种日志在mysql中都有着重要的作用，再回顾一下： binlog主要用于复制和数据恢复。 redo log用于恢复在内存更新后，还没来得及刷到磁盘的数据。 undo log用于实现回滚和多版本控制。 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/什么是脏读、不可重复读、幻读","date":"2021-08-04T03:20:11.087Z","updated":"2021-08-04T03:17:18.492Z","comments":true,"path":"2021/08/04/MySQL数据库/什么是脏读、不可重复读、幻读/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 脏读、不可重复读、幻读在现代关系型数据库中，事务机制是非常重要的，假如在多个事务并发操作数据库时，如果没有有效的机制进行避免就会导致出现脏读，不可重复读，幻读。 脏读1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。 2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据。 这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。 不可重复读事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。 这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。 幻读事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。 第一类更新丢失事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。 第二类更新丢失其实跟第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。 事务隔离级别为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交、读已提交、可重复读、串行化。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。所以在设置数据库的事务隔离级别时需要做一下权衡，MySQL默认是可重复读的级别。 读未提交读未提交(Read Uncommitted)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。 读已提交读已提交(Read Committed)， 在该隔离级别下，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果。可以防止脏读和第一类更新丢失，但是不能解决可重复读和幻读的问题。 可重复读可重复读(Repeatable Read)，MySQL默认的隔离级别。在该隔离级别下，一个事务多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失、第二类更新丢失的问题，不过还是会出现幻读。 串行化串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。 总结下面我们对事务的隔离级别和对并发问题的解决情况，请看下图： 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/MySQL主从复制读写分离，能讲一下吗","date":"2021-08-04T03:20:11.081Z","updated":"2021-08-04T03:17:18.489Z","comments":true,"path":"2021/08/04/MySQL数据库/MySQL主从复制读写分离，能讲一下吗/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%8C%E8%83%BD%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%90%97/","excerpt":"","text":"思维导图 微信公众号已开启：【java技术爱好者】，还没关注的记得关注哦~ 文章已收录到我的Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言在很多项目，特别是互联网项目，在使用MySQL时都会采用主从复制、读写分离的架构。 为什么要采用主从复制读写分离的架构？如何实现？有什么缺点？让我们带着这些问题开始这段学习之旅吧！ 为什么使用主从复制、读写分离主从复制、读写分离一般是一起使用的。目的很简单，就是为了提高数据库的并发性能。你想，假设是单机，读写都在一台MySQL上面完成，性能肯定不高。如果有三台MySQL，一台mater只负责写操作，两台salve只负责读操作，性能不就能大大提高了吗？ 所以主从复制、读写分离就是为了数据库能支持更大的并发。 随着业务量的扩展、如果是单机部署的MySQL，会导致I/O频率过高。采用主从复制、读写分离可以提高数据库的可用性。 主从复制的原理①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。 ②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。 ③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。 ④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。 ⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。 如何实现主从复制我这里用三台虚拟机(Linux)演示，IP分别是104(Master)，106(Slave)，107(Slave)。 预期的效果是一主二从，如下图所示： Master配置使用命令行进入mysql： 1mysql -u root -p 接着输入root用户的密码(密码忘记的话就网上查一下重置密码吧~)，然后创建用户： 123456//192.168.0.106是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#x27;root&#x27;@&#x27;192.168.0.106&#x27; identified by &#x27;Java@1234&#x27;;//192.168.0.107是slave从机的IPGRANT REPLICATION SLAVE ON *.* to &#x27;root&#x27;@&#x27;192.168.0.107&#x27; identified by &#x27;Java@1234&#x27;;//刷新系统权限表的配置FLUSH PRIVILEGES; 创建的这两个用户在配置slave从机时要用到。 接下来在找到mysql的配置文件/etc/my.cnf，增加以下配置： 12345678# 开启binloglog-bin=mysql-binserver-id=104# 需要同步的数据库，如果不配置则同步全部数据库binlog-do-db=test_db# binlog日志保留的天数，清除超过10天的日志# 防止日志文件过大，导致磁盘空间不足expire-logs-days=10 配置完成后，重启mysql： 1service mysql restart 可以通过命令行show master status\\G;查看当前binlog日志的信息(后面有用)： Slave配置Slave配置相对简单一点。从机肯定也是一台MySQL服务器，所以和Master一样，找到/etc/my.cnf配置文件，增加以下配置： 12# 不要和其他mysql服务id重复即可server-id=106 接着使用命令行登录到mysql服务器： 1mysql -u root -p 然后输入密码登录进去。 进入到mysql后，再输入以下命令： 1234567CHANGE MASTER TO MASTER_HOST=&#x27;192.168.0.104&#x27;,//主机IPMASTER_USER=&#x27;root&#x27;,//之前创建的用户账号MASTER_PASSWORD=&#x27;Java@1234&#x27;,//之前创建的用户密码MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,//master主机的binlog日志名称MASTER_LOG_POS=862,//binlog日志偏移量master_port=3306;//端口 还没完，设置完之后需要启动： 12# 启动slave服务start slave; 启动完之后怎么校验是否启动成功呢？使用以下命令： 1show slave status\\G; 可以看到如下信息（摘取部分关键信息）： 123456789101112131415161718192021*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.0.104 Master_User: root Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 619 Relay_Log_File: mysqld-relay-bin.000001 Relay_Log_Pos: 782 Relay_Master_Log_File: mysql-bin.000001 //binlog日志文件名称 Slave_IO_Running: Yes //Slave_IO线程、SQL线程都在运行 Slave_SQL_Running: Yes Master_Server_Id: 104 //master主机的服务id Master_UUID: 0ab6b3a6-e21d-11ea-aaa3-080027f8d623 Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it Master_Retry_Count: 86400 Auto_Position: 0 另一台slave从机配置一样，不再赘述。 测试主从复制在master主机执行sql： 12345678CREATE TABLE `tb_commodity_info` ( `id` varchar(32) NOT NULL, `commodity_name` varchar(512) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `commodity_price` varchar(36) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品价格&#x27;, `number` int(10) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品数量&#x27;, `description` varchar(2048) DEFAULT &#x27;&#x27; COMMENT &#x27;商品描述&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;商品信息表&#x27;; 接着我们可以看到两台slave从机同步也创建了商品信息表： 主从复制就完成了！java技术爱好者有点东西哦~ 读写分离主从复制完成后，我们还需要实现读写分离，master负责写入数据，两台slave负责读取数据。怎么实现呢？ 实现的方式有很多，以前我公司是采用AOP的方式，通过方法名判断，方法名中有get、select、query开头的则连接slave，其他的则连接master数据库。 但是通过AOP的方式实现起来代码有点繁琐，有没有什么现成的框架呢，答案是有的。 Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy两部分组成。 ShardingSphere-JDBC定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。 读写分离就可以使用ShardingSphere-JDBC实现。 下面演示一下SpringBoot+Mybatis+Mybatis-plus+druid+ShardingSphere-JDBC代码实现。 项目配置版本说明： 12345SpringBoot：2.0.1.RELEASEdruid：1.1.22mybatis-spring-boot-starter:1.3.2mybatis-plus-boot-starter：3.0.7sharding-jdbc-spring-boot-starter:4.1.1 添加sharding-jdbc的maven配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt;&lt;/dependency&gt; 然后在application.yml添加配置： 1234567891011121314151617181920212223242526272829303132# 这是使用druid连接池的配置，其他的连接池配置可能有所不同spring: shardingsphere: datasource: names: master,slave0,slave1 master: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.0.108:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT username: yehongzhi password: YHZ@1234 slave0: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.0.109:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT username: yehongzhi password: YHZ@1234 slave1: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.0.110:3306/test_db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT username: yehongzhi password: YHZ@1234 props: sql.show: true masterslave: load-balance-algorithm-type: round_robin sharding: master-slave-rules: master: master-data-source-name: master slave-data-source-names: slave0,slave1 sharding.master-slave-rules是标明主库和从库，一定不要写错，否则写入数据到从库，就会导致无法同步。 load-balance-algorithm-type是路由策略，round_robin表示轮询策略。 启动项目，可以看到以下信息，代表配置成功： 编写Controller接口： 1234567891011121314151617/** * 添加商品 * * @param commodityName 商品名称 * @param commodityPrice 商品价格 * @param description 商品价格 * @param number 商品数量 * @return boolean 是否添加成功 * @author java技术爱好者 */ @PostMapping(&quot;/insert&quot;) public boolean insertCommodityInfo(@RequestParam(name = &quot;commodityName&quot;) String commodityName, @RequestParam(name = &quot;commodityPrice&quot;) String commodityPrice, @RequestParam(name = &quot;description&quot;) String description, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception &#123; return commodityInfoService.insertCommodityInfo(commodityName, commodityPrice, description, number); &#125; 准备就绪，开始测试！ 测试打开POSTMAN，添加商品： 控制台可以看到如下信息： 查询数据的话则通过slave进行： 就是这么简单！ 缺点尽管主从复制、读写分离能很大程度保证MySQL服务的高可用和提高整体性能，但是问题也不少： 从机是通过binlog日志从master同步数据的，如果在网络延迟的情况，从机就会出现数据延迟。那么就有可能出现master写入数据后，slave读取数据不一定能马上读出来。 可能有人会问，有没有事务问题呢？ 实际上这个框架已经想到了，我们看回之前的那个截图，有一句话是这样的： 微信公众号已开启：【java技术爱好者】，没关注的同学记得关注哦~ 坚持原创，持续输出兼具广度和深度的技术文章。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/MySQL与MVVC机制","date":"2021-08-04T03:20:11.075Z","updated":"2021-08-04T03:17:18.485Z","comments":true,"path":"2021/08/04/MySQL数据库/MySQL与MVVC机制/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B8%8EMVVC%E6%9C%BA%E5%88%B6/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言无论是上一篇文章讲的事务隔离级别，还是之前讲的undo log日志，其实都涉及到MVCC机制，那么什么是MVCC机制，它的作用是什么，下面就让我们带着问题一起学习吧。 什么是MVCCMVCC全称是多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。MVCC机制的作用其实就是避免同一个数据在不同事务之间的竞争，提高系统的并发性能。 它的特点如下： 允许多个版本同时存在，并发执行。 不依赖锁机制，性能高。 只在读已提交和可重复读的事务隔离级别下工作。 为什么使用MVCC在早期的数据库中，只有读读之间的操作才可以并发执行，读写，写读，写写操作都要阻塞，这样就会导致MySQL的并发性能极差。 采用了MVCC机制后，只有写写之间相互阻塞，其他三种操作都可以并行，这样就可以提高了MySQL的并发性能。 MVCC机制的原理在讲解MVCC机制的原理之前首先要介绍几个概念。 ReadViewReadView可以理解为数据库中某一个时刻所有未提交事务的快照。ReadView有几个重要的参数： m_ids：表示生成ReadView时，当前系统正在活跃的读写事务的事务Id列表。 min_trx_id：表示生成ReadView时，当前系统中活跃的读写事务的最小事务Id。 max_trx_id：表示生成ReadView时，当前时间戳InnoDB将在下一次分配的事务id。 creator_trx_id：当前事务id。 所以当创建ReadView时，可以知道这个时间点上未提交事务的所有信息。 隐藏列InnoDB存储引擎中，它的聚簇索引记录中都包含两个必要的隐藏列，分别是： trx_id：事务Id，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。 roll_pointer：回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo log中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。 事务链每次对记录进行修改时，都会记录一条undo log信息，每一条undo log信息都会有一个roll_pointer属性(INSERT操作没有这个属性，因为之前没有更早的版本)，可以将这些undo日志都连起来，串成一个链表。事务链如下图一样： 原理我们都知道，MySQL事务隔离级别有四种，分别是读未提交(Read Uncommitted，简称RU)、读已提交(Read Committed，简称RC)、可重复读(Repeatable Read，简称RR)、串行化(Serializable)，只有RC和RR才跟MVCC机制相关，RU和Serializable都不会使用到MVCC机制。因为在读未提交(RU)级别下是直接返回记录上的最新值，Serializable级别下则会对所有读取的行都加锁。 RC和RR隔离级别的实现就是通过版本控制来完成，核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的处理，通过什么判断呢？就是上文讲到的ReadView，ReadView包含了当前系统活跃的读写事务的信息，判断的逻辑如下： 如果被访问版本的trx_id属性值小于ReadView的最小事务Id，表示该版本的事务在生成 ReadView 前已经提交，所以该版本可以被当前事务访问。 如果被访问版本的trx_id属性值大于ReadView的最大事务Id，表示该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。 如果被访问版本的trx_id属性值在m_ids列表最小事务Id和最大事务Id之间，那就需要判断一下 trx_id 属性值是不是包含在 m_ids 列表中，如果包含的话，说明创建 ReadView 时生成该版本的事务还是活跃的，所以该版本不可以访问；如果不包含的话，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。 我们下面举例说明RC和RR隔离级别的区别，假如有一条user数据，初始值name=”刘德华”，然后经过下面的更新，时间点如下： RC隔离级别的MVCC： RC隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView。 在T4时间点时，版本链如下所示： 在T4时间点的Select语句执行时，当前时间系统正在活跃的事务有trx_id为100和200都未提交，所以此时生成的ReadView的事务列表是[100,200]，因此查询语句会根据当前版本链中小于事务列表中的最大的版本数据，即查询到的是刘德华。 在T6时间点时，版本链如下所示： 在T6时间点的Select语句执行时，当前时间系统正在活跃的事务有trx_id为200未提交，所以此时生成的ReadView的事务列表时[200]，因此查询语句会根据当前版本链中小于事务列表中的最大的版本数据，即查询到的是古天乐。 在T8时间点时，版本链如下所示： 在T6时间点的Select语句执行时，当前时间系统正在活跃的事务都已经提交，所以此时生成的ReadView的事务列表为空，因此查询语句会直接查询当前数据库最新数据，即查询到的是麦长青。 由于每次查询都会生成新的ReadView，所以有可能出现不可重复读的问题。 RR隔离级别的MVCC： RR隔离级别的事务在第一次读取数据时生成ReadView，之后的查询都不会再生成，所以一个事务的查询结果每次都是一样的。 因为三次查询都是在同一个事务tx_300中。 所以在第一次查询，也就是T4时间点时会生成ReadView，事务列表为[100,200]，所以当前可见版本的查询结果为刘德华。 第二次查询，T6时间点不会生成新的ReadView，所以查询结果依然是刘德华。 第三次查询，T8时间一样，不会生成ReadView，沿用T4时间点生成的ReadView，所以查询结果依然是刘德华。 由于在同一个事务中，RR级别的事务在查询中只会生成一个ReadView，所以能解决不可重复读的问题。 总结要理解MVCC机制，关键在于要理解ReadView、隐藏列、事务链三者在其中的作用。还有就是只有RC和RR的隔离级别才会使用MVCC机制，两者最大的区别在于生成ReadView的时机的不同，RC级别生成ReadView的时机是每次查询都会生成新的ReadView，而RR级别是在当前事务第一次查询时生成，并且生成的ReadView会一直沿用到事务提交为止，保证可重复读。 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"MySQL数据库/Canal+Kafka实现MySQL与Redis数据同步","date":"2021-08-04T03:20:11.069Z","updated":"2021-08-04T03:17:18.484Z","comments":true,"path":"2021/08/04/MySQL数据库/Canal+Kafka实现MySQL与Redis数据同步/","link":"","permalink":"https://alloceee.github.io/2021/08/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/Canal+Kafka%E5%AE%9E%E7%8E%B0MySQL%E4%B8%8ERedis%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/","excerpt":"","text":"思维导图 前言在很多业务情况下，我们都会在系统中加入redis缓存做查询优化。 如果数据库数据发生更新，这时候就需要在业务代码中写一段同步更新redis的代码。 这种数据同步的代码跟业务代码糅合在一起会不太优雅，能不能把这些数据同步的代码抽出来形成一个独立的模块呢，答案是可以的。 架构图canal是一个伪装成slave订阅mysql的binlog，实现数据同步的中间件。上一篇文章《canal入门》 我已经介绍了最简单的使用方法，也就是tcp模式。 实际上canal是支持直接发送到MQ的，目前最新版是支持主流的三种MQ：Kafka、RocketMQ、RabbitMQ。而canal的RabbitMQ模式目前是有一定的bug，所以一般使用Kafka或者RocketMQ。 本文使用Kafka，实现Redis与MySQL的数据同步。架构图如下： 通过架构图，我们很清晰就知道要用到的组件：MySQL、Canal、Kafka、ZooKeeper、Redis。 下面演示Kafka的搭建，MySQL搭建大家应该都会，ZooKeeper、Redis这些网上也有很多资料参考。 搭建Kafka首先在官网下载安装包： 解压，打开/config/server.properties配置文件，修改日志目录： 1log.dirs=./logs 首先启动ZooKeeper，我用的是3.6.1版本： 接着再启动Kafka，在Kafka的bin目录下打开cmd，输入命令： 1kafka-server-start.bat ../../config/server.properties 我们可以看到ZooKeeper上注册了Kafka相关的配置信息： 然后需要创建一个队列，用于接收canal传送过来的数据，使用命令： 1kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic canaltopic 创建的队列名是canaltopic。 配置Cannal Servercanal官网下载相关安装包： 找到canal.deployer-1.1.4/conf目录下的canal.properties配置文件： 12345678# tcp, kafka, RocketMQ 这里选择kafka模式canal.serverMode = kafka# 解析器的线程数，打开此配置，不打开则会出现阻塞或者不进行解析的情况canal.instance.parser.parallelThreadSize = 16# 配置MQ的服务地址，这里配置的是kafka对应的地址和端口canal.mq.servers = 127.0.0.1:9092# 配置instance，在conf目录下要有example同名的目录，可以配置多个canal.destinations = example 然后配置instance，找到/conf/example/instance.properties配置文件： 12345678910111213141516## mysql serverId , v1.0.26+ will autoGen(自动生成，不需配置)# canal.instance.mysql.slaveId=0# position infocanal.instance.master.address=127.0.0.1:3306# 在Mysql执行 SHOW MASTER STATUS;查看当前数据库的binlogcanal.instance.master.journal.name=mysql-bin.000006canal.instance.master.position=4596# 账号密码canal.instance.dbUsername=canalcanal.instance.dbPassword=Canal@****canal.instance.connectionCharset = UTF-8#MQ队列名称canal.mq.topic=canaltopic#单队列模式的分区下标canal.mq.partition=0 配置完成后，就可以启动canal了。 测试这时可以打开kafka的消费者窗口，测试一下kafka是否收到消息。 使用命令进行监听消费： 1kafka-console-consumer.bat --bootstrap-server 127.0.0.1:9092 --from-beginning --topic canaltopic 有个小坑。我这里使用的是win10系统的cmd命令行，win10系统默认的编码是GBK，而Canal Server是UTF-8的编码，所以控制台会出现乱码： 怎么解决呢？ 在cmd命令行执行前切换到UTF-8编码即可，使用命令行：chcp 65001 然后再执行打开kafka消费端的命令，就不乱码了： 接下来就是启动Redis，把数据同步到Redis就完事了。 封装Redis客户端环境搭建完成后，我们可以写代码了。 首先引入Kafka和Redis的maven依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml文件增加以下配置： 123456spring: redis: host: 127.0.0.1 port: 6379 database: 0 password: 123456 封装一个操作Redis的工具类： 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class RedisClient &#123; /** * 获取redis模版 */ @Resource private StringRedisTemplate stringRedisTemplate; /** * 设置redis的key-value */ public void setString(String key, String value) &#123; setString(key, value, null); &#125; /** * 设置redis的key-value，带过期时间 */ public void setString(String key, String value, Long timeOut) &#123; stringRedisTemplate.opsForValue().set(key, value); if (timeOut != null) &#123; stringRedisTemplate.expire(key, timeOut, TimeUnit.SECONDS); &#125; &#125; /** * 获取redis中key对应的值 */ public String getString(String key) &#123; return stringRedisTemplate.opsForValue().get(key); &#125; /** * 删除redis中key对应的值 */ public Boolean deleteKey(String key) &#123; return stringRedisTemplate.delete(key) == null; &#125;&#125; 创建MQ消费者进行同步在application.yml配置文件加上kafka的配置信息： 1234567891011121314151617spring: kafka: # Kafka服务地址 bootstrap-servers: 127.0.0.1:9092 consumer: # 指定一个默认的组名 group-id: consumer-group1 #序列化反序列化 key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer producer: key-serializer: org.apache.kafka.common.serialization.StringDeserializer value-serializer: org.apache.kafka.common.serialization.StringDeserializer # 批量抓取 batch-size: 65536 # 缓存容量 buffer-memory: 524288 根据上面Kafka消费命令那里，我们知道了json数据的结构，可以创建一个CanalBean对象进行接收： 1234567891011121314151617181920212223242526public class CanalBean &#123; //数据 private List&lt;TbCommodityInfo&gt; data; //数据库名称 private String database; private long es; //递增，从1开始 private int id; //是否是DDL语句 private boolean isDdl; //表结构的字段类型 private MysqlType mysqlType; //UPDATE语句，旧数据 private String old; //主键名称 private List&lt;String&gt; pkNames; //sql语句 private String sql; private SqlType sqlType; //表名 private String table; private long ts; //(新增)INSERT、(更新)UPDATE、(删除)DELETE、(删除表)ERASE等等 private String type; //getter、setter方法&#125; 12345678public class MysqlType &#123; private String id; private String commodity_name; private String commodity_price; private String number; private String description; //getter、setter方法&#125; 1234567public class SqlType &#123; private int id; private int commodity_name; private int commodity_price; private int number; private int description;&#125; 最后就可以创建一个消费者CanalConsumer进行消费： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class CanalConsumer &#123; //日志记录 private static Logger log = LoggerFactory.getLogger(CanalConsumer.class); //redis操作工具类 @Resource private RedisClient redisClient; //监听的队列名称为：canaltopic @KafkaListener(topics = &quot;canaltopic&quot;) public void receive(ConsumerRecord&lt;?, ?&gt; consumer) &#123; String value = (String) consumer.value(); log.info(&quot;topic名称:&#123;&#125;,key:&#123;&#125;,分区位置:&#123;&#125;,下标:&#123;&#125;,value:&#123;&#125;&quot;, consumer.topic(), consumer.key(),consumer.partition(), consumer.offset(), value); //转换为javaBean CanalBean canalBean = JSONObject.parseObject(value, CanalBean.class); //获取是否是DDL语句 boolean isDdl = canalBean.getIsDdl(); //获取类型 String type = canalBean.getType(); //不是DDL语句 if (!isDdl) &#123; List&lt;TbCommodityInfo&gt; tbCommodityInfos = canalBean.getData(); //过期时间 long TIME_OUT = 600L; if (&quot;INSERT&quot;.equals(type)) &#123; //新增语句 for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) &#123; String id = tbCommodityInfo.getId(); //新增到redis中,过期时间是10分钟 redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT); &#125; &#125; else if (&quot;UPDATE&quot;.equals(type)) &#123; //更新语句 for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) &#123; String id = tbCommodityInfo.getId(); //更新到redis中,过期时间是10分钟 redisClient.setString(id, JSONObject.toJSONString(tbCommodityInfo), TIME_OUT); &#125; &#125; else &#123; //删除语句 for (TbCommodityInfo tbCommodityInfo : tbCommodityInfos) &#123; String id = tbCommodityInfo.getId(); //从redis中删除 redisClient.deleteKey(id); &#125; &#125; &#125; &#125;&#125; 测试MySQL与Redis同步mysql对应的表结构如下： 12345678CREATE TABLE `tb_commodity_info` ( `id` varchar(32) NOT NULL, `commodity_name` varchar(512) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `commodity_price` varchar(36) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品价格&#x27;, `number` int(10) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品数量&#x27;, `description` varchar(2048) DEFAULT &#x27;&#x27; COMMENT &#x27;商品描述&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;商品信息表&#x27;; 首先在MySQL创建表。然后启动项目，接着新增一条数据： 1INSERT INTO `canaldb`.`tb_commodity_info` (`id`, `commodity_name`, `commodity_price`, `number`, `description`) VALUES (&#x27;3e71a81fd80711eaaed600163e046cc3&#x27;, &#x27;叉烧包&#x27;, &#x27;3.99&#x27;, &#x27;3&#x27;, &#x27;又大又香的叉烧包，老人小孩都喜欢&#x27;); tb_commodity_info表查到新增的数据： Redis也查到了对应的数据，证明同步成功！ 如果更新呢？试一下Update语句： 1UPDATE `canaldb`.`tb_commodity_info` SET `commodity_name`=&#x27;青菜包&#x27;,`description`=&#x27;很便宜的青菜包呀，不买也开看看了喂&#x27; WHERE `id`=&#x27;3e71a81fd80711eaaed600163e046cc3&#x27;; 没有问题！ 总结那么你会说，canal就没有什么缺点吗？ 肯定是有的： canal只能同步增量数据。 不是实时同步，是准实时同步。 存在一些bug，不过社区活跃度较高，对于提出的bug能及时修复。 MQ顺序性问题。我这里把官网的回答列出来，大家参考一下。 尽管有一些缺点，毕竟没有一样技术或者产品是完美的，最重要是合适。 我们公司在同步MySQL数据到Elastic Search也是采用Canal+RocketMQ的方式。 参考资料：canal官网 絮叨上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 如果你觉得这篇文章对你有用，点个赞吧~ 你的点赞是我创作的最大动力~ 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！","categories":[],"tags":[]},{"title":"","slug":"JVM核心知识/从JVM讲到类加载机制，很简单的","date":"2021-08-04T03:20:11.041Z","updated":"2021-08-04T03:17:18.469Z","comments":true,"path":"2021/08/04/JVM核心知识/从JVM讲到类加载机制，很简单的/","link":"","permalink":"https://alloceee.github.io/2021/08/04/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/%E4%BB%8EJVM%E8%AE%B2%E5%88%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E7%AE%80%E5%8D%95%E7%9A%84/","excerpt":"思维导图 文章已收录到Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、JVM介绍在介绍JVM之前，先看一下.java文件从编码到执行的过程： 整个过程是，x.java文件需要编译成x.class文件，通过类加载器加载到内存中，然后通过解释器或者即时编译器进行解释和编译，最后交给执行引擎执行，执行引擎操作OS硬件。 从类加载器到执行引擎这块内容就是JVM。","text":"思维导图 文章已收录到Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、JVM介绍在介绍JVM之前，先看一下.java文件从编码到执行的过程： 整个过程是，x.java文件需要编译成x.class文件，通过类加载器加载到内存中，然后通过解释器或者即时编译器进行解释和编译，最后交给执行引擎执行，执行引擎操作OS硬件。 从类加载器到执行引擎这块内容就是JVM。 JVM是一个跨语言的平台。从上面的图中可以看到，实际上JVM上运行的不是.java文件，而是.class文件。这就引出一个观点，JVM是一个跨语言的平台，他不仅仅能跑java程序，只要这种编程语言能编译成JVM可识别的.class文件都可以在上面运行。 所以除了java以外，能在JVM上运行的语言有很多，比如JRuby、Groovy、Scala、Kotlin等等。 从本质上讲JVM就是一台通过软件虚拟的计算机，它有它自身的指令集，有它自身的操作系统。 所以Oracle给JVM定了一套JVM规范，Oracle公司也给出了他的实现。基本上是目前最多人使用的java虚拟机实现，叫做Hotspot。使用java -version可以查看： 一些体量较大，有一定规模的公司，也会开发自己的JVM虚拟机，比如淘宝的TaobaoVM、IBM公司的J9-IBM、微软的MicrosoftVM等等。 二、JDK、JRE、JVM JVM应该很清楚了，是运行.class文件的虚拟机。JRE则是运行时环境，包括JVM和java核心类库，没有核心的类库是跑不起来的。 JDK则包括JRE和一些开发使用的工具集。 所以总的关系是JDK &gt; JRE &gt; JVM。 三、Class加载过程类加载是JVM工作的一个很重要的过程，我们知道.class是存在在硬盘上的一个文件，如何加载到内存工作的呢，面试中也经常问这个问题。所以你要和其他程序员拉开差距，体现差异化，这个问题要搞懂。 类加载的过程实际上分为三大步：**Loading(加载)、Linking(连接)、Initlalizing(初始化)**。 其中第二步Linking又分为三小步：**Verification(验证)、Preparation(准备)、Resolution(解析)**。 3.1 LoadingLoading是把.class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据，在堆中生成一个java.lang.Class类对象代表这个类，作为方法区这些类型数据的访问入口。 3.2 LinkingLinking简单来说，就是把原始的类定义的信息合并到JVM运行状态之中。分为三小步进行。 3.2.1 Verification验证加载的类信息是否符合class文件的标准，防止恶意信息或者不符合规范的字节信息。是JVM虚拟机运行安全的重要保障。 3.2.2 Preparation创建类或者接口中的静态变量，并初始化静态变量赋默认值。赋默认值不是赋初始值，比如static int i = 5，这一步只是把i赋值为0，而不是赋值为5。赋值为5是在后面的步骤。 3.2.3 Resolution把class文件常量池里面用到的符号引用转换成直接内存地址，直接可以访问到的内容。 3.3 Initlalizing这一步真正去执行类初始化clinit()(类构造器)的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态代码块内(static{})的逻辑。当初始化一个类时，发现父类还没有进行过初始化，则先初始化父类。虚拟机会保证一个类的clinit()方法在多线程环境中被正确加锁和同步。 四、类加载器上面就是类加载的整个过程。而最后一步Initlalizing是通过类加载器加载类。类加载器这里我单独讲一下，因为这是一个重点。 Java中的类加载器由上到下分为： Bootstrap ClassLoader（启动类加载器） ExtClassLoader（扩展类加载器） AppClassLoader（应用程序类加载器） 从类图，可以看到ExtClassLoader和AppClassLoader都是ClassLoader的子类。 所以如果要自定义一个类加载器，可以继承ClassLoader抽象类，重写里面的方法。重写什么方法后面再讲。 五、双亲委派机制讲完类加载器，这些类加载器是怎么工作的呢。对于双亲委派机制可能多多少少有听过，没听过也没关系，我正要讲。 上面说过有Bootstrap，ExtClassLoader，AppClassLoader三个类加载器。工作机制如下： 加载类的逻辑是怎么样的呢，核心代码是可以在JDK源码中找到的，在抽象类ClassLoader类的loadClass()，有兴趣可以源码看看： 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //如果上层有类加载器，递归向上，往上层的类加载器寻找 c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; //如果上层的都找不到相应的class if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); //自己去加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 其实整个逻辑已经很清晰了，为了更好理解，我这里画张图给给大家，更好理解一点： 看到这里，应该都清楚了双亲委派机制的流程了。重点来了，为什么要使用双亲委派机制呢？ 如果面试官问这个问题，一定要答出关键字：安全性。 反证法来辩证。假设不采用双亲委派机制，那我可以自定义一个类加载器，然后我写一个java.lang.String类用自定义的类加载器加载进去，原来java本身又有一个java.lang.String类，那么类的唯一性就没法保证，就不就给虚拟机的安全带来的隐患了吗。所以要保证一个类只能由同一个类加载器加载，才能保证系统类的的安全。 六、自定义类加载器自定义类加载器，上面讲过可以有样学样，自定义一个类继承ClassLoader抽象类。重写哪个方法呢？loadClass()方法是加载类的方法，重写这个不就行了？ 如果重写loadClass()那证明有思考过，但是不太对，因为重写loadClass()会破坏了双亲委派机制的逻辑。应该重写loadClass()方法里的findClass()方法。 findClass()方法才是自定义类加载器加载类的方法。 那findClass()方法源码是怎么样的呢？ 明显这个方法是给子类重写用的，权限修饰符也是protected，如果不重写，那就会抛出找不到类的异常。如果学过设计模式的同学，应该看得出来这里用了模板模式的设计模式。所以我们自定义类加载器重写此方法即可。开始动手！ 创建CustomerClassLoader类，继承ClassLoader抽象类的findClass()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CustomerClassLoader extends ClassLoader &#123; //class文件在磁盘中的路径 private String path; //通过构造器初始化class文件的路径 public CustomerClassLoader(String path) &#123; this.path = path; &#125; /** * 加载类 * * @param name 类的全路径 * @return Class&lt;?&gt; * @author Ye hongzhi */ @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = null; //获取class文件，转成字节码数组 byte[] data = getData(); if (data != null) &#123; //将class的字节码数组转换成Class类的实例 clazz = defineClass(name, data, 0, data.length); &#125; //返回Class对象 return clazz; &#125; private byte[] getData() &#123; File file = new File(path); if (file.exists()) &#123; try (FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream();) &#123; byte[] buffer = new byte[1024]; int size; while ((size = in.read(buffer)) != -1) &#123; out.write(buffer, 0, size); &#125; return out.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; else &#123; return null; &#125; &#125;&#125; 这样就完成了，接下来测试一下，定义一个Hello类。 12345public class Hello &#123; public void say() &#123; System.out.println(&quot;hello.......java&quot;); &#125;&#125; 使用javac命令编译成class文件，如下图： 最后写个main方法运行测试一把： 1234567891011public class Main &#123; public static void main(String[] args) throws Exception &#123; String path = &quot;D:\\\\mall\\\\core\\\\src\\\\main\\\\java\\\\io\\\\github\\\\yehongzhi\\\\classloader\\\\Hello.class&quot;; CustomerClassLoader classLoader = new CustomerClassLoader(path); Class&lt;?&gt; clazz = classLoader.findClass(&quot;io.github.yehongzhi.classloader.Hello&quot;); System.out.println(&quot;使用类加载器：&quot; + clazz.getClassLoader()); Method method = clazz.getDeclaredMethod(&quot;say&quot;); Object obj = clazz.newInstance(); method.invoke(obj); &#125;&#125; 运行结果： 七、破坏双亲委派机制看到这里，你肯定会很疑惑。上面不是才讲过双亲委派机制为了保证系统的安全性吗，为什么又要破坏双亲委派机制呢？ 重温一下双亲委派机制，应该还记得，就是底层的类加载器一直委托上层的类加载器，如果上层的已经加载了，就无需加载，上层的类加载器没有加载则自己加载。这就突出了双亲委派机制的一个缺陷，就是只能子的类加载器委托父的类加载器，不能反过来用父的类加载器委托子的类加载器。 那你会问，什么情况会出现父的类加载器委托子的类加载器呢？ 还真有这个场景，就是加载JDBC的数据库驱动。在JDK中有一个所有 JDBC 驱动程序需要实现的接口Java.sql.Driver。而Driver接口的实现类则是由各大数据库厂商提供。那问题就出现了，DriverManager(JDK的rt.jar包中)要加载各个实现了Driver接口的实现类，然后进行统一管理，但是DriverManager是由Bootstrap类加载器加载的，只能加载JAVA_HOME下lib目录下的文件(可以看回上面双亲委派机制的第一张图)，但是实现类是服务商提供的，由AppClassLoader加载，这就需要Bootstrap(上层类加载器)委托AppClassLoader(下层类加载器)，也就破坏了双亲委派机制。这只是其中一种场景，破坏双亲委派机制的例子还有很多。 那么怎么实现破坏双亲委派机制呢？ 最简单就是自定义类加载器，前面讲过为了不破坏双亲委派机制重写findClass()方法，所以如果我要破坏双亲委派机制，那就重写loadClass()方法，直接把双亲委派机制的逻辑给改了。在JDK1.2后不提倡重写此方法。所以提供下面这种方式。 使用线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是AppClassLoader类加载器。 那么刚刚说的JDBC又是采用什么方式破坏双亲委派机制的呢？ 当然是采用上下文文件类加载器，还有使用了SPI机制，下面一步一步分解。 第一步，Bootstrap加载DriverManager类，在DriverManager类的静态代码块调用初始化方法。 123456public class DriverManager &#123; static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;); &#125;&#125; 第二步，加载Driver接口的所有实现类，得到Driver实现类的集合，获取一个迭代器。 第三步，看ServiceLoader.load()方法。 第四步，看迭代器driversIterator。 接着一直找下去，就会看到一个很神奇的地方。 而这个常量值PREFIX则是： 1private static final String PREFIX = &quot;META-INF/services/&quot;; 所以我们可以在mysql驱动包中找到这个文件： 通过文件名找接口的实现类，这是java的SPI机制。到此为止，破案了大人！ 作为暖男的我，就画张图，总结一下整个过程吧： 总结这篇文章主要介绍了JVM，然后讲到JVM的类加载机制的三大步骤，接着讲自定义类加载器以及双亲委派机制。最后再深入探讨了为什么要使用双亲委派机制，又为什么要破坏双亲委派机制的问题。可能讲得有点长，不过我相信应该都看懂了，因为我讲得比较通俗，而且图文并茂。 上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"JVM核心知识/JVM垃圾回收总结","date":"2021-08-04T03:20:11.020Z","updated":"2021-08-04T03:17:18.466Z","comments":true,"path":"2021/08/04/JVM核心知识/JVM垃圾回收总结/","link":"","permalink":"https://alloceee.github.io/2021/08/04/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%BB%E7%BB%93/","excerpt":"","text":"思维导图 前言Java相对于C/C++语言来说，最明显的特点在于Java引入了自动垃圾回收。垃圾回收(Garbage Collection简称GC)可以使程序员不在需要关心JVM内存管理的问题，专注于写程序本身。平时程序员是很难感知到GC的存在，但是如果涉及到一些性能调优，线上的问题排查等等，深入地了解GC是必不可少的。往往通过一些JVM参数的设置能就使系统性能提高不少。 一、JVM内存区域要深入了解GC，首先要明白GC会回收哪些数据，数据位于哪个区域。接着我们看一下JVM的内存区域。 从图中可以看出，内存区域分为五个： 虚拟机栈：线程私有，由一个个栈帧组成，每个栈帧对应着一个调用的方法，保存有方法的局部变量等信息。方法被调用时栈帧入栈，方法结束调用时栈帧出栈。入栈出栈的时机很清楚，所以不需要进行GC。 本地方法栈：与虚拟机栈非常类似，本地方法栈与虚拟机栈的区别在于，虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法(Native Method)。这块区域也不需要进行GC。 程序计数器：线程私有的，它的作用可以看做是当前线程所执行的字节码的行号指示器。我们知道JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会被挂起，而另一个线程获取到时间片开始执行。在JVM中，就是通过程序计数器来记录某个线程的字节码执行位置，当被挂起的线程重新获取到时间片的时候，就知道上次被挂起时执行到哪个位置了。这块区域也不需要GC。 方法区：在Java8之前有永久代的概念，在堆中实现，受GC的管理，主要存储类的信息，常量，静态变量，由于永久代有 -XX:MaxPermSize 的上限，所以很容易造成 OOM。在Java8之后，永久代被移除，然后把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。所以Java8以后，方法区也不需要GC。 堆：堆是Java对象的存储区域，任何new字段分配的Java对象实例和数组，都被分配在了堆上。GC主要作用于这个区域，对这两类数据进行回收。 二、如何判断对象是否可回收上面讲了GC主要作用的区域是在堆中，那么又是怎么判断是否可以回收的呢？在GC里面有两种算法来判断，一种是引用计数，对象引用的次数为0就是垃圾，另一种是可达性算法，如果一个对象不在以GC Root根节点为起点的引用链中，则视为垃圾。 2.1 引用计数算法首先看引用计数法，简单点说对象被引用，就会在此对象的对象头上计数器加一，每当有一个引用失效时计数器的值减一，如果没有引用(引用次数为0)则此对象可回收。但是这种算法很难解决对象之间互相循环引用的问题。 2.2 可达性算法所谓的GC Roots就是一组必须活跃的引用，基本思路就是从一系列的GC Root一直往下搜索，通过GC Root串成的一条线称为引用链，如果有对象不在任何一条以GC Root为起点的引用链中，则此对象就会被GC回收，这就是可达性算法。 哪些对象可作为GC Root对象呢： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 三、常见的垃圾回收算法上面已经讲了如何判断哪些对象时可回收的。那么判断完是否可回收后，GC又是使用什么算法进行回收的呢？这就要讲一讲垃圾回收的几种方式： 标记清除法 标记整理法 复制算法 分代收集算法 3.1 标记清除法其实很简单，分为标记和清除两个步骤。第一步根据可达性算法标记被回收的对象，第二步回收被标记的对象。 明显这种垃圾回收算法的缺点是很容易产生内存碎片。 3.2 标记整理法前面两个步骤和标记清除算法一样，而不同的是在标记清除算法的基础上多了一步整理的过程。如图所示，整理步骤的时候，将所有存活的对象都往左边移动，然后清理另一端的所有区域，这样就不会产生内存碎片。 虽然不会产生内存碎片，但是由于频繁地移动存活的对象，所以效率十分低下。 3.3 复制算法把内存分成两份，分别是A区域和B区域，第一步根据可达性算法把存活的对象标记出来，第二步把存活的对象复制到B区域，第三步把A区域全部清空。这就是复制算法。 复制算法不会产生内存碎片，并且不需要频繁移动存活的对象，而缺点就是内存利用不充分，比如一块500M的内存，要分成两份，只能利用到250M。 3.4 分代收集算法分代搜集算法是针对对象的不同特性，而使用适合的算法，这里面并没有实际上的新算法产生。与其说分代收集算法是第四个算法，不如说它是对前三个算法的实际应用。 首先我们先探讨一下对象的不同特性，内存中的对象其实可以根据生命周期的长短大致分为三种： 夭折对象(新生代)：朝生夕死的对象，比如方法里的局部变量。 持久对象(老年代)：存活的比较久但还是要死的对象，比如缓存对象，单例对象等等。 永久对象(永久代)：对象生成后几乎不灭的对象，例如String池中的对象（享元模式）、加载过的类信息等等。 上述的对象对应在内存中的区域就是，夭折对象和持久对象在Java堆中，永久对象在方法区。 分代算法的原理就是根据对象的存货周期不同将堆分为年轻代和老年代。新生代又分为Eden 区，from Survivor 区（S0区），to Survivor 区(S1区)，比例为8:1:1。 先看年轻代的GC，年轻代采用的回收算法是复制算法。新建的对象被创建后就会分配在Eden 区，当Eden区将满时，就会触发GC。 在这一步GC会把大部分夭折对象回收，根据可达性算法标记出存活的对象，把存活对象复制到S0区，然后清空Eden 区。 接着继续到下一次触发GC时，就会把Eden区和S0区的存活对象复制到S1区，然后清空Eden区和S0区。每次垃圾回收后S0和S1区的角色互换。每次GC后，如果对象存活下来则年龄加一。 我们知道在年轻代中存活得越久的对象，年龄会越大，如果存活对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代。由于老年代的对象一般不会经常回收，所以采用的算法是标记整理法，老年代的回收次数相对较少，每次回收时间比较长。 四、Stop the worldJava中Stop The World机制简称STW，执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集器之外），当垃圾回收完成后，再继续运行，所以尽量减少STW的时间，就是优化JVM的主要目标。 五、常见的垃圾收集器垃圾收集器其实就是上面讲的算法的具体实现，目前没有说哪个垃圾收集器是最好的，只有根据应用的特点选择最合适的，所以说合适的才是最好的。 常见的垃圾收集器除了G1垃圾收集器外，都是只作用于一个区域，要么年轻代要么老年代，所以一般是配合使用，总共有7种，怎么配合使用，请看下面这张图，有连线的就是可以配合使用的。 5.1 Serial收集器Serial收集器作用于年轻代，单线程的垃圾收集器，单线程意味着它只会使用一个CPU或者一个线程去完成垃圾回收的工作，当它在垃圾回收时，由于SWT机制，其他工作线程都会被暂时挂起，直到垃圾回收完成。这种垃圾收集器适用于Client模式的应用，在单CPU的环境下，由于没有和其他线程交互的开销，可以专心垃圾回收的工作，能够把单线程的优势发挥到极致，简单高效。通过-XX:+UseSerialGC可以开启这种回收模式。 5.2 ParNew收集器ParNew 收集器是Serial收集器的多线程版本，作用于年轻代，默认开启的收集线程数和cpu数量一样，运行数量可以通过修改ParallelGCThreads设定。 5.3 Parallel Scavenge收集器Parallel Scavenge收集器也被称为吞吐量优先收集器，作用于年轻代，多线程采用复制算法的垃圾收集器，跟ParNew 收集器有些类似。和ParNew 收集器不同的是，Parallel Scavenge收集器关注的是吞吐量，它提供了两个参数来控制吞吐量，分别是-XX:MaxGCPauseMillis(控制最大的垃圾收集停顿时间)、 -XX:GCTimeRatio(直接设置吞吐量大小)。 如果设置了-XX:+UseAdaptiveSizePolicy参数，虚拟机就会根据系统的运行情况收集监控信息，动态调整新生代的大小，Eden,Survivor比例等，以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标，这种调节方式称为GC的自适应调节策略。这也是Parallel Scavenge收集器和ParNew 收集器最大的区别。 5.4 Serial Old收集器Serial Old 收集器是工作在老年代的单线程垃圾收集器，采用的算法是标记整理算法。在Client模式下可以和Serial收集器配合使用，如果在Server模式的应用，在JDK1.5之前可以和Parallel Scavenge收集器配合使用，另一种使用场景则是CMS垃圾收集器的后备预案，在发生Concurrent Mode Failure使用。 5.5 Parallel Old收集器Parallel Old 收集器是Parallel Scavenge收集器的老年代版本，多线程收集，采用标记整理算法。下图是Parallel Scavenge收集器和Parallel Old 收集器配合工作的过程图。 5.6 CMS收集器CMS收集器是一种以获取最短回收停顿时间为目标的收集器，采用标记-清除算法。适用于希望系统停顿时间短，给用户更好的体验的场景。 CMS收集器运行时主要分为四个步骤： 初始标记：标记GC Roots能直接关联的对象。存在Stop The World。 并发标记：GC Roots Tracing，可以和用户线程并发执行。 重新标记：标记期间产生的对象存活的再次判断，修正对这些对象的标记，执行时间相对并发标记短，存在Stop The World。 并发清除：清除对象,可以和用户线程并发执行。 CMS收集器的缺点在于： 对CPU资源比较敏感。 无法处理浮动垃圾。可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理时用户线程还在运行，所以清理垃圾同时新的垃圾也会不断产生，这部分垃圾（即浮动垃圾）只能在下一次 GC 时再清理掉。 采用的是标记清除算法，所以会产生内存碎片。内存碎片会导致大对象无法分配到连续的内存空间，然后会产生Full GC，影响应用的性能。 5.7 G1收集器G1垃圾回收器主要是面向服务端的垃圾回收器，年轻代和老年代都可使用。运作时，整体上采用标记整理算法，局部上看是采用复制算法，两种算法都不会产生内存碎片，所以回收器在回收后能产生连续的内存空间。 它是专门针对以下场景设计的： 像CMS收集器一样，能与应用程序线程并发执行。 整理空闲空间更快。 需要GC停顿时间更好预测。 不希望牺牲大量的吞吐性能。 不需要更大的Java Heap。 G1垃圾回收器的内存分区不再采用传统的内存分区，将新生代，老年代的物理空间划分取消了。 取而代之的是，把堆内存分成若干个Region(区域)，每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生的STW。G1垃圾回收器和传统的垃圾回收器的最大区别就在于，弱化了分代概念，引入了分区的思想。 G1中每代的存储地址都不是连续的，而是使用了不连续的大小相同的Region。除此之外G1中还多了一个H，H代表Humongous，用于存储巨大对象(humongous object)，当对象大小大于等于region一半的对象，就直接分配到了老年代，防止了反复拷贝移动。 G1垃圾回收过程可分为四步： 初始标记。收集所有GC根（对象的起源指针，根引用），STW，在年轻代完成。 并发标记。标记存活对象。 最终标记。是最后一个标记阶段，STW，很短，完成所有标记工作。 筛选回收。回收没有存活对象的Region并加入可用Region队列。 总结本文的简述了JVM的垃圾回收的理论知识，思路是先搞懂GC作用的区域是在堆中，然后介绍可达性算法的作用是为了标记存活的对象，知道哪些是可回收对象，接着就是使用垃圾回收算法进行回收，然后介绍了常见的几种垃圾回收算法(标记清除，复制算法，标记整理)，最后再介绍常见的几种垃圾回收器。 对于垃圾回收器的介绍，这里只是简单的描述，并没有深入地讲解，因为每一个垃圾回收器如果展开细述都能讲上半天，所以有兴趣的话，可以自己再去探索一下，个人认为CMS和G1垃圾回收器是比较重要的两种。 这篇文章就讲到这里了，希望看完之后能对你有所帮助，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"Java基础/怎么在Java中自定义注解","date":"2021-08-04T03:20:10.992Z","updated":"2021-08-04T03:17:18.481Z","comments":true,"path":"2021/08/04/Java基础/怎么在Java中自定义注解/","link":"","permalink":"https://alloceee.github.io/2021/08/04/Java%E5%9F%BA%E7%A1%80/%E6%80%8E%E4%B9%88%E5%9C%A8Java%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 什么是注解注解是JDK1.5引入的新特性，主要用于简化代码，提高编程的效率。其实在日常开发中，注解并不少见，比如Java内置的@Override、@SuppressWarnings，或者Spring提供的@Service、@Controller等等，随着这些注解使用的频率越来越高，作为开发人员当真有必要深入学习一番。 Java内置的注解先说说Java内置的三个注解，分别是： @Override：检查当前的方法定义是否覆盖父类中的方法，如果没有覆盖，编译器就会报错。 @SuppressWarnings：忽略编译器的警告信息。 @Deprecated：用于标识该类或方法已过时，建议开发人员不要使用该类或方法。 元注解元注解其实就是描述注解的注解。主要有四个元注解，分别是： @Target用于描述注解的使用范围，也就是注解可以用在什么地方，取值有： CONSTRUCTOR：用于描述构造器。 FIELD：用于描述字段。 LOCAL_VARIABLE：用于描述局部变量。 METHOD：用于描述方法。 PACKAGE：用于描述包。 PARAMETER：用于描述参数。 TYPE：用于描述类，包括class，interface，enum。 @Retention表示需要在什么级别保存该注释信息，用于描述注解的生命周期，取值由枚举RetentionPoicy定义。 SOURCE：在源文件中有效（即源文件保留），仅出现在源代码中，而被编译器丢弃。 CLASS：在class文件中有效（即class保留），但会被JVM丢弃。 RUNTIME：JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 如果只是做一些检查性操作，使用SOURCE，比如@Override，@SuppressWarnings。 如果要在编译时进行一些预处理操作，就用 CLASS。 如果需要获取注解的属性值，去做一些运行时的逻辑，可以使用RUNTIME。 @Documented将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。它是一个标记注解，没有成员。 @Inherited是一个标记注解，用来指定该注解可以被继承。使用 @Inherited 注解的 Class 类，表示这个注解可以被用于该 Class 类的子类。 自定义注解下面实战一下，自定义一个注解@LogApi，用于方法上，当被调用时即打印日志，在控制台显示调用方传入的参数和调用返回的结果。 定义注解首先定义注解@LogApi，在方法上使用，为了能在反射中读取注解信息，当然是设置为RUNTIME。 12345@Target(value = ElementType.METHOD)@Documented@Retention(value = RetentionPolicy.RUNTIME)public @interface LogApi &#123;&#125; 这种没有属性的注解，属于标记注解。 多说几句，如果需要传递属性值，也可以设置属性值value，比如@RequestMapping注解。 12345678@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123; @AliasFor(&quot;path&quot;) String[] value() default &#123;&#125;;&#125; 如果在使用时。只设置value值，可以忽略value，比如这样： 1234567891011//完整是@RequestMapping(value = &#123;&quot;/list&quot;&#125;)//忽略value不写@RequestMapping(&quot;/list&quot;)public Map&lt;String, Object&gt; list() throws Exception &#123; Map&lt;String, Object&gt; userMap = new HashMap&lt;&gt;(); userMap.put(&quot;1号佳丽&quot;, &quot;李嘉欣&quot;); userMap.put(&quot;2号佳丽&quot;, &quot;袁咏仪&quot;); userMap.put(&quot;3号佳丽&quot;, &quot;张敏&quot;); userMap.put(&quot;4号佳丽&quot;, &quot;张曼玉&quot;); return userMap;&#125; 标记注解刚刚定义完注解之后，就可以在需要的地方标记注解，很简单。 12345@LogApi@RequestMapping(&quot;/list&quot;)public Map&lt;String, Object&gt; list() throws Exception &#123; //业务代码...&#125; 解析注解最关键的一步来了，解析注解，一般在项目中会使用Spring的AOP技术解析注解，当然如果只需要解析一次的话，也可以使用Spring容器的生命周期函数。 这里的场景是打印每次方法被调用的日志，所以使用AOP比较合适。 创建一个切面类LogApiAspect进行解析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Aspect@Componentpublic class LogApiAspect &#123; //切面点为标记了@LogApi注解的方法 @Pointcut(&quot;@annotation(io.github.yehongzhi.user.annotation.LogApi)&quot;) public void logApi() &#123; &#125; //环绕通知 @Around(&quot;logApi()&quot;) @SuppressWarnings(&quot;unchecked&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; long starTime = System.currentTimeMillis(); //通过反射获取被调用方法的Class Class type = joinPoint.getSignature().getDeclaringType(); //获取类名 String typeName = type.getSimpleName(); //获取日志记录对象Logger Logger logger = LoggerFactory.getLogger(type); //方法名 String methodName = joinPoint.getSignature().getName(); //获取参数列表 Object[] args = joinPoint.getArgs(); //参数Class的数组 Class[] clazz = new Class[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; clazz[i] = args[i].getClass(); &#125; //通过反射获取调用的方法method Method method = type.getMethod(methodName, clazz); //获取方法的参数 Parameter[] parameters = method.getParameters(); //拼接字符串，格式为&#123;参数1:值1,参数2::值2&#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; parameters.length; i++) &#123; Parameter parameter = parameters[i]; String name = parameter.getName(); sb.append(name).append(&quot;:&quot;).append(args[i]).append(&quot;,&quot;); &#125; if (sb.length() &gt; 0) &#123; sb.deleteCharAt(sb.lastIndexOf(&quot;,&quot;)); &#125; //执行结果 Object res; try &#123; //执行目标方法，获取执行结果 res = joinPoint.proceed(); logger.info(&quot;调用&#123;&#125;.&#123;&#125;方法成功，参数为[&#123;&#125;]，返回结果[&#123;&#125;]&quot;, typeName, methodName, sb.toString(), JSONObject.toJSONString(res)); &#125; catch (Exception e) &#123; logger.error(&quot;调用&#123;&#125;.&#123;&#125;方法发生异常&quot;, typeName, methodName); //如果发生异常，则抛出异常 throw e; &#125; finally &#123; logger.info(&quot;调用&#123;&#125;.&#123;&#125;方法，耗时&#123;&#125;ms&quot;, typeName, methodName, (System.currentTimeMillis() - starTime)); &#125; //返回执行结果 return res; &#125;&#125; 定义完切面类后，需要在启动类添加启动AOP的注解。 123456789@SpringBootApplication//添加此注解，开启AOP@EnableAspectJAutoProxypublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class, args); &#125;&#125; 测试我们再在Controller控制层增加一个有参数的接口。 123456789@LogApi@RequestMapping(&quot;/get/&#123;id&#125;&quot;)public String get(@PathVariable(name = &quot;id&quot;) String id) throws Exception &#123; HashMap&lt;String, Object&gt; user = new HashMap&lt;&gt;(); user.put(&quot;id&quot;, id); user.put(&quot;name&quot;, &quot;关之琳&quot;); user.put(&quot;经典角色&quot;, &quot;十三姨&quot;); return JSONObject.toJSONString(user);&#125; 启动项目，然后请求接口list()，我们可以看到控制台出现被调用方法的日志信息。 请求有参数的接口get()，可以看到参数名称和参数值都被打印在控制台。 这种记录接口请求参数和返回值的功能，在实际项目中基本上都会使用，因为这能利于系统的排错和性能调优等等。 我们也可以在这个例子中，学会使用注解和切面编程，可谓是一举两得！ 总结注解的使用能大大地减少开发的代码量，所以在实际项目的开发中会使用到非常多的注解。特别是做一些公共基础的功能，比如日志记录，事务管理，权限控制这些功能，使用注解就非常高效且优雅。 对于自定义注解，主要有三个步骤，定义注解，标记注解，解析注解，并不是很难。 这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"Java基础/String类","date":"2021-08-04T03:20:10.988Z","updated":"2021-08-04T03:17:18.477Z","comments":true,"path":"2021/08/04/Java基础/String类/","link":"","permalink":"https://alloceee.github.io/2021/08/04/Java%E5%9F%BA%E7%A1%80/String%E7%B1%BB/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary String类在Java中String类的使用的频率可谓相当高。它是Java语言中的核心类，在java.lang包下，主要用于字符串的比较、查找、拼接等等操作。如果要深入理解一个类，最好的方法就是看看源码： 123456789public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 //...&#125; 从源码中，可以看出以下几点： String类被final关键字修饰，表示String类不能被继承，并且它的成员方法都默认为final方法。 String类实现了Serializable、CharSequence、 Comparable接口。 String类的值是通过char数组存储的，并且char数组被private和final修饰，字符串一旦创建就不能再修改。 下面通过几个问题不断加深对String类的理解。 问题一上面说字符串一旦创建就不能再修改，String类提供的replace()方法不就可以替换修改字符串的内容吗？ 实际上replace()方法并没有对原字符串进行修改，而是创建了一个新的字符串返回，看看源码就知道了。 1234567891011121314151617181920212223242526public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; //创建一个新的字符串返回 return new String(buf, true); &#125; &#125; return this;&#125; 其他方法也是一样，无论是sub、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。 问题二为什么要使用final关键字修饰String类？ 首先要讲final修饰类的作用，被final修饰的类不能被继承，类中的所有成员方法都会被隐式地指定为final方法。也就是不能拥有子类，成员方法也不能被重写。 回到问题，String类被final修饰主要基于安全性和效率两点考虑。 安全性 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。 String被许多的Java类(库)用来当做参数，比如网络连接地址URL，文件路径path，还有反射机制所需要的String参数等，假若String不是固定不变的，将会引起各种安全隐患。 效率 字符串不变性保证了hash码的唯一性，因此可以放心的进行缓存，这也是一种性能优化手段，意味着不必每次都取计算新的哈希码。 只有当字符串是不可变的，字符串池才有可能实现，字符串常量池是java堆内存中一个特殊的存储区域，当创建一个String对象，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。 字符串常量池字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，所以在实例化字符串的时候使用字符串常量池进行优化。 池化思想其实在Java中并不少见，字符串常量池也是类似的思想，当创建字符串时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。 我们可以写个简单的例子证明： 12345public static void main(String[] args) throws Exception &#123; String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2);//true&#125; 还有一个面试中经常问的，new String(“abc”)创建了几个对象？ 这可能就是想考你对字符串常量池的理解，我一般回答是一个或者两个对象。 如果之前”abc”字符串没有使用过，毫无疑问是创建两个对象，堆中创建了一个String对象，字符串常量池创建了一个，一共两个。 如果之前已经使用过了”abc”字符串，则不会再在字符串常量池创建对象，而是从字符串常量缓冲区中获取，只会在堆中创建一个String对象。 123String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;);//s2这行代码，只会创建一个对象 字符串拼接字符串的拼接在Java中是很常见的操作，但是拼接字符串并不是简简单单地使用”+”号即可，还有一些要注意的点，否则会造成效率低下。 比如下面这段代码： 1234567public static void main(String[] args) throws Exception &#123; String s = &quot;&quot;; for (int i = 0; i &lt; 10; i++) &#123; s+=i; &#125; System.out.println(s);//0123456789&#125; 在循环内使用+=拼接字符串会有什么问题呢？我们反编译一下看看就知道了。 其实反编译后，我们可以看到String类使用”+=”拼接的底层其实是使用StringBuilder，先初始化一个StringBuilder对象，然后使用append()方法拼接，最后使用toString()方法得到结果。 问题在于如果在循环体内使用+=拼接，会创建很多临时的StringBuilder对象，拼接后再调用toString()赋给原String对象。这会生成大量临时对象，严重影响性能。 所以在循环体内进行字符串拼接时，建议使用StringBuilder或者StringBuffer类，例子如下： 1234567public static void main(String[] args) throws Exception &#123; StringBuilder s = new StringBuilder(); for (int i = 0; i &lt; 10; i++) &#123; s.append(i); &#125; System.out.println(s.toString());//0123456789&#125; StringBuilder和StringBuffer的区别在于，StringBuffer的方法都被sync关键字修饰，所以是线程安全的，而StringBuilder则是线程不安全的(效率高)。 总结回顾一下，本文介绍了String类的不可变的特点，还有字符串常量池的作用，最后简单地从JVM编译的层面对字符串拼接提出一点建议。所谓温故而知新，即使是一些很基础很常见的类，如果深入去探索的话，也会有一番收获。 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"Java基础/Java基础不简单，讲一讲枚举","date":"2021-08-04T03:20:10.981Z","updated":"2021-08-04T03:17:18.475Z","comments":true,"path":"2021/08/04/Java基础/Java基础不简单，讲一讲枚举/","link":"","permalink":"https://alloceee.github.io/2021/08/04/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E4%B8%8D%E7%AE%80%E5%8D%95%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 什么是枚举枚举是JDK1.5新增的一种数据类型，是一种特殊的类，常用于表示一组常量，比如一年四季，12个月份，星期一到星期天，服务返回的错误码，结算支付的方式等等。枚举是使用enum关键字来定义。 枚举的使用在使用枚举之前我们先探讨一个问题，为什么要使用枚举。 现在有个业务场景是结算支付，有支付宝和微信支付两种方式，1表示支付宝，2表示微信支付，还需要根据编码(1或2)获取相应的英文名，如果不用枚举，我们就要这样写。 1234567891011121314151617public class PayTypeUtil &#123; //支付宝 private static final int ALI_PAY = 1; //微信支付 private static final int WECHAT_PAY = 2; //根据编码获取支付方式的名称 public String getPayName(int code) &#123; if (ALI_PAY == code) &#123; return &quot;Ali_Pay&quot;; &#125; if (WECHAT_PAY == code) &#123; return &quot;Wechat_Pay&quot;; &#125; return null; &#125;&#125; 如果这时，产品经理说要增加一个银联支付，就要加多if的判断，就会造成有多少种支付方式，就有多少个if，非常难看。 如果使用枚举，就变得很优雅，先看代码： 12345678910111213141516171819202122232425public enum PayTypeEnum &#123; /** 支付宝*/ ALI_PAY(1, &quot;ALI_PAY&quot;), /** 微信支付*/ WECHAT_PAY(2, &quot;WECHAT_PAY&quot;); private int code; private String describe; PayTypeEnum(int code, String describe) &#123; this.code = code; this.describe = describe; &#125; //根据编码获取支付方式 public PayTypeEnum find(int code) &#123; for (PayTypeEnum payTypeEnum : values()) &#123; if (payTypeEnum.getCode() == code) &#123; return payTypeEnum; &#125; &#125; return null; &#125; //getter、setter方法&#125; 当我们需要扩展，只需要定义多一个实例即可，其他代码都不用动，比如加多一个银联支付。 1234567/** 支付宝*/ALI_PAY(1, &quot;ALI_PAY&quot;),/** 微信支付*/WECHAT_PAY(2, &quot;WECHAT_PAY&quot;),//只需要加多一行代码即可完成扩展/** 银联支付*/UNION_PAY(3,&quot;UNION_PAY&quot;); 一般在实际项目中，最多的写法就是这样，主要是简单明了，易于扩展。 第二种常见的用法是结合switch-case使用，比如我定义一个一年四季的枚举。 12345678910public enum Season &#123; //春 SPRING, //夏 SUMMER, //秋 AUTUMN, //冬 WINTER;&#125; 然后结合switch使用。 12345678910111213141516171819202122public static void main(String[] args) throws Exception&#123; doSomething(Season.SPRING);&#125;private static void doSomething(Season season)&#123; switch (season)&#123; case SPRING: System.out.println(&quot;不知细叶谁裁出，二月春风似剪刀&quot;); break; case SUMMER: System.out.println(&quot;接天莲叶无穷碧，映日荷花别样红&quot;); break; case AUTUMN: System.out.println(&quot;停车坐爱枫林晚，霜叶红于二月花&quot;); break; case WINTER: System.out.println(&quot;梅花香自苦寒来，宝剑锋从磨砺出&quot;); break; default: System.out.println(&quot;垂死病中惊坐起，笑问客从何处来&quot;); &#125;&#125; 可能很多人觉得直接用int，String类型配合switch使用就够了，为什么还要支持枚举，这样的设计是不是显得很多余，其实非也。 不妨反过来想，假如用1到4代表四季，接收的参数类型就是int，在没有提示的情况下，我们仅仅只知道数int类型是很难猜到需要传入数字的范围，字符串也是一样，如果不用枚举你是很难一眼看出需要传入什么参数，这才是最关键的。 如果使用枚举，那么问题就迎刃而解，当你调用doSomething()方法时，一看到枚举就知道传入的是哪几个参数，因为已经在枚举类里面定义好了。这对于项目交接，还有代码的可读性都是非常有利的。 这种限制不单止限制了调用方，也限制了传入的参数只能是定义好的枚举，不用担心传入的参数错误导致的程序错误。 所以枚举类使用得恰当，对于项目的可维护性是有很大提升的。 枚举本身的方法首先我们先以上面的支付类型枚举PayTypeEnum为例子，看看有哪些自带的方法。 valueOf()方法这是一个静态方法，传入一个字符串(枚举的名称)，获取枚举类。如果传入的名称不存在，则报错。 1234public static void main(String[] args) throws Exception&#123; System.out.println(PayTypeEnum.valueOf(&quot;ALI_PAY&quot;)); System.out.println(PayTypeEnum.valueOf(&quot;HUAWEI_PAY&quot;));&#125; values()方法返回包含枚举类中所有枚举数据的一个数组。 123456public static void main(String[] args) throws Exception &#123; PayTypeEnum[] payTypeEnums = PayTypeEnum.values(); for (PayTypeEnum payTypeEnum : payTypeEnums) &#123; System.out.println(&quot;code: &quot; + payTypeEnum.getCode() + &quot;,describe: &quot; + payTypeEnum.getDescribe()); &#125;&#125; ordinal()方法默认情况下，枚举类会给定义的枚举提供一个默认的次序，ordinal()方法就可以返回枚举的次序。 1234567891011public static void main(String[] args) throws Exception &#123; PayTypeEnum[] payTypeEnums = PayTypeEnum.values(); for (PayTypeEnum payTypeEnum : payTypeEnums) &#123; System.out.println(&quot;ordinal: &quot; + payTypeEnum.ordinal() + &quot;, Enum: &quot; + payTypeEnum); &#125;&#125;/**ordinal: 0, Enum: ALI_PAYordinal: 1, Enum: WECHAT_PAYordinal: 2, Enum: UNION_PAY*/ name()、toString()方法返回定义枚举用的名称。 12345678public static void main(String[] args) throws Exception &#123; for (Season season : Season.values()) &#123; System.out.println(season.name()); &#125; for (Season season : Season.values()) &#123; System.out.println(season.toString()); &#125;&#125; 输出结果都是一样的： 1234SPRINGSUMMERAUTUMNWINTER 为什么？因为底层代码是一样，返回的是name。 1234567891011public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; public final String name() &#123; return name; &#125; public String toString() &#123; return name; &#125;&#125; 区别在于toString()方法没有被final修饰，可以重写，name()方法不能重写。 compareTo()方法因为枚举类实现了Comparable接口，所以必须重写compareTo()方法，比较的是枚举的次序，也就是ordinal，源码如下： 12345678public final int compareTo(E o) &#123; Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal;&#125; 因为实现Comparable接口，所以可以用来排序，比如这样： 123456789public static void main(String[] args) throws Exception &#123; //这里是乱序的枚举数组 Season[] seasons = new Season[]&#123;Season.WINTER, Season.AUTUMN, Season.SPRING, Season.SUMMER&#125;; //调用sort方法排序，按默认次序排序 Arrays.sort(seasons); for (Season season : seasons) &#123; System.out.println(season); &#125;&#125; 输出结果，按照默认次序排序： 1234SPRINGSUMMERAUTUMNWINTER 原理以枚举Season为例，分析一下枚举的底层。表面上看，一个枚举很简单： 12345678910public enum Season &#123; //春 SPRING, //夏 SUMMER, //秋 AUTUMN, //冬 WINTER;&#125; 实际上编译器在编译的时候做了很多动作，我们使用javap -v对Season.class文件反编译，可以看到很多细节。 首先我们看到枚举是继承了抽象类Enum的类。 1Season extends java.lang.Enum&lt;Season&gt; 第二，通过一段静态代码块初始化枚举。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=4, locals=0, args_size=0 0: new #4 // class io/github/yehongzhi/user/redisLock/Season 3: dup 4: ldc #7 // String SPRING 6: iconst_0 7: invokespecial #8 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V 10: putstatic #9 // Field SPRING:Lio/github/yehongzhi/user/redisLock/Season; 13: new #4 // class io/github/yehongzhi/user/redisLock/Season 16: dup 17: ldc #10 // String SUMMER 19: iconst_1 20: invokespecial #8 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V 23: putstatic #11 // Field SUMMER:Lio/github/yehongzhi/user/redisLock/Season; 26: new #4 // class io/github/yehongzhi/user/redisLock/Season 29: dup 30: ldc #12 // String AUTUMN 32: iconst_2 33: invokespecial #8 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V 36: putstatic #13 // Field AUTUMN:Lio/github/yehongzhi/user/redisLock/Season; 39: new #4 // class io/github/yehongzhi/user/redisLock/Season 42: dup 43: ldc #14 // String WINTER 45: iconst_3 46: invokespecial #8 // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V 49: putstatic #15 // Field WINTER:Lio/github/yehongzhi/user/redisLock/Season; 52: iconst_4 53: anewarray #4 // class io/github/yehongzhi/user/redisLock/Season 56: dup 57: iconst_0 58: getstatic #9 // Field SPRING:Lio/github/yehongzhi/user/redisLock/Season; 61: aastore 62: dup 63: iconst_1 64: getstatic #11 // Field SUMMER:Lio/github/yehongzhi/user/redisLock/Season; 67: aastore 68: dup 69: iconst_2 70: getstatic #13 // Field AUTUMN:Lio/github/yehongzhi/user/redisLock/Season; 73: aastore 74: dup 75: iconst_3 76: getstatic #15 // Field WINTER:Lio/github/yehongzhi/user/redisLock/Season; 79: aastore 80: putstatic #1 // Field $VALUES:[Lio/github/yehongzhi/user/redisLock/Season; 83: return 这段静态代码块的作用就是生成四个静态常量字段的值，还生成了$VALUES字段，用于保存枚举类定义的枚举常量。相当于执行了以下代码： 123456789Season SPRING = new Season1();Season SUMMER = new Season2();Season AUTUMN = new Season3();Season WINTER = new Season4();Season[] $VALUES = new Season[4];$VALUES[0] = SPRING;$VALUES[1] = SUMMER;$VALUES[2] = AUTUMN;$VALUES[3] = WINTER; 第三个，关于values()方法，这是一个静态方法，作用是返回该枚举类的数组，底层实现原理，其实是这样的。 123456public static io.github.yehongzhi.user.redisLock.Season[] values(); Code: 0: getstatic #1 // Field $VALUES:[Lio/github/yehongzhi/user/redisLock/Season; 3: invokevirtual #2 // Method &quot;[Lio/github/yehongzhi/user/redisLock/Season;&quot;.clone:()Ljava/lang/Object; 6: checkcast #3 // class &quot;[Lio/github/yehongzhi/user/redisLock/Season;&quot; 9: areturn 其实是将静态代码块初始化的$VALUES数组克隆一份，然后强转成Season[]返回。相当于这样： 123public static Season[] values()&#123; return (Season[])$VALUES.clone();&#125; 所以表面上，只是加了一个enum关键字定义枚举，但是底层一旦确认是枚举类，则会由编译器对枚举类进行特殊处理，通过静态代码块初始化枚举，只要是枚举就一定会提供values()方法。 通过反编译我们也知道所有的枚举父类都是抽象类Enum，所以Enum有的成员变量，实现的接口，子类也会有。 所以只要是枚举都会有name，ordinal这两个字段，并且我们看Enum的构造器。 123456789/*** Sole constructor. Programmers cannot invoke this constructor.* It is for use by code emitted by the compiler in response to* enum type declarations.*/protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal;&#125; 翻译一下上面那段英文，意思大概是：唯一的构造器，程序员没法调用此构造器，它是供编译器响应枚举类型声明而使用的。得出结论，枚举实例的创建也是由编译器完成的。 枚举实现单例很多人都说，枚举类是最好的实现单例的一种方式，因为枚举类的单例是线程安全，并且是唯一一种不会被破坏的单例模式实现。也就是不能通过反射的方式创建实例，保证了整个应用中只有一个实例，非常硬核的单例。 1234567891011121314151617181920212223242526272829public class SingletonObj &#123; //内部类使用枚举 private enum SingletonEnum &#123; INSTANCE; private SingletonObj singletonObj; //在枚举类的构造器里初始化singletonObj SingletonEnum() &#123; singletonObj = new SingletonObj(); &#125; private SingletonObj getSingletonObj() &#123; return singletonObj; &#125; &#125; //对外部提供的获取单例的方法 public static SingletonObj getInstance() &#123; //获取单例对象，返回 return SingletonEnum.INSTANCE.getSingletonObj(); &#125; //测试 public static void main(String[] args) &#123; SingletonObj a = SingletonObj.getInstance(); SingletonObj b = SingletonObj.getInstance(); System.out.println(a == b);//true &#125;&#125; 假如有人想通过反射创建枚举类呢，我们以Season枚举为例。 1234567public static void main(String[] args) throws Exception &#123; Constructor&lt;Season&gt; constructor = Season.class.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); //通过反射调用构造器，创建枚举 Season season = constructor.newInstance(&quot;NEW_SPRING&quot;, 4); System.out.println(season);&#125; 然后就会报错，因为不允许对枚举的构造器使用反射调用。 查看源码，就可以看到，有个专门针对枚举的if判断。 12345678910111213141516171819public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException &#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; //判断是否是枚举，如果是枚举的话，报、抛出异常 if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) //抛出异常，不能通过反射创建枚举 throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125; 总结枚举看起来好像是很小一部分的知识，其实深入挖掘的话，我们会发现还是有很多地方值得学习的。第一点使用枚举定义常量更容易扩展，而且代码可读性更强，维护性更好。接着第二点是需要了解枚举自带的方法。第三点通过反编译，探索编译器在编译阶段为枚举做了什么事情。最后再讲一下枚举实现单例模式的例子。 这篇文章讲到这里了，感谢大家的阅读，希望看完这篇文章能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"Java基础/hashcode和equals区别与联系","date":"2021-08-04T03:20:10.977Z","updated":"2021-08-04T03:17:18.480Z","comments":true,"path":"2021/08/04/Java基础/hashcode和equals区别与联系/","link":"","permalink":"https://alloceee.github.io/2021/08/04/Java%E5%9F%BA%E7%A1%80/hashcode%E5%92%8Cequals%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 写在前面其实很早我就注意到阿里巴巴Java开发规范有一句话：只要重写 equals，就必须重写 hashCode。 我想很多人都会问为什么，所谓知其然知其所以然，对待知识不单止知道结论还得知道原因。 hashCode方法hashCode()方法的作用是获取哈希码，返回的是一个int整数 学过数据结构的都知道，哈希码的作用是确定对象在哈希表的索引下标。比如HashSet和HashMap就是使用了hashCode方法确定索引下标。如果两个对象返回的hashCode相同，就被称为“哈希冲突”。 equals方法equals()方法的作用很简单，就是判断两个对象是否相等，equals()方法是定义在Object类中，而所有的类的父类都是Object，所以如果不重写equals方法则会调用Object类的equals方法。 Object类的equals方法是用“==”号进行比较，在很多时候，因为==号比较的是两个对象的内存地址而不是实际的值，所以不是很符合业务要求。所以很多时候我们需要重写equals方法，去比较对象中每一个成员变量的值是否相等。 问题来了 重写equals()方法就可以比较两个对象是否相等，为什么还要重写hashcode()方法呢？ 因为HashSet、HashMap底层在添加元素时，会先判断对象的hashCode是否相等，如果hashCode相等才会用equals()方法比较是否相等。换句话说，HashSet和HashMap在判断两个元素是否相等时，会先判断hashCode，如果两个对象的hashCode不同则必定不相等。 下面我们做一个试验，有一个User类，只重写equals()方法，然后放到Set集合中去重。 1234567891011121314151617181920212223242526public class User &#123; private String id; private String name; private Integer age; public User(String id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return Objects.equals(id, user.id) &amp;&amp; Objects.equals(name, user.name) &amp;&amp; Objects.equals(age, user.age); &#125; //getter、setter、toString方法&#125; 然后我们循环创建10个成员变量的值都是一样的User对象，最后放到Set集合中去重。 12345678910111213public static void main(String[] args) &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; User user = new User(&quot;1&quot;, &quot;张三&quot;, 18); list.add(user); &#125; Set&lt;User&gt; set = new HashSet&lt;&gt;(list); for (User user : set) &#123; System.out.println(user); &#125; List&lt;User&gt; users = list.stream().distinct().collect(Collectors.toList()); System.out.println(users);&#125; 按道理我们预期会去重，只剩下一个“张三”的user，但实际上因为没有重写hashCode方法，所以没有去重。 接着我们在User类里面重写一些hashCode方法再试试，其他不变。 123456789public class User &#123; //其他不变 //重写hashCode方法 @Override public int hashCode() &#123; return Objects.hash(id, name, age); &#125;&#125; 再运行，结果正确。 究其原因在于HashSet会先判断hashCode是否相等，如果hashCode不相等就直接认为两个对象不相等，不会再用equals()比较了。我们不妨看看重写hashCode方法和不重写hashCode方法的哈希码。 这是不重写hashCode方法的情况，每个user对象的哈希码都不一样，所以HashSet会认为都不相等。 这是重写hashCode方法的情况，因为是用对象所有的成员变量的值计算出的哈希码，所以只要两个对象的成员变量都是相等的，则生成的哈希码是相同的。 那么有些人看到这里，就会问，如果两个对象返回的哈希码都是一样的话，是不是就一定相等？ 答案是不一定的，因为HashSet、HashMap判断哈希码相等后还会再用equals()方法判断。 总而言之： 哈希码不相等，则两个对象一定不相同。 哈希码相等，两个对象不一定相同。 两个对象相同，则哈希码和值都一定相等。 总结所以回到开头讲的那句，只要重写 equals，就必须重写 hashCode，这是一个很重要的细节，如果不注意的话，很容易发生业务上的错误。 特别是有时候我们明明用了HashSet，distinct()去重，但是就是不生效，这时应该回头看看重写了equals()和hashCode()方法了吗？ 那么这篇文章就写到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[]},{"title":"","slug":"搜索引擎/【300期】Elasticsearch 是如何做到快速检索的","date":"2021-08-03T09:49:49.140Z","updated":"2021-07-14T03:46:13.049Z","comments":true,"path":"2021/08/03/搜索引擎/【300期】Elasticsearch 是如何做到快速检索的/","link":"","permalink":"https://alloceee.github.io/2021/08/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/%E3%80%90300%E6%9C%9F%E3%80%91Elasticsearch%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%BF%AB%E9%80%9F%E6%A3%80%E7%B4%A2%E7%9A%84/","excerpt":"","text":"【300期】Elasticsearch 是如何做到快速检索的一、前言本文大致包括一下内容： 关于搜索 传统关系型数据库和ES的差别 搜索引擎原理 细究倒排索引 倒排索引具体是个什么样子的（posting list -&gt;term dic-&gt;term index） 关于postings list的一些巧技（FOR、Roaring Bitmaps） 如何快速做联合查询 二、关于搜索先设想一个关于搜索的场景，假设我们要搜索一首诗句内容中带“前”字的古诗， 用 传统关系型数据库和 ES 实现会有什么差别？ 如果用像 MySQL 这样的 RDBMS 来存储古诗的话，我们应该会去使用这样的 SQL 去查询 1select name from poems where content like &quot;%前%&quot;; 这种我们称为顺序扫描法，需要遍历所有的记录进行匹配。 不但效率低，而且不符合我们搜索时的期望，比如我们在搜索“ABCD”这样的关键词时，通常还希望看到”A”,”AB”,”CD”,“ABC”的搜索结果。 于是乎就有了专业的搜索引擎，比如我们今天的主角 – ES。 搜索引擎原理搜索引擎的搜索原理简单概括的话可以分为这么几步， 内容爬取，停顿词过滤，比如一些无用的像“的”，“了”之类的语气词/连接词 内容分词，提取关键词 根据关键词建立倒排索引 用户输入关键词进行搜索 这里我们就引出了一个概念，也就是我们今天要剖析的重点 - 倒排索引。也是ES的核心知识点。 ES可以说是对Lucene的一个封装，里面关于倒排索引的时间就是通过lucene这个jar包提供的API实现的，所以下面讲的关于倒排索引的内容实际上都是lucene里面的内容。 三、倒排索引先看下建立倒排索引之后，我们上述的查询需求会变成什么样子 这样我们一输入“前”，借助倒排索引就可以直接定位到符合查询条件的古诗。 当然这只是一个很大白话的形式来描述倒排索引的简要工作原理。在 ES 中，这个倒排索引是具体是个什么样的，怎么存储的等等，这些才是倒排索引的精华内容。推荐：250期面试题 1. 几个概念在进入下文之前，先描述几个前置概念。 term关键词这个东西是我自己的讲法，在 ES 中，关键词被称为 term。 postings list还是用上面的例子，&#123;静夜思, 望庐山瀑布&#125;是 “前” 这个 term 所对应列表。在 ES 中，这些被描述为所有包含特定 term 文档的 id 的集合。由于整型数字 integer 可以被高效压缩的特质，integer 是最适合放在 postings list 作为文档的唯一标识的，ES 会对这些存入的文档进行处理，转化成一个唯一的整型 id。 再说下这个 id 的范围，在存储数据的时候，在每一个 shard 里444444面，ES 会将数据存入不同的 segment，这是一个比 shard 更小的分片单位，这些 segment 会定期合并。在每一个 segment 里面都会保存最多 2^31 个文档，每个文档被分配一个唯一的 id，从0到(2^31)-1。 相关的名词都是 ES 官方文档给的描述，后面参考材料中都可以找到出处。 2. 索引内部结构上面所描述的倒排索引，仅仅是一个很粗糙的模型。真的要在实际生产中使用，当然还差的很远。 在实际生产场景中，比如 ES 最常用的日志分析，日志内容进行分词之后，可以得到多少的 term？ 那么如何快速的在海量 term 中查询到对应的 term 呢？遍历一遍显然是不现实的。 term dictionary于是乎就有了 term dictionary，ES 为了能快速查找到 term，将所有的 term 排了一个序，二分法查找。是不是感觉有点眼熟，这不就是 MySQL 的索引方式的，直接用 B+树建立索引词典指向被索引的数据。 term index但是问题又来了，你觉得 Term Dictionary 应该放在哪里？肯定是放在内存里面吧？磁盘 io 那么慢。就像 MySQL 索引就是存在内存里面了。 但是如果把整个 term dictionary 放在内存里面会有什么后果呢？ 内存爆了… 别忘了，ES 默认可是会对全部 text 字段进行索引，必然会消耗巨大的内存，为此 ES 针对索引进行了深度的优化。在保证执行效率的同时，尽量缩减内存空间的占用。 于是乎就有了 term index。 Term index从数据结构上分类算是一个“Trie树”，也就是我们常说的字典树。这是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。 这棵树不会包含所有的term，它包含的是term的一些前缀（这也是字典树的使用场景，公共前缀）。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。就像右边这个图所表示的。（类似英文字典，首先定位S开头的一个单词，或者定位到Sh开头的一个单词，然后再往后顺序查询）。 lucene在这里还做了两点优化，一是term dictionary在磁盘上面是分block保存的，一个block内部利用公共前缀压缩，比如都是Ab开头的单词就可以把Ab省去。二是term index在内存中是以FST（finite state transducers）的数据结构保存的。 FST有两个优点： 空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间 查询速度快。O(len(str))的查询时间复杂度 FST 的理论比较复杂，本文不细讲 延伸阅读：https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/ OK，现在我们能得到 lucene 倒排索引大致是个什么样子的了。 四、关于postings list的一些技巧在实际使用中，postings list还需要解决几个痛点， postings list如果不进行压缩，会非常占用磁盘空间 联合查询下，如何快速求交并集（intersections and unions） 对于如何压缩，可能会有人觉得没有必要，”posting list 不是已经只存储文档 id 了吗？还需要压缩？”，但是如果在 posting list 有百万个 doc id 的情况，压缩就显得很有必要了。（比如按照朝代查询古诗？），至于为啥需要求交并集，ES 是专门用来搜索的，肯定会有很多联合查询的需求吧 （AND、OR）。 按照上面的思路，我们先将如何压缩。 1. 压缩Frame of Reference在 lucene 中，要求 postings lists 都要是有序的整形数组。这样就带来了一个很好的好处，可以通过 增量编码（delta-encode）这种方式进行压缩。 比如现在有 id 列表 [73, 300, 302, 332, 343, 372]，转化成每一个 id 相对于前一个 id 的增量值（第一个 id 的前一个 id 默认是 0，增量就是它自己）列表是[73, 227, 2, 30, 11, 29]。在这个新的列表里面，所有的 id 都是小于 255 的，所以每个 id 只需要一个字节存储。 实际上 ES 会做的更加精细， 它会把所有的文档分成很多个 block，每个 block 正好包含 256 个文档，然后单独对每个文档进行增量编码，计算出存储这个 block 里面所有文档最多需要多少位来保存每个 id，并且把这个位数作为头信息（header）放在每个 block 的前面。这个技术叫 Frame of Reference。 上图也是来自于 ES 官方博客中的一个示例（假设每个 block 只有 3 个文件而不是 256）。 FOR 的步骤可以总结为： 进过最后的位压缩之后，整型数组的类型从固定大小 (8,16,32,64 位)4 种类型,扩展到了[1-64] 位共 64 种类型。 通过以上的方式可以极大的节省 posting list 的空间消耗，提高查询性能。不过 ES 为了提高 filter 过滤器查询的性能，还做了更多的工作，那就是缓存。 Roaring Bitmaps（for filter cache）在ES中，可以用filters来优化查询，filter查询只处理文档是否匹配与否，不涉及文档评分操作，查询的结果可以被缓存。 对于filter查询，es提供了filter cache这种特殊的缓存，filter cache用来存储filters得到的结果集。缓存filters不需要太多的内存，它只保留一种信息，即哪些文档与filter相匹配。同时它可以由其他的查询服用，极大地提升了查询的性能。 我们上面提到的 Frame Of Reference 压缩算法对于 postings list 来说效果很好，但对于需要存储在内存中的 filter cache 等不太合适。 filter cache 会存储那些经常使用的数据，针对 filter 的缓存就是为了加速处理效率，对压缩算法要求更高。 对于这类postings list，ES采用不一样的压缩方式。 首先我们知道 postings list 是 Integer 数组，具有压缩空间。 假设有这么一个数组，我们第一个压缩的思路是什么？用位的方式来表示，每个文档对应其中的一位，也就是我们常说的位图，bitmap。 它经常被作为索引用在数据库、查询索引和搜索引擎中，并且位操作（如and求交集、or求并集）之间可以并行，效率更好。 但是，位图有个很明显的缺点，不管业务中实际的元素基数有多少，它占用的内存空间都恒定不变。也就是说不适用于稀疏存储。业内对于稀疏位图也有很多成熟的压缩方案，lucene 采用的就是roaring bitmaps。推荐：250期面试题 我这里用简单的方式描述一下这个压缩过程是怎么样， 将 doc id 拆成高 16 位，低 16 位。对高位进行聚合 (以高位做 key，value 为有相同高位的所有低位数组)，根据低位的数据量 (不同高位聚合出的低位数组长度不相同)，使用不同的 container(数据结构) 存储。 len&lt;4096 ArrayContainer 直接存值 len&gt;=4096 BitmapContainer 使用 bitmap 存储 分界线的来源：value 的最大总数是为2^16=65536. 假设以 bitmap 方式存储需要 65536bit=8kb,而直接存值的方式，一个值 2 byte，4K 个总共需要2byte*4K=8kb。所以当 value 总量 &lt;4k 时,使用直接存值的方式更节省空间。 空间压缩主要体现在: 高位聚合（假设数据中有100w个高位相同的值，原先需要100w_2byte，现在只要1_2byte） 低位压缩 缺点就是于位操作的速度相对于原生的bitmap会有影响。 这就是trade-off呀，平衡的艺术。 2.联合查询讲完了压缩，我们再来讲讲联合查询。 先讲简单的，如果查询有 filter cache，那就是直接拿 filter cache 来做计算，也就是说位图来做 AND 或者 OR 的计算。 如果查询的 filter 没有缓存，那么就用 skip list 的方式去遍历磁盘上的 postings list。 以上是三个 posting list。我们现在需要把它们用 AND 的关系合并，得出 posting list 的交集。首先选择最短的 posting list，逐个在另外两个 posting list 中查找看是否存在，最后得到交集的结果。遍历的过程可以跳过一些元素，比如我们遍历到绿色的 13 的时候，就可以跳过蓝色的 3 了，因为 3 比 13 要小。 用skip list还会带来一个好处，还记得前面说的吗，postings list 在磁盘里面是采用 FOR 的编码方式存储的 会把所有的文档分成很多个 block，每个 block 正好包含 256 个文档，然后单独对每个文档进行增量编码，计算出存储这个 block 里面所有文档最多需要多少位来保存每个 id，并且把这个位数作为头信息（header）放在每个 block 的前面。 因为这个 FOR 的编码是有解压缩成本的。利用 skip list，除了跳过了遍历的成本，也跳过了解压缩这些压缩过的 block 的过程，从而节省了 cpu。推荐：250期面试题 五、总结 为了能够快速定位到目标文档，ES使用倒排索引技术来优化搜索速度，虽然空间消耗比较大，但是搜索性能提高十分显著。 为了能够在数量巨大的terms中快速定位到某一个term，同时节约对内存的使用和减少磁盘io的读取，lucene使用”term index -&gt; term dictionary -&gt; posting list”的倒排索引结构，通过FST压缩放入内存，进一步提高搜索效率。 为了减少posting list的磁盘消耗，lucene使用了FOR(Frame of Reference)技术压缩，带来的压缩效果十分明显。 ES的filter语句采用了Roaring Bitmap技术来缓存搜索结果，保证高频filter查询速度的同时降低存储空间消耗。 在联合查询时，在有filter cache的情况下，会直接利用位图的原生特性快速求交并集得到联合查询结果，否则使用skip list对多个posting list求交并集，跳过遍历成本并且节省部分数据的解压缩cpu成本。 Elaticsearch的索引思路 将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数（同时也利用磁盘顺序读特性），结合各种压缩算法，用及其苛刻的态度使用内存。 所以，对于使用Elasticsearch进行索引时需要注意： 不需要索引的字段，一定要明确定义出来，因为默示是自动建索引的 同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的 选择有规律的ID很重要，随机性太大的ID（比如Java的UUID）不利于查询 最后说一下，技术选型永远伴随着业务场景的考量，每种数据库都有自己要解决的问题（或者说擅长的领域），对应的就有自己的数据结构，而不同的使用场景和数据结构，需要用不同的索引，才能起到最大化加快查询的目的。 这篇文章讲的虽是 Lucene 如何实现倒排索引，如何精打细算每一块内存、磁盘空间、如何用诡谲的位运算加快处理速度，但往高处思考，再类比一下 MySQL，你就会发现，虽然都是索引，但是实现起来，截然不同。笼统的来说，b-tree 索引是为写入优化的索引结构。当我们不需要支持快速的更新的时候，可以用预先排序等方式换取更小的存储空间，更快的检索速度等好处，其代价就是更新慢，就像 ES。 希望本篇文章能给你带来一些收获~ 参考文档 https://www.elastic.co/cn/blog/frame-of-reference-and-roaring-bitmaps https://www.elastic.co/cn/blog/found-elasticsearch-from-the-bottom-up http://blog.mikemccandless.com/2014/05/choosing-fast-unique-identifier-uuid.html https://www.infoq.cn/article/database-timestamp-02 https://zhuanlan.zhihu.com/p/137574234","categories":[],"tags":[]},{"title":"ES 不香吗，为啥还要 ClickHouse？","slug":"搜索引擎/ES 不香吗，为啥还要 ClickHouse？","date":"2021-08-03T03:50:35.924Z","updated":"2021-08-04T03:10:55.359Z","comments":true,"path":"2021/08/03/搜索引擎/ES 不香吗，为啥还要 ClickHouse？/","link":"","permalink":"https://alloceee.github.io/2021/08/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/ES%20%E4%B8%8D%E9%A6%99%E5%90%97%EF%BC%8C%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%20ClickHouse%EF%BC%9F/","excerpt":"Elasticsearch 是一个实时的分布式搜索分析引擎，它的底层是构建在 Lucene 之上的。简单来说是通过扩展 Lucene 的搜索能力，使其具有分布式的功能。 ES通常会和其他两个开源组件Logstash（日志采集）和Kibana（仪表盘）一起提供端到端的日志/搜索分析的功能，常常被简称为ELK。","text":"Elasticsearch 是一个实时的分布式搜索分析引擎，它的底层是构建在 Lucene 之上的。简单来说是通过扩展 Lucene 的搜索能力，使其具有分布式的功能。 ES通常会和其他两个开源组件Logstash（日志采集）和Kibana（仪表盘）一起提供端到端的日志/搜索分析的功能，常常被简称为ELK。 关于OLAP利器Clickhouse是俄罗斯搜索巨头Yandex开发的面向列式存储的关系型数据库。ClickHouse是过去两年中OLAP领域中最热门的，并与2016年开源。 ES是最为流行的大数据日志和搜索解决方案，但是近几年来，它的江湖地位受到了一些挑战，许多公司已经开始把自己的日志解决方案从ES迁移到了Clickhouse，这里就包括：携程，快手等公司。 架构和设计的对比ES的底层是Lucene，主要是要解决搜索的问题。搜索是大数据领域要解决的一个常见的问题，就是在海量的数据量要如何按照条件找到需要的数据。搜索的核心技术是倒排索引和布隆过滤器。 ES通过分布式技术，利用分片与副本机制，直接解决了集群下搜索性能与高可用的问题。 ElasticSearch 是为分布式设计的，有很好的扩展性，在一个典型的分布式配置中，每一个节点（node）可以配制成不同的角色。 如上图所示： Client Node，负责API和数据的访问的节点，不存储/处理数据 Data Node，负责数据的存储和索引 Master Node，管理节点，负责Cluster中的节点的协调，不存储数据 ClickHouse是基于MPP架构的分布式ROLAP（关系OLAP）分析引擎。每个节点都有相同的责任，并负责部分数据处理（不共享任何内容）。 ClickHouse是一个真正的列式数据库管理系统（DBMS）。在ClickHouse中，数据始终是按列存储的，包括矢量（向量或列块）执行的过程。 让查询变得更快，最简单且有效地方法是减少数据扫描范围和数据传输时的大小，而列式存储和数据压缩就可以帮助实现上述两点。 ClickHouse同时使用了日志合并树，稀疏索引和CPU功能（如SIMD单指令多数据）充分发挥了硬件优势，可实现高效的计算。 ClickHouse使用Zookeeper进行分布式节点之间的协调。 为了支持搜索，Clickhouse 同样支持布隆过滤器。 查询对比实战为了对比 ES 和 Clickhouse 的基本查询能力的差异，我写了一些代码来验证： 1https://github.com/gangtao/esvsch 这个测试的架构如下： 架构主要有四个部分组成： ①ES stack ES stack 有一个单节点的 Elastic 的容器和一个 Kibana 容器组成，Elastic 是被测目标之一，Kibana 作为验证和辅助工具。 部署代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445version: &#x27;3.7&#x27;services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.4.0 container_name: elasticsearch environment: - xpack.security.enabled=false - discovery.type=single-node ulimits: memlock: soft: -1 hard: -1 nofile: soft: 65536 hard: 65536 cap_add: - IPC_LOCK volumes: - elasticsearch-data:/usr/share/elasticsearch/data ports: - 9200:9200 - 9300:9300 deploy: resources: limits: cpus: &#x27;4&#x27; memory: 4096M reservations: memory: 4096M kibana: container_name: kibana image: docker.elastic.co/kibana/kibana:7.4.0 environment: - ELASTICSEARCH_HOSTS=http://elasticsearch:9200 ports: - 5601:5601 depends_on: - elasticsearchvolumes: elasticsearch-data: driver: local ②Clickhouse stack Clickhouse stack 有一个单节点的 Clickhouse 服务容器和一个 TabixUI 作为 Clickhouse 的客户端。 部署代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748version: &quot;3.7&quot;services: clickhouse: container_name: clickhouse image: yandex/clickhouse-server volumes: - ./data/config:/var/lib/clickhouse ports: - &quot;8123:8123&quot; - &quot;9000:9000&quot; - &quot;9009:9009&quot; - &quot;9004:9004&quot; ulimits: nproc: 65535 nofile: soft: 262144 hard: 262144 healthcheck: test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;-q&quot;, &quot;localhost:8123/ping&quot;] interval: 30s timeout: 5s retries: 3 deploy: resources: limits: cpus: &#x27;4&#x27; memory: 4096M reservations: memory: 4096M tabixui: container_name: tabixui image: spoonest/clickhouse-tabix-web-client environment: - CH_NAME=dev - CH_HOST=127.0.0.1:8123 - CH_LOGIN=default ports: - &quot;18080:80&quot; depends_on: - clickhouse deploy: resources: limits: cpus: &#x27;0.1&#x27; memory: 128M reservations: memory: 128M ②Clickhouse stack Clickhouse stack 有一个单节点的 Clickhouse 服务容器和一个 TabixUI 作为 Clickhouse 的客户端。 部署代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748version: &quot;3.7&quot;services: clickhouse: container_name: clickhouse image: yandex/clickhouse-server volumes: - ./data/config:/var/lib/clickhouse ports: - &quot;8123:8123&quot; - &quot;9000:9000&quot; - &quot;9009:9009&quot; - &quot;9004:9004&quot; ulimits: nproc: 65535 nofile: soft: 262144 hard: 262144 healthcheck: test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;-q&quot;, &quot;localhost:8123/ping&quot;] interval: 30s timeout: 5s retries: 3 deploy: resources: limits: cpus: &#x27;4&#x27; memory: 4096M reservations: memory: 4096M tabixui: container_name: tabixui image: spoonest/clickhouse-tabix-web-client environment: - CH_NAME=dev - CH_HOST=127.0.0.1:8123 - CH_LOGIN=default ports: - &quot;18080:80&quot; depends_on: - clickhouse deploy: resources: limits: cpus: &#x27;0.1&#x27; memory: 128M reservations: memory: 128M ③数据导入 stack 数据导入部分使用了 Vector.dev 开发的 vector，该工具和 fluentd 类似，都可以实现数据管道式的灵活的数据导入。 ④测试控制 stack 测试控制我使用了 Jupyter，使用了 ES 和 Clickhouse 的 Python SDK 来进行查询的测试。 用 Docker compose 启动 ES 和 Clickhouse 的 stack 后，我们需要导入数据，我们利用 Vector 的 generator 功能，生成 syslog，并同时导入 ES 和 Clickhouse。 在这之前，我们需要在 Clickhouse 上创建表。ES 的索引没有固定模式，所以不需要事先创建索引。 创建表的代码如下： 1234567891011121314CREATE TABLE default.syslog( application String, hostname String, message String, mid String, pid String, priority Int16, raw String, timestamp DateTime(&#x27;UTC&#x27;), version Int16) ENGINE = MergeTree() PARTITION BY toYYYYMMDD(timestamp) ORDER BY timestamp TTL timestamp + toIntervalMonth(1); 创建好表之后，我们就可以启动 vector，向两个 stack 写入数据了。vector 的数据流水线的定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[sources.in] type = &quot;generator&quot; format = &quot;syslog&quot; interval = 0.01 count = 100000[transforms.clone_message] type = &quot;add_fields&quot; inputs = [&quot;in&quot;] fields.raw = &quot;&#123;&#123; message &#125;&#125;&quot;[transforms.parser] # General type = &quot;regex_parser&quot; inputs = [&quot;clone_message&quot;] field = &quot;message&quot; # optional, default patterns = [&#x27;^&lt;(?P&lt;priority&gt;\\d*)&gt;(?P&lt;version&gt;\\d) (?P&lt;timestamp&gt;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;T\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;\\.\\d&#123;3&#125;Z) (?P&lt;hostname&gt;\\w+\\.\\w+) (?P&lt;application&gt;\\w+) (?P&lt;pid&gt;\\d+) (?P&lt;mid&gt;ID\\d+) - (?P&lt;message&gt;.*)$&#x27;][transforms.coercer] type = &quot;coercer&quot; inputs = [&quot;parser&quot;] types.timestamp = &quot;timestamp&quot; types.version = &quot;int&quot; types.priority = &quot;int&quot;[sinks.out_console] # General type = &quot;console&quot; inputs = [&quot;coercer&quot;] target = &quot;stdout&quot; # Encoding encoding.codec = &quot;json&quot; [sinks.out_clickhouse] host = &quot;http://host.docker.internal:8123&quot; inputs = [&quot;coercer&quot;] table = &quot;syslog&quot; type = &quot;clickhouse&quot; encoding.only_fields = [&quot;application&quot;, &quot;hostname&quot;, &quot;message&quot;, &quot;mid&quot;, &quot;pid&quot;, &quot;priority&quot;, &quot;raw&quot;, &quot;timestamp&quot;, &quot;version&quot;] encoding.timestamp_format = &quot;unix&quot;[sinks.out_es] # General type = &quot;elasticsearch&quot; inputs = [&quot;coercer&quot;] compression = &quot;none&quot; endpoint = &quot;http://host.docker.internal:9200&quot; index = &quot;syslog-%F&quot; # Encoding # Healthcheck healthcheck.enabled = true 这里简单介绍一下这个流水线： source.in：生成 syslog 的模拟数据，生成 10w 条，生成间隔和 0.01 秒。 transforms.clone_message：把原始消息复制一份，这样抽取的信息同时可以保留原始消息。 transforms.parser：使用正则表达式，按照 syslog 的定义，抽取出 application，hostname，message，mid，pid，priority，timestamp，version 这几个字段。 transforms.coercer：数据类型转化。 sinks.out_console：把生成的数据打印到控制台，供开发调试。 sinks.out_clickhouse：把生成的数据发送到Clickhouse。 sinks.out_es：把生成的数据发送到 ES。 运行 Docker 命令，执行该流水线： 1234docker run \\ -v $(mkfile_path)/vector.toml:/etc/vector/vector.toml:ro \\ -p 18383:8383 \\ timberio/vector:nightly-alpine 数据导入后，我们针对一下的查询来做一个对比。ES 使用自己的查询语言来进行查询，Clickhouse 支持 SQL，我简单测试了一些常见的查询，并对它们的功能和性能做一些比较。 返回所有的记录： 123456789# ES&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;&#125;# Clickhouse &quot;SELECT * FROM syslog&quot; 匹配单个字段： 1234567891011# ES&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;hostname&quot;:&quot;for.org&quot; &#125; &#125;&#125;# Clickhouse &quot;SELECT * FROM syslog WHERE hostname=&#x27;for.org&#x27;&quot; 匹配多个字段： 123456789101112131415# ES&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;:&quot;up.com ahmadajmi&quot;, &quot;fields&quot;:[ &quot;hostname&quot;, &quot;application&quot; ] &#125; &#125;&#125;# Clickhouse、&quot;SELECT * FROM syslog WHERE hostname=&#x27;for.org&#x27; OR application=&#x27;ahmadajmi&#x27;&quot; 范围查询，查找版本大于 2 的记录： 1234567891011121314# ES&#123; &quot;query&quot;:&#123; &quot;range&quot;:&#123; &quot;version&quot;:&#123; &quot;gte&quot;:2 &#125; &#125; &#125;&#125;# Clickhouse&quot;SELECT * FROM syslog WHERE version &gt;= 2&quot; 查找到存在某字段的记录： 1234567891011# ES&#123; &quot;query&quot;:&#123; &quot;exists&quot;:&#123; &quot;field&quot;:&quot;application&quot; &#125; &#125;&#125;# Clickhouse&quot;SELECT * FROM syslog WHERE application is not NULL&quot; ES 是文档类型的数据库，每一个文档的模式不固定，所以会存在某字段不存在的情况；而 Clickhouse 对应为字段为空值。 正则表达式查询，查询匹配某个正则表达式的数据： 12345678910111213141516# ES&#123; &quot;query&quot;:&#123; &quot;regexp&quot;:&#123; &quot;hostname&quot;:&#123; &quot;value&quot;:&quot;up.*&quot;, &quot;flags&quot;:&quot;ALL&quot;, &quot;max_determinized_states&quot;:10000, &quot;rewrite&quot;:&quot;constant_score&quot; &#125; &#125; &#125;&#125;# Clickhouse&quot;SELECT * FROM syslog WHERE match(hostname, &#x27;up.*&#x27;)&quot; 聚合计数，统计某个字段出现的次数： 12345678910111213# ES&#123; &quot;aggs&quot;:&#123; &quot;version_count&quot;:&#123; &quot;value_count&quot;:&#123; &quot;field&quot;:&quot;version&quot; &#125; &#125; &#125;&#125;# Clickhouse&quot;SELECT count(version) FROM syslog&quot; 聚合不重复的值，查找所有不重复的字段的个数： 12345678910111213# ES&#123; &quot;aggs&quot;:&#123; &quot;my-agg-name&quot;:&#123; &quot;cardinality&quot;:&#123; &quot;field&quot;:&quot;priority&quot; &#125; &#125; &#125;&#125;# Clickhouse&quot;SELECT count(distinct(priority)) FROM syslog &quot; 我用 Python 的 SDK，对上述的查询在两个 Stack 上各跑 10 次，然后统计查询的性能结果。 我们画出出所有的查询的响应时间的分布： 总查询时间的对比如下： 通过测试数据我们可以看出 Clickhouse 在大部分的查询的性能上都明显要优于 Elastic。 在正则查询（Regex query）和单词查询（Term query）等搜索常见的场景下，也并不逊色。 在聚合场景下，Clickhouse 表现异常优秀，充分发挥了列村引擎的优势。 注意，我的测试并没有任何优化，对于 Clickhouse 也没有打开布隆过滤器。可见 Clickhouse 确实是一款非常优秀的数据库，可以用于某些搜索的场景。 当然 ES 还支持非常丰富的查询功能，这里只有一些非常基本的查询，有些查询可能存在无法用 SQL 表达的情况。 总结本文通过对于一些基本查询的测试，对比了 Clickhouse 和 Elasticsearch 的功能和性能。 测试结果表明，Clickhouse 在这些基本场景表现非常优秀，性能优于 ES，这也解释了为什么用很多的公司应从 ES 切换到 Clickhouse 之上。","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://alloceee.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://alloceee.github.io/tags/ElasticSearch/"},{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://alloceee.github.io/tags/ClickHouse/"}],"author":"Alloceee"},{"title":"第4章 计算机网络","slug":"SystemArchitect/第4章：计算机网络","date":"2021-08-01T04:26:47.530Z","updated":"2021-08-10T03:07:51.720Z","comments":true,"path":"2021/08/01/SystemArchitect/第4章：计算机网络/","link":"","permalink":"https://alloceee.github.io/2021/08/01/SystemArchitect/%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"网络架构与协议三层模型三层模型主要将网路划分为核心层、汇聚层和接入层。每一层都有着特定的作用： 核心层提供不同区域或者下层的告诉连接和最优传递路径； 核心层是互联网络的高速骨干，由于其重要性，因此在设计中应该采用冗余组件设计，使其具备高可靠性，能快速适应变化。在设计核心层设备的功能时，应尽量避免使用数据包过滤、策略路由等降低数据包转发处理的特性，以优化核心层获得低延迟和良好的可管理性。 核心层应具有有限的和一致的范围，如果核心层覆盖的范围过大，连接的设备过多，必然引起网络的复杂度加大，导致网络管理性降低；同时，如果核心层覆盖的范围不一致，必然导致大量处理不一致情况的功能都在核心层网络设备中实现，会降低核心网络设备的性能。 对于那些需要连接因特网和外部网络的网络工程来说，核心层应包括一条或多条连接到外部网络的链接，这样可以实现外部连接的可管理性和高效性。 汇聚层将网络业务连接到接入层，并且实施与安全、流量负载和路由相关的策略； 接入层为局域网接入广域网或者终端用户访问网络提供接入； 网络生命周期网络的生命周期至少包括网络系统的构思计划、分析设计、实时运行和维护的过程。对于大多数网络系统来说，由于应用的不断发展，这些网络系统需要不断重复设计、实施、维护的过程。 网络逻辑结构设计是体现网络色剂核心思想的关键阶段，在这一阶段根据需求规范和通信规范，选择一种比较事宜的网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。 网络工程网络规划网络设计网络逻辑结构设计网络逻辑结构设计是体现网络设计核心思想的关键阶段，在这一阶段根据需求规范和通信规范，选择一种比较适宜的网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。 在逻辑网络设计阶段，需要描述满足用户需求的网络行为及性能，详细说明数据是如何在网络上传输的，此阶段不涉及网络元素的具体物理位置。网络设计者利用需求分析和现有网络体系分析的结果来设计逻辑网络结构。如果现有的软件、硬件不能满足新网络的需求，现有系统就必须升级。如果现有系统能继续运行使用，可以将它们集成到新设计中来。如果不集成旧系统，网络设计小组可以找一个新系统，对它进行测试，确定是否符合用户的需求。 此阶段最后应该得到一份逻辑网络设计文档。 网络物理结构设计物理网络设计是对逻辑网络设计的物理实现，通过对设备的具体物理分布、运行环境等的确定，确保网络的物理连接符合逻辑连接的要求。在这一阶段，网络设计者需要确定具体的软硬件、连接设备、布线和服务。 分层设计为了能够更好地分析与设计复杂的大型互连网络，在计算机网络设计中，主要采用分层（分级）设计模型，它类似于软件工程中的结构化设计。通过一些通用规则来设计网络，就可以简化设计、优化带宽的分配和规划。在分层设计中，引入了三个关键层的概念，分别是核心层、汇聚层和接入层。 通常将网络中直接面向用户连接或访问网络的部分称为接入层，将位于接入层和核心层之间的部分称为分布层或汇聚层。接入层的目的是允许终端用户连接到网络，因此，接入层交换机具有低成本和高端口密度特性。 汇聚层是核心层和接入层的分界面，完成网络访问策略控制、数据包处理、过滤、寻址，以及其他数据处理的任务。汇聚层交换机是多台接入层交换机的汇聚点，它必须能够处理来自接入层设备的所有通信量，并提供到核心层的上行链路，因此，汇聚层交换机与接入层交换机比较，需要更高的性能，更少的接口和更高的交换速率。 网络主干部分称为核心层，核心层的主要目的在于通过高速转发通信，提供优化、可靠的骨干传输结构，因此，核心层交换机应拥有更高的可靠性，性能和吞吐量。核心层为网络提供了骨干组件或高速交换组件，在纯粹的分层设计中，核心层只完成数据交换的特殊任务。需要根据网络需求的地理距离、信息流量和数据负载的轻重来选择核心层技术，常用的技术包括 ATM、100Base-Fx 和千兆以太网等。在主干网中，考虑到高可用性的需求，通常会使用双星（树）结构，即采用两台同样的交换机，与汇聚层交换机分别连接，并使用链路聚合技术实现双机互联。 层次化网络设计应该遵循一些简单的原则，这些原则可以保证设计出来的网络更加具有层层次的特性： 在设计时，设计者应该尽量控制层次化的程度。一般情况下，由核心层、汇聚层、接入层三个层次就足够了，过多的层次会导致整体网络性能的下降，并且会提高网络的延迟，但是方便网络故障排查和文档编写。 在接入层应当保持对网络结构的严格控制，接入层的用户总是为了获取更大的外部网络访问带宽，而随意申请其他的渠道访问外部网路是不允许的。 为了保证网络的层次性，不能在设计中随意加入额外链接，额外连接是指打破层次性，在不相邻层次间的连接，这些连接会导致网络中的各种问题，例如缺乏汇聚层的访问控制和数据包过滤等。 在进行设计时，应当首先设计接入层，根据流量负载、流量和行为的分析，对上层进行更精细的容量规划，再依次完成各上层的设计。 除去接入层的其他层次，应尽量采用模块化方式，每个层次由多个模块或者设备集合构成，每个模块间的边界应非常清晰。 DNS查询过程分为两种查询方式：递归查询和迭代查询 递归查询的查询方式为：当用户发出查询请求时，本地服务器要进行递归查询。这种查询方式要求服务器彻底地进行名字，并返回最后的结果——IP地址或错误信息。如果查询请求在本地服务器中不能完成，那么服务器就根据它的配置向域名树中的上级服务器进行查询，在最坏的情况下可能要查询到根服务器。每次查询返回的结果如果是其他名字服务器的IP地址，则本地服务器要把查询请求发送给这些服务器，故进一步的查询。 迭代查询的查询方式为：服务器与服务器之间的查询采用迭代的方式进行，发出查询请求的服务器得到的响应可能不是目标的IP地址，而是其他服务器的引用（名字和地址），那么本地服务器就要访问被引用的服务器，做进一步的查询。如此反复多次，每次都要接近目标的授权服务器，直至到最后的结果——目标的IP地址或错误信息。 根域名服务器为众多请求提供域名，若采用递归方式会大大影响性能。 DHCP如果发送给DHCP客户端的地址已经被其他DHCP客户端使用，客户端会向服务器发送DhcpDecline信息包拒绝接受已经分配的地址信息。 DHCPDecline: DHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用。 开放式数据存储系统开放式数据存储系统，要求采用专用网络连接并管理存储设备和存储管理子系统。针对这种应用，采用SAN存储方式最为合适。 直连式存储（Direct-Attached Storage，DAS）在服务器上外挂了一组大容量硬盘，存储设备与服务器上外挂了一组大容量硬盘，存储设备与服务器主机之间采用SCSI通道连接，带宽为IOMB/s，20MB/s，40MB/s和80MB/s等。直连式存储直接将存储设备连接到服务器上，这种方法难以扩展存储容量，并且不支持数据容错功能，当服务器出现异常时会造成数据丢失。 网络接入存储（Network Attached Storage，NAS）是将存储设备连接到现有的网络上，提供数据存储和文件访问服务的设备。NAS服务器是在专用主机上安装简化了的瘦操作系统（只具有访问权限控制、数据保护和恢复等功能）的文件服务器。NAS服务器内置了与网络连接所需要的协议，可以直接联网，具有权限的用户都可以通过网络访问NAS服务器中的文件。 存储区域网络（Storage Area Network，SAN）是一种连接存储设备和存储管理子系统的专用网络，专门提供数据存储和管理功能。SAN可以被看作是负责数据传输的后端网络，而前端网络（或称为数据网络）则负责正常的TCP/IP传输。也可以把SAN看作是通过特定的互连方式连接的若干台存储服务器组成的单独的数据网络，提供企业级的数据存储服务。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://alloceee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Alloceee"},{"title":"为什么MySQL使用B+树","slug":"数据库/MySQL/other/为什么MySQL使用B+树","date":"2021-07-27T09:10:38.662Z","updated":"2021-07-30T09:43:24.547Z","comments":true,"path":"2021/07/27/数据库/MySQL/other/为什么MySQL使用B+树/","link":"","permalink":"https://alloceee.github.io/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BD%BF%E7%94%A8B+%E6%A0%91/","excerpt":"在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，我们就以这两种数据结构为例，分析比较 B+ 树的优点。","text":"在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，我们就以这两种数据结构为例，分析比较 B+ 树的优点。 概述首先需要澄清的一点是，MySQL跟B+树没有直接的关系，真正与B+树有关系的是MySQL的默认存储引擎InnoDB，MySQL中存储引擎的主要作用是负责数据的存储和提取，除了InnoDB之外，MySQL中也支持MyISAM作为表的底层存储引擎。 我们在使用 SQL 语句创建表时就可以为当前表指定使用的存储引擎，你能在 MySQL 的文档 Alternative Storage Engines 中找到它支持的全部存储引擎，例如：MyISAM、CSV、MEMORY 等，然而默认情况下，使用如下所示的 SQL 语句来创建表就会得到 InnoDB 存储引擎支撑的表： 1234CREATE TABLE t1 ( a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB; 想要详细了解 MySQL 默认存储引擎的读者，可以通过之前的文章 『浅入浅出』MySQL 和 InnoDB 了解包括 InnoDB 存储方式、索引和锁等内容，我们在这里主要不会介绍 InnoDB 相关的过多内容。 我们今天最终将要分析的问题其实还是，为什么 MySQL 默认的存储引擎 InnoDB 会使用 MySQL 来存储数据，相信对MySQL稍微有些了解的人都知道，无论是表中的数据（主键索引）还是辅助索引最终都会使用B+树来存储数据，其中前者在表中会以&lt;id,row&gt;的方式存储，而后者会以&lt;index,id&gt;的方式进行存储，这其实也比较好理解： 在主键索引中，id是主键，我们能够通过id找到该行的全部列； 在辅助索引中，索引中的几个列构成了键，我们能够通过索引中的列找到id，如果有需要的话，可以再通过id找到当前数据行的全部内容； 对于InnoDB来说，所有的数据都是以键值对的方式存储的，主键索引和辅助索引在存储数据时都会将id和index作为键，将所有列和id作为键对应的值。 在具体分析 InnoDB 使用 B+ 树背后的原因之前，我们需要为 B+ 树找几个『假想敌』，因为如果我们只有一个选择，那么选择 B+ 树也并不值得讨论，找到的两个假想敌就是 B 树和哈希，相信这也是很多人会在面试中真实遇到的问题，我们就以这两种数据结构为例，分析比较 B+ 树的优点。 设计为什么MySQL的InnoDB存储引擎会选择B+树作为底层数据结构，而不选择B树或者哈希？在这一节中，我们将通过以下的两个方面介绍InnoDB这样选择的原因。 InnoDB需要支持的场景和功能需要在特定查询上拥有较强的性能； CPU将磁盘上的数据加载到内存中需要花费大量的时间，这使得B+树成为了非常好的选择。 数据的持久化以及持久化数据的查询其实是一种常见的需求，而数据的持久化就需要我们与磁盘、内存和CPU打交道；MySQL作为OLTP的数据库不仅需要具备事务的处理能力，而且要保证数据的持久化而且能够有一定的实时数据查询能力，这些需求共同决定了B+树的选择，接下来我们会详细分析上述两个原因背后的逻辑。 读写性能OLTP代表Online Transaction Processing，与OLTP相比的还有OLAP：Online Analytical Processing，从这两个名字中我们就可以看出，前者指的是传统的关系型数据库，主要用于处理基本的、日常的事务处理，而后者主要在数据仓库中使用，用于支持一些复杂的分析和决策。 作为支撑CLTP数据的存储引擎，我们经常会使用InnoDB完成以下的一些工作： 通过 INSERT、UPDATE 和 DELETE 语句对表中的数据进行增加、修改和删除； 通过 UPDATE 和 DELETE 语句对符合条件的数据进行批量的删除； 通过 SELECT 语句和主键查询某条记录的全部列； 通过 SELECT 语句在表中查询符合某些条件的记录并根据某些字段排序； 通过 SELECT 语句查询表中数据的行数； 通过唯一索引保证表中某个字段或者某几个字段的唯一性； 如果我们使用B+树作为底层的数据结构，那么所有只会访问或者修改一条数据的SQL的时间复杂度都是O($log_n$)，也就是树的高度，但是使用哈希却有可能达到O(1)的时间复杂度，看起来是不是特别的美好，但是当我们使用如下所示的SQL时，哈希的表现就不会这么好了： 1234SELECT * FROM posts WHERE author = &#x27;draven&#x27; ORDER BY created_at DESCSELECT * FROM posts WHERE comments_count &gt; 10UPDATE posts SET github = &#x27;github.com/draveness&#x27; WHERE author = &#x27;draven&#x27;DELETE FROM posts WHERE author = &#x27;draven&#x27; 如果我们使用哈希作为底层的数据结构，遇到上述的场景时，使用哈希构成的主键索引或者辅助索引可能就没有办法快速处理了，它对于处理范围查询或者排序性能会非常差，只能进行全表扫描并依次判断是否满足条件。全表扫描对于数据库来说是一个非常糟糕的结果，这其实也就意味着我们使用的数据结构对于这些查询没有其他任何效果，最终的性能可能都不如从日志中顺序进行匹配。 使用B+树其实能够保证按照键的顺序进行存储，也就是相邻的所有数据其实都是按照自然顺序排列的，使用哈希却无法达到这样的效果，因为哈希函数的目的就是让数据尽可能被分散到不同的桶中进行存储，所以在遇到可能存在相同键author = ‘draven’ 或者排序以及范围查询comments_count &gt; 10时，由哈希作为底层数据结构的表可能就会面对数据库查询的噩梦 —— 全表扫描。 B树和B+树在数据结构上其实有一些类似，它们都可以按照某些顺序对索引中的内容进行遍历，对于排序和范围查询等操作，B树和B+树相比于哈希会带来更好的性能，当然如果索引建立不够友好或者SQL查询非常复杂，依然会导致全表扫描。 数据加载既然使用哈希无法应对我们常见的SQL中排序和范围查询等操作，而B树和B+树都可以相对高效地执行这些查询，那么为什么我们不选择B树呢？这个原因其实非常简单——计算机在读写文件时会以页为单位将数据加载到内存中。页的大小可能会根据操作系统的不同而发生变化，不过在大多数的操作系统中，页的大小都是4KB，你可以通过如下的命令获取操作系统上的页大小： 12$ getconf PAGE_SIZE4096 当我们需要在数据库中查询数据时，CPU 会发现当前数据位于磁盘而不是内存中，这时就会触发 I/O 操作将数据加载到内存中进行访问，数据的加载都是以页的维度进行加载的，然而将数据从磁盘读取到内存中所需要的成本是非常大的，普通磁盘（非 SSD）加载数据需要经过队列、寻道、旋转以及传输的这些过程，大概要花费 10ms 左右的时间。 我们在估算 MySQL 的查询时就可以使用 10ms 这个数量级对随机 I/O 占用的时间进行估算，这里想要说的是随机 I/O 对于 MySQL 的查询性能影响会非常大，而顺序读取磁盘中的数据时速度可以达到 40MB/s，这两者的性能差距有几个数量级，由此我们也应该尽量减少随机 I/O 的次数，这样才能提高性能。 B树与B+树的最大区别就是，B树可以在非叶结点中存储数据，但是B+树的所有数据其实都存储在叶子结点中，当一个表底层的数据结构是B树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』： 如果不考虑任何优化，在上面的简单B树中我们需要进行4次磁盘的随机I/O才能找到所有满足条件的数据行： 加载根节点所在的页，发现根节点的第一个元素是 6，大于 4； 通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5； 重新加载根节点所在的页，发现根节点不包含第二个元素； 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8； 当然我们可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以我们不需要考虑优化 B 树而带来的收益，直接来看看什么样的优化 B+ 树可以做，而 B 树不行。 由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。 B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以通过『指针』依次按顺序连接，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能。 有些读者可能会认为使用 B+ 树这种数据结构会增加树的高度从而增加整体的耗时，然而高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5，所以这并不是影响性能的根本问题。 总结任何不考虑应用场景的设计都不是最好的设计，当我们明确的定义了使用 MySQL 时的常见查询需求并理解场景之后，再对不同的数据结构进行选择就成了理所当然的事情，当然 B+ 树可能无法对所有 OLTP 场景下的查询都有着较好的性能，但是它能够解决大多数的问题。 我们在这里重新回顾一下 MySQL 默认的存储引擎选择 B+ 树而不是哈希或者 B 树的原因： 哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描； B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O； 如果想要追求各方面的极致性能也不是没有可能，只是会带来更高的复杂度，我们可以为一张表同时建 B+ 树和哈希构成的存储结构，这样不同类型的查询就可以选择相对更快的数据结构，但是会导致更新和删除时需要操作多份数据。 从今天的角度来看，B+ 树可能不是 InnoDB 的最优选择，但是它一定是能够满足当时设计场景的需要，从 B+ 树作为数据库底层的存储结构到今天已经过了几十年的时间，我们不得不说优秀的工程设计确实有足够的生命力。而我们作为工程师，在选择数据库时也应该非常清楚地知道不同数据库适合的场景，因为软件工程中没有银弹。 到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题： 常用于分析的 OLAP 数据库一般会使用什么样的数据结构存储数据？为什么？ Redis 是如何对数据进行持久化存储的？常见的数据结构都有什么？ 如果对文章中的内容有疑问或者想要了解更多软件工程上一些设计决策背后的原因，可以在博客下面留言，作者会及时回复本文相关的疑问并选择其中合适的主题作为后续的内容。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"}],"author":"Alloceee"},{"title":"SQL如何使用Concat连接两列数据","slug":"数据库/MySQL/other/concat组合多个字段","date":"2021-07-26T16:00:00.000Z","updated":"2021-08-01T03:35:29.856Z","comments":true,"path":"2021/07/27/数据库/MySQL/other/concat组合多个字段/","link":"","permalink":"https://alloceee.github.io/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/concat%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5/","excerpt":"使用concat直接组合多个字段，连接字符串和嵌套使用","text":"使用concat直接组合多个字段，连接字符串和嵌套使用 方法/步骤concat直接组合多个字段1select concat(name,uid) as name from user concat不仅可以使用字段名，也可以使用字符串1select concat(name,&#x27;~&#x27;,uid) as name from user concat嵌套使用1select concat(name,concat(uid,sex)) as name from user","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Alloceee"},{"title":"第5章 系统性能评价","slug":"SystemArchitect/第5章：系统性能评价","date":"2021-07-25T16:00:00.000Z","updated":"2021-08-12T08:00:19.039Z","comments":true,"path":"2021/07/26/SystemArchitect/第5章：系统性能评价/","link":"","permalink":"https://alloceee.github.io/2021/07/26/SystemArchitect/%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/","excerpt":"性能设计主要包含两方面的内容：一是作为未来计算机发展的参考和规划；另一个则是对现有系统进行性能上的调整已达到最优化。","text":"性能设计主要包含两方面的内容：一是作为未来计算机发展的参考和规划；另一个则是对现有系统进行性能上的调整已达到最优化。 性能指标描述当前流行系统主要涉及的性能指标 对计算机评价的主要性能指标1.时钟频率（主频）主频是计算机的主要性能指标之一，在很大程度上决定了计算机的运算速度。CPU的工作节拍是由主时钟来控制的，主时钟不断产生固定频率的时钟脉冲，这个主时钟的评率即是CPU的主频。主频越高，意味着CPU的工作节拍就越快，运算速度也就越快。现在已经发展为多核心CPU，除了看时钟频率还得看单个CPU中的内核数。 2.高速缓存高速缓存可以提高CPU的运行效率。目前一般采用两级高速缓存技术，有些使用三层。高速缓冲存储器均由静态RAM（Random Access Memory，随机存取存储器）组成，结构较复杂，在 CPU 管芯面积不能太大的情况下，L1 级高速缓存的容量不可能做得太大。采用回写（WriteBack）结构的高速缓存。它对读和写操作均有可提供缓存。而采用写通（Write-through）结构的高速缓存，仅对读操作有效。L2 及 L3 高速缓存容量也会影响 CPU的性能，原则是越大越好。 3.运算速度运算速度是计算机工作能力和生产效率的主要表征，它取决于给定时间内 CPU 所能处理的数据量和 CPU 的主频。其单位一般用 MIPS（百万条指令/秒）和 MFLOPS（百万次浮点运算/秒）。MIPS 用于描述计算机的定点运算能力；MFLOPS 则用来表示计算机的浮点运算能力。 网络操作系统数据库管理系统衡量数据库管理系统的主要性能指标包括数据库本身和管理系统两部分。 数据库和数据库管理系统的性能指标包括数据库的大小、单个数据库文件的大小、数据库中表的数量、单个表的大小、表中允许的记录（行）数量、单个记录（行）的大小、表上所允许的所有数量、数据库所允许的索引数量、最大并发事务处理能力、负载均衡能力、最大连接数。 CPU/内存使用状况、查询语句性能、进程/线程使用状态、日志文件大小等。 Web服务器Web 服务器也称为 WWW 服务器，主要功能是提供网上信息浏览服务。 在 UNIX 和 Linux 平台下使用最广泛的 HTTP 服务器是 W3C、NCSA 和 Apache 服务器，而 Windows 平台使用 IIS 的 Web 服务器。跨平台的 Web 服务器有 IBM WebSphere、BEA WebLogic、Tomcat 等。在选择使用 Web 服务器时，应考虑的本身特性因素有性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。 Web 服务器的主要性能指标包括最大并发连接数、响应延迟、吞吐量（每秒处理的请求数）、成功请求数、失败请求数、每秒点击次数、每秒成功点击次数、每秒失败点击次数、尝试连接数、用户连接数等。 应用系统：应用系统的可用性、响应时间、并发用户数、特定应用资源占用等。 性能计算描述当前使用到的主要性能指标的计算方法 性能设计描述如何对现有系统进行性能上的调整优化，并介绍几个已经成熟的设计规则和解决方案 性能评估描述如何对当前取得的性能指标进行评价和改进 基准测试程序把应用程序中用的最多、最频繁的那部分核心程序作为评价计算机性能的标准程序，称为基准测试程序。 对于真实程序、核心程序、小型基准程序和合成基准程序来说，其评测程序依次递减。 事务处理性能委员会（Transaction Processing Performance Council，TPC）是制定商务应用基准程序（Benchmark）标准规范、性能和价格度量，并管理测试结果发布的非营利组织，其发布的TPC-C是在线事务处理的基准程序，TPC-D是决策支持的基准程序。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第10章：设计模式","slug":"SystemArchitect/第10章：设计模式","date":"2021-07-21T06:33:00.000Z","updated":"2021-08-10T09:05:36.031Z","comments":true,"path":"2021/07/21/SystemArchitect/第10章：设计模式/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1.设计模式概述1.1设计模式的概念GoF设计模式：对被用来在特定场景下解决一般设计问题的类和互相通信的对象的描述。通俗地说，可以把设计模式理解为对某一类问题的通用解决方案。 1.2设计模式的组成一般的，在描述一个设计模式时，至少需要包含四个方面： 模式名称（Pattern name） 问题（Problem） 解决方案（Solution） 效果（Consequence） 这四个方面就是设计模式的四要素。 1.3GoF设计模式（模式介绍）创建型1.Factory Method模式（工厂方法）Factory Method 模式提供了一种延迟创建类的方法，使用这个方法可以在运行期由子类决定创建哪一个类的实例。 2.Abstract Factory模式（抽象工厂）Abstract Factory又称为抽象工厂模式，该模式主要为解决复杂系统中对象创建的问题。抽象工厂模式提供了一个一致的对象创建接口来创建一系列具有相似基类或相似接口的对象。 3.Buider模式（建造器）Builder模式与Abstract Factory模式非常类似，但Builder模式是逐步地构造出一个复杂对象，并在最后返回对象的实例。Builder模式可以把复杂对象的创建与表示分离，使得同样的创建过程可以创建不同的表示。 4.Prototype模式（原型）Prototype模式可以根据原型实例制定创建的对象的种类，并通过深复制这个原型来创建新的对象。Prototype模式有着同Abstract Factory模式和Builder模式相同的效果，不过当需要实例化的类是在运行期才被指定的而且要避免创建一个与产品曾是平行的工厂类层次时，可以使用Prototype模式。使用Prototype模式可以在运行时增加或减少原型，比Abstract Factory和Builder模式更加灵活。 5.Singleton模式（单例）使用Singleton模式可以保证一个类仅有一个实例，从而可以提供一个单一的全局访问点。 结构型6.Adapter模式（适配器）Adapter模式可以解决系统间接口不相容的问题。通过Adapter可以把类的接口转化为客户程序所希望的接口，从而提高复用性。 7.Bridge模式（桥接）Bridge模式基于类的最小设计的原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（Implementation）分离开来，从而可以保证各部分的独立性以及应对他们的功能拓展。 8.Composite模式（组合）Composite模式提供了一种以树形结构组合对象的方法，使用Composite可以使单个对象和组合后的对象具有一致性以提高软件的复用性。 9.Decorator模式（装饰者）Decorator模式可以动态地为对象的某一个方法增加更多的功能。在更多时候，使用Decorator模式可以不必继承出新的子类从而维护简介的类继承结构。 10.Facade模式（门面）Facade模式为一组类提供了一致的访问接口。使用Facade可以封装内部具有不同接口的类，使其对外提供统一的访问方法。Facade模式在J2EE系统开发中发展为Session Facade模式。 11.Flyweight模式（享元）Flyweight模式可以共享大量的细粒度对象，从而节省创建对象所需要分配的空间，不过在时间上的开销会变大。 12.Proxy模式（代理）顾名思义，Proxy模式为对象提供了一种访问代理，通过对象Proxy可以控制客户程序的访问。例如：访问权限的控制、访问地址的控制、访问方式的控制等，甚至可以通过Proxy将开销较大的访问化整为零，提高访问效率。 行为型13.Interpreter模式（解释器）定义了一个解释器，来解释遵循给定语言和文法的句子。 14.Template Method模式（模板）定义一个操作的模板，其中的一些步骤会在子类中实现，以适应不同的情况。 15.Chain of Responsibility模式（责任链）Chain of Responsibility模式把可以响应请求的对象组织成一条链，并在这条对象链上传递对象，从而保证多个对象都有机会处理请求而且可以避免请求方和响应方的耦合。 16.Command模式（命令）将请求封装为对象，从而增强请求的能力，如参数化、排队、记录日志等。 17.Iterator模式（迭代器）Iterator模式提供了顺序访问一个对象集合的各元素的方法，使用Iterator可以避免暴露集合中对象的耦合关系。 18.Mediator模式（中介者）Mediator模式可以减少系统中对象间的耦合性。Mediator模式使用中介对象封装其他对象，从而使这些被封装的对象间的关系就成了松散耦合。 19.Memento模式（备忘录）Memento模式提供了一种捕获对象状态的方法，且不会破坏对象的封装，并且可以在对象外部保存对象的状态，并在需要的时候恢复对象状态。 20.Observer模式（观察者）Observer模式提供了将对象的状态广播到一组观察者的方式，从而可以让每个观察者随时都可以得到对象更新的通知。 21.State模式（状态）State模式允许一个对象在其内部状态改变的时候改变他的行为。 22.Strategy（策略）使用Strategy模式可以让对象中算法的变化独立于客户。 23.Visitor模式（访问者）表示对某对象结构中各元素的操作，使用Visitor模式可以在不改变各元素类的前提下定义作用于这些元素的新操作。具有固定结构的活动节点需要多种处理能力，且处理能力可扩展，也就是说要求在不改变原来类结构（活动节点）的基础上增加新功能。 1.5设计模式与软件架构1.6设计模式分类 创建型 结构型 行为型 应用范围 应用于类 Factory Method Adapter Interpreter Template Method 应用于对象 Abstract Factory Builder Prototype Singleton Adapter Bridege Composite Decorator Facade Flyweight Proxy Chain of Responsiblity Command Interator Mediator Memento Observer State Strategy Visitor 1.7设计模式的六大原则开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热拔插的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级，想要达到这样的效果，我们需要使用接口和抽象类。 1.8模式具体分析5.Signleton模式7.Bridge模式桥接模式的角色和职责： 1.Client调用端 这是Bridge模式的调用者。 2.抽象类（Abstraction） 抽象类接口（接口这货抽象类）维护对行为实现（implementation）的引用，他的角色就是桥接类。 3.Refined Abstraction 这是Abstraction的子类。 4.Implementor 行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作） 5.ConcreteImplmentor Implementor的子类。 桥接模式的UML图如下： 总结： 1.桥接模式的优点 （1）实现了抽象和实现部分的分离 桥接模式分离了抽象部分和实现部分，从而极大地提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 （2）更好的可扩展性 由于桥接模式把抽象部分和实现部分分离了，从而分别定义接口，这就使得抽象部分和实现部分可以分别独立扩展，而不会相互影响，大大的提供了系统的可扩展性。 （3）可动态的切换实现 由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。 （4）实现细节对客户端透明，可以对用户隐藏实现细节。 2.桥接模式的缺点 （1）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 （2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。 3.桥接模式的使用场景 （1）如果一个系统需要在构建的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使他们在抽象层建立一个关联关系。 （2）抽象化角色和实现化角色可以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。","categories":[],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}]},{"title":"第9章：软件架构设计","slug":"SystemArchitect/第9章：软件架构设计","date":"2021-07-21T06:32:00.000Z","updated":"2021-08-12T06:52:01.910Z","comments":true,"path":"2021/07/21/SystemArchitect/第9章：软件架构设计/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC9%E7%AB%A0%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。","text":"软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。 软件架构风格软件架构设计的一个核心问题是否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。 软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（idiomatic paradigm），定义了用于描述系统的术语表和一组指导构建系统的规则。 软件架构风格是指描述特定软件系统组织方式的惯用模式。组织方式描述了系统的组成构件和这些构件的组织方式，惯用模式则反映众多系统共有的结构和语义。从集成开发环境与用户的交互方式看，用户通常采用交互式的方式对脚本语言进行编辑、解释执行与调试。在这种情况下，采用以数据存储为中心的架构风格能够很好地支持交互式数据处理，而管道-过滤器架构风格则对用户的交互式数据处理支持有限。从集成开发环境的扩展性来看，系统核心需求要求实现各种编辑、语法检查、解释执行等多种功能的灵活组织、配置与替换。在这种情况下，采用以数据存储为中心的架构风格，以数据格式解耦各种功能之间的依赖关系，并可以灵活定义功能之间的逻辑顺序。管道-过滤器架构风格同样以数据格式解耦数据处理过程之间的依赖关系，但其在数据处理逻辑关系的灵活定义方面较差。从集成开发环境的数据管理来看，集成开发环境需要支持脚本语言、语法树(用于检查语法错误)、可视化模型、调试信息等多种数据类型，并需要支持数据格式的转换。 以数据存储为中心的架构将数据存储在统一的中心存储器中，中心存储器能够表示多种数据格式，并能够为数据格式转换提供各种支持。管道-过滤器架构风格通常只能支持有限度的数据格式，并且在数据格式转换方面的灵活性较差。 为了满足需求(2) ，应该采用解释器架构风格。具体来说，需要：①为可视化编程元素及其拖拽关系定义某种语言，并描述其语法与语义；②编写解释器对该语言进行 解释；③生成对应的脚本语言程序。为了满足需求(3) ，应该采用隐式调用架构风格。具体来说，首先需要定义“断点在调试过程中命中”这一事件，并实现当断点命中后的屏幕定位函数。集成开发环境维 护一个事件注册表结构，将该事件与屏幕定位函数关联起来形成注册表中的一个记录项。 在调试过程中，集成开发环境负责监听各种事件，当“断点在调试过程中命中”这一事件发生时，集成开发环境查找事件注册表，找到并调用屏幕定位函数，从而实现脚本语言编辑界面与调试代码的自动定位。 3.1软件架构风格分类（1）设计词汇表是什么？ （2）构建和连接件的类型是什么？ （3）可容许的结构模式是什么？ （4）基本的计算模型是什么？ （5）风格的基本不变性是什么？ （6）其使用的常见例子是什么？ （7）使用此风格的优缺点是什么？ （8）其常见的特例是什么？ 3.2数据流风格数据流风格的软件架构是一种最常见，结构最为简单的软件架构。这样的架构下，所有的数据按照流的形式在执行过程中前进，不存在结构的反复和重构，就像工厂中的汽车流水线一样，数据就像汽车零部件一样的流水线的各个节点上被加工，最终输出所需要的结果（一步完整的汽车）。在流动过程中，数据经过序列间的数据处理组件进行加工，然后将处理结果向后传送，最后进行输出。 批处理序列批处理风格的每一步处理都是独立的，并且每一步是顺序执行的。只有当前一步处理完，后一步处理才能开始。数据传送在步与步之间作为一个整体。（组件为一系列固定顺序的计算单元，组件间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在前一步结束后才能开始，数据必须是完整的，以整体的方式传递）。 批处理的典型应用： （1）经典数据处理； （2）程序开发； （3）Windows 下的 BAT 程序就是这种应用的典型实例 管道-过滤器在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。 此风格特别重要的过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。一个管道/过滤器网络输出的正确性并不依赖于过滤器进行增量计算过程的顺序。 典型应用： （1）以UNIX Shell编写的程序。UNIX 既提供一种符号，以连接各组成部分（UNIX 的进程），又提供某种进程运行时机制以实现管道。 （2）传统的编译器。传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。 特点3.3调用/返回风格调用返回风格顾名思义，就是指在系统中采用了调用与返回机制。利用调用-返回实际上是一种分而治之的策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。程序从其执行起点开始执行该构建的代码，程序执行结束，将控制返回给程序调用构件。 主程序/子程序主程序/子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。调用关系具有层次性，其语义逻辑表现为子程序的正确性，取决于它调用的子程序的正确性。 面向对象风格抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。 特点：（1）对象负责维护其表示的完整性； 层次结构MVC B/S结构三层 C/S 结构应运而生。三层 C/S 结构是将应用功能分成表示层、功能层和数据层三个部分 面向服务的架构SOA是一种在计算环境中设计、开发、部署和管理离散逻辑单元（服务）模型的方法。 本题主要考查考生对基于场景的架构分析方法(Scenarios-based Architecture AnalysisMethod, SAAM)的掌握和理解。SAAM是卡耐基梅隆大学软件工程研究所的Kazman等人于1983年提出的一种非功能质量属性的架构分析方法,是最早形成文档并得到广泛应用的软件架构分析方法。SAAM•的主要输入是问题描述、需求说明和架构描述，其分析过程主要包括场景开发、架构描述、单个场景评估、场景交互和总体评估。 架构需求与软件质量属性6个质量属性及实现从架构关注点来研究质量属性实现，将质量属性分为6种：可用性、可修改性、性能、安全性、可测试性、易用性。 1.可用性战术可以分为：错误检测、错误恢复、错误预防。 ① 错误检测 命令/响应：一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响应，例如远程错误的检测。 心跳（计时器）：一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心跳消息，则假定构件失败，并通知错误纠正构件。 异常：当出现异常时，异常处理程序开发执行。 ② 错误恢复 表决：通过冗余构件（或处理器）与表决器连接，构件按相同的输入及算法计算输出值交给表决器，由表决器按表决算法（如多数规则）确定是否有构件出错，表决通常用在控制系统中。 主动冗余（热重启、热备份）：所有的冗余构件都以并行的方式对事件做出响应。它们都处在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方式使用另一个构件的响应。 被动冗余（暧重启/双冗余/三冗余）：一个构件（主构件）对事件做出响应，并通知其他构件（备用的）必须进行的状态更新（同步）。当错误发生时，备用构件从最新同步点接替主构件的工作。 备件：备件是计算平台配置用于更换各种不同的故障构件。 状态再同步：主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方法取决于可以承受的停机时间、更新的规模及更新的内容多少。 检查点/回滚：检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做出响应。当在两检查点之间发生故障时，则以这个一致状态的检查点（有快照）和之后发生的事务日志来恢复系统（数据库中常使用）。 ③ 错误预防 从服务中删除：如删除进程再重新启动，以防止内存泄露导致故障的发生。 事务：使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。 进程监视器：通过监视进程来处理进程的错误。 可用性通常采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性 2.可修改性战术包括局部化修改、防止连锁反应、推迟绑定时间。 ① 局部化修改。在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。 维持语义的一致性：语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作，不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量语义一致性。使用“抽象通用服务”（如应用框架的使用和其他中间软件的使用）来支持可修改性是其子战术。 预期期望的变更：通过对变更的预估，进行预设、准备，从而使变更的影响最小。 泛化该模块：使一个模块更通用、更广泛的功能。 限制可能的选择：如在更换某一模块（如处理器）时，限制为相同家族的成员。 ② 防止连锁反应。由于模块之间有各种依赖性，因此，修改会产生连锁反应。防止连锁反应的战术如下。 信息隐藏：就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成为私有的，通过接口获得公有责任。 维持现有的接口：尽可能维持现有接口的稳定性。例如通过添加接口（通过新的接口提供新的服务）可以达到这一目的。 限制通信路径：限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。 仲裁者的使用：在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活动。仲裁者有很多种类型，例如：桥、调停者、代理等就是可以提供把服务的语法从一种形式转换为另一种形式的仲裁者。 ③ 推迟绑定时间。系统具备在运行时进行绑定并允许非开发人员进行修改（配置）。运行时注册：支持即插即用。 配置文件：在启动时设置参数。 多态：在方法调用的后期绑定。 构件更换：允许载入时绑定。 3.性能（2）性能战术。性能与时间相关，影响事件的响应时间有两个基本因素。 资源消耗：事件到达后进入一系列的处理程序，每一步处理都要占用资源，而且在处理过程中消息在各构件之间转换，这些转换也需要占用资源。 闭锁时间：指对事件处理时碰到了资源争用、资源不可用或对其他计算的依赖等情况，就产生了等待时间。 性能的战术有如下几种。 ① 资源需求 减少处理事件流所需的资源：提高计算效率（如改进算法）、减少计算开销（如在可修改性 与性能之间权衡，减少不必要的代理构件）。 减少所处理事件的数量：管理事件率、控制采样频率。 控制资源的使用：限制执行时间（如减少迭代次数）、限制队列大小。 ② 资源管理 引入并发：引入并发对负载平衡很重要。 维持数据或计算的多个副本：C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力；高速缓存可以存放数据副本（在不同速度的存储库之间的缓冲）。 增加可用资源：在成本允许时，尽量使用速度更快的处理器、内存和网络。 ③ 资源仲裁 资源仲裁战术是通过如下调度策略来实现的。 先进/先出（FIFO）； 固定优先级调度：先给事件分配特定的优先级，再按优先级高低顺序分配资源； 动态优先级调度：轮转调度、时限时间最早优先； 静态调度：可以离线确定调度。 性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、 引入并发机制、采用资源调度等。 4.安全性安全性战术：包括抵抗攻击、检测攻击和从攻击中恢复。 ① 抵抗攻击 对用户进行身份验证：包括动态密码、一次性密码、数字证书及生物识别等； 对用户进行授权：即对用户的访问进行控制管理； 维护数据的机密性：一般通过对数据和通信链路进行加密来实现； 维护完整性：对数据添加校验或哈希值； 限制暴露的信息； 限制访问：如用防火墙、DMZ 策略。 ② 检测攻击。一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。 ③ 从攻击中恢复。 恢复：与可用性中的战术相同； 识别攻击者：作为审计追踪，用于预防性或惩罚性目的。 安全性质量属性相关，通常可采用入侵检测、用户认证、用户授权、追踪审计等架构策略实现该属性。 5.可测试性可测试性战术：包括输入/输出和内部监控 ① 输入/输出 记录/回放：指捕获跨接口的信息，并将其作为测试专用软件的输入； 将接口与实现分离：允许使用实现的替代（模拟器）来支持各种测试目的； 优化访问线路/接口：用测试工具来捕获或赋予构件的变量值。 ② 内部监控。当监视器处于激活状态时，记录事件（如通过接口的信息）。 记录/回放 6.易用性易用性战术：包括运行时战术、设计时战术和支持用户主动操作。 ① 运行时战术 任务的模型：维护任务的信息，使系统了解用户试图做什么，并提供各种协助； 用户的模型：维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面； 系统的模型：维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。 ② 设计时战术。将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。 ③ 支持用户主动操作。支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显示多个视图”。 软件架构文档化任何软件编档（包括软件架构编档）的规则归纳为7条： （1）从读者的角度编写文档。 （2）避免出现不必要的重复。 （3）避免歧义。 （4）使用标准结构。 （5）记录基本原理。 （6）使文档保持更新，但更新频率不要过高。 （7）针对目标的适宜性对文档进行评审。 功耗控制软件设计层面的功耗控制主要可以从一下方面展开： 1.软硬件协同设计，即软件的设计要与硬件的匹配，考虑硬件因素； 2.编译优化，采用低功耗优化的编译技术； 3.减少系统的持续运行时间，可从算法角度进行优化； 4.用“中断”代替“查询”； 5.进行电源的有效管理。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第1章：计算机组成与体系结构","slug":"SystemArchitect/第1章：计算机组成与体系结构","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-09T01:59:35.484Z","comments":true,"path":"2021/07/21/SystemArchitect/第1章：计算机组成与体系结构/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.计算机系统1.3 复杂指令集系统与精简指令集系统 指令系统类型 指令 寻址方式 实现方式 其他 CISC（复杂） 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术 研制周期长 RISC（精简） 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编译，有效支持高级语言 2.存储器系统2.3 Cache存储器Cache的性能是计算机系统性能的重要方面。命中率是cache的一个重要指标，但不是最重要的指标。cache设计的主要目标是在成本允许的情况下达到较高的命中率，使存储系统具有最短的平均访问时间。cache的命中率和cache容量的关系是：cache容量越大，则命中率越高，随着容量的增加，其失效率接近0%（命中率接近100%）。但是，增加cache容量意味着增加cache的成本和增加cache的命中时间。 计算机系统中的存储部件通常组织成层次结构，越接近CPU的存储部件访问速度越快。寄存器组是CPU中的暂存器件，访问速度是最快的。目前也通常把cache(分为多级)集成在CPU中。 3.流水线流水线技术把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构复杂执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构，这个就可以实现多个任务的重叠执行，以提高工作效率。 3.1 流水线周期流水线应用过程中，会将需要处理的工作分为 N 个阶段，最耗时的那一段所消耗的时间为流水线周期。 3.2 计算流水线执行时间以流水线的执行时间可通俗的表达为： 流水线执行时间=第 1 条指令的执行时间+（n-1）*流水线周期 n 代表需要处理的任务数量。 而实际上，真正做流水线处理时，考虑到处理的复杂性，会将指令的每个执行阶段的时 间都统一为流水线周期，即 1 条指令的执行时间为：4ms+4ms+4ms=12ms。 所以：实际流水线执行时间=4ms+4ms+4ms+(100-1)*4=408ms。 考试时 80%以上的概率采用理论公式计算，所以考试时需要以理论公式计算，若计算的结果无正确选项才考虑采用实际公式计算。 3.3 流水线的吞吐率流水线的吞吐率（Though Put rate，TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。有些文献也称为平均吞吐率、实际吞吐率。计算流水线吞吐率的最基本的公式如下：$$TP = \\frac{n}{T_k}$$其中n为任务数，$T_k$是处理完成n个任务所用的时间。 流水线的最大吞吐率为：$$TP_{max} = \\lim_{n\\to\\infty}\\frac{n}{(k+n-1)\\Delta{t}} = \\frac{1}{\\Delta{t}}$$ 3.4 流水线的加速比加速比：不使用流水线的执行时间/使用流水线的执行时间 如果不使用流水线，即顺序执行所用的时间为 $T_0$ ，使用流水线的执行时间为$T_k$，则计算流水线加速比的基本公式如下：$$S = \\frac{T_0}{T_k}$$如果流水线各个流水段的执行时间都相等（设为Dt），则一条k段流水线完成n个连续任务所需要的时间为(k+n-1)Dt。如果不使用流水线，即顺序执行这 n 个任务，则所需要的时间为 nkDt。因此，各个流水段执行时间均相等的一条 k 段流水线完成 n 个连续任务 时的实际加速比为：$$S = \\frac{nk\\Delta{t}}{(k+n-1)\\Delta{t}} = \\frac{nk}{k+n-1}$$这种情况下的最大加速比为：$$S_{max} = \\lim_{n\\to\\infty}\\frac{nk}{k+n-1} = k$$效率：即流水线设备的利用率，指流水线中的设备实际使用时间与整个运行时间的比值 主频CPU的工作频率（主频）包括两个部分：外频与倍频，两者的乘机就是主频。 作为外频，就是外部频率，指的是系统总线频率。 倍频的全称是倍频系数，倍频系数是指CPU主频与外频之间的相对比例关系。最初CPU主频和系统总线速度是一样的，但CPU的速度越来越快，倍频技术也就相应产生。它的作用是使系统总线工作在相对较低的频率上，而CPU速度可以通过倍频来提升。 主频 = 外频 * 倍频 = 200MHz * 13 = 2.6GHz","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Allocee"},{"title":"第2章：操作系统","slug":"SystemArchitect/第2章：操作系统","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-10T09:42:34.450Z","comments":true,"path":"2021/07/21/SystemArchitect/第2章：操作系统/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统的类型与结构操作系统是计算机系统中最基本的系统软件，它既是管理计算年级系统的软、硬件资源，又控制程序的执行。 从资源管理的角度看，操作系统主要是对处理器、存储器、文件、设备和作业进行管理。 操作系统的定义操作系统（Operating System，OS）是计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源，合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用。操作系统为用户提供的接口表现形式一般为：命令、菜单、窗口之类的，而操作系统为应用程序提供的接口为 API。 操作系统分类按照操作系统的功能划分，操作系统的基本类型有批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统、嵌入式操作系统、微内核操作系统等。 实时操作系统（RTOS）任务是RTOS中最重要的操作对象，每个任务在RTOS的调度下由CPU分时执行。任务的调度目前主要有时间分片式、轮流查询式和优先抢占式三种，不同的RTOS可能支持其中一种或几种，其中优先抢占式对实时性的支持最好。 在非实时系统中，调度的主要目的是缩短系统平均响应时间，提高系统资源的利用率，或优化某一项指标；而实时系统中调度的目的则是要尽可能地保证每个任务满足他们的时间约束，及时对外部请求做出响应。 操作系统基本原理操作系统的主要功能是进行处理机与进程管理、存储管理、设备管理、文件管理和作业管理的工作。 进程管理进程是处理机管理中最基本的、最重要的概念。进程是系统并发执行的体现。为了动态地看待操作系统，则以进程作为独立运行的基本单位，以进程作为分配资源的基本单位，从进程的角度来研究操作系统。因此，处理机管理也被称为进程管理。处理机管理的功能就是组织和协调用户对处理机的争夺使用，把处理机分配给进程，对进程进行管理和控制，最大限度也发挥处理机的作用。 1.进程的概念用静态的观点看，操作系统是一组程序和表格的集合。用动态的观点看，操作系统是进程的动态和并发执行的。 在多道程序系统中，程序的运行环境发生了很大的变化。主要体现在： （1）资源共享。为了提高资源的利用率，计算机系统中的资源不再由一道程序专用，而是由多道程序共同使用。 （2）程序的并发执行或并行执行。逻辑上讲允许多道不同用户的程序并行运行；允许一个用户程序内部完成不同操作的程序段之间并行运行；允许操作系统内部不同的程序之间并行运行。物理上讲：内存储器中保存多个程序，I/O 设备被多个程序交替地共享使用；在多处理机系统的情形下，表现为多个程序在各自的处理机上运行，执行时间是重叠的。单处理机系统时，程序的执行表现为多道程序交替地在处理机上相互空插运行。 实际上，在多道程序系统中，程序的并行执行和资源共享之间是相辅相成的。一方面，只有允许程序并行执行，才可能存在资源共享的问题；另一方面，只有有效地实现资源共享，才可能使得程序并行执行。 3.关于挂起状态引入挂起状态的原因有： （1）对换的需要。 4．进程互斥与同步进程互斥 定义为：一组并发进程中一个或多个程序段，因共享某一共有资源而导致必须以一个不允许交叉执行的单位执行。也就是说互斥是要保证临界资源在某一时刻只被一个进程访问。 进程同步定义为：把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程同步。也就是说进程之间是异步执行的，同步即是使各进程按一定的制约顺序和速度执行。 简单一点来说，互斥是资源的竞争关系，而同步是进程间的协作关系 由于资源共享与进程合作，并发执行的任务（进程）之间可能产生相互制约关系，这些制约关系可分为两类：竞争与协作。 并发进程之间的竞争关系为互斥，并发进程之间的协作关系体现为同步。 同步是因合作进程之间协调彼此的工作而控制自己的执行速度，即因相互合作，相互等待而产生的制约关系。 互斥是进程之间竞争临界资源而禁止两个以上的进程同时进入临界区所发生的制约关系。 一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，体现的制约关系是任务的同步。 微内核在设计微内核OS时，采用了面向对象的技术，其中的“封装”，“继承”，“对象类”和“多态性”，以及在对象之间采用消息传递机制等，都十分有利于提高系统的“正确性”、“可靠性”、“易修改性”、“易扩展性”等，而且还能显著地减少开发系统所付出的开销。 采用微内核结构的操作系统与传统的操作系统相比，其优点是提高了系统的灵活性、可扩展性，增加了系统的可靠性，提供了对分布式系统的支持。其原因如下： 灵活性和可扩展性：由于微内核OS的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核OS只需要在相应的服务器中增加新的功能，或再增加一个专门的服务器。与此同时，也必然改善系统的灵活性，不仅可在操作系统中增加新的功能，还可修改原有功能，以及删除已过时的功能，以形成一个更为精干有效地操作系统。 增强了系统的可靠性和可移植性：由于微内核是处于精心设计和严格测试的，容易保证其正确性；另一方面是它提供了规范而精简的应用程序接口（API），为微内核外部的程序编制高质量的代码创建了条件。此外，由于所有服务器都是运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，当某个服务器出现错误时，不会影响内核，也不会影响其他服务器。另外，由于在微内核结构的操作系统中，所有与特定CPU和I/O设备硬件有关的代码，均放在内核和内核下面的硬件隐藏层中，而操作系统其他绝大部分（即各种服务器）均与硬件平台无关，因而，把操作系统移植到另一个计算机硬件平台上所需作的修改是比较小的。 提供了对分布式系统的支持：由于在微内核OS中，客户和服务器之间以及服务器和服务器之间的通信，是采用消息传递通信机制运行的，致使微内核OS能很好地支持分布式系统和网络系统。事实上，只要在分布式系统中赋予所有进程和服务器唯一的标识符，在微内核中再配置一张系统映射表（即进程和服务器的标识符与它们所驻留的机器之间的对应表），在进行客户与服务器通信时，只需要所发送的消息中表上发送进程和接收进程的标识符，微内核便可利用系统映射表将消息发往目标，而无论目标是驻留在哪台机器上。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"操作系统","slug":"操作系统","permalink":"https://alloceee.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"Alloceee"},{"title":"第3章：数据库系统","slug":"SystemArchitect/第3章：数据库系统","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-05T07:17:13.608Z","comments":true,"path":"2021/07/21/SystemArchitect/第3章：数据库系统/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"数据库模式与范式数据的规范化综合1NF、2NF和3NF、BCNF的内涵可概括如下： （1）非主属性完全函数依赖于码（2NF的要求） （2）非主属性不传递依赖于任何一个候选码（3NF的要求） （3）主属性对不含它的码完全函数依赖（BCNF的要求） （4）没有属性完全函数依赖于一组非主属性（BCNF的要求） 数据库设计逻辑结构设计1.基本E-R模型向关系模型转换2.数据模型优化（1）改善数据库的性能。 减少连接运算 减少关系大小和数据量（分表） 分表常用有水平分割与垂直分割。水平分割为分系建立关系，垂直分割为将常用数据与非常用数据分开。 （2）节约存储空间 缩小每个属性占用的空间 通常可以有两种方法：即用编码和用缩写符号表示属性，但这两种方法的缺点是失去了属性值含义的直观性。 采用假属性 主要任务逻辑结构设计阶段的主要任务是确定数据模型、将ER图转换成指定数据模型、确定完整性约束、确定用户视图。 超类实体：由多个实体中共有的属性组成 派生属性：由其他属性计算获得，用于存储计算结果值。 数据挖掘数据挖掘是从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程，数据挖掘的任务有关联分析、聚类分析、分类分析、异常分析、特意群组分析和演变分析等等。 并非所有的信息发现任务都被称为数据挖掘。例如，使用数据库管理系统查找个别的记录，或通过英特网的搜索引擎查找特定的web页面，则是信息检索领域的任务。虽然这些任务是重要的，可能设计使用复杂的算法和数据结构，但是他们主要是依赖传统的计算机科学技术和数据的明显特征来创建索引结构，从而有效地组织和检索信息。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"第6章：开发方法","slug":"SystemArchitect/第6章：开发方法","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-12T08:01:44.596Z","comments":true,"path":"2021/07/21/SystemArchitect/第6章：开发方法/","link":"","permalink":"https://alloceee.github.io/2021/07/21/SystemArchitect/%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/","excerpt":"","text":"软件生命周期在 GB8566-88（《软件工程国家标准——计算机软件开发规范》） 中将软件生命周期划分为 8 个阶段：可行性研究与计划、需求分析、概要设计、详细设计、实现、集成测试、确认测试、使用和维护。 所列举的图与开发阶段的对应关系为：1、需求分析阶段：数据流图。2、概要设计阶段：模块结构图、层次图和HIPO图。3、详细设计阶段：程序流程图、伪代码、盒图。 软件开发模型3.统一过程（Unified Process,UP）RUP软件开发生命周期是一个二维的软件开发模型，其中有9个核心工作流，分别为： 业务建模、需求 分析设计 实施 测试 部署 配置与变更管理 项目管理 环境 RUP把软件生命生存周期划分为多个循环，每个循环产生产品的一个新的版本，每个循环依次由4个连续的阶段组成，每个阶段完成确定的任务。这四个阶段分别为： 初始阶段：定义最终产品视图与业务模型，并确定系统范围。 细化阶段：设计及确定系统的体系结构，制定工作计划及资源要求。 构造阶段：构造产品并继续演进需求、体系构造、计划直至产品提交。 移交阶段：把产品提交给用户使用。 每个阶段都有一个或多人连续的迭代组成。迭代并不是重复得做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程，它需要项目经理根据当前迭代所处的阶段以及上次迭代的结果，适当地对工作流中的行为进行裁剪。在每个阶段结束前都有一个里程碑评估该阶段的工作。如果未能通过该里程碑的评估，则决策者应该做出决定，是取消该项目还是继续该阶段的工作。 与其他软件开发过程相比，RUP具有自己的特点，即RUP是用例驱动的、以体系结构为中心的、迭代和增量的软件开发过程。 逆向工程逆向工程导出的信息可分为如下4个抽象层次。 （1）实现级：包括程序的抽象语法树、符号表等信息。 （2）结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。 （3）功能级：包括反映程序段功能及程序段之间关系的信息。 （4）领域级：包括反映程序分量或程序与应用领域概念之间对应关系的信息。","categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"}],"author":"Alloceee"},{"title":"","slug":"计算机网络/TCP协议面试10连问","date":"2021-07-20T05:09:35.090Z","updated":"2021-04-13T05:16:30.616Z","comments":true,"path":"2021/07/20/计算机网络/TCP协议面试10连问/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%9510%E8%BF%9E%E9%97%AE/","excerpt":"","text":"TCP和UDP的区别 面向连接 可靠性 基于字节流 001. 能不能说一说 TCP 和 UDP 的区别？首先概括一下基本的区别: TCP是一个面向连接的、可靠的、基于字节流的传输层协议。 而UDP是一个面向无连接的传输层协议。(就这么简单，其它TCP的特性也就没有了)。 具体来分析，和 UDP 相比，TCP 有三大核心特性: 面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。 可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。 TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。 当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。 相应的，UDP 就是无状态, 不可控的。 面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。 002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程: 从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。 然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。 服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。 之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。 另外需要提醒你注意的是，从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加1，为什么呢？只需要记住一个规则: 凡是需要对端确认的，一定消耗TCP报文的序列号。 SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。 为什么不是两次？根本原因: 无法确认客户端的接收能力。 分析如下: 如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。 看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。 看到问题的吧，这就带来了连接资源的浪费。 为什么不是四次？三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？ 当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。 三次握手过程中可以携带数据么？第三次握手的时候，可以携带。前两次握手不能携带数据。 如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。 第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。 同时打开会怎样？如果双方同时发 SYN报文，状态变化会是怎样的呢？ 这是一个可能会发生的情况。 状态变迁如下: 在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了! 发完SYN，两者的状态都变为SYN-SENT。 在各自收到对方的SYN后，两者状态都变为SYN-REVD。 接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。 这就是同时打开情况下的状态变迁。 四次挥手断开连接一般挥手过程及状态变化 刚开始双方处于ESTABLISHED状态。 客户端要断开了，向服务器发送 FIN 报文，在 TCP 报文中的位置如下图: 发送后客户端变成了FIN-WAIT-1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。 服务端接收后向客户端确认，变成了CLOSED-WAIT状态。 客户端接收到了服务端的确认，变成了FIN-WAIT2状态。 随后，服务端向客户端发送FIN，自己进入LAST-ACK状态， 客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。 注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。 等待2MSL的意义如果不等待会怎样？ 如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 为什么是四次挥手而不是三次？因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。 如果是三次挥手会有什么问题？ 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 同时发起挥手会怎样？（同时关闭会怎样？）如果客户端和服务端同时发送 FIN ，状态会如何变化？如图所示: SYN Flood攻击原理三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。 半连接队列当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。 全连接队列当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列(Accept Queue)**。 SYN Flood 攻击原理SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果: 处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。 由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。 如何应对 SYN Flood 攻击？ 增加 SYN 连接，也就是增加半连接队列的容量。 减少 SYN + ACK 重试次数，避免大量的超时重发。 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。 剖析TCP报文首部字段（介绍一下 TCP 报文头部的字段）报文头部结构如下(单位为字节): 源端口、目标端口如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。 那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。 序列号即Sequence number, 指的是本报文段第一个字节的序列号。 从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。 序列号在 TCP 通信的过程中有两个作用: 在 SYN 报文中交换彼此的初始序列号。 保证数据包按正确的顺序组装。 即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。 ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？ 如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。 而动态增长的 ISN 大大提高了猜测 ISN 的难度。 确认号即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。 标记位常见的标记位有SYN,ACK,FIN,RST,PSH。 SYN 和 ACK 已经在上文说过，后三个解释如下: FIN：即 Finish，表示发送方准备断开连接。 RST：即 Reset，用来强制断开连接。 PSH：即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。 窗口大小占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。 校验和占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。 可选项可选项的格式如下: 常用的可选项有以下几个: TimeStamp: TCP 时间戳，后面详细介绍。 MSS: 指的是 TCP 允许的从对方接收的最大报文段。 SACK: 选择确认选项。 Window Scale：窗口缩放选项。 TCP快速打开（TFP）原理第一节讲了 TCP 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？ 可以啊。今天来说说这个优化后的 TCP 握手流程，也就是 TCP 快速打开(TCP Fast Open, 即TFO)的原理。 优化的过程是这样的，还记得我们说 SYN Flood 攻击时提到的 SYN Cookie 吗？这个 Cookie 可不是浏览器的Cookie, 用它同样可以实现 TFO。 TFO 流程首轮三次握手首先客户端发送SYN给服务端，服务端接收到。 注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。 客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。 首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！ 后面的三次握手在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。 重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。 当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。 流程如下: 注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。 TFO 的优势TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。 TCP时间戳的作用timestamp是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下: 1kind(1 字节) + length(1 字节) + info(8 个字节) 其中 kind = 8， length = 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节。 那么这些字段都是干嘛的呢？它们用来解决那些问题？ 接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题: 计算往返时延 RTT(Round-Trip Time) 防止序列号的回绕问题 计算往返时延RTT在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示: 如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的； 如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。 实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。 那这个时候引入时间戳就很好的解决了这个问题。 比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么： step 1: a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1。 step 2: b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1。 step 3: a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。 防止序列号回绕问题现在我们来模拟一下这个问题。 序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。 第几次发包 发送字节 对应序列号 状态 1 0 ~ 1 0 ~ 1 成功接收 2 1 ~ 2 1 ~ 2 滞留在网络中 3 2 ~ 3 2 ~ 3 成功接收 4 3 ~ 4 3 ~ 4 成功接收 5 4 ~ 5 0 ~ 1 成功接收，序列号从0开始 6 5 ~ 6 1 ~ 2 ？？？ 假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为1 ~ 2的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。 那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。 TCP超时重传算法TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。 那么这个重传间隔是如何来计算的呢？ 今天我们就来讨论一下这个问题。 这个重传间隔也叫做超时重传时间(Retransmission TimeOut, 简称RTO)，它的计算跟上一节提到的 RTT 密切相关。这里我们将介绍两种主要的方法，一个是经典方法，一个是标准方法。 经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，没产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0): 1SRTT = (α * SRTT) + ((1 - α) * RTT) 其中，α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9。 拿到 SRTT，我们就可以计算 RTO 的值了: 1RTO = min(ubound, max(lbound, β * SRTT)) β 是加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界。 其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是0.8 ~ 0.9, RTT 对于 RTO 的影响太小。 标准方法(Jacobson/Karels算法)为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫Jacobson / Karels 算法。 一共有三步。 第一步: 计算SRTT，公式如下: 1SRTT = (1 - α) * SRTT + α * RTT 注意这个时候的 α跟经典方法中的α取值不一样了，建议值是1/8，也就是0.125。 第二步: 计算RTTVAR(round-trip time variation)这个中间变量。 1RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。 第三步: 计算最终的RTO: 1RTO = µ * SRTT + ∂ * RTTVAR µ建议值取1, ∂建议值取4。 这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切。 TCP流量控制对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。 而流量控制索要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。 要具体理解流量控制，首先需要了解滑动窗口的概念。 TCP滑动窗口概念TCP 滑动窗口分为两种: 发送窗口和接收窗口。 发送窗口发送端的滑动窗口结构如下: 其中包含四大部分: 已发送且已确认 已发送但未确认 未发送但可以发送 未发送也不可以发送 其中有一些重要的概念，我标注在图中: 发送窗口就是图中被框住的范围。SND 即send, WND 即window, UNA 即unacknowledged, 表示未被确认，NXT 即next, 表示下一个发送的位置。 接收窗口接收端的窗口结构如下: REV 即 receive，NXT 表示下一个接收的位置，WND 表示接收窗口大小。 流量控制过程这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。 首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。 假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。 现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。 注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。 因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。 此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。 这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。 TCP阻塞控制上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。 对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态: 拥塞窗口（Congestion Window，cwnd） 慢启动阈值（Slow Start Threshold，ssthresh） 涉及到的算法有这几个: 慢启动 拥塞避免 快速重传和快速恢复 接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。 拥塞窗口拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。 那么之前介绍了接收窗口的概念，两者有什么区别呢？ 接收窗口(rwnd)是接收端给的限制 拥塞窗口(cwnd)是发送端的限制 限制谁呢？ 限制的是发送窗口的大小。 有了这两个窗口，如何来计算发送窗口？ 1发送窗口大小 = min(rwnd, cwnd) 取两者的较小值。而拥塞控制，就是来控制cwnd的变化。 慢启动刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。 因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下: 首先，三次握手，双方宣告自己的接收窗口大小 双方初始化自己的拥塞窗口(cwnd)大小 在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。 难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！ 在到达阈值后，如何来控制 cwnd 的大小呢？ 这就是拥塞避免做的事情了。 拥塞避免原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 / cwnd。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。 也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。 当然，慢启动和拥塞避免是一起作用的，是一体的。 快速重传和快速恢复快速重传在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。 比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。 这就是快速重传，它解决的是是否需要重传的问题。 选择性重传那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？ 当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。 在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。 快速恢复当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。 在这个阶段，发送端如下改变： 拥塞阈值降低为 cwnd 的一半 cwnd 的大小变为拥塞阈值 cwnd 线性增加 以上就是 TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。 能不能说说 Nagle 算法和延迟确认？Nagle 算法试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。 而避免小包的频繁发送，这就是 Nagle 算法要做的事情。 具体来说，Nagle 算法的规则如下: 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送 后面发送满足下面条件之一就可以发了: 数据包大小达到最大段大小(Max Segment Size, 即 MSS) 之前所有包的 ACK 都已接收到 延迟确认试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？ 延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。 不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复: 接收到了大于一个 frame 的报文，且需要调整窗口大小 TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置） 发现了乱序包 两者一起使用会怎样？前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。 如何理解 TCP 的 keep-alive？大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。 试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。 这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。 在 Linux 下，可以这样查看相关的配置: 1sudo sysctl -a | grep keepalive// 每隔 7200 s 检测一次net.ipv4.tcp_keepalive_time = 7200// 一次最多重传 9 个包net.ipv4.tcp_keepalive_probes = 9// 每个包的间隔重传间隔 75 snet.ipv4.tcp_keepalive_intvl = 75 不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？ 站在应用的角度: 7200s 也就是两个小时检测一次，时间太长 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接 因此是一个比较尴尬的设计。 基于丢包的阻塞控制点产生的问题Google的BBR阻塞控制算法","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件","date":"2021-07-20T05:09:35.077Z","updated":"2020-05-11T07:00:28.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-基础","date":"2021-07-20T05:09:35.072Z","updated":"2020-05-11T07:01:06.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-基础/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"介绍一下消息队列MQ的使用场景1.通过异步处理提高系统性能在不适用消息队列 服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送到消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获得数据，异步写入数据库，由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。 消息队列具有很好的削峰功能–即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀，促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。 2.降低系统耦合性使用消息队列的好处 消息中间件使用场景介绍消息中间件(ActiveMQ、RabbitMQ、RocketMQ、Kafka)简介及对比消息中间件的编年史 其他问题 引入消息队列之后如何确保高可用性 如何保证消息不被重复消费呢 如何保证消息的高可靠性传输 我该怎么保证从消息队列里拿到的数据按顺序执行 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该如何处理？有几百万消息持续积压几小时，说说该如何解决？ 如果让你来开发一个消息队列中间件，你会怎么设计架构","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-RocketMQ","date":"2021-07-20T05:09:35.070Z","updated":"2020-05-11T07:00:32.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-RocketMQ/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RocketMQ/","excerpt":"","text":"RocketMQ","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-RabbitMQ","date":"2021-07-20T05:09:35.068Z","updated":"2020-05-11T07:01:54.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-RabbitMQ/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/","excerpt":"","text":"RabbitMQRabbitMq AMQP规范和RabbitMQ基本概念 要素 生产者、消费者、消息 信道 交换器、队列、绑定、路由键 消息的确认 交换器类型 Direct Fanout Topic 虚拟主机 RabbitMQ在Windows下安装和运行 原生Java客户端使用 消息发布时的权衡 失败通知 发布者确认 事务 备用交换器 消息消费时的权衡 消息的获得方式 QoS预取模式 可靠性和性能的权衡 消息的拒绝 消息的拒绝方式 死信交换器 控制队列 临时队列 永久队列 队列级别消息过期 消息的属性 属性列表 消息的持久化 与Spring集成 Xml配置方式 SpringBoot 实战：应用解耦 安装配置 下载安装和日常管理 web监控平台 集群化与镜像队列 简介MQ全称为Message Queue，消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。队列的使用除去了接收和发送应用程序同时执行的请求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等。 RabbitMQ是一个在AMQP基础上完成的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。 AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端和消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。Erlang中的实现由RabbitMQ等。 安装先下载erlang，再安装rabbitmq erlang下载地址 rabbitmq下载地址 本机查看管理页面 http://127.0.0.1:15672/ 端口号：5672 用户角色1、超级管理员(administrator)可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。2、监控者(monitoring)可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)3、策略制定者(policymaker)可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。4、普通管理者(management)仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。5、其他无法登陆管理控制台，通常就是普通的生产者和消费者。 1.背景RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue)的开源实现。 2.应用场景2.1异步处理场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种1.串行的方式;2.并行的方式(1)串行方式:将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. (2)并行方式:将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并性已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,英爱是写入数据库后就返回.(3)消息队列引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。 2.2 应用解耦场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. 这种做法有一个缺点: 当库存系统出现故障时,订单就会失败。(这样马云将少赚好多好多钱^ ^)订单系统和库存系统高耦合.引入消息队列 订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。 库存系统:订阅下单的消息,获取下单消息,进行库操作。就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失(马云这下高兴了).流量削峰流量削峰一般在秒杀活动中应用广泛场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。作用:1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^)2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.2.秒杀业务根据消息队列中的请求信息，再做后续处理. 3.系统架构 几个概念说明:Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。Queue:消息的载体,每个消息都会被投到一个或多个队列。Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来.Routing Key:路由关键字,exchange根据这个关键字进行消息投递。vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。Producer:消息生产者,就是投递消息的程序.Consumer:消息消费者,就是接受消息的程序.Channel:消息通道,在客户端的每个连接里,可建立多个channel. 4.任务分发机制4.1Round-robin dispathching循环分发RabbbitMQ的分发机制非常适合扩展,而且它是专门为并发程序设计的,如果现在load加重,那么只需要创建更多的Consumer来进行任务处理。 4.2Message acknowledgment消息确认为了保证数据不被丢失,RabbitMQ支持消息确认机制,为了保证数据能被正确处理而不仅仅是被Consumer收到,那么我们不能采用no-ack，而应该是在处理完数据之后发送ack.在处理完数据之后发送ack,就是告诉RabbitMQ数据已经被接收,处理完成,RabbitMQ可以安全的删除它了.如果Consumer退出了但是没有发送ack,那么RabbitMQ就会把这个Message发送到下一个Consumer，这样就保证在Consumer异常退出情况下数据也不会丢失.RabbitMQ它没有用到超时机制.RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有正确处理，也就是说RabbitMQ给了Consumer足够长的时间做数据处理。如果忘记ack,那么当Consumer退出时,Mesage会重新分发,然后RabbitMQ会占用越来越多的内存. 5.Message durability消息持久化要持久化队列queue的持久化需要在声明时指定durable=True;这里要注意,队列的名字一定要是Broker中不存在的,不然不能改变此队列的任何属性.队列和交换机有一个创建时候指定的标志durable,durable的唯一含义就是具有这个标志的队列和交换机会在重启之后重新建立,它不表示说在队列中的消息会在重启后恢复消息持久化包括3部分 exchange持久化,在声明时指定durable =&gt; true hannel.ExchangeDeclare(ExchangeName, “direct”, durable: true, autoDelete: false, arguments: null);//声明消息队列，且为可持久化的12.queue持久化,在声明时指定durable =&gt; true channel.QueueDeclare(QueueName, durable: true, exclusive: false, autoDelete: false, arguments: null);//声明消息队列，且为可持久化的13.消息持久化,在投递时指定delivery_mode =&gt; 2(1是非持久化). channel.basicPublish(“”, queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());1如果exchange和queue都是持久化的,那么它们之间的binding也是持久化的,如果exchange和queue两者之间有一个持久化，一个非持久化,则不允许建立绑定.注意：一旦创建了队列和交换机,就不能修改其标志了,例如,创建了一个non-durable的队列,然后想把它改变成durable的,唯一的办法就是删除这个队列然后重现创建。 6.Fair dispath 公平分发你可能也注意到了,分发机制不是那么优雅,默认状态下,RabbitMQ将第n个Message分发给第n个Consumer。n是取余后的,它不管Consumer是否还有unacked Message，只是按照这个默认的机制进行分发.那么如果有个Consumer工作比较重,那么就会导致有的Consumer基本没事可做,有的Consumer却毫无休息的机会,那么,Rabbit是如何处理这种问题呢? 通过basic.qos方法设置prefetch_count=1，这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理一个Message，换句话说,在接收到该Consumer的ack前,它不会将新的Message分发给它 channel.basic_qos(prefetch_count=1)1注意，这种方法可能会导致queue满。当然，这种情况下你可能需要添加更多的Consumer，或者创建更多的virtualHost来细化你的设计。 7.分发到多个Consumer7.1Exchange先来温习以下交换机路由的几种类型:Direct Exchange:直接匹配,通过Exchange名称+RountingKey来发送与接收消息.Fanout Exchange:广播订阅,向所有的消费者发布消息,但是只有消费者将队列绑定到该路由器才能收到消息,忽略Routing Key.Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息;Headers Exchange:消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey.默认的exchange:如果用空字符串去声明一个exchange，那么系统就会使用”amq.direct”这个exchange，我们创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去 channel.BasicPublish(“”, “TaskQueue”, properties, bytes);1因为在第一个参数选择了默认的exchange，而我们申明的队列叫TaskQueue，所以默认的，它在新建一个也叫TaskQueue的routingKey，并绑定在默认的exchange上，导致了我们可以在第二个参数routingKey中写TaskQueue，这样它就会找到定义的同名的queue，并把消息放进去。如果有两个接收程序都是用了同一个的queue和相同的routingKey去绑定direct exchange的话，分发的行为是负载均衡的，也就是说第一个是程序1收到，第二个是程序2收到，以此类推。如果有两个接收程序用了各自的queue，但使用相同的routingKey去绑定direct exchange的话，分发的行为是复制的，也就是说每个程序都会收到这个消息的副本。行为相当于fanout类型的exchange。下面详细来说: 7.2 Bindings 绑定绑定其实就是关联了exchange和queue，或者这么说:queue对exchange的内容感兴趣,exchange要把它的Message deliver到queue。 7.3Direct exchangeDriect exchange的路由算法非常简单:通过bindingkey的完全匹配，可以用下图来说明. Exchange和两个队列绑定在一起,Q1的bindingkey是orange，Q2的binding key是black和green.当Producer publish key是orange时,exchange会把它放到Q1上,如果是black或green就会到Q2上,其余的Message被丢弃. 7.4 Multiple bindings多个queue绑定同一个key也是可以的,对于下图的例子,Q1和Q2都绑定了black,对于routing key是black的Message，会被deliver到Q1和Q2，其余的Message都会被丢弃. 7.5 Topic exchange对于Message的routing_key是有限制的，不能使任意的。格式是以点号“.”分割的字符表。比如：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”。你可以放任意的key在routing_key中，当然最长不能超过255 bytes。对于routing_key，有两个特殊字符 *(星号)代表任意一个单词#(hash)0个或多个单词 Producer发送消息时需要设置routing_key，routing_key包含三个单词和连个点号o,第一个key描述了celerity(灵巧),第二个是color(色彩),第三个是物种:在这里我们创建了两个绑定： Q1 的binding key 是”.orange.“； Q2 是 “..rabbit” 和 “lazy.#”： Q1感兴趣所有orange颜色的动物Q2感兴趣所有rabbits和所有的lazy的.例子:rounting_key 为 “quick.orange.rabbit”将会发送到Q1和Q2中rounting_key 为”lazy.orange.rabbit.hujj.ddd”会被投递到Q2中,#匹配0个或多个单词。8.消息序列化RabbitMQ使用ProtoBuf序列化消息,它可作为RabbitMQ的Message的数据格式进行传输,由于是结构化的数据,这样就极大的方便了Consumer的数据高效处理,当然也可以使用XML，与XML相比,ProtoBuf有以下优势:1.简单2.size小了3-10倍3.速度快了20-100倍4.易于编程6.减少了语义的歧义.，ProtoBuf具有速度和空间的优势，使得它现在应用非常广泛 SpringBoot整合https://blog.csdn.net/qq_38455201/article/details/80308771","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-MetaQ","date":"2021-07-20T05:09:35.067Z","updated":"2020-05-11T07:00:30.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-MetaQ/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-MetaQ/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-Kafka","date":"2021-07-20T05:09:35.064Z","updated":"2020-05-11T07:00:48.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-Kafka/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-Kafka/","excerpt":"","text":"KafkaKafka Kafka入门 Kafka中的基本概念 为什么选择Kafka Kafka的安装和配置参数 Kafka的生产者和消费者 消息的发送和接收 生产者和消费者的配置 消费者群组和再均衡 消费者中的提交和偏移量 序列化和反序列化 深入理解Kafka 控制器和复制 请求处理流程 物理存储原理 保证Kafka的可靠数据传递 数据管道和流式处理入门 数据管道基本概念 流式处理基本概念和设计模式","categories":[],"tags":[]},{"title":"","slug":"消息中间件/消息中间件-ActiveMQ","date":"2021-07-20T05:09:35.063Z","updated":"2020-05-11T07:00:50.000Z","comments":true,"path":"2021/07/20/消息中间件/消息中间件-ActiveMQ/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-ActiveMQ/","excerpt":"","text":"ActiveMq JMS规范 什么是JMS（Java Messaging Service）规范？ 包含要素 消息类型 P2P模型 Topic(PUB\\SUB)模型 ActiveMQ使用 安装和部署 原生ActiveMQ的API编程 与Spring集成 Xml配置方式 SpringBoot Request-Response模式 实战：用户注册的异步处理 ActiveMQ高级特性和用法 嵌入式MQ 消息存储的持久化机制 消息持久订阅 消息的可靠性 通配符式分层订阅 死信队列DLQ(Dead Letter Queue) 镜像队列 虚拟主题 组合Destinations 实战：限时订单 企业级高可用集群部署方案 Shared File System DB Replicated LevelDB Store Broker-Cluster","categories":[],"tags":[]},{"title":"","slug":"这次我让你彻底弄懂 RESTful","date":"2021-07-20T05:09:35.058Z","updated":"2021-01-04T10:46:04.000Z","comments":true,"path":"2021/07/20/这次我让你彻底弄懂 RESTful/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E8%BF%99%E6%AC%A1%E6%88%91%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20RESTful/","excerpt":"","text":"RESTful 想必大家都耳熟能详。 但是为什么要有 RESTful，RESTful 到底是什么意思。 为什么称之为 RESTful 架构？ 我不用 RESTful 不行吗？ 什么样才叫真正的 RESTful ？ 其实网上 RESTful 的文章有挺多的，不过有些讲的糊里糊涂的，而且很大部分都忽略了 HATEOAS。 在之前的面试中面试官就问过我，你怎么理解 RESTful 的，英文全称是啥？为什么叫这个名字? 当时我人都傻了。 面试官不讲武德，针对我这个刚出社会的小伙子。 其实有很多人也稀里糊涂的，也包括我自己。 就面向资源呗，不加动词咯，还能咋滴，我加动词不也能用吗？ 而且我之前还特不能理解，为啥这叫架构？ 我特意搜索了下架构的解释。 软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。 整体结构与组件的抽象描述。 RESTful 哪有什么组件和结构之间的玩意？ 所以就至今我写下这篇文章的时候我也理解不了为什么叫 RESTful 架构。 可能是我对架构的理解太狭隘，还不到火候。 我个人只能理解成 RESTful 风格的 API 设计，也就是说 RESTful 只是一种指导风格，就像我们 Java 要用驼峰命名法。 那不用驼峰命名法代码就不能跑了吗？ 当然能跑，这只是一种希望大家都能遵循的规范。 对 RESTful 而言我觉得算不上规范，只能说指导风格。 来让我们正式的进入对 RESTful 的剖析。 RESTREST 不是一个单词，是 Representational State Transfer 的缩写。 直译过来就是表述性状态转移。 我对这个名字蒙了一年多，就不能说点能听得懂的嘛。 从提出 REST 的论文中我翻了翻，没有明说但是表达的意思是其实它还有个主语 Resource 。 所以是资源的表述性状态转移。 稍微可以理解一点了。 我们先不管什么状态转移，大致先有点感觉。 知道 REST 之后 RESTful 就不难解释了，加 ful 就是变形容词了，比如 wonderful girl。 至此对名字稍微解释了一下，疑惑还在没事，咱们慢慢理。 REST 的核心核心就是资源，用 URL 定位资源，用 HTTP 动词来描述所要做的操作。 HTTP的提供了很多动词：GET、PUT、POST、DELETE…… 这些动词都是有含义的。 比如 GET 就是获取资源，是查询请求。 PUT 指的是修改资源，是幂等的。 POST 也是修改(新增也是一种修改)，指的是不幂等的操作。 所以根据这些规范我们都能得知这次交互的一些动作，所以 RESTful 风格正确的使用姿势如下： 比如获取一个 user。 错误姿势：GET /getUserById?userId=1。 正确姿势：GET /users/1。 再比如新增 user。 错误姿势：POST /addUser （省略body）。 正确姿势：POST /users （省略body）。 可以看到 HTTP 的动词其实就能指代你要对资源做的操作，所以不需要在 URL 上做一些东西，就把 URL 表明的东西看作一个资源即可。 这里注意要用对 HTTP 动词，比如一个获取资源的请求用 PUT，用了也能获取资源但是这不合适。 其实更深一步的理解是 HTTP 是一个协议。 协议其实就是约定好的一个东西，协议就规定 GET 是获取资源，那你非得在 URL 上再重复一遍或者所有请求不论增删改都用 GET 这个动作，这其实就是没有完全遵循这个协议。 可以说只是把 HTTP 当成一个传输管道，而不是约定好的协议。 这其实是对 HTTP 更深一层的认识，我认为也是 RESTful 被推出的原因。 当然理想很丰满，现实很骨感，还是有很多人就 getUserById。 不过我个人觉得问题不大，公司统一就行。 HATEOAS即 Hypermedia as the Engine of Application State 的缩写，翻译过来就是作为应用状态引擎的超媒体。 这也是 REST 提出的设计。 是不是理解不了？其实很简单。 例子我就不自己编了，抄一下 stackoverflow 回答上的例子。 比如你请求获取用户列表： 12GET /usersAccept: application/json+userdb 此时的返回应该是： 12345678910111213141516171819202122232425262728293031323334353637383940200 OKContent-Type: application/json+userdb&#123; &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Emil&quot;, &quot;country: &quot;Sweden&quot;, &quot;links&quot;: [ &#123; &quot;href&quot;: &quot;/user/1&quot;, &quot;rel&quot;: &quot;self&quot;, &quot;method&quot;: &quot;GET&quot; &#125;, &#123; &quot;href&quot;: &quot;/user/1&quot;, &quot;rel&quot;: &quot;edit&quot;, &quot;method&quot;: &quot;PUT&quot; &#125;, &#123; &quot;href&quot;: &quot;/user/1&quot;, &quot;rel&quot;: &quot;delete&quot;, &quot;method&quot;: &quot;DELETE&quot; &#125; ] &#125;, &#123; &quot;id&quot;: 2, ....省略..... &#125; ], &quot;links&quot;: [ &#123; &quot;href&quot;: &quot;/user&quot;, &quot;rel&quot;: &quot;create&quot;, &quot;method&quot;: &quot;POST&quot; &#125; ]&#125; 重点就是这个 links，结果会返回你能对这个资源所做的操作。 比如对于 userId 是 1 的，你调用PUT /user/1就是做修改这个用户，DELETE /user/1就是删除这个用户。 最外层的 links 告诉你用 POST /user 就能再创建一个用户。 这里还有个隐藏信息，可以看到外层的 links 没有返回 DELETE 的信息，说明此时客户端无法删除用户！ 所以说 RESTful API 还需要再返回此时能对资源做的操作，这样客户端就知道它能做什么。 它也不需要管具体怎么做，反正返回里面会告诉它 DELETE 就这样这样，POST 就这样这样。 没告诉它的就是不能做的。 然后这个时候再去理解下资源的表述性状态转移，是不是感觉来了？ 如果说上一 part 提到用 HTTP 的动词来指代动作， URL 仅表示资源的现实是骨感的。 那么 HATEOAS 的现实就是骨灰。 基本上没几家公司会这么做。 就我个人而言这玩意没啥用。 它的出发点是让客户端从响应就能得知对资源操作的入口，并且通过响应得知哪些动作能执行。 听起来好像有点用，但是就我目前的功力，我只能看到响应变得十分冗余。 最后这篇文章关于 RESTful API 具体的写法我就提到一些，还有挺多的就自己查资料吧。 文章的目的是为了让你理解 RESTful API，我再总结一下重点。 HTTP 是协议，不是传输通道。（对协议不理解的看我之前的 HTTP 分析） 所以协议约定了很多东西，推荐我们按照协议的用法进行客户端和服务端的交互。 也就是 RESTful 表明的面向资源，通过 HTTP 动作 + URL 上的资源。 RESTful 还提到了 HATEOAS，虽说基本上没什么公司会这样使用，但是它能让你更好的理解 REST 这个名字的含义。 RESTful 是一种风格，你是否采用这种风格对你的程序运行没有影响，类比驼峰命名来思考。 简而言之，RESTful 就是不要在 URL 上表现出动作，用 HTTP 动词代表动作，URL 上只做资源。 仅此而已。 至于要不要严格遵循 RESTful 风格，我个人的看法是公司内部保持一致就行。","categories":[],"tags":[]},{"title":"","slug":"数据库/Redis/Redis计数器解决并发问题","date":"2021-07-20T05:09:35.036Z","updated":"2020-08-06T03:11:18.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis计数器解决并发问题/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/","excerpt":"","text":"Redis解决并发问题用setnx替代set命令初始化计数器，这确保了一旦A初始化计数器成功，B就不会再去初始化计数器。 12345678910111213141516171819202122/** * 获取用户当前的排序 * @return int */ protected function getCurrentOrder() &#123; $redis = new R(&quot;game&quot;); $order = $redis-&gt;get(self::$hd_ename); $number = point_model::getPointLogByTips(self::$hd_ename, &#x27;luckNumber&#x27;); if(!$order)&#123; if($number)&#123; $number = $number[count($number) - 1][&#x27;point&#x27;]; &#125;else&#123; $number = 0; &#125; $redis-&gt;setex(self::$hd_ename,120,$number); &#125;else&#123; $number = $redis-&gt;incr(self::$hd_ename); &#125; return $number; &#125; 我们都或多或少遇到过并发问题。家人因为看电视抢遥控器，这就是一种并发；两个孩子争着玩同一个玩具，这也是并发。在每一次“双11”购物节狂欢的背后，都有一群程序员在严阵以待，这不是一位数的并发，而是成千上万级别的并发。 说了什么是并发，接下来将向大家演示如何用Redis处理一个典型的并发问题。我们选择最常见的商品抢购场景，假定我们有100件商品，参与抢购的用户有成千上万，如何确保我们的商品不被多抢了？ 聪明的你应该想到了，可以用计数器来控制，每卖出一件商品，计数器加1，当计数器到达100时，我们的商品就卖完了。程序的工作流程如下图。 看起来很完美，但需要通过高并发场景的检验。我们假定有A、B两个进程同时在运行这段程序。 问题1初始化set计数器：A、B都发现计数器尚未初始化，在A执行“计数器加1”后，B去set计数器，此时计数器的值比正确值少1。（为什么时间差那么大？这在高并发场景中是完全可能存在的） 问题2计数器加1：A、B都读到计数器的值为99，不满足&gt;=100，两者都抢到了商品，但最终卖掉了101件，显然超卖了。 上面的流程存在两个问题，我们需要对程序流程做一点改进，新的流程如下图。 改进1用setnx替代set命令初始化计数器，这确保了一旦A初始化计数器成功，B就不会再去初始化计数器。 改进2先对计数器加1，再判断计数器是否&gt;100，如果是，说明超卖了。这确保了即使A、B同时读到计数器的值为99，都去对计数器加1，两者至少有一个得到的结果&gt;100，不会超卖。 从以上的内容我们学习到，如何用Redis处理一个常见的并发场景，这背后还有更多的技术细节值得我们深入了解，期待在下一篇文章中与大家共同学习。","categories":[],"tags":[]},{"title":"Redis的skiplist","slug":"数据库/Redis/Redis-skiplist","date":"2021-07-20T05:09:35.033Z","updated":"2021-07-27T01:42:38.389Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis-skiplist/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-skiplist/","excerpt":"","text":"跳表的实现从排行榜切入懂行的老哥一看这个小标题，就知道我要以排行榜作为切入点，去讲 Redis 的 zset 了。 是的，经典面试题，请实现一个排行榜，大部分情况下就是在考验你知不知道 Redis 的 zset 结构，和其对应的操作。 当然了，排行榜我们也可以基于其他的解决方案。比如 mysql。 我曾经就基于 mysql 做过排行榜，一条 sql 就能搞定。但是仅限于数据量比较少，性能要求不高的场景（我当时只有 11 支队伍做排行榜，一分钟刷新一次排行榜）。 对于这种经典的面试八股文，网上一找一大把，所以本文就不去做相关解析了。 说好的只是一个切入点。 如果你不知道具体怎么实现，或者根本就不知道这题在问啥，那一定记得看完本文后要去看看相关的文章。最好自己实操一下。 相信我，八股文，得背，这题会考。 zset的内部编码众所周知，Redis 对外提供了五种基本数据类型。但是每一种基本类型的内部编码却是另外一番风景： 其中 list 数据结构，在 Redis 3.2 版本中还提供了 quicklist 的内部编码。不是本文重点，我提一嘴就行，有兴趣的朋友自己去了解一下。 本文主要探讨的是上图中的 zset 数据结构。 zset 的内部编码有两种：ziplist 和 skiplist。 其实你也别觉得这个东西有多神奇。因为对于这种对外一套，对内又是一套的“双标党”其实你已经很熟悉了。 它就是 JDK 的一个集合类，来朋友们，大胆的喊出它的名字：HashMap。 HashMap 除了基础的数组结构之外，还有另外两个数据结构：一个链表，一个红黑树。 这样一联想是不是就觉得也不过如此，心里至少有个底了。 当链表长度大于 8 且数组长度大于 64 的时候， HashMap 中的链表会转红黑数。 对于 zset 也是一样的，一定会有条件触发其内部编码 ziplist 和 skiplist 之间的变化？ 这个问题的答案就藏在 redis.conf 文件中，其中有两个配置： 上图中配置的含义是，当有序集合的元素个数小于 zset-max-ziplist-entries 配置的值，且每个元素的值的长度都小于 zset-max-ziplist-value 配置的值时，zset 的内部编码是 ziplist。 反之则用 skiplist。 理论铺垫上了，接下我给大家演示一波。 首先，我们给 memberscore 这个有序集合的 key 设置两个值，然后看看其内部编码： 此时有序集合的元素个数是 2，可以看到，内部编码采用的是 ziplist 的结构。 为了大家方便理解这个储存，我给大家画个图： 然后我们需要触发内部编码从 ziplist 到 skiplist 的变化。 先验证 zset-max-ziplist-value 配置，往 memberscore 元素中塞入一个长度大于 64字节（zset-max-ziplist-value默认配置）的值： 这个时候 key 为 memberscore 的有序集合中有 3 个元素了，其中有一个元素的值特别长，超过了 64 字节。 此时的内部编码采用的是 skiplist。 接下来，我们往 zset 中多塞点值，验证一下元素个数大于 zset-max-ziplist-entries 的情况。 我们搞个新的 key，取值为 whytestkey。 首先，往 whytestkey 中塞两个元素，这是其内部编码还是 ziplist： 那么问题来了，从配置来看 zset-max-ziplist-entries 128。 这个 128 是等于呢还是大于呢？ 没关系，我也不知道，试一下就行了。 现在已经有两个元素了，再追加 126 个元素，看看： 通过实验我们发现，当 whytestkey 中的元素个数是 128 的时候，其内部编码还是 ziplist。 那么触发其从 ziplist 转变为 skiplist 的条件是 元素个数大于 128，我们再加入一个试一试： 果然，内部编码从 ziplist 转变为了 skiplist。 理论验证完毕，zset 确实是有两幅面孔。 本文主要探讨 skiplist 这个内部编码。 它就是标题说的：基于运气的数据结构。 什么是 skiplist？这个结构是一个叫做 William Pugh 的哥们在 1990 年发布的一篇叫做《Skip Lists: A Probabilistic Alternative to Balanced Trees》的论文中提出的。 1论文地址：ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf 摘要里面说：跳表是一种可以用来代替平衡树的数据结构，跳表使用概率平衡而不是严格的平衡，因此，与平衡树相比，跳表中插入和删除的算法要简单得多，并且速度要快得多。 论文里面，在对跳表算法进行详细描述的地方他是这样说的： 首先火男大佬说，对于一个有序的链表来说，如果我们需要查找某个元素，必须对链表进行遍历。比如他给的示意图的 a 部分。 我单独截取一下： 这个时候，大家还能跟上，对吧。链表查找，逐个遍历是基本操作。 那么，如果这个链表是有序的，我们可以搞一个指针，这个指针指向的是该节点的下下个节点。 意思就是往上抽离一部分节点。 怎么抽离呢，每隔一个节点，就抽一个出来，和上面的 a 示意图比起来，变化就是这样的： 抽离出来有什么好处呢？ 假设我们要查询的节点是 25 。 当就是普通有序链表的时候，我们从头节点开始遍历，需要遍历的路径是： head -&gt; 3 -&gt; 6 -&gt; 7 -&gt; 9 -&gt; 12 -&gt; 17 -&gt; 19 -&gt; 21 -&gt; 25 需要 9 次查询才能找到 25 。 但是当结构稍微一变，变成了 b 示意图的样子之后，查询路径就是： 第二层的 head -&gt; 6 -&gt; 9 -&gt; 17 -&gt; 21 -&gt; 25。 5 次查询就找到了 25 。 这个情况下我们找到指定的元素，不会超过 (n/2)+1 个节点： 那么这个时候有个小问题就来了：怎么从 21 直接到 25 的呢？ 看论文中的图片，稍微有一点不容易明白。 所以，我给大家重新画个示意图： 看到了吗？“多了”一个向下的指针。其实也不是多了，只是论文里面没有明示而已。 所以，查询 25 的路径是这样的，空心箭头指示的方向： 在 21 到 26 节点之间，往下了一层，逻辑也很简单。 21 节点有一个右指针指向 26，先判断右指针的值大于查询的值了。 于是下指针就起到作用了，往下一层，再继续进行右指针的判断。 其实每个节点的判断逻辑都是这样，只是前面的判断结果是进行走右指针。 按照这个往上抽节点的思想，假设我们抽到第四层，也就是论文中的这个示意图： 我们查询 25 的时候，只需要经过 2 次。 第一步就直接跳过了 21 之前的所有元素。 怎么样，爽不爽？ 但是，它是有缺陷的。 火男的论文里面是这样说的： This data structure could be used for fast searching, but insertion and deletion would be impractical. 查询确实飞快。但是对于插入和删除 would be impractical。 impractical 是什么意思？ 你看，又学一个四级单词。 对于插入和删除几乎是难以实现的。 你想啊，上面那个最底层的有序链表，我一开始就拿出来给你了。 然后我就说基于这个有序链表每隔一个节点抽离到上一层去，再构建一个链表。那么这样上下层节点比例应该是 2:1。巴拉巴拉的….. 但是实际情况应该是我们最开始的时候连这个有序链表都没有，需要自己去创建的。 就假设要在现有的这个跳表结构中插入一个节点，毋庸置疑，肯定是要插入到最底层的有序链表中的。 但是你破坏了上下层 2:1 的比例了呀？ 怎么办，一层层的调整呗。 可以，但是请你考虑一下编码实现起来的难度和对应的时间复杂度？ 要这样搞，直接就是一波劝退。 这就受不了了？ 我还没说删除的事呢。 那怎么办？ 看看论文里面怎么说到： 首先我们关注一下第一段划红线的地方。 火男写到：50% 的节点在第一层，25% 的节点在第二层， 12.5% 的节点在第三层。 你以为他在给你说什么？ 他要表达的意思除了每一层节点的个数之外，还说明了层级： 没有第 0 层，至少论文里面没有说有第 0 层。 如果你非要说最下面那个有全部节点的有序链表叫做第 0 层，我觉得也可以。但是，我觉得叫它基础链表更加合适一点。 然后我再看第二段划线的地方。 火男提到了一个关键词：randomly，意思是随机。 说出来你可能不信，但是跳表是用随机的方式解决上面提出的插入（删除）之后调整结构的问题。 怎么随机呢？抛硬币。 是的，没有骗你，真的是“抛硬币”。 跳表中的“硬币”当跳表中插入一个元素的时候，火男表示我们上下层之间可以不严格遵循 1:2 的节点关系。 如果插入的这个元素需要建立索引，那么把索引建立在第几层，都是由抛硬币决定的。 或者说：由抛硬币的概率决定的。 我问你，一个硬币抛出去之后，是正面的概率有多大？ 是不是 50%？ 如果我们把这个概率记为 p，那么 50%，即 p=1/2。 上面我们提到的概率，到底是怎么用的呢？ 火男的论文中有一小节是这样的写的： 随机选择一个层级。他说我们假设概率 p=1/2，然后叫我们看图 5。 图 5 是这样的： 非常关键的一张图啊。 短短几行代码，描述的是如何选择层级的随机算法。 首先定义初始层级为 1（lvl := 1）。 然后有一行注释：random() that returns a random value in [0…1) random() 返回一个 [0…1) 之间的随机值。 接下来一个 while…do 循环。 循环条件两个。 第一个：random() &lt; p。由于 p = 1/2，那么该条件成立的概率也是 1/2。 如果每随机一次，满足 random() &lt; p，那么层级加一。 那假设你运气爆棚，接连一百次随机出来的数都是小于 p 的怎么办？岂不是层级也到 100 层了？ 第二个条件 lvl &lt; MaxLevel，就是防止这种情况的。可以保证算出来的层级不会超过指定的 MaxLevel。 这样看来，虽然每次都是基于概率决定在那个层级，但是总体趋势是趋近于 1/2 的。 带来的好处是，每次插入都是独立的，只需要调整插入前后节点的指针即可。 一次插入就是一次查询加更新的操作，比如下面的这个示意图： 对于这个概率，其实火男在论文专门写了一个小标题，还给出了一个图表： 最终得出的结论是，火男建议 p 值取 1/4。如果你主要关心的是执行时间的变化，那么 p 就取值 1/2。 说一下我的理解。首先跳表这个是一个典型的空间换时间的例子。 一个有序的二维数组，查找指定元素，理论上是二分查找最快。而跳表就是在基础的链表上不断的抽节点（或者叫索引），形成新的链表。 所以，当 p=1/2 的时候，就近似于二分查找，查询速度快，但是层数比较高，占的空间就大。 当 p=1/4 的时候，元素升级层数的概率就低，总体层高就低，虽然查询速度慢一点，但是占的空间就小一点。 根据《Redis深度历险》一书里面的描述，在 Redis 中 p 的取值就是 1/4，MaxLevel 的取值是 64（视版本而定，有的Redis版本是32）。 论文里面还花了大量的篇幅去推理时间复杂度，有兴趣的可以去看着论文一起推理一下： 跳表在Java中的应用跳表，虽然是一个接触比较少的数据结构。 其实在 java 中也有对应的实现。 先问个问题：Map 家族中大多都是无序的，那么请问你知道有什么 Map 是有序的呢？ TreeMap，LinkedHashMap 是有序的，对吧。 但是他们不是线程安全的。 那么既是线程安全的，又是有序的 Map 是什么？ 那就是它，一个存在感也是低的不行的 ConcurrentSkipListMap。 你看它这个名字多吊，又有 list 又有 Map。 看一个测试用例： 12345678910111213141516public class MainTest &#123; public static void main(String[] args) &#123; ConcurrentSkipListMap&lt;Integer, String&gt; skipListMap = new ConcurrentSkipListMap&lt;&gt;(); skipListMap.put(3,&quot;3&quot;); skipListMap.put(6,&quot;6&quot;); skipListMap.put(7,&quot;7&quot;); skipListMap.put(9,&quot;9&quot;); skipListMap.put(12,&quot;12&quot;); skipListMap.put(17,&quot;17&quot;); skipListMap.put(19,&quot;19&quot;); skipListMap.put(21,&quot;21&quot;); skipListMap.put(25,&quot;25&quot;); skipListMap.put(26,&quot;26&quot;); System.out.println(&quot;skipListMap = &quot; + skipListMap); &#125;&#125; 输出结果是这样的，确实是有序的： 稍微的剖析一下。首先看看它的三个关键结构。 第一个是 index： index 里面包含了一个节点 node、一个右指针（right）、一个下指针（down）。 第二个是 HeadIndex: 它是继承自 index 的，只是多了一个 level 属性，记录是位于第几层的索引。 第三个是 node： 这个 node 没啥说的，一看就是个链表。 这三者之间的关系就是示意图这样的： 我们就用前面的示例代码，先 debug 一下，把上面的示意图，用真实的值填充上。 debug 跑起来之后，可以看到当前是有两层索引的，需要注意的是这里的两层是不包含最底层的基础的有序链表的： 我们先看看第二层的链表是怎样的，也就是看第二层头节点的 right 属性： 所以第二层的链表是这样的： 第二层的 HeadIndex 节点除了我们刚刚分析的 right 属性外，还有一个 down，指向的是下一层，也就是第一层的 HeadIndex： 可以看到第一层的 HeadIndex 的 down 属性是 null。但是它的 right 属性是有值的，但 right 属性里面的 down 属性也是 null： 可以画出第一层的链表结构是这样的： 同时我们可以看到其 node 属性里面其实是整个有序链表（其实每一层的 HeadIndex 里面都有，right 节点里面也有）： 所以，整个跳表结构是这样的，需要注意的是最底层的有序链表和第一层之间是虚线连接的，它们之间是不存在 down 属性的： 但是当你拿着同样的程序，自己去调试的时候，你会发现，你的跳表不长这样啊？ 当然不一样了，一样了才是撞了鬼了。 别忘了，索引的层级是随机产生的。 ConcurrentSkipListMap 是怎样随机的呢？ 带大家看看 put 部分的源码。 标号为 ① 的地方代码很多，但是核心思想是把指定元素维护进最底层的有序链表中。就不进行解读了，所以我把这块代码折叠起来了。 标号为 ② 的地方是 (rnd &amp; 0x80000001) == 0。 这个 rnd 是上一行代码随机出来的值。 而 0x80000001 对应的二进制是这样的： 一头一尾都是1，其他位都是 0。 那么只有 rnd 的一头一尾都是 0 的时候，才会满足 if 条件，(rnd &amp; 0x80000001) == 0。 二进制的一头一尾都是 0，说明是一个正偶数。 随机出来一个正偶数的时候，表明需要对其进行索引的维护。 负偶数，负奇数，正偶数，正奇数。而这里只要正偶数，说明这里的概率其实是 1/4。 标号为 ③ 的地方是判断当前元素要维护到第几层索引中。默认是第 1 层。 ((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0 ，已知 rnd 是一个正偶数，那么从其二进制的低位的第二位（第一位肯定是0嘛）开始，有几个连续的 1，就维护到第几层。 不明白？没关系，我举个例子。 假设随机出来的正偶数是 110，其二进制是 01101110。因为有 3 个连续的 1，那么 level 就是从 1 连续自增 3 次，最终的 level 就是 4。 那么问题就来了，如果我们当前最多只有 2 层索引呢？直接就把索引干到第 4 层吗？ 这个时候标号为 ④ 的代码的作用就出来了。 如果新增的层数大于现有的层数，那么只是在现有的层数上进行加一。 这个时候我们再回过头去看看火男论文里面的随机算法： 意思是一个意思，但是实现起来其实是两个不同的方案。但是核心实现都是随机。 所以，你现在知道了，由于有随机数的出现，所以即使是相同的参数，每次都可以构建出不一样的跳表结构。 比如还是前面演示的代码，我 debug 截图的时候有两层索引。 但是，其实有的时候我也会碰到 3 层索引的情况。 别问为什么，用心去感受，你心里应该有数。 另外，开篇用 redis 作为了切入点，其实 redis 的跳表整体思想是大同的，但是也是有小异的。 比如 Redis 在 skiplist 的 forward 指针（相当于 index）上，每个 forward 指针都增加了 span 属性。 在《Redis深度历险》一书里面对该属性进行了描述： 好了，那么这次的文章就到这里啦。","categories":[],"tags":[]},{"title":"Redis应用-位图","slug":"数据库/Redis/Redis应用-位图","date":"2021-07-20T05:09:35.031Z","updated":"2021-08-01T03:38:47.040Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis应用-位图/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%BA%94%E7%94%A8-%E4%BD%8D%E5%9B%BE/","excerpt":"我们都知道8bit = 1b = 2^-10kb， bitmap就是通过最小的单位 bit来进行0或者1的设置，表示某个元素对应的值或者状态。 一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。 位图并不是一种特殊的数据结构，其实本质上是二进制字符串，也可以看做是 byte 数组。可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。","text":"我们都知道8bit = 1b = 2^-10kb， bitmap就是通过最小的单位 bit来进行0或者1的设置，表示某个元素对应的值或者状态。 一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。 位图并不是一种特殊的数据结构，其实本质上是二进制字符串，也可以看做是 byte 数组。可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。 位图的优势: 基于最小的单位bit进行存储，所以非常省空间。 设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的 二进制数据的存储，进行相关计算的时候非常快 方便扩容 一般可以在如下场景使用： 用户签到 用户在线状态 统计活跃用户 各种状态值 常用命令SETBIT对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。SETBIT key offset valueoffset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。 GETBIT对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 1GETBIT key offset BITCOUNT计算给定字符串中，被设置为 1 的比特位的数量。 1BITCOUNT key BITPOS返回位图中第一个值为 bit 的二进制位的位置。 1BITPOS key bit[start][end] BITOP对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITOP operation destkey key[key…]operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种 BITOP AND destkey key[key...]，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITFIELDbitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令。 适用于各类统计应用记录用户的签到，每日在线情况等，可以将当天或者当天的偏移量对应的bit位设置为1即可，使用 BITCOUNT可以轻松统计签到次数。 还有一种使用比较多的情况，就是设置各类状态值，例如商城的设置：是否可以评价订单，是否展示售罄商品，是否正常营业等状态值可以使用bitmap来存储 在性能方面，如前面提到的签到，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT key [start] [end] 的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。 当然如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法： 将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。 使用 BITCOUNT key [start] [end] 的 start 和 end 参数，每次只对所需的部分位进行计算，然后在进行累加。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Alloceee"},{"title":"Redis常见问题","slug":"数据库/Redis/Redis常见问题","date":"2021-07-20T05:09:35.030Z","updated":"2021-07-27T08:38:12.716Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis常见问题/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、Redis雪崩、穿透、并发等5大难题解决方案缓存雪崩数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。 雪崩的简单过程： redis集群大面积故障 缓存失效，但依然大量请求访问缓存服务redis redis大量失效后，大量请求转向到mysql数据库 mysql的调用量暴增，很快就扛不住了，甚至直接宕机 由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。 如何预防缓存雪崩： 缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.缓存降级 可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。 当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。 降级的最终目的是保证核心服务可用，即使是有损的。 比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。 在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 3.Redis备份和快速预热 (1)Redis数据备份和恢复 (2)快速缓存预热 4.提前演练 最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。 缓存穿透缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决思路： 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。 可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。 缓存并发这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。 缓存预热缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路： 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 目的就是在系统上线前，将数据加载到缓存中。 二、Redis为什么是单线程，高并发快的3大原因详解Redis的高并发和快速原因 redis是基于内存的，内存的读写速度非常快； redis是单线程的，省去了很多上下文切换线程的时间； redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。 下面重点介绍单线程设计和IO多路复用核心设计快的原因。 为什么Redis是单线程的？1.官方答案 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。 2.性能指标 关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 3.详细原因 1.不需要各种锁的性能消耗 Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 2.单线程多进程集群方案 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。 所以单线程、多进程的集群不失为一个时髦的解决方案。 3.CPU消耗 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？ 可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。 Redis单线程的优劣势单进程单线程优势 代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善； IO多路复用技术 redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。 多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。 Redis高并发快总结 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。 三、Redis缓存和MySQL数据一致性方案详解 需求起因 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。 这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。 读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子： 如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。 如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。 缓存和数据库一致性解决方案1.第一种方案：采用延时双删策略 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。 伪代码如下： 123456public void write(String key,Object data)&#123; redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key);&#125; 具体的步骤就是： 先删除缓存；再写数据库；休眠500毫秒；再次删除缓存。 那么，这个500毫秒怎么确定的，具体该休眠多久呢？ 需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。 设置缓存过期时间 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 该方案的弊端 结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。 2、第二种方案：异步更新缓存(基于订阅binlog的同步机制) 技术整体思路： MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 读Redis：热数据基本都在Redis 写MySQL:增删改都是操作MySQL 更新Redis数据：MySQL的数据操作binlog，来更新到Redis Redis更新 1）数据操作主要分为两大块： 一个是全量(将全部数据一次写入到redis)一个是增量（实时更新） 这里说的是增量,指的是mysql的update、insert、delate变更数据。 2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。 当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://alloceee.github.io/tags/Redis/"}]},{"title":"","slug":"数据库/Redis/Redis","date":"2021-07-20T05:09:35.027Z","updated":"2020-05-11T07:01:38.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis/","excerpt":"","text":"Redis面试题大全含答案 1.什么是Redis？答：Remote Dictionary Server(Redis)是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 2.Redis的特点什么是？\\1. 支持多种数据结构，如 string(字符串)、 list(双向链表)、dict(hash表)、set(集合)、zset(排序set)、hyperloglog(基数估算)\\2. 支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。\\3. 支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。单进程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。 3.Redis数据类型有哪些？答：String(字符串)Hash(hash表)List(链表)Set(集合)SortedSet(有序集合zset) 4.Redis中的常用命令哪些？incr 让当前键值以1的数量递增，并返回递增后的值incrby 可以指定参数一次增加的数值，并返回递增后的值incrby 可以指定参数一次增加的数值，并返回递增后的值decrby 可以指定参数一次递减的数值，并返回递减后的值incrbyfloat 可以递增一个双精度浮点数append 作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value。返回值是追加后字符串的总长度。mget/mset 作用与get/set相似，不过mget/mset可以同时获得/设置多个键的键值del 根据key来删除valueflushdb 清除当前库的所有数据hset 存储一个哈希键值对的集合hget获取一个哈希键的值hmset 存储一个或多个哈希是键值对的集合hmget 获取多个指定的键的值hexists 判断哈希表中的字段名是否存在 如果存在返回1 否则返回0hdel 删除一个或多个字段hgetall 获取一个哈希是键值对的集合hvals 只返回字段值hkeys 只返回字段名hlen 返回key的hash的元素个数lpush key value向链表左侧添加rpush key value向链表右侧添加lpop key 从左边移出一个元素rpop key 从右边移出一个元素llen key 返回链表中元素的个数 相当于关系型数据库中 select count()lrange key start end lrange命令将返回索引从start到stop之间的所有元素。Redis的列表起始索引为0。lrange也支持负索引 lrange nn -2 -1 如 -1表示最右边第一个元素 -2表示最右边第二个元素，依次类推。lindex key indexnumber 如果要将列表类型当做数组来用，lindex命令是必不可少的。lindex命令用来返回指定索引的元素，索引从0开始如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。Lset key indexnumber value 是另一个通过索引操作列表的命令，它会将索引为index的元素赋值为value。sadd key value 添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0scard key 返回set的元素个数，如果set是空或者key不存在返回0smembers key 返回key对应set的所有元素，结果是无序的sismember key value 判断value 是否在set中，存在返回1，0表示不存在或者key不存在srem key value 从key对应set中移除给定元素，成功返回1，如果value 在集合中不存在或者key不存在返回0zadd key score value 将一个或多个value及其socre加入到set中zrange key start end 0和-1表示从索引为0的元素到最后一个元素（同LRANGE命令相似）zrange key 0 -1 withscores 也可以连同score一块输出，使用WITHSCORES参数zremrangebyscore key start end 可用于范围删除操作ping 测试redis是否链接 如果已链接返回 PONGecho value测试redis是否链接 如果已链接返回 echo命令后给定的值keys * 返回所有的key 可以加通配exists key判断string类型一个key是否存在 如果存在返回1 否则返回0expire key time(s) 设置一个key的过期时间 单位秒。时间到达后会删除key及valuettl key 查询已设置过期时间的key的剩余时间 如果返回-2表示该键值对已经被删除persist 移除给定key的过期时间select dbindex 选择数据库(0-15)move key dbIndex 将当前数据库中的key转移到其他数据库中dbsize 返回当前数据库中的key的数目info 获取服务器的信息和统计flushdb 删除当前选择的数据库中的keyflushall 删除所有数据库中的所有keyquit 退出连接 5.Redis的配置以及持久化方案有几种？以下两种RDB方式AOF方式 什么是RDB方式？是RDB是对内存中数据库状态进行快照RDB方式：将Redis在内存中的数据库状态保存到磁盘里面，RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态（默认下，持久化到dump.rdb文件，并且在redis重启后，自动读取其中文件，据悉，通常情况下一千万的字符串类型键，1GB的快照文件，同步到内存中的 时间是20-30秒）RDB的生成方式：1、执行命令手动生成有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求，创建RDB文件结束之前，客户端发送的BGSAVE和SAVE命令会被服务器拒绝 2、通过配置自动生成可以设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令，可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令例如：save 900 1save 300 10save 60 10000那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行服务器在900秒之内，对数据库进行了至少1次修改服务器在300秒之内，对数据库进行了至少10次修改服务器在60秒之内，对数据库进行了至少10000次修改 什么是AOF方式？AOF持久化方式在redis中默认是关闭的，需要修改配置文件开启该方式。AOF：把每条命令都写入文件，类似mysql的binlog日志AOF方式：是通过保存Redis服务器所执行的写命令来记录数据库状态的文件。AOF文件刷新的方式，有三种：appendfsync always - 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全appendfsync everysec - 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据appendfsync no - 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾AOF数据恢复方式服务器在启动时，通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态，具体过程：载入AOF文件创建模拟客户端从AOF文件中读取一条命令使用模拟客户端执行命令循环读取并执行命令，直到全部完成如果同时启用了RDB和AOF方式，AOF优先，启动时只加载AOF文件恢复数据","categories":[],"tags":[]},{"title":"","slug":"数据库/Redis/Redis-集群的原理与搭建","date":"2021-07-20T05:09:35.022Z","updated":"2020-07-15T03:05:34.000Z","comments":true,"path":"2021/07/20/数据库/Redis/Redis-集群的原理与搭建/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E6%90%AD%E5%BB%BA/","excerpt":"","text":"前言 Redis 是我们目前大规模使用的缓存中间件，由于它强大高效而又便捷的功能，得到了广泛的使用。单节点的Redis已经就达到了很高的性能，为了提高可用性我们可以使用Redis集群。本文参考了Rdis的官方文档和使用Redis官方提供的Redis Cluster工具搭建Rdis集群。 注意 ：Redis的版本要在3.0以上,截止今天，Redis的版本是3.2.9，本教程也使用3.2.9作为教程 Redis集群的概念 介绍 Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的错误。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 Redis 集群提供了以下两个好处： 将数据自动切分（split）到多个节点的能力。 当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。 数据分片 Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中： 节点 A 负责处理 0 号至 5500 号哈希槽。 节点 B 负责处理 5501 号至 11000 号哈希槽。 节点 C 负责处理 11001 号至 16384 号哈希槽。 这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说： 我现在想设置一个key，叫my_name: 1set my_name zhangguoji 按照Redis Cluster的哈希槽算法，CRC16(‘my_name’)%16384 = 2412 那么这个key就被分配到了节点A上 。 同样的，当我连接(A,B,C)的任意一个节点想获取my_name这个key,都会转到节点A上 ，再比如 ，如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。 增加一个D节点的结果可能如下： 节点A覆盖1365-5460 节点B覆盖6827-10922 节点C覆盖12288-16383 节点D覆盖0-1364,5461-6826,10923-1228 与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。 因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。 所以,Redis Cluster的模型大概是这样的形状 主从复制模型 为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。 在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。 另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。 不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。 Redis一致性保证 Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作： 第一个原因是因为集群是用了异步复制. 写操作过程: 客户端向主节点B写入一条命令. 主节点B向客户端回复命令状态. 主节点将写操作复制给他得从节点 B1, B2 和 B3 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 ** 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。 举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 . Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了. 注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项 搭建Redis集群 要让集群正常工作至少需要3个主节点，在这里我们要创建6个redis节点，其中三个为主节点，三个为从节点，对应的redis节点的ip和端口对应关系如下（为了简单演示都在同一台机器上面） 123456127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002127.0.0.1:7003127.0.0.1:7004127.0.0.1:7005 安装和启动Redis 下载安装包 1wget http://download.redis.io/releases/redis-3.2.9.tar.gz 解压安装 123tar zxvf redis-3.2.9.tar.gzcd redis-3.2.9make &amp;&amp; make PREFIX=/usr/local/redis install 这里如果失败的自行yum安装gcc和tcl 12yum install gcc yum install tcl 创建目录 1234cd /usr/local/redismkdir clustercd clustermkdir 7000 7001 7002 7003 7004 7005 复制和修改配置文件 将redis目录下的配置文件复制到对应端口文件夹下,6个文件夹都要复制一份 1cp redis-3.2.9/redis.conf /usr/local/redis/cluster/7000 修改配置文件redis.conf，将下面的选项修改 123456789101112131415161718# 端口号port 7000# 后台启动daemonize yes# 开启集群cluster-enabled yes#集群节点配置文件cluster-config-file nodes-7000.conf# 集群连接超时时间cluster-node-timeout 5000# 进程pid的文件位置pidfile /var/run/redis-7000.pid# 开启aofappendonly yes# aof文件路径appendfilename &quot;appendonly-7005.aof&quot;# rdb文件路径dbfilename dump-7000.rdb 6个配置文件安装对应的端口分别修改配置文件 创建启动脚本 在/usr/local/redis目录下创建一个start.sh 1234567#!/bin/bashbin/redis-server cluster/7000/redis.confbin/redis-server cluster/7001/redis.confbin/redis-server cluster/7002/redis.confbin/redis-server cluster/7003/redis.confbin/redis-server cluster/7004/redis.confbin/redis-server cluster/7005/redis.conf 这个时候我们查看一下进程看启动情况 1ps -ef | grep redis 进程状态如下： 123456root 1731 1 1 18:21 ? 00:00:49 bin/redis-server *:7000 [cluster] root 1733 1 0 18:21 ? 00:00:29 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:08 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:26 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:13 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:08 bin/redis-server *:7005 [cluster] 有6个redis进程在开启，说明我们的redis就启动成功了 开启集群 这里我们只是开启了6个redis进程而已，它们都还只是独立的状态，还么有组成集群 这里我们使用官方提供的工具redis-trib，不过这个工具是用ruby写的，要先安装ruby的环境 1yum install ruby rubygems -y 执行，报错 12345[root@centos]# redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005/usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require&#x27;: no such file to load -- redis (LoadError) from /usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require&#x27; from /usr/local/bin/redis-trib.rb:25[root@centos]# 原来是ruby和redis的连接没安装好 安装gem-redis 1gem install redis 安装到这里的时候突然卡住很久不动，网上搜了下，这里需要翻墙或者换镜像 1gem source -a https://gems.ruby-china.org 这里可以将镜像换成ruby-china的镜像，不过我好像更换失败，最终还是翻墙下载了 12345[root@centos]# gem install redisSuccessfully installed redis-3.2.11 gem installedInstalling ri documentation for redis-3.2.1...Installing RDoc documentation for redis-3.2.1... 等下载好后我们就可以使用了 12345[root@centos]# gem install redisSuccessfully installed redis-3.2.11 gem installedInstalling ri documentation for redis-3.2.1...Installing RDoc documentation for redis-3.2.1... 将redis-3.2.9的src目录下的trib复制到相应文件夹 1cp redis-3.2.9/src/redis-trib.rb /usr/local/redis/bin/redis-trib 创建集群： 1redis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 命令的意义如下： 给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。 选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。 简单来说，以上的命令的意思就是让redis-trib程序帮我们创建三个主节点和三个从节点的集群， 接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中： 12345678910111213141516171819202122&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002Adding replica 127.0.0.1:7003 to 127.0.0.1:7000Adding replica 127.0.0.1:7004 to 127.0.0.1:7001Adding replica 127.0.0.1:7005 to 127.0.0.1:7002M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) masterM: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) masterM: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) masterS: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6Can I set the above configuration? (type &#x27;yes&#x27; to accept): 按下yes，集群就会将配置应用到各个节点，并连接起（join)各个节点，也即是，让各个节点开始通讯 123456789101112131415161718192021222324252627&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. Redis集群的使用 连接集群 这里我们使用reids-cli连接集群，使用时加上-c参数，就可以连接到集群 连接7000端口的节点 123456[root@centos1 redis]# ./redis-cli -c -p 7000127.0.0.1:7000&gt; set name zgj-&gt; Redirected to slot [5798] located at 127.0.0.1:7001OK127.0.0.1:7001&gt; get name&quot;zgj&quot; 前面的理论知识我们知道了，分配key的时候，它会使用CRC16算法，这里将keyname分配到了7001节点上 1Redirected to slot [5798] located at 127.0.0.1:7001 redis cluster 采用的方式很直接，它直接跳转到7001 节点了，而不是还在自身的7000节点。 好，现在我们连接7003这个从节点进入 1234[root@centos1 redis]# ./redis-cli -c -p 7003127.0.0.1:7003&gt; get name-&gt; Redirected to slot [5798] located at 127.0.0.1:7001&quot;zgj&quot; 这里获取name的值，也同样跳转到了7001上 我们再测试一下其他数据 123456789127.0.0.1:7001&gt; set age 20-&gt; Redirected to slot [741] located at 127.0.0.1:7000OK127.0.0.1:7000&gt; set message helloworld-&gt; Redirected to slot [11537] located at 127.0.0.1:7002OK127.0.0.1:7002&gt; set height 175-&gt; Redirected to slot [8223] located at 127.0.0.1:7001OK 我们发现数据会在7000-7002这3个节点之间来回跳转 测试集群中的节点挂掉 上面我们建立了一个集群，3个主节点和3个从节点，7000-7002负责存取数据，7003-7005负责把7000-7005的数据同步到自己的节点上来。 我们现在来模拟一下一台matser服务器宕机的情况 12345678910111213141516171819202122232425262728293031[root@centos1 redis]# ps -ef | grep redisroot 1731 1 0 18:21 ? 00:01:02 bin/redis-server *:7000 [cluster] root 1733 1 0 18:21 ? 00:00:43 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:22 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:40 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:27 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:22 bin/redis-server *:7005 [cluster] root 23988 1 0 18:30 ? 00:00:42 ./redis-server *:6379 root 24491 1635 0 21:55 pts/1 00:00:00 grep redis[root@centos1 redis]# kill 1731[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots:0-5460 (5461 slots) master 0 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里看得出来，现在已经有了3个节点了，7003被选取成了替代7000成为主节点了。 我们再来模拟 7000节点重新启动了的情况，那么它还会自动加入到集群中吗？那么，7000这个节点上充当什么角色呢？ 我们试一下： 12345678910111213141516171819202122232425[root@centos1 redis]# bin/redis-server cluster/7000/redis.conf[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7000&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)S: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots: (0 slots) slave replicates d403713ab9db48aeac5b5393b69e1201026ef479S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots:0-5460 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里我们可以看到7000节点变成了7003节点的从节点 我们试着将7000和7003两个节点都关掉 123456789101112131415161718192021222324252627282930[root@centos1 redis]# ps -ef | grep redisroot 1733 1 0 18:21 ? 00:00:45 bin/redis-server *:7001 [cluster] root 1735 1 0 18:21 ? 00:00:24 bin/redis-server *:7002 [cluster] root 1743 1 0 18:21 ? 00:00:42 bin/redis-server *:7003 [cluster] root 1745 1 0 18:21 ? 00:00:29 bin/redis-server *:7004 [cluster] root 1749 1 0 18:21 ? 00:00:24 bin/redis-server *:7005 [cluster] root 23988 1 0 18:30 ? 00:00:43 ./redis-server *:6379 root 24527 1 0 22:04 ? 00:00:00 bin/redis-server *:7000 [cluster] root 24541 1635 0 22:07 pts/1 00:00:00 grep redis[root@centos1 redis] kill 1743[root@centos1 redis] kill 24527[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[ERR] Not all 16384 slots are covered by nodes. 这里我们的集群就不能工作了，因为两个节点主节点和从节点都挂掉了，原来7001分配的slot现在无节点接管，需要人工介入重新分配slots。 集群中加入新的主节点 这里在cluster目录下再新建一个7006并修改对应的配置文件，然后启动这个这个redis进程 然后再使用redis-trib的add node指令加入节点 1bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000 这里前面的节点表示要加入的节点，第二个节点表示要加入的集群中的任意一个节点，用来标识这个集群 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@centos1 redis]# bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000&gt;&gt;&gt; Adding node 127.0.0.1:7006 to cluster 127.0.0.1:7000&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7006 to make it join the cluster.[OK] New node added correctly.[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7006&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots: (0 slots) master 0 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这里我们可以看到7006节点已经变成了一个主节点，然鹅，等等，好像发现了有什么地方不对 12M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots: (0 slots) master 里面0 slots,也就是说节点6没有分配哈希槽，即不能进行数据的存取，拿我加上去干嘛。 原来redis cluster 不是在新加节点的时候帮我们做好了迁移工作，需要我们手动对集群进行重新分片迁移，也是这个命令： 1/bin/redis-trib reshard 127.0.0.1:7000 这个命令是用来迁移slot节点的，后面的127.0.0.1:7000是表示哪个集群的，7000-7006都是可以的 1234567891011121314151617181920212223242526272829303132333435[root@centos1]# redis-trib.rb reshard 127.0.0.1:7000Connecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7002: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7003: OK&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7006)M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 slots: (0 slots) master 0 additional replica(s)M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slots: (0 slots) slave replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6cS: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slots: (0 slots) slave replicates d2237fdcfbba672de766b913d1186cebcb6e1761M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slots: (0 slots) slave replicates dfa0754c7854a874a6ebd2613b86140ad97701fcM: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 slots:0-5460 (5461 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.How many slots do you want to move (from 1 to 16384)? 它提示我们需要迁移多少slot到7006上，我们可以算一下：16384/4 = 4096，也就是说，为了平衡分配起见，我们需要移动4096个槽点到7006上。 好，那输入4096: 它又提示我们，接受的node ID是多少，7006的id 我们通过上面就可以看到是efc3131fbdc6cf929720e0e0f7136cae85657481: 12345What is the receiving node ID? efc3131fbdc6cf929720e0e0f7136cae85657481Please enter all the source node IDs. Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots. Type &#x27;done&#x27; once you entered all the source nodes IDs.Source node #1: 接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 4096 个哈希槽， 并将这些槽移动到7006节点上面。 如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 4096 个， 然后移动到7006节点上： 1Source node #1:all 接下来就开始迁移了，并且会询问你是否确认： 1234567Moving slot 1359 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1360 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1361 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1362 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1363 from d2237fdcfbba672de766b913d1186cebcb6e1761 Moving slot 1364 from d2237fdcfbba672de766b913d1186cebcb6e1761Do you want to proceed with the proposed reshard plan (yes/no)? 输入yes并回车后，redis-trib就会正式执行重新分片操作，将制定的哈希槽从源节点一个个移动到7006节点上 。 迁移结束之后，我们来检查一下 12345678910111213141516171819202122232425M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000 slots:1365-5460 (4096 slots) master 1 additional replica(s)S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003 slots: (0 slots) slave replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446aS: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004 slots: (0 slots) slave replicates b85519795fa42aa33d4e88d25104cbae895933a6M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006 slots:0-1364,5461-6826,10923-12287 (4096 slots) master 0 additional replica(s)M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001 slots:6827-10922 (4096 slots) master 1 additional replica(s)S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005 slots: (0 slots) slave replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002 slots:12288-16383 (4096 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 我们可以看到 slots:0-1364,5461-6826,10923-12287 (4096 slots) 这些原来在其他节点上的哈希槽都迁移到了7006上 增加一个从节点 新建一个 7007从节点，作为7006的从节点 我们再新建一个节点7007，步骤类似，就先省略了。建好后，启动起来，我们看如何把它加入到集群中的从节点中： 1[root@centos1]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000 add-node的时候加上–slave表示是加入到从节点中，但是这样加，是随机的。这里的命令行完全像我们在添加一个新主服务器时使用的一样，所以我们没有指定要给哪个主服 务器添加副本。这种情况下，redis-trib会将7007作为一个具有较少副本的随机的主服务器的副本。 那么，你猜，它会作为谁的从节点，应该是7006，因为7006还没有从节点。我们运行下。 12345678910[root@web3 7007]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000......[OK] All 16384 slots covered.Automatically selected master 127.0.0.1:7006Connecting to node 127.0.0.1:7007: OK&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7007 to make it join the cluster.Waiting for the cluster to join.&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.[OK] New node added correctly. 上面提示说，自动选择了7006作为master节点。并且成功了。我们检查下： 1234567891011121314151617181920212223242526272829303132333435363738[root@centos1]# redis-trib.rb check 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7002: OK&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)S: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slots: (0 slots) slave replicates d2237fdcfbba672de766b913d1186cebcb6e1761M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 slots:0-1364,5461-6826,10923-12287 (4096 slots) master 1 additional replica(s)S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slots: (0 slots) slave replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6cS: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slots: (0 slots) slave replicates dfa0754c7854a874a6ebd2613b86140ad97701fcM: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 slots:1365-5460 (4096 slots) master 1 additional replica(s)M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 slots:6827-10922 (4096 slots) master 1 additional replica(s)S: 86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 slots: (0 slots) slave replicates efc3131fbdc6cf929720e0e0f7136cae85657481M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 slots:12288-16383 (4096 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 果然，7007加入到了7006的从节点当中。 你说，我如果想指定一个主节点行不行？当然可以。我们再建一个7008节点。 1bin/redis-trib.rb add-node --slave --master-id efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7008 127.0.0.1:7000 –master-id 表示指定的主节点node id。这里指定的是 7006 这个主节点。 123Waiting for the cluster to join.&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.[OK] New node added correctly. 提示我们已经作为7006的从节点了，也就是加入到7006的从节点来了，照这么说，7006就有2个从节点了，我们看一下： 1234bin/redis-cli -c -p 7008 cluster nodes |grep efc3131fbdc6cf929720e0e0f7136cae8565748186d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 1445089507786 8 connectedefc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master - 0 1445089508289 8 connected 0-1364 5461-6826 10923-1228744321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 myself,slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 0 0 connected 我们过滤了下看结果，果真，7007和7008是7006的从节点了。 刚好，我们再做一个实验，我把7006的进程杀掉，看7007和7008谁会变成主节点： 123456789101112131415161718192021222324252627[root@centos1]# ps -ef|grep redisroot 11384 1 0 09:56 ? 00:00:16 redis-server *:7001 [cluster]root 11388 1 0 09:56 ? 00:00:16 redis-server *:7002 [cluster]root 11392 1 0 09:56 ? 00:00:16 redis-server *:7003 [cluster]root 11396 1 0 09:56 ? 00:00:15 redis-server *:7004 [cluster]root 11400 1 0 09:56 ? 00:00:15 redis-server *:7005 [cluster]root 12100 1 0 11:01 ? 00:00:11 redis-server *:7000 [cluster]root 12132 1 0 11:28 ? 00:00:11 redis-server *:7006 [cluster]root 12202 1 0 13:14 ? 00:00:02 redis-server *:7007 [cluster]root 12219 1 0 13:39 ? 00:00:00 redis-server *:7008 [cluster]root 12239 8259 0 13:49 pts/0 00:00:00 grep redis[root@centos1]# kill 12132[root@centos1]# redis-cli -c -p 7008127.0.0.1:7008&gt; get ss5rtr-&gt; Redirected to slot [1188] located at 127.0.0.1:7007&quot;66&quot;127.0.0.1:7007&gt; cluster nodesefc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master,fail - 1445089780668 1445089779963 8 disconnectedd2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 master - 0 1445089812195 7 connected 1365-546030858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slave dfa0754c7854a874a6ebd2613b86140ad97701fc 0 1445089813710 3 connected86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 myself,master - 0 0 10 connected 0-1364 5461-6826 10923-12287cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 master - 0 1445089814214 2 connected 6827-109224b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slave cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 0 1445089812701 2 connected44321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 slave 86d05e7c2b197dc182b5e71069e791d033cf899e 0 1445089814214 10 connected3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slave d2237fdcfbba672de766b913d1186cebcb6e1761 0 1445089813204 7 connecteddfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 master - 0 1445089813204 3 connected 12288-16383127.0.0.1:7007&gt; 这里7007获得了成为主节点的机会，7008就变成了7007的从节点。 那么这个时候，重启7006节点，那么他就会变成了一个7007的从节点了。 移除一个节点 上面是增加一个节点，接下来就是移除一个节点了，移除节点的命令是 1bin/redis-trib del-node 127.0.0.1:7000 `&lt;node-id&gt;` 没我们尝试下输入以下命令 123456789101112[root@centos]# bin/redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7002: OK[ERR] Node 127.0.0.1:7007 is not empty! Reshard data away and try again. 这里报错了，提示我们7007节点里面有数据，让我们把7007节点里的数据移除出去，也就是说需要重新分片，这个和上面增加节点的方式一样，我们再来一遍 1bin/redis-trib.rb reshard 127.0.0.1:7000 省去中间内容，原来7007节点上已经有了4096个哈希槽，这里我们也移动4096个哈希槽 然后将这些哈希槽移动到7001节点上 123Source node #1:86d05e7c2b197dc182b5e71069e791d033cf899eSource node #2:doneDo you want to proceed with the proposed reshard plan (yes/no)? yes 然后我们再继续执行移除命令，结果如下 123456789101112131415[root@centos1]# redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000Connecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7003: OKConnecting to node 127.0.0.1:7007: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7002: OK&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; 127.0.0.1:7006 as replica of 127.0.0.1:7001&gt;&gt;&gt; 127.0.0.1:7008 as replica of 127.0.0.1:7001&gt;&gt;&gt; SHUTDOWN the node. 删除成功，而且还很人性化的将7006和7008这2个原来7007的附属节点送给了7001。考虑的真周到~ 移除一个从节点 移除一个从节点就比较简单了，因为从节点没有哈希槽，也不需要考虑数据迁移，直接移除就行 1234567891011121314[root@centos1]# redis-trib.rb del-node 127.0.0.1:7005 44321e7d619410dc4e0a8745366610a0d06d2395&gt;&gt;&gt; Removing node 44321e7d619410dc4e0a8745366610a0d06d2395 from cluster 127.0.0.1:7005Connecting to node 127.0.0.1:7005: OKConnecting to node 127.0.0.1:7001: OKConnecting to node 127.0.0.1:7002: OKConnecting to node 127.0.0.1:7004: OKConnecting to node 127.0.0.1:7000: OKConnecting to node 127.0.0.1:7006: OKConnecting to node 127.0.0.1:7008: OKConnecting to node 127.0.0.1:7003: OK&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node.[root@centos1]# redis-trib.rb check 127.0.0.1:7008Connecting to node 127.0.0.1:7008: [ERR] Sorry, can&#x27;t connect to node 127.0.0.1:7008 表示移除成功 Redis性能测试 Redis自带了性能测试工具redis-benchmark 使用说明如下： 1234567891011121314151617181920212223Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;]-h &lt;hostname&gt; Server hostname (default 127.0.0.1)-p &lt;port&gt; Server port (default 6379)-s &lt;socket&gt; Server socket (overrides host and port)-c &lt;clients&gt; Number of parallel connections (default 50)-n &lt;requests&gt; Total number of requests (default 10000)-d &lt;size&gt; Data size of SET/GET value in bytes (default 2)-k &lt;boolean&gt; 1=keep alive 0=reconnect (default 1)-r &lt;keyspacelen&gt; Use random keys for SET/GET/INCR, random values for SADD Using this option the benchmark will get/set keys in the form mykey_rand:000000012456 instead of constant keys, the &lt;keyspacelen&gt; argument determines the max number of values for the random number. For instance if set to 10 only rand:000000000000 - rand:000000000009 range will be allowed.-P &lt;numreq&gt; Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).-q Quiet. Just show query/sec values--csv Output in CSV format-l Loop. Run the tests forever-t &lt;tests&gt; Only run the comma-separated list of tests. The test names are the same as the ones produced as output.-I Idle mode. Just open N idle connections and wait. 基准测试 基准的测试命令： redis-benchmark -q -n 100000 结果入下： 1234567891011121314151617181920root@centos1 bin]# redis-benchmark -q -n 100000-bash: redis-benchmark: command not found[root@centos1 bin]# ./redis-benchmark -q -n 100000PING_INLINE: 61576.36 requests per secondPING_BULK: 60277.28 requests per secondSET: 61349.69 requests per secondGET: 60459.49 requests per secondINCR: 58858.15 requests per secondLPUSH: 59066.75 requests per secondRPUSH: 57339.45 requests per secondLPOP: 55586.44 requests per secondRPOP: 56465.27 requests per secondSADD: 57045.07 requests per secondSPOP: 53734.55 requests per secondLPUSH (needed to benchmark LRANGE): 57012.54 requests per secondLRANGE_100 (first 100 elements): 55803.57 requests per secondLRANGE_300 (first 300 elements): 54914.88 requests per secondLRANGE_500 (first 450 elements): 53333.33 requests per secondLRANGE_600 (first 600 elements): 56529.11 requests per secondMSET (10 keys): 59276.82 requests per second 这里可以看出，单机版的redis每秒可以处理6万个请求，这已经是一个非常厉害的数据了，不得不佩服 我们再来看下集群情况下是是什么情况 123456789101112131415161718[root@centos1 bin]# ./redis-benchmark -q -n 100000 -p 7000PING_INLINE: 64599.48 requests per secondPING_BULK: 64184.85 requests per secondSET: 66800.27 requests per secondGET: 65616.80 requests per secondINCR: 66269.05 requests per secondLPUSH: 40273.86 requests per secondRPUSH: 40355.12 requests per secondLPOP: 43421.62 requests per secondRPOP: 45187.53 requests per secondSADD: 62539.09 requests per secondSPOP: 61538.46 requests per secondLPUSH (needed to benchmark LRANGE): 38182.51 requests per secondLRANGE_100 (first 100 elements): 25555.84 requests per secondLRANGE_300 (first 300 elements): 9571.21 requests per secondLRANGE_500 (first 450 elements): 7214.49 requests per secondLRANGE_600 (first 600 elements): 5478.85 requests per secondMSET (10 keys): 41893.59 requests per second 这里看出大部分和单机版的性能查不多，主要是lrange命令的差别是很大的 流水线测试 使用流水线 默认情况下，每个客户端都是在一个请求完成之后才发送下一个请求（基准会模拟50个客户端除非使用-c指定特别的数量），这意味着服务器几乎是按顺序读取每个客户端的命令。RTT也加入了其中。 真实世界会更复杂，Redis支持/topics/pipelining，使得可以一次性执行多条命令成为可能。Redis流水线可以提高服务器的TPS redis-benchmark -n 1000000 -t set,get -P 16 -q 加入-P选项使用管道技术，一次执行多条命令 123./redis-benchmark -n 1000000 -t set,get -P 16 -qSET: 515198.34 requests per secondGET: 613873.56 requests per second 每秒处理get/sret请求达到了60/50W,真的厉害！ 遇到的问题 安装redis集群的时候遇到了挺多问题，踩了很多坑，单单是修改配置文件就出了不少问题，那些配置文件的内容都要一一修改，有些配置不修改就会出现无法创建进程的错误 注意配置集群的时候不要加密码，否则会出现无法连接的情况 gem install的时候需要修改镜像或者翻墙 昨天启动成功，今天启动的时候报错 1[ERR] Node 172.168.63.202:7001 is not empty. Either the nodealready knows other nodes (check with CLUSTER NODES) or contains some key in database 0 解决方法： 将需要新增的节点下aof、rdb等本地备份文件删除； 同时将新Node的集群配置文件删除,即：删除你redis.conf里面cluster-config-file所在的文件； 再次添加新节点如果还是报错，则登录新Node,执行bin/redis-cli–h x –p对数据库进行清除： 1127.0.0.1:7001&gt; flushdb #清空当前数据库 总结 之间对了Redis的了解并不是说非常多，只是简单的会用，因为现在企业里也很多都在用，刚好老大说接下来的项目可能会用到Redis集群，让我先去了解下，所以最近就在回头看，一边看文档，博客，一边实践，踩了很多的坑，出问题的时候的确是让人感到很痛苦很郁闷的，可是当运行成功的那一刻心情却是无比激动和开心的，可能这就是编程的魅力吧。","categories":[],"tags":[]},{"title":"为什么禁止使用外键","slug":"数据库/MySQL/other/为什么禁止使用外键","date":"2021-07-20T05:09:35.017Z","updated":"2021-07-27T01:33:05.354Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/为什么禁止使用外键/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE/","excerpt":"","text":"外键的优点一、数据一致性由数据库自身保证数据一致性、完整性会更可靠，程序很难100％保证数据的一致性、完整性 二、ER图可靠性有主外键的数据库设计可以增加ER图的可读性 外键的缺点一、级联问题阿里巴巴的开发手册中，就曾指出强制要求不允许使用外键，一切外键概念必须在应用层解决。 因为每次级联delete或update的时候，都要级联操作相关的外键表，不论有没有这个必要，由其在高并发的场景下，这会导致性能瓶颈 二、增加数据库压力外键等于把数据的一致性事务实现，全部交给数据库服务器完成，并且有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源 三、死锁问题若是高并发大流量事务场景，使用外键还可能容易造成死锁 四、开发不方便有外键时，无论开发还是维护，需要手工维护数据时，都不太方便，要考虑级联因素 总结一、如是单机且低并发，也不需要性能调优，再或者不能用程序保证数据的一致性，完整性，可以使用外键二、如果为了高并发，分布式，使系统性能更优，以及更好维护，则一定不能使用外键 引言其实这个话题是老生常谈，很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条 **【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 ** 但是呢，询问他们原因，大多是这么回答的 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便。 坦白说，这么说也是对的。但是呢，不够全面，所以开一文来详细说明。 正文首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。比如使用外键，可以 保证数据的完整性和一致性 级联操作方便 将数据完整性判断托付给了数据库完成，减少了程序的代码量 然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下 性能问题假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。 并发问题在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。 扩展性问题这里主要是分为两点 做平台迁移方便，比如你从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。 技术问题使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"外键","slug":"外键","permalink":"https://alloceee.github.io/tags/%E5%A4%96%E9%94%AE/"}]},{"title":"","slug":"数据库/MySQL/other/mysql count() 函数 字段按条件统计数量并排除某个字段重复值","date":"2021-07-20T05:09:35.015Z","updated":"2021-05-31T09:48:08.904Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/mysql count() 函数 字段按条件统计数量并排除某个字段重复值/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/mysql%20count()%20%E5%87%BD%E6%95%B0%20%E5%AD%97%E6%AE%B5%E6%8C%89%E6%9D%A1%E4%BB%B6%E7%BB%9F%E8%AE%A1%E6%95%B0%E9%87%8F%E5%B9%B6%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%87%8D%E5%A4%8D%E5%80%BC/","excerpt":"","text":"mysql count() 函数 字段按条件统计数量并排除某个字段重复值 12345678910111213141516SELECT *, count(c.recruit_info_id) AS apply_number, count( IF (c.approval_status= 5, 1, NULL) ) AS s_numberFROM `sh_further_position_posting` `a`LEFT JOIN `sh_student_keshi` `b` ON `a`.`student_keshi_id` = `b`.`student_keshi_id`LEFT JOIN `sh_further_recruit_info` `c` ON `c`.`post_id` = `a`.`post_id`WHERE 1 = 1GROUP BY `a`.`post_id`ORDER BY `a`.`create_time` DESCLIMIT 10","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/other/left join、right join和join的区别","date":"2021-07-20T05:09:35.013Z","updated":"2021-03-17T01:24:58.396Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/left join、right join和join的区别/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/left%20join%E3%80%81right%20join%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"真的是一张图道清所有join的区别啊，可惜我还是看不懂，可能人比较懒，然后基本一个left join给我就是够用的了，所以就没怎么去仔细研究了，但是现实还是逼我去搞清楚，索性自己动手，总算理解图中的含义了，下面就听我一一道来。 首先，我们先来建两张表，第一张表命名为kemu，第二张表命名为score： 一、left join顾名思义，就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。如下： 12345select *from kemuleft join score on kemu.id = score.id 结果集： 二、right join “右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据，如下： 12345select *from kemuright join score on kemu.id = score.id 结果集： 三、joinjoin，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的，如下 12345select *from kemujoin score on kemu.id = score.id 结果集：","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/other/Find_in_set","date":"2021-07-20T05:09:35.011Z","updated":"2021-07-28T03:49:38.885Z","comments":true,"path":"2021/07/20/数据库/MySQL/other/Find_in_set/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/other/Find_in_set/","excerpt":"","text":"Returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings. A string list is a string composed of substrings separated by , characters. If the first argument is a constant string and the second is a column of type SET, the FIND_IN_SET() function is optimized to use bit arithmetic. Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL. This function does not work properly if the first argument contains a comma (,) character. 12mysql&gt; SELECT FIND_IN_SET(&#x27;b&#x27;,&#x27;a,b,c,d&#x27;); -&gt; 2 mysql中FIND_IN_SET函数用来比较是不是包含，不管‘list’字段是变量或给定的字符串常量都能很好的工作。MySQL中原型为：FIND_IN_SET(str,strlist)。 假如字符串str 在由N 子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被‘,’符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则 FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。 str也可以是变量，比如表中的一个字段。 虽然这样很好用，但问题是如果数据量大的情况下怎么办，性能会是问题么，手册上有说对find_in_set 做的优化，但在没有索引的情况下他的性能应该是个问题。","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/面试","date":"2021-07-20T05:09:35.002Z","updated":"2021-07-19T02:37:46.649Z","comments":true,"path":"2021/07/20/数据库/MySQL/面试/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%9D%A2%E8%AF%95/","excerpt":"","text":"为什么在写SQL语句时遵守最左前缀原则才能用到索引？不遵守就用不到索引？其底层工作机制是怎样的？ MySQL中写缓冲区为什么能优化写入的速度？如何做到的？ MySQL在执行一个SQL语句时会经过哪些步骤？这每个步骤可以如何优化？ 写了一个很长的SQL，这个SQL最终的执行顺序是怎样的？如何优化复杂SQL？ 到底多大数据的表才是大表？500万条？2000万条？5000万条？ 如果一个表中数据量很大，这个时候如何建立索引，如何优化索引？ 高并发场景下，使用MySQL事务时应该要注意哪些方面，如何进行优化？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/开篇","date":"2021-07-20T05:09:34.998Z","updated":"2021-01-26T03:57:14.000Z","comments":true,"path":"2021/07/20/数据库/MySQL/开篇/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%BC%80%E7%AF%87/","excerpt":"","text":"基础篇1.基础架构：一条SQL查询语句是如何执行的？ Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数字和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 连接器 连接器负责跟客户端建立链接、获取权限、维持和管理链接。 如果长时间没有动静，连接器默认8小时会自动断开，再次发送请求需要进行重连。 数据库中长连接指的是连接成功后，如果客户端持续有请求，则一直使用同一个连接，短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 全部使用长连接，会非常占用内存，导致内存占用太大，被系统强行杀掉（OOM），导致MySQL异常重启。 解决方案： 1.定期断开连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 2.MySQL5.7及以上版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接回复到刚刚创建完的状态。 查询缓存 不建议使用查询缓存： 因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要对一个表的更新，这个表上所有的查询花奴才能都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低，除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 MySQL8.0已经移除该功能。 分析器 分析器会先做”词法分析”。你输入的是由多个字符喜欢和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 然后是“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的额这个NySQL语句是否满足MySQL语法。 优化器 优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 执行器 开始执行的时候，会先判断你对这个表T哟没有执行查询的权限，如果没有，就会返回没有权限的错误（在工程上实现，如果命中查询缓存，就会在查询缓存返回结果的时候，做权限验证，查询也会在优化器之前调用precheck权限验证）。 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 2.日志系统：一条SQL更新语句是如何执行的？MySQL的逻辑架构图和查询一直，执行语句前要先连接数据库，这是连接器的工作。 一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空，这也就是我们一般不建议使用查询缓存的原因。 接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引，然后，执行器负责具体执行，找到这一行，然后更新。 与查询流程不一样的是，更新流程还涉及两个重要的日志模块:redo log(重做日志)和bin log(归档日志)。 redo log(重做日志)在MySQL有一个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高，为了解决这个问题，MySQL的设计者采用WAL技术，全称 Write-Ahead Logging。它的关键点就是先写日志，再写磁盘。 具体俩说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。 于此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以自己录4GB操作。从头开始写，写到末尾就又回到开头循环写，如图所示。 write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的操作，得停下来先擦掉一些记录，把checkpoint推进一下。 有了redo log，InnoDB就可以保存即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 binlog(归档日志)MySQL整体来看，分为两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块就是引擎层，负责存储相关的具体事宜。redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)。 为什么会有两个日志 因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档，而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统-也就是redo log来实现crash-safe能力。 两种日志的区别 1.redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎都可以使用。 2.redo log是物理日志，记录的是“在某个数据页上做了什么修改”;binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2 这一行的c字段加 1”。 3.redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 执行器和InnoDB引擎在执行这个简单Update语句时的内部流程 1.执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在是的数据项本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 2.执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 3.引擎将这行新数据更新到内存中，同时将这个更新数据操作记录到redo log里面，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务。 4.执行器生成这个操作的binlog，并把binlog写入磁盘。 5.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。 两阶段提交为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起： 怎样让数据库恢复到半个月内任意一秒的状态？ 前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做： 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。 好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。 3.事务隔离：为什么你改了我还看不见？简单来说，事务就是保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。MyISAM就不支持事务，InnoDB支持。 隔离性与隔离级别提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。 在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（readuncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释： 1.读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 2.读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 3.可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 4.串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。 配置的方式是，将启动参数tranaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。 总结来说，哪个隔离级别都有它自己的使用场景，要根据业务情况来定。 事务隔离的实现在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。 基于上面的说明，建议不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 在MySQL5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里，即使长事务最终提交，回滚段被清理，文件也不会变小。有数据只有20GB，而回滚段有200GB的库，最终只好为了清理回滚段，重建整个库。 除了对回滚段的印象，长事务还占用锁资源，也可能拖垮整个库。 事务的启动方式如前面所述，长事务有这些潜在风险，建议尽量避免，其实很多时候业务开发不是有意使用长事务，而是由于误用所致。 MySQL的事务启动方式有一下几种： 1.显示启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback。 2.set autocommit=0，这命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会主动提交，这个事务持续存到知道你主动执行commit或rollback语句，或者断开连接。 有些客户端连接框架会默认连接成功后先执行一个set autocommit=0命令，这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。 因此，建议总是使用set autocommit=1，通过显式语句的方式来启动事务。 在autocommit=1的情况下，用begin显式启动的事务。 但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。 如果你也有这个顾虑，我建议你使用 commit work and chain 语法。 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。 如何避免长事务对业务的影响？首先，从应用开发端来看： 1.确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志 来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它 改成 1。 2.确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框 起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。 这种只读事务可以去掉。 3.业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命 令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。 其次，从数据库端来看： 1.监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill； 2.Percona 的 pt-kill 这个工具不错，推荐使用； 3.在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题； 4.如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方 便。 4.深入浅出索引（上）索引的出现其实是为了提高数据查询的效率，就像书的目录一样。 索引的常见模型索引的出现是为了提高查询效率，但是实现索引的方式却又很多种，所以这里也就引入了索引模型的概念，可以用于提高读写效率的数据结构很多，比较常见、简单的数据结构分别是哈希表、有序数组和索引树。 从使用的角度，简单分析这三种模型的区别。 哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示： 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链 表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询 的速度是很慢的。 你可以设想下，如果你现在要找身份证号在 [ID_card_X, ID_card_Y] 这个区间的所有用 户，就必须全部扫描一遍了。 所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证 号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示： 这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候 如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。 同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区 间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证 号，退出循环。 如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就 麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。 所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有 人口信息，这类不会再修改的数据。 二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我 们用二叉搜索树来实现的话，示意图如下所示： 二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你 要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。 当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个 保证，更新的时间复杂度也是 O(log(N))。 树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从 左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉 树。其原因是，索引不止存在内存中，还要写到磁盘上。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就 不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块 的大小。 N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引 擎中了。 在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引 擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实 现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就 以 InnoDB 为例，和你分析一下其中的索引模型。 InnoDB 的索引模型在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组 织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。 每一个索引在 InnoDB 里面对应一棵 B+ 树。 假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树 的示例示意图如下。 从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 （clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引 （secondary index）。 基于主键索引和普通索引的查询有什么 区别？ 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树； 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引 树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量 使用主键查询。 索引维护B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例， 如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请 一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合 并。合并的过程，可以认为是分裂过程的逆过程。 基于上面的索引维护过程说明，我们来讨论一个案例： 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自 增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而 哪些场景下不应该。 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。 也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插 入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字 段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？ 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级 索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整 型（bigint）则是 8 个字节。 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。 有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求 是这样的： 只有一个索引； 该索引必须是唯一索引。 你一定看出来了，这就是典型的 KV 场景。 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置 为主键，可以避免每次查询需要搜索两棵树。 总结InnoDB采用B+树结构，因为B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问数。 由于InnoDB是索引组织表，一般情况下建议创建一个自增组件，这样非主键索引占用的空间最小，但是事无绝对，根据业务场景也可以使用业务逻辑字段做主键。 5.深入浅出索引（下）6.全局锁和表锁：给表加个字段怎么有这么多阻碍？数据库锁设计的初衷是处理并发问题，作为多用户共享的资源，当出现并发访问的时候，数据需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。 根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁和行锁三类。 全局锁顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是Flush tables with read lock(FTWRL)。当你需要整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。 以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做 备份。注意，在备份过程中整个库完全处于只读状态。 但是让整库都只读，听上去就很危险： 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从 延迟。 不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑 不一致的。其实是有一个方法能够拿到一 致性视图的，就是在可重复读隔离级别下开启一个事务。 官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持， 这个过程中数据是可以正常更新的。 你一定在疑惑，有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎 要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有 更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。 所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了 不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员 使用 InnoDB 替代 MyISAM 的原因之一。 你也许会问，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确 实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要 有两个原因： 1.在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库 还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。 2.在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个 库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状 态，这样会导致整个库长时间处于不可写状态，风险较高。 业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作 （DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操 作，都是会被锁住的。 但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们 要介绍的表级锁。 表级锁MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock， MDL)。 **表锁的语法是lock tables…read/write.**与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放，需要注意，lock tables语法除了会限制别的线程的读写外，也限制了本线程接下来的操作对象。 举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。 在还没出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。 另一类表级的锁MDL（metadata lock）。DML不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性，你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果更表结构对不上，肯定是不行的。 因此，在MySQL5.5版本中引入了MDL，当对一个表做增删查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。 读写锁之间、写锁之间是互斥的，用来保证变成表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。 虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。 你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响，而实际上，即使是小表，操作不慎也会出问题。 我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需 要的也是 MDL 读锁，因此可以正常执行。 之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。 如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读 锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。 如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。 你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会 马上释放，而会等到整个事务提交后再释放。 基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？ 首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。 但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请 求很频繁，而你不得不加个字段，你该怎么做呢？ 这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不 到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这 个过程。 MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。 12ALTER TABLE tbl_name NOWAIT add column ...ALTER TABLE tbl_name WAIT N add column ... 小结全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，我建议你选择使用– single-transaction 参数，对应用会更友好。 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 lock tables 这样的语句，你需要追查一下，比较可能的情况是： 要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎； 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。 MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。 最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一 列。这时候，从备库上会看到什么现象呢？ online ddl Online DDL的过程是这样的： 拿MDL写锁 降级成MDL读锁 真正做DDL 升级成MDL写锁 释放MDL锁 1、2、4、5如果没有锁冲突，执行时间非常短。第3步占用了DDL绝大部分时间，这期间这个表 可以正常读写数据，是因此称为“online ” 我们文中的例子，是在第一步就堵住了 7.行锁功过：怎么减少行锁对性能的影响？8.事务到底是隔离还是不隔离的？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇3","date":"2021-07-20T05:09:34.997Z","updated":"2021-05-21T07:12:28.976Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇3/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%873/","excerpt":"","text":"33.我查这么多数据，会不会把数据内存打爆？34.到底可不可以使用join?在实际生产中，关于 join 语句使用的问题，一般会集中在以下两类： 我们 DBA 不让使用 join，使用 join 有什么问题呢？ 如果有两个大小不同的表做 join，应该用哪个表做驱动表呢？ Index Nested-Loop Join这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称 NLJ。 35.join语句怎么优化？36.为什么临时表可以重名？37.什么时候会使用内部临时表？38.都说InnoDB好，那还要不要使用Memory引擎？39.自增主键为什么不是连续的？40.insert语句的锁为什么这么多？41.怎么最快地复制一张表？42.grant之后要跟着flush privileges吗？43.要不要使用分区表？44.45.递增id用完了怎么办？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇2","date":"2021-07-20T05:09:34.995Z","updated":"2021-05-20T08:17:29.913Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇2/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%872/","excerpt":"","text":"21.为什么我只查一行的语句，锁这么多？22.MySQL有哪些“饮鸩止渴”提高性能的方法？23.MySQL是怎么保证数据不丢的？只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。 binlog的写入机制其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。 一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。 系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。 事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空binlog cache。状态如图 1 所示。 24.MySQL是怎么保证主备一致的？25.MySQL是怎么保证高可用的？26.备库为什么会延迟好几个小时？27.主库出问题了，从库怎么办？28.读写分离有哪些坑？29.如何判断一个数据库是不是出问题了?30.答疑文章（二）：用动态的观点看加锁31.误删数据后除了跑路，还能怎么办？32.为什么还有kill不掉的语句？","categories":[],"tags":[]},{"title":"","slug":"数据库/MySQL/实践篇1","date":"2021-07-20T05:09:34.993Z","updated":"2021-04-08T01:16:29.938Z","comments":true,"path":"2021/07/20/数据库/MySQL/实践篇1/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E8%B7%B5%E7%AF%871/","excerpt":"","text":"实践篇9.普通索引和唯一索引，应该怎么选择？10.MySQL为什么有时候会选错索引？11.怎么给字符串字段加索引？12.为什么我的MySQL会“抖”一下？13.为什么表数据删除一半，表文件大小不变？14.count(*)这么慢，我改怎么办？count(*)的实现方式你首先要明确的是，在不同的 MySQL 引擎中，count(*) 有不同的实现方式。 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。 15.日志和索引相关问题16.“order by”是怎么工作的？17.如何正确地显示随机消息？18.为什么这些SQL语句逻辑相同，性能却差异巨大？19.为什么我只查一行的语句，也执行这么慢？20.幻读是什么，幻读有什么问题？","categories":[],"tags":[]},{"title":"","slug":"搜索引擎/搜索引擎-Lucene","date":"2021-07-20T05:09:34.986Z","updated":"2020-05-11T07:00:28.000Z","comments":true,"path":"2021/07/20/搜索引擎/搜索引擎-Lucene/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-Lucene/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"搜索引擎/ES倒排索引","date":"2021-07-20T05:09:34.982Z","updated":"2020-08-20T02:19:26.000Z","comments":true,"path":"2021/07/20/搜索引擎/ES倒排索引/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/ES%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/","excerpt":"","text":"面试题ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？ 面试官心理分析问这个，其实面试官就是要看看你了解不了解 es 的一些基本原理，因为用 es 无非就是写入数据，搜索数据。你要是不明白你发起一个写入和搜索请求的时候，es 在干什么，那你真的是…… 对 es 基本就是个黑盒，你还能干啥？你唯一能干的就是用 es 的 api 读写数据了。要是出点什么问题，你啥都不知道，那还能指望你什么呢？ 面试题剖析es 写数据过程 客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node （协调节点）。 coordinating node 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。 实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node 。 coordinating node 如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端。 es-write es 读数据过程可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。 客户端发送请求到任意一个 node，成为 coordinate node 。 coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。 接收请求的 node 返回 document 给 coordinate node 。 coordinate node 返回 document 给客户端。 es 搜索数据过程es 最强大的是做全文检索，就是比如你有三条数据： 123java真好玩儿啊java好难学啊j2ee特别牛Copy to clipboardErrorCopied 你根据 java 关键词来搜索，将包含 java 的 document 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。 客户端发送请求到一个 coordinate node 。 协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard ，都可以。 query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。 fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。 写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。 写数据底层原理es-write-detail 先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。 如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。这个过程就是 refresh 。 每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file ，每秒钟会产生一个新的磁盘文件 segment file ，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。 但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。 操作系统里面，磁盘文件其实都有一个东西，叫做 os cache ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache ，先进入操作系统级别的一个内存缓存中去。只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。 为什么叫 es 是准实时的？NRT ，全称 near real-time 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 restful api 或者 java api ，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。 重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。 commit 操作发生第一步，就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。 这个 commit 操作叫做 flush 。默认 30 分钟自动执行一次 flush ，但如果 translog 过大，也会触发 flush 。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。 translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。 translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。 实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。 总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。 数据写入 segment file 之后，同时就建立好了倒排索引。 删除/更新数据底层原理如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。 如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。 buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point ，标识所有新的 segment file ，然后打开 segment file 供搜索使用，同时删除旧的 segment file 。 底层 lucene简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。 通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。 倒排索引在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。 那么，倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。 举个栗子。 有以下文档： DocId Doc 1 谷歌地图之父跳槽 Facebook 2 谷歌地图之父加盟 Facebook 3 谷歌地图创始人拉斯离开谷歌加盟 Facebook 4 谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关 5 谷歌地图之父拉斯加盟社交网站 Facebook 对文档进行分词之后，得到以下倒排索引。 WordId Word DocIds 1 谷歌 1, 2, 3, 4, 5 2 地图 1, 2, 3, 4, 5 3 之父 1, 2, 4, 5 4 跳槽 1, 4 5 Facebook 1, 2, 3, 4, 5 6 加盟 2, 3, 5 7 创始人 3 8 拉斯 3, 5 9 离开 3 10 与 4 .. .. .. 另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。 那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 Facebook ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。 要注意倒排索引的两个重要细节： 倒排索引中的所有词项对应一个或多个文档； 倒排索引中的词项根据字典顺序升序排列 上面只是一个简单的例子，并没有严格按照字典顺序升序排列。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/浅谈JavaScript的防抖与节流","date":"2021-07-20T05:09:34.916Z","updated":"2021-05-21T09:43:28.928Z","comments":true,"path":"2021/07/20/大前端/other/浅谈JavaScript的防抖与节流/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E6%B5%85%E8%B0%88JavaScript%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"前言在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。 非立即执行版 1234567891011function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 立即执行版 12345678910111213function debounce(func,wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 立即执行版的意思是触发事件后函数会立即执行，然后n秒内不触发事件才能继续执行函数的效果。 防抖应用场景 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务器接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务器压力； 表单验证； 按钮提交事件； 浏览器窗口缩放，resize事件（如窗口停止改变大小之后重新计算布局）等。 函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器 时间戳版: 123456789101112function throttle(func,wait)&#123; let previous = 0; return function()&#123; let now = Date.now(); let context = this; let args = arguments; if(now - previous &gt; wait)&#123; func.apply(context,args); previous = now; &#125; &#125;&#125; 定时器版: 12345678910111213function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 节流应用场景 按钮点击事件； 拖拽事件； onScroll； 计算鼠标移动的距离（mouseover） 总结 函数防抖：将几次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一次时间内只触发一次函数。原理是通过判断是否达到一定时间来触发函数。 区别函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的时间处理函数，而函数防抖只是在最后一次事件后才触发一次函数。比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次Ajax请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/杂","date":"2021-07-20T05:09:34.915Z","updated":"2021-03-16T02:08:38.491Z","comments":true,"path":"2021/07/20/大前端/other/杂/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E6%9D%82/","excerpt":"","text":"12345678910111213active = &#123; reload: function()&#123; //执行重载 table.reload(&#x27;table_id_base&#x27;, &#123; page: &#123; curr: 1 //重新从第 1 页开始 &#125; ,where: &#123; base_name: $(&#x27;#basename&#x27;).val() &#125; &#125;, &#x27;data&#x27;); &#125;, &#125; 12var type = $(this).data(&#x27;type&#x27;); active[type] ? active[type].call(this) : &#x27;&#x27;; $(this).data() 获取自定义属性 $(this).data(‘type’) data-type 对象名[方法名].call(this) 调用对应方法","categories":[],"tags":[]},{"title":"","slug":"大前端/other/前端路由、后端路由、单页面应用、多页面应用","date":"2021-07-20T05:09:34.913Z","updated":"2021-05-24T01:42:53.794Z","comments":true,"path":"2021/07/20/大前端/other/前端路由、后端路由、单页面应用、多页面应用/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E3%80%81%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%94%B1%E3%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E3%80%81%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/","excerpt":"","text":"前端路由 定义：在单页面应用，大部分页面结构不变，只改变部分内容的使用 优点：用户体验好，不需要每次都从服务器全部获取，快速展示给用户 缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。 后端路由通过用户请求的url导航到具体的html页面；每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端js再去请求数据，使用前端模板和数据进行组合，生成想要的HTML 前后端路由对比 从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。 在某些场合中，用ajax请求，可以让页面无刷新，页面变了但Url没有变化，用户就不能复制到想要的地址，用前端路由做单页面网页就很好的解决了这个问题。但是前端路由使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。 单页面的优势 不存在页面切换问题，因为只在同一个页面间切换，会更流畅，而且可以附加各种动画和过度效果，用户体验更好。 可以用到vue的路由和状态保持，不用担心切换造成的数据不同步。 打包方便，有现成的脚手架可以用，也比较不容易出问题 只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次 页面跳转：使用js中的append/remove或者show/hide的方式来进行页面内容的更换； 数据传递：可通过全局变量或者参数传递，进行相关数据交互 使用场景： 适用于高度追求高度支持搜索引擎的应用 多页面的优势 逻辑清楚，各个页面按照功能和逻辑划分，不用担心业务复杂度 单个页面体积较小，加载速度比较有保证 多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载 页面跳转：使用window.location.href = “./index.html”进行页面间的跳转； 数据传递：可以使用path?account=”123”&amp;password=””路径携带数据传递的方式，或者localstorage、cookie等存储方式 使用场景： 高要求的体验度，追求界面流畅的应用 多页面的劣势 重复代码较多 页面经常需要切换，切换效果取决于浏览器和网络情况，对用户体验会有一定负面影响 无法充分利用vue的路由和状态保持，在多个页面之间共享和同步数据状态会成为一个难题 hash 模式这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 “www.baidu.com/#hashhash&quot; ，其中 “#hashhash” 就是我们期望的 hash 值。 由于 hash 值的变化不会导致浏览器像服务器发送请求，而且 hash 的改变会触发 hashchange 事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。 12345// 监听hash变化，点击浏览器的前进后退会触发window.addEventListener(&#x27;hashchange&#x27;, function(event)&#123; let newURL = event.newURL; // hash 改变后的新 url let oldURL = event.oldURL; // hash 改变前的旧 url&#125;,false) 下面实现一个路由对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class HashRouter&#123; constructor()&#123; //用于存储不同hash值对应的回调函数 this.routers = &#123;&#125;; window.addEventListener(&#x27;hashchange&#x27;,this.load.bind(this),false) &#125; //用于注册每个视图 register(hash,callback = function()&#123;&#125;)&#123; this.routers[hash] = callback; &#125; //用于注册首页 registerIndex(callback = function()&#123;&#125;)&#123; this.routers[&#x27;index&#x27;] = callback; &#125; //用于处理视图未找到的情况 registerNotFound(callback = function()&#123;&#125;)&#123; this.routers[&#x27;404&#x27;] = callback; &#125; //用于处理异常情况 registerError(callback = function()&#123;&#125;)&#123; this.routers[&#x27;error&#x27;] = callback; &#125; //用于调用不同视图的回调函数 load()&#123; let hash = location.hash.slice(1), handler; //没有hash 默认为首页 if(!hash)&#123; handler = this.routers.index; &#125; //未找到对应hash值 else if(!this.routers.hasOwnProperty(hash))&#123; handler = this.routers[&#x27;404&#x27;] || function()&#123;&#125;; &#125; else&#123; handler = this.routers[hash] &#125; //执行注册的回调函数 try&#123; handler.apply(this); &#125;catch(e)&#123; console.error(e); (this.routers[&#x27;error&#x27;] || function()&#123;&#125;).call(this,e); &#125; &#125;&#125; 再来一个例子 12345678910&lt;body&gt; &lt;div id=&quot;nav&quot;&gt; &lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt; &lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt; &lt;a href=&quot;#/page3&quot;&gt;page3&lt;/a&gt; &lt;a href=&quot;#/page4&quot;&gt;page4&lt;/a&gt; &lt;a href=&quot;#/page5&quot;&gt;page5&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819let router = new HashRouter();let container = document.getElementById(&#x27;container&#x27;);//注册首页回调函数router.registerIndex(()=&gt; container.innerHTML = &#x27;我是首页&#x27;);//注册其他视图回到函数router.register(&#x27;/page1&#x27;,()=&gt; container.innerHTML = &#x27;我是page1&#x27;);router.register(&#x27;/page2&#x27;,()=&gt; container.innerHTML = &#x27;我是page2&#x27;);router.register(&#x27;/page3&#x27;,()=&gt; container.innerHTML = &#x27;我是page3&#x27;);router.register(&#x27;/page4&#x27;,()=&gt; &#123;throw new Error(&#x27;抛出一个异常&#x27;)&#125;);//加载视图router.load();//注册未找到对应hash值时的回调router.registerNotFound(()=&gt;container.innerHTML = &#x27;页面未找到&#x27;);//注册出现异常时的回调router.registerError((e)=&gt;container.innerHTML = &#x27;页面异常，错误消息：&lt;br&gt;&#x27; + e.message); history 模式在 HTML5 之前，浏览器就已经有了 history 对象。但在早期的 history 中只能用于多页面的跳转： 1234history.go(-1); // 后退一页history.go(2); // 前进两页history.forward(); // 前进一页history.back(); // 后退一页 在 HTML5 的规范中，history 新增了以下几个 API 123history.pushState(); // 添加新的状态到历史状态栈history.replaceState(); // 用新的状态代替当前状态history.state // 返回当前状态对象 由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面，所以在 HTML5 中的 histroy 具备了实现前端路由的能力。 对于单页应用的 history 模式而言，url 的改变只能由下面四种方式引起： 点击浏览器的前进或后退按钮 点击 a 标签 在 JS 代码中触发 history.pushState 函数 在 JS 代码中触发 history.replaceState 函数 下面实现一个路由对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class HistoryRouter&#123; constructor()&#123; //用于存储不同path值对应的回调函数 this.routers = &#123;&#125;; this.listenPopState(); this.listenLink(); &#125; //监听popstate listenPopState()&#123; window.addEventListener(&#x27;popstate&#x27;,(e)=&gt;&#123; let state = e.state || &#123;&#125;, path = state.path || &#x27;&#x27;; this.dealPathHandler(path) &#125;,false) &#125; //全局监听A链接 listenLink()&#123; window.addEventListener(&#x27;click&#x27;,(e)=&gt;&#123; let dom = e.target; if(dom.tagName.toUpperCase() === &#x27;A&#x27; &amp;&amp; dom.getAttribute(&#x27;href&#x27;))&#123; e.preventDefault() this.assign(dom.getAttribute(&#x27;href&#x27;)); &#125; &#125;,false) &#125; //用于首次进入页面时调用 load()&#123; let path = location.pathname; this.dealPathHandler(path) &#125; //用于注册每个视图 register(path,callback = function()&#123;&#125;)&#123; this.routers[path] = callback; &#125; //用于注册首页 registerIndex(callback = function()&#123;&#125;)&#123; this.routers[&#x27;/&#x27;] = callback; &#125; //用于处理视图未找到的情况 registerNotFound(callback = function()&#123;&#125;)&#123; this.routers[&#x27;404&#x27;] = callback; &#125; //用于处理异常情况 registerError(callback = function()&#123;&#125;)&#123; this.routers[&#x27;error&#x27;] = callback; &#125; //跳转到path assign(path)&#123; history.pushState(&#123;path&#125;,null,path); this.dealPathHandler(path) &#125; //替换为path replace(path)&#123; history.replaceState(&#123;path&#125;,null,path); this.dealPathHandler(path) &#125; //通用处理 path 调用回调函数 dealPathHandler(path)&#123; let handler; //没有对应path if(!this.routers.hasOwnProperty(path))&#123; handler = this.routers[&#x27;404&#x27;] || function()&#123;&#125;; &#125; //有对应path else&#123; handler = this.routers[path]; &#125; try&#123; handler.call(this) &#125;catch(e)&#123; console.error(e); (this.routers[&#x27;error&#x27;] || function()&#123;&#125;).call(this,e); &#125; &#125;&#125; 再来一个例子 1234567891011121314&lt;body&gt; &lt;div id=&quot;nav&quot;&gt; &lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt; &lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt; &lt;a href=&quot;/page3&quot;&gt;page3&lt;/a&gt; &lt;a href=&quot;/page4&quot;&gt;page4&lt;/a&gt; &lt;a href=&quot;/page5&quot;&gt;page5&lt;/a&gt; &lt;button id=&quot;btn&quot;&gt;page2&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021222324let router = new HistoryRouter();let container = document.getElementById(&#x27;container&#x27;);//注册首页回调函数router.registerIndex(() =&gt; container.innerHTML = &#x27;我是首页&#x27;);//注册其他视图回到函数router.register(&#x27;/page1&#x27;, () =&gt; container.innerHTML = &#x27;我是page1&#x27;);router.register(&#x27;/page2&#x27;, () =&gt; container.innerHTML = &#x27;我是page2&#x27;);router.register(&#x27;/page3&#x27;, () =&gt; container.innerHTML = &#x27;我是page3&#x27;);router.register(&#x27;/page4&#x27;, () =&gt; &#123; throw new Error(&#x27;抛出一个异常&#x27;)&#125;);document.getElementById(&#x27;btn&#x27;).onclick = () =&gt; router.assign(&#x27;/page2&#x27;)//注册未找到对应path值时的回调router.registerNotFound(() =&gt; container.innerHTML = &#x27;页面未找到&#x27;);//注册出现异常时的回调router.registerError((e) =&gt; container.innerHTML = &#x27;页面异常，错误消息：&lt;br&gt;&#x27; + e.message);//加载页面router.load();","categories":[],"tags":[]},{"title":"","slug":"大前端/other/什么是回流，什么是重绘，有什么区别？","date":"2021-07-20T05:09:34.909Z","updated":"2021-04-16T05:24:14.821Z","comments":true,"path":"2021/07/20/大前端/other/什么是回流，什么是重绘，有什么区别？/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"","text":"html 加载时发生了什么在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体 DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。 什么是回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 什么是重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 区别：他们的区别很大： 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流 当页面布局和几何属性改变时就需要回流 比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变 扩展：浏览器的帮忙所以我们能得知回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系 因为这些机制的存在，所以浏览器会帮助我们优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 自己的优化但是靠浏览器不如靠自己，我们可以改变一些写法减少回流和重绘 比如改变样式的时候，不去改变他们每个的样式，而是直接改变className 就要用到cssText 但是要注意有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。 为了解决这个问题，可以采用cssText累加的方法，但是IE不支持累加，前面添一个分号可以解决。 还有添加节点的时候比如要添加一个div里面有三个子元素p，如果添加div再在里面添加三次p，这样就触发很多次回流和重绘，我们可以用cloneNode(true or false) 来避免，一次把要添加的都克隆好再appened就好了，还有其他很多的方法就不一一说了","categories":[],"tags":[]},{"title":"","slug":"大前端/other/事件委托","date":"2021-07-20T05:09:34.907Z","updated":"2021-07-19T02:12:42.160Z","comments":true,"path":"2021/07/20/大前端/other/事件委托/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"基本概念事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。 举个通俗的例子 比如一个宿舍的同学同时快递到了，一种方法就是他们一个个去领取，还有一种方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一 一分发给每个宿舍同学； 在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM 元素，而出去统一领取快递的宿舍长就是代理的元素，所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个。 事件冒泡前面提到事件委托的原理是DOM元素的事件冒泡，那么事件冒泡是什么呢？ 一个事件触发后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段 如上图所示，事件传播分成三个阶段： 捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件； 目标阶段：在目标节点上触发，称为“目标阶段” 冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层； 事件委托的优点【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒 1234567&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; ...... &lt;li&gt;item n&lt;/li&gt;&lt;/ul&gt; // …… 代表中间还有未知数个 li如上面代码所示，如果给每个li列表项都绑定一个函数，那对内存的消耗是非常大的，因此较好的解决办法就是将li元素的点击事件绑定到它的父元素ul身上，执行事件的时候再去匹配判断目标元素。 【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件） 假设上述的例子中列表项li就几个，我们给每个列表项都绑定了事件； 在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者删除列表项li元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件； 如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。 基本实现【1】JavaScript原生实现事件委托 比如我们有这样的一个 HTML 片段： Go somewhere Do something Say hi 按照传统的做法，需要像下面这样为它们添加 3 个事 件处理程序 12345678910111213var item1 = document.getElementById(&quot;goSomewhere&quot;);var item2 = document.getElementById(&quot;doSomething&quot;);var item3 = document.getElementById(&quot;sayHi&quot;); item1.onclick = function() &#123; location.href = &quot;http://www.baidu.com&quot;;&#125;;item2.onclick = function() &#123; document.title = &quot;事件委托&quot;;&#125;;item3.onclick = function() &#123; alert(&quot;hi&quot;);&#125;; 如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不 清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示 1234567891011121314151617var item1 = document.getElementById(&quot;goSomewhere&quot;);var item2 = document.getElementById(&quot;doSomething&quot;);var item3 = document.getElementById(&quot;sayHi&quot;); document.addEventListener(&quot;click&quot;, function (event) &#123; var target = event.target; switch (target.id) &#123; case &quot;doSomething&quot;: document.title = &quot;事件委托&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http://www.baidu.com&quot;; break; case &quot;sayHi&quot;: alert(&quot;hi&quot;); break; &#125;&#125;) 【2】jQuery事件delegate()实现事件委托 delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。 格式：$(selector).delegate(childSelector, event, data, function) 参数 描述childSelector 必需，规定要附加事件处理程序的一个或多个子元素。event必需，规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。 data 可选，规定传递到函数的额外数据。function 必需，规定当事件发生时运行的函数。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(document).ready(function () &#123; $(&quot;#myLinks&quot;).delegate(&quot;#goSomewhere&quot;, &quot;click&quot;, function () &#123; location.href = &quot;http://www.baidu.com&quot;; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用事件委托注意事项 使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/yarn的安装和使用","date":"2021-07-20T05:09:34.905Z","updated":"2021-05-17T01:15:16.791Z","comments":true,"path":"2021/07/20/大前端/other/yarn的安装和使用/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/yarn%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"yarn的简介：Yarn是facebook发布的一款取代npm的包管理工具。 yarn的特点：速度超快。Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。超级安全。在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。超级可靠。使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。yarn的安装:下载node.js，使用npm安装npm install -g yarn查看版本：yarn –version安装node.js,下载yarn的安装程序:提供一个.msi文件，在运行时将引导您在Windows上安装YarnYarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可yarn config set registry https://registry.npm.taobao.org -gyarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -gyarn的常用命令：安装yarn npm install -g yarn安装成功后，查看版本号： yarn –version创建文件夹 yarn md yarn进入yarn文件夹 cd yarn初始化项目 yarn init // 同npm init，执行输入信息后，会生成package.json文件yarn的配置项： yarn config list // 显示所有配置项yarn config get //显示某配置项yarn config delete //删除某配置项yarn config set [-g|–global] //设置配置项安装包： yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lockyarn install –flat //安装一个包的单一版本yarn install –force //强制重新下载所有包yarn install –production //只安装dependencies里的包yarn install –no-lockfile //不读取或生成yarn.lockyarn install –pure-lockfile //不生成yarn.lock添加包（会更新package.json和yarn.lock）： yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型： yarn add –dev/-D // 加到 devDependenciesyarn add –peer/-P // 加到 peerDependenciesyarn add –optional/-O // 加到 optionalDependencies//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本： yarn add –exact/-E // 安装包的精确版本。例如yarn add &#x66;&#111;&#x6f;&#64;&#x31;&#46;&#50;&#x2e;&#51;会接受1.9.1版，但是yarn add &#102;&#x6f;&#x6f;&#x40;&#49;&#46;&#50;&#x2e;&#x33; –exact只会接受1.2.3版yarn add –tilde/-T // 安装包的次要版本里的最新版。例如yarn add &#102;&#111;&#x6f;&#x40;&#49;&#46;&#x32;&#x2e;&#x33; –tilde会接受1.2.9，但不接受1.3.0发布包 yarn publish移除一个包 yarn remove ：移除一个包，会自动更新package.json和yarn.lock更新一个依赖 yarn upgrade 用于更新包到基于规范范围的最新版本运行脚本 yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本显示某个包的信息 yarn info 可以用来查看某个模块的最新版本信息缓存 yarn cacheyarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存npm 与 yarn命令比较: npm 与 yarn相关问题比较:npm模块的依赖: npm存在一些历史遗留问题，请看下图： 比如说你的项目模块依赖是图中描述的，@1.2.1代表这个模块的版本。在你安装A的时候需要安装依赖C和D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装模块的时候C和D是某一个版本，而当以后C、D更新的时候，再次安装模块就会安装C和D的最新版本，如果新的版本无法兼容你的项目，你的程序可能就会出BUG，甚至无法运行。这就是npm的弊端，而yarn为了解决这个问题推出了yarn.lock的机制，这是作者项目中的yarn.lock文件。 yarn.lock文件格式: 大家会看到，这个文件已经把依赖模块的版本号全部锁定，当你执行yarn install的时候，yarn会读取这个文件获得依赖的版本号，然后依照这个版本号去安装对应的依赖模块，这样依赖就会被锁定，以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候，把这个yarn.lock拷贝到相应的环境项目下再安装即可。注意：这个文件不要手动修改它，当你使用一些操作如yarn add时，yarn会自动更新yarn.lock。 使用yrm工具管理一些npm源安装yarn global add yrm查看可用源yrm ls选择源yrm use yarn快速删除node_modules手动删除真的很慢： 安装： npm install rimraf -g使用：rimraf node_modulesrimraf是node的一个包，可以快速删除node_modules，再也不用等半天了","categories":[],"tags":[]},{"title":"","slug":"大前端/other/requestIdleCallback和requestAnimationFrame详解","date":"2021-07-20T05:09:34.901Z","updated":"2021-04-16T05:23:58.248Z","comments":true,"path":"2021/07/20/大前端/other/requestIdleCallback和requestAnimationFrame详解/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/requestIdleCallback%E5%92%8CrequestAnimationFrame%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"页面流畅与 FPS页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60时，页面是流畅的，小于这个值时，用户会感觉到卡顿。 1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。 Frame那么浏览器每一帧都需要完成哪些工作？ 通过上图可看到，一帧内需要完成如下六个步骤的任务： 处理用户的交互 JS 解析执行 帧开始。窗口尺寸变更，页面滚去等的处理 requestAnimationFrame(rAF) 布局 绘制 requestIdleCallback上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 requestIdleCallback里注册的任务。 从上图也可看出，和 requestAnimationFrame 每一帧必定会执行不同，requestIdleCallback 是捡浏览器空闲来执行任务。 如此一来，假如浏览器一直处于非常忙碌的状态，requestIdleCallback 注册的任务有可能永远不会执行。此时可通过设置 timeout （见下面 API 介绍）来保证执行。 callback：回调，即空闲时需要执行的任务，该回调函数接收一个IdleDeadline对象作为入参。其中IdleDeadline对象包含： didTimeout，布尔值，表示任务是否超时，结合 timeRemaining 使用。 timeRemaining()，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。 options：目前 options 只有一个参数 timeout。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。 IdleDeadline对象参考MDN:https://developer.mozilla.org/zh-CN/docs/Web/API/IdleDeadline API1var handle = window.requestIdleCallback(callback[, options]) 示例 1234567891011121314151617181920212223242526272829requestIdleCallback(myNonEssentialWork, &#123; timeout: 2000 &#125;);// 任务队列const tasks = [ () =&gt; &#123; console.log(&quot;第一个任务&quot;); &#125;, () =&gt; &#123; console.log(&quot;第二个任务&quot;); &#125;, () =&gt; &#123; console.log(&quot;第三个任务&quot;); &#125;,];function myNonEssentialWork (deadline) &#123; // 如果帧内有富余的时间，或者超时 while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0) &#123; work(); &#125; if (tasks.length &gt; 0) requestIdleCallback(myNonEssentialWork); &#125;function work () &#123; tasks.shift()(); console.log(&#x27;执行任务&#x27;);&#125; 超时的情况，其实就是浏览器很忙，没有空闲时间，此时会等待指定的 timeout 那么久再执行，通过入参 dealine 拿到的 didTmieout 会为 true，同时 timeRemaining () 返回的也是 0。超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长。 cancelIdleCallback与 setTimeout 类似，返回一个唯一 id，可通过 cancelIdleCallback 来取消任务。 总结 一些低优先级的任务可使用 requestIdleCallback 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）。 因为它发生在一帧的最后，此时页面布局已经完成，所以不建议在 requestIdleCallback 里再操作 DOM，这样会导致页面再次重绘。DOM 操作建议在 rAF 中进行。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。 Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 requestIdleCallback 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。 额外补充一下window.requestAnimationFrame 在没有 requestAnimationFrame 方法的时候，执行动画，我们可能使用 setTimeout 或setInterval 来触发视觉变化；但是这种做法的问题是：回调函数执行的时间是不固定的，可能刚好就在末尾，或者直接就不执行了，经常会引起丢帧而导致页面卡顿。 归根到底发生上面这个问题的原因在于时机，也就是浏览器要知道何时对回调函数进行响应。**setTimeout 或 setInterval 是使用定时器来触发回调函数的，而定时器并无法保证能够准确无误的执行，有许多因素会影响它的运行时机，比如说：当有同步代码执行时，会先等同步代码执行完毕，异步队列中没有其他任务，才会轮到自己执行**。并且，我们知道每一次重新渲染的最佳时间大约是 16.6 ms，如果定时器的时间间隔过短，就会造成 过度渲染，增加开销；过长又会延迟渲染，使动画不流畅。 requestAnimationFrame 方法不同与 setTimeout 或 setInterval，它是由系统来决定回调函数的执行时机的，会请求浏览器在下一次重新渲染之前执行回调函数。无论设备的刷新率是多少，**requestAnimationFrame 的时间间隔都会紧跟屏幕刷新一次所需要的时间；例如某一设备的刷新率是 75 Hz，那这时的时间间隔就是 13.3 ms（1 秒 / 75 次）。需要注意的是这个方法虽然能够保证回调函数在每一帧内只渲染一次，但是如果这一帧有太多任务执行，还是会造成卡顿的；因此它只能保证重新渲染的时间间隔最短是屏幕的刷新时间。** requestAnimationFrame 方法的具体说明可以看 MDN 的相关文档，下面通过一个网页动画的示例来了解一下如何使用。 1234567let offsetTop = 0;const div = document.querySelector(&quot;.div&quot;);const run = () =&gt; &#123; div.style.transform = `translate3d(0, $&#123;offsetTop += 10&#125;px, 0)`; window.requestAnimationFrame(run);&#125;;run(); 如果想要实现动画效果，每一次执行回调函数，必须要再次调用 requestAnimationFrame 方法；与 setTimeout 实现动画效果的方式是一样的，只不过不需要设置时间间隔。 来源 https://www.jianshu.com/p/2771cb695c81","categories":[],"tags":[]},{"title":"","slug":"大前端/other/requestAnimationFrame详解","date":"2021-07-20T05:09:34.899Z","updated":"2021-01-06T09:21:34.000Z","comments":true,"path":"2021/07/20/大前端/other/requestAnimationFrame详解/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/requestAnimationFrame%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"为什么要说它，源于看到的一道面试题：问题是用js实现一个无限循环的动画。 首先想到的是定时器 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #e&#123; width: 100px; height: 100px; background: red; position: absolute; left: 0; top: 0; zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;e&quot;&gt;&lt;/div&gt;&lt;script&gt; var e = document.getElementById(&quot;e&quot;); var flag = true; var left = 0; function render() &#123; if(flag == true)&#123; if(left&gt;=100)&#123; flag = false &#125; e.style.left = ` $&#123;left++&#125;px` &#125;else&#123; if(left&lt;=0)&#123; flag = true &#125; e.style.left = ` $&#123;left--&#125;px` &#125; &#125; setInterval(function()&#123; render() &#125;,1000/60)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以说是完美实现！ 至于时间间隔为什么是1000/60,这是因为大多数屏幕渲染的时间间隔是每秒60帧。 既然setInterval可以搞定为啥还要用requestAnimationFrame呢？最直观的感觉就是，添加api的人是个大神级牛人，我只能怀疑自己。 所以搜索相关问题发现以下两点 requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：1、requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。2、在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #e&#123; width: 100px; height: 100px; background: red; position: absolute; left: 0; top: 0; zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;e&quot;&gt;&lt;/div&gt;&lt;script&gt; var e = document.getElementById(&quot;e&quot;); var flag = true; var left = 0; function render() &#123; if(flag == true)&#123; if(left&gt;=100)&#123; flag = false &#125; e.style.left = ` $&#123;left++&#125;px` &#125;else&#123; if(left&lt;=0)&#123; flag = true &#125; e.style.left = ` $&#123;left--&#125;px` &#125; &#125; //requestAnimationFrame效果 (function animloop() &#123; render(); window.requestAnimationFrame(animloop); &#125;)();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我没有添加各个浏览器的兼容写法，这里只说用法。 效果是实现了，不过我想到两个问题。 1、怎么停止requestAnimationFrame？是否有类似clearInterval这样的类似方法？ 第一个问题：答案是确定的 必须有：cancelAnimationFrame()接收一个参数 requestAnimationFrame默认返回一个id，cancelAnimationFrame只需要传入这个id就可以停止了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #e&#123; width: 100px; height: 100px; background: red; position: absolute; left: 0; top: 0; zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;e&quot;&gt;&lt;/div&gt;&lt;script&gt; var e = document.getElementById(&quot;e&quot;); var flag = true; var left = 0; var rafId = null function render() &#123; if(flag == true)&#123; if(left&gt;=100)&#123; flag = false &#125; e.style.left = ` $&#123;left++&#125;px` &#125;else&#123; if(left&lt;=0)&#123; flag = true &#125; e.style.left = ` $&#123;left--&#125;px` &#125; &#125; //requestAnimationFrame效果 (function animloop(time) &#123; console.log(time,Date.now()) render(); rafId = requestAnimationFrame(animloop); //如果left等于50 停止动画 if(left == 50)&#123; cancelAnimationFrame(rafId) &#125; &#125;)(); //setInterval效果 // setInterval(function()&#123; // render() // &#125;,1000/60)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2019-10-10 at 10.19.07.gif 附上一个效果图。也可直接capy代码测试。 2、如果我想动画频率降低怎么做，为什么不考虑加快呵呵 当前刷新频率已经是屏幕的刷新频率了再快也没有意义了 这个略微麻烦点 默认情况下，requestAnimationFrame执行频率是1000/60,大概是16ms多执一次。 如果我们想每50ms执行一次怎么办呢？ requestAnimationFrame执行条件类似递归调用 （说的是类似）别咬我，既然这样的话我们能否自定一个时间间隔再执行呢？当然定时器这么low的东西我们就不考虑了，都已经抛弃它用rAF了（都快结束了我才想起写简写太他妈长了）， 这个思路来源于我几年前搞IM的一个项目，服务端推送消息为了减小包的大小不给时间戳，这个我们做前端的都知道，我们虽然很牛逼 不过用户更牛逼，万一改了时间就不好玩了。 解决方案是 当和服务端通信时 记录下一个时间差，（时间差等于服务端时间-本地时间）不管正负我们只要这个时间差。这样每当我们接受到消息 或者发送消息的时候我们就拿本地时间和是价差相加。这样就可以保证和服务端时间是一致的了，思路是不是很牛逼哈哈。 撤了半天我们通过以上思路来解决下rAF改变间隔的问题 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #e&#123; width: 100px; height: 100px; background: red; position: absolute; left: 0; top: 0; zoom: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;e&quot;&gt;&lt;/div&gt;&lt;script&gt; var e = document.getElementById(&quot;e&quot;); var flag = true; var left = 0; //当前执行时间 var nowTime = 0; //记录每次动画执行结束的时间 var lastTime = Date.now(); //我们自己定义的动画时间差值 var diffTime = 40; function render() &#123; if(flag == true)&#123; if(left&gt;=100)&#123; flag = false &#125; e.style.left = ` $&#123;left++&#125;px` &#125;else&#123; if(left&lt;=0)&#123; flag = true &#125; e.style.left = ` $&#123;left--&#125;px` &#125; &#125; //requestAnimationFrame效果 (function animloop() &#123; //记录当前时间 nowTime = Date.now() // 当前时间-上次执行时间如果大于diffTime，那么执行动画，并更新上次执行时间 if(nowTime-lastTime &gt; diffTime)&#123; lastTime = nowTime render(); &#125; requestAnimationFrame(animloop); &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附上一个效果： 2019-10-10 at 10.58.30.gif 作者：我是一个前端链接：https://www.jianshu.com/p/fa5512dfb4f5来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/i图标标签元素与span行内元素内容不对齐的解决方法","date":"2021-07-20T05:09:34.897Z","updated":"2021-06-21T00:53:32.624Z","comments":true,"path":"2021/07/20/大前端/other/i图标标签元素与span行内元素内容不对齐的解决方法/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/i%E5%9B%BE%E6%A0%87%E6%A0%87%E7%AD%BE%E5%85%83%E7%B4%A0%E4%B8%8Espan%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E4%B8%8D%E5%AF%B9%E9%BD%90%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"Dom结构大致是： 1234&lt;a&gt; &lt;i&gt;图标&lt;/i&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;/a&gt; 如上图，子节点i图标标签有vertical-align:middle属性。为使得子节点内容都居中，父节点a标签设置如下属性： 12line-height:2rem;text-align:center; 图标与文字“Delete”没有对齐，文字“Delete”居中了，然而icon图标并未居中。在icon字体图标具有vertical-align:middle属性并且不改变的前提下，要使icon与文字对齐，在父节点设置text-align:center的方式貌似不是较好的解决方式。 一种解决方法：让内容span也设置vertical-align:middle属性，i标签与span标签都设置line-height:2rem和text-align:center属性。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/ETag","date":"2021-07-20T05:09:34.895Z","updated":"2021-07-04T05:39:35.927Z","comments":true,"path":"2021/07/20/大前端/other/ETag/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/ETag/","excerpt":"","text":"基础概念什么是ETagETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中的一个属性而已。 12345678910HTTP/1.1 200 OKDate: Mon, 23 May 2005 22:38:34 GMTContent-Type: text/html; charset=UTF-8Content-Encoding: UTF-8Content-Length: 138Last-Modified: Wed, 08 Jan 2003 23:11:55 GMTServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)ETag: &quot;3f80f-1b6-3e1cb03b&quot;Accept-Ranges: bytesConnection: close 12345678&lt;html&gt;&lt;head&gt; &lt;title&gt;An Example Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World, this is a very simple HTML document.&lt;/body&gt;&lt;/html&gt; 请注意第8行的 ETag: “3f80f-1b6-3e1cb03b”配置，那么为什么要用ETag呢？ ETag是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，浏览器把”3f80f-1b6-3e1cb03b” 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: “3f80f-1b6-3e1cb03b” 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全量数据返回给客户端。 注：HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。 通常情况下，ETag更类似于资源指纹(fingerprints)，如果资源发生变化了就会生成一个新的指纹，这样可以快速的比较资源的变化。在服务器端实现中，很多情况下并不会用哈希来计算ETag，这会严重浪费服务器端资源，很多网站默认是禁用ETag的。有些情况下，可以把ETag退化，比如通过资源的版本或者修改时间来生成ETag。 如果通过资源修改时间来生成ETag，那么效果和HTTP协议里面的另外一个控制属性(Last-Modified)就雷同了，使用 Last-Modified 的问题在于它的精度在秒(s)的级别，比较适合不太敏感的静态资源。 后记在友盟的时候做过一个项目 - 在线参数，这个功能在很多游戏类App中非常流行，也有很多App会通过它来控制内置广告的开关，曾经一度流量过大以至于阿里那边发邮件过来要我们关闭这个服务区（这是个免费的服务）。为了继续造福群众，我们做了一些优化流量的措施： 减少SDK请求的次数设计了一种服务器端缓存验证机制前者是因为很多开发者把调用方法写在了Activity里面，这样每次Activity重建的时候都会导致给服务器发请求。但是对于SDK来说无法判断请求是开发者故意发起的还是由于Activity重建导致的，所以解决这个问题需要开发者配合 - 这明显是不可能的。考虑到在线参数并不会经常性的发生变化，SDK限制了请求间隔为10分钟 - 考虑大部分App的声明周期是3 - 10 分钟（对于读书、视频等媒体类应用例外），这等于App每次启动只能请求一次服务器，这种限制在开发者DEBUG阶段会造成奇怪的问题 - 明明更新了在线参数，本地却不起效果。 第二个措施其实是进一步优化，在最早设计在线参数的时候已经添加了服务器端的验证机制 - 每次请求数据的时候带上服务器返回的最后修改时间，如果服务器端发现数据没有变化，那么就不再返回数据。但是这个协议是在HTTP-Body里面通过私有协议实现的，每次请求服务器的时候依然会发送大量数据(&lt;1K)，所以优化的措施是每次先发送一个最简的协议给服务器如果数据有变化再发送一个标准的协议给服务器取回数据。 当时我对HTTP协议并不熟悉，这些设计都是通过私有协议实现的，其实完全可以通过HTTP来实现，这样可以较好的分离控制逻辑和业务数据 GZIP压缩前言在基于 HTTP 协议的网络传输中 GZip 经常被使用，Nginx 中也可以使用半行代码开启 GZip。GZip 压缩的原理是什么呢？本篇文章是我在网上阅读了一些文档后做的简单总结。 从 RFC 1952 看起RFC 1952 是 GZIP file format specification version 4.3。该规范主要定义了 GZip 压缩的在数据格式方面的规范，以方便不同的操作系统、CPU、文件系统等之间进行文件传输交换。下面挑有意思的几个点说，感兴趣的可以阅读 RFC 1952 的原文。 GZIP 的文件格式在设计上其实是可以允许一个文件里有多个压缩数据集（compressed data sets）—— GZIP 压缩后的片段拼接而成的。但就我们大多数应用场景来说，基本上都是一个文件一个压缩数据集，如果是多个文件一起打包的话，也往往是将多个包合并成一个 tar 文件。 每个压缩数据集都是下面的结构： | ID1 | ID2 | CM | FLG | MTIME（4字节） | XFL | OS | —-&gt; more | 与 | 之间是 1 byte，都是大端字节（Big Edian） 其中 ID1 和 ID2 分别是 0x1f 和 0x8b，用来标识文件格式是 gzip CM 标识 加密算法，目前 0-7是保留字，8 指的是 deflate 算法 FLG 从低地址到高地址分别是 FTEXT、FHCRC、FEXTRA、FNAME、FCOMMENT、reserved、 reserved、reserved，这里每个 bit 被设置了之后有什么意义感兴趣的话可以详细参考 RFC 1952。比较有意思的是 FEXTRA，如果它被设置了表示存在额外的拓展字段。拓展字段的结构如下： | SI1 | SI2 | LEN | … LEN bytes of subfield data … | SI1、SI2 是对子域的 ID，由 ASCII 码组成。如果你需要使用的话，可以向他的维护者 Jean-Loup Gailly &#x67;&#122;&#x69;&#112;&#x40;&#x70;&#x72;&#x65;&#x70;&#46;&#x61;&#x69;&#46;&#109;&#x69;&#x74;&#x2e;&#x65;&#x64;&#x75; 发邮件申请。目前 Apollo file 就有自己的专属 ID MTIME 指的是源文件最近一次修改时间，存的是 Unix 时间戳 XFL 是给压缩算法传的一些参数，用来标识如何解压。defalte 算法中 2 表示使用压缩率最高的算法，4 表示使用压缩速度最快的算法 OS 标识压缩程序运行的文件系统，以处理 EOF 等的问题 more 后面是根据 FLG 的开启情况决定的，可能会有 循环冗余校验码、源文件长度、附加信息等多种其他信息 压缩核心之 DeflateGZIP 的核心是 Deflate，在 RFC 1951 中被标准化，并且在当时作为 LZW 的替代品有了非常广泛的使用。 Deflate 是一个同时使用 LZ77 与 Huffman Coding 的算法，这里简单介绍下这两种算法的大致思路： LZ77 LZ77 的核心思路是如果一个串中有两个重复的串，那么只需要知道第一个串的内容和后面串相对于第一个串起始位置的距离 + 串的长度。 比如： ABCDEFGABCDEFH → ABCDEFG(7,6)H。7 指的是往前第 7 个数开始，6 指的是重复串的长度，ABCDEFG(7,6)H 完全可以表示前面的串，并且是没有二义性的。 LZ77 用 滑动窗口（sliding-window compression）来实现这个算法。具体思路是扫描头从串的头部开始扫描串，在扫描头的前面有一个长度为 N 的滑动窗口。如果发现扫描头处的串和窗口里的 最长匹配串 是相同的，则用（两个串之间的距离，串的长度）来代替后一个重复的串，同时还需要添加一个表示是真实串还是替换后的“串”的字节在前面以方便解压（此串需要在 真实串和替换“串” 之前都有存在）。 实际过程中滑动窗口的大小是固定的，匹配的串也有最小长度限制，以方便 标识+两个串之间的距离+串的长度 所占用的字节是固定的 以及 不要约压缩体积越大。更加详细的实现可以参考：Standford Edu. lz77 algorithm、 LZ77 Compression Algorithm、 LZ77压缩算法编码原理详解(结合图片和简单代码) 这里通过这个压缩机制也就能比较容易的解释为啥 CSS BEM 写法 GZIP 压缩之后可以忽略长度以及 JPEG 图片 GZIP 之后可能会变大 的情况了 解压：GZIP 的压缩因为要在窗口里寻找重复串相对来说效率是比较低的（LZ77 还是通过 Hash 等系列方法提高了很多），那解压又是怎么个情况呢？观察压缩后的整个串，每个小串前都有一个标识要标记是原始串还是替换“串”，通过这个标识就能以 O（1）的复杂度直接读完并且替换完替换“串”，整体上效率是非常可观的。 Huffman Coding Huffman Coding 是大学课本中一般都会提到的算法。核心思路是通过构造 Huffman Tree 的方式给字符重新编码（核心是避免一个叶子的路径是另外一个叶子路径的前缀），以保证出现频路越高的字符占用的字节越少。关于 Huffman Tree 的构造这里不再细说，不太清楚的可以参考：Huffman Coding。 解压：Huffman Coding 之后需要维护一张 Huffman Map 表，来记录重新编码后的字符串，根据这张表，还原原始串也是非常高效的。 Deflate 综合使用了 LZ77 和 Huffman Coding 来压缩文件，相对而言又提升了很多。详细可以参考 gzip原理与实现 网站中的使用在 RFC 2016 中 GZIP 已经成为了规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用 GZIP 传输 HTML、CSS、JavaScript 等资源文件。 Nginx 开启 Nginx 的 ngx_http_gzip_module 也提供了开启 GZIP 压缩的方式，有下面的一些常用配置： 12345678# 开启gzip on;# 压缩等级，1-9。设置多少可以参考：http://serverfault.com/questions/253074/what-is-the-best-nginx-compression-gzip-levelgzip_comp_level 2;# &quot;MSIE [1-6]\\.&quot; 比如禁止 IE6 使用 GZIPgzip_disable regex ...# 最小压缩文件长度gzip_min_length 20;# 使用 GZIP 压缩的最小 HTTP 版本gzip_http_version 1.1;# 压缩的文件类型，值是 [MIME type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types)gzip_types text/html; 相关探测 Nginx 上开启 GZIP 之后，理论上会按照 GZIP 配置打开压缩。那如何检测是否开启成功了呢？ 打开浏览器，访问你的网站，看 Chrome 的 Network，如果 Size 上有两个不一样大小的体积（如：222KB 和 613KB），则代表 GZIP 已经成功开启。 那浏览器又是如何和服务器配合的呢？ 浏览器在请求资源的时候再 header 里面带上 accept-encoding: gzip 的参数。Nginx 在接收到 Header 之后，发现如果有这个配置，则发送 GZIP 之后的文件（返回的 header 里也包含相关的说明），如果没有则发送源文件。浏览器根据 response header 来处理要不要针对返回的文件进行解压缩然后展示。","categories":[],"tags":[]},{"title":"","slug":"大前端/other/ES6","date":"2021-07-20T05:09:34.893Z","updated":"2021-04-13T07:46:28.619Z","comments":true,"path":"2021/07/20/大前端/other/ES6/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/ES6/","excerpt":"","text":"https://www.jianshu.com/p/287e0bb867ae","categories":[],"tags":[]},{"title":"","slug":"大前端/other/css文字如何垂直居中","date":"2021-07-20T05:09:34.891Z","updated":"2021-06-08T07:24:14.150Z","comments":true,"path":"2021/07/20/大前端/other/css文字如何垂直居中/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/css%E6%96%87%E5%AD%97%E5%A6%82%E4%BD%95%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"","text":"方法1：使用line-height属性使文字垂直居中 line-height属性设置行间的距离（行高）；该属性不允许使用负值。 line-height属性会影响行框的布局。在应用到一个块级元素时，它定义了该元素中基线之间的最小距离而不是最大距离。 line-height 与 font-size 的计算值之差（在 CSS 中成为“行间距”）分为两半，分别加到一个文本行内容的顶部和底部。可以包含这些内容的最小框就是行框。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css 垂直居中&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 300px; background: #ddd; line-height:300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法2：将外部块格式化为表格单元格 表格单元格的内容可以垂直居中，将外部块格式化为表格单元格就可垂直居中文本。 示例：将段落置于具有特定给定高度的块内 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css 垂直居中&lt;/title&gt; &lt;style&gt; .box&#123; width: 400px; height: 200px; background: #ddd; display: table-cell; vertical-align: middle; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;css 垂直居中了--文本文字&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法3：使用CSS3的flex布局 使文字垂直居中 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css 垂直居中&lt;/title&gt; &lt;style&gt; .box&#123; width: 300px; height: 200px; background: #ddd; /*设置为伸缩容器*/ display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; /*垂直居中*/ -webkit-box-align: center;/*旧版本*/ -moz-box-align: center;/*旧版本*/ -ms-flex-align: center;/*混合版本*/ -webkit-align-items: center;/*新版本*/ align-items: center;/*新版本*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;css 垂直居中--文本文字（弹性布局）&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/JavaScript对象封装的简单实现方法(3种方法)","date":"2021-07-20T05:09:34.857Z","updated":"2021-08-03T12:59:34.703Z","comments":true,"path":"2021/07/20/大前端/JavaScript/JavaScript对象封装的简单实现方法(3种方法)/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/JavaScript%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95(3%E7%A7%8D%E6%96%B9%E6%B3%95)/","excerpt":"","text":"1. 使用关键字new创建对象 12345function Person(name,age)&#123; this.name = name; this.age = age;&#125;var p = new Persion(); 2. 使用Object直接创建对象 可以看出，这种方法扩展很方便。 123var obj = new Object(); // 这里也可以写成 var = &#123;&#125;obj.name = &#x27;ling&#x27;;obj.age = 22; 3. 使用JSON创建（对象字面量的说法更准确，但JSON更好理解） 从Javascript1.2开始，创建对象有了更快捷的方式。 1234var p = &#123; name :&#x27;lin&#x27;, //&quot;name&quot;:&quot;lingceng这样加引号解析方式相同 gander:&#x27;mage&#x27;&#125; 实践方式 结合构造函数和原型模式创建对象的方式很适合实践。 12345678910111213141516171819function Person(name,age)&#123; //实例属性 //实例多份拷贝 this.name = name; this.age = age;&#125;Person.prototype = &#123; //因为原型被替换，所以需要恢复construtor的默认指向 constructor:Person, showName:function()&#123; alert(&#x27;ShowName in prototype:&#x27;+this.name); &#125;, showAge:function()&#123; alert(this.age); &#125;&#125;var p = new Persion(&#x27;lin&#x27;,22);p.showAge();","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/Javascript-节流与防抖","date":"2021-07-20T05:09:34.854Z","updated":"2021-01-11T08:28:38.000Z","comments":true,"path":"2021/07/20/大前端/JavaScript/Javascript-节流与防抖/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/Javascript-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/","excerpt":"","text":"函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用. 只有当上一次函数执行后达到规定的时间间隔, 才能进行下一次调用. 但要保证一个累计最小调用时间间隔(例如拖拽类的节流需要有连续效果) 函数节流用于onresize, onscroll等短时间内会多次触发的事件 函数节流的原理: 使用定时器做时间节流. 当触发一个事件时, 先用setTimeout让这个事件延迟一小段时间在执行. 如果在这个时间间隔内又触发了事件, 就clearTimeout原来的定时器, 在setTimeout一个新的定时器重复以上流程 函数节流简单实现: function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100); &#125; window.onresize = function() &#123; throttle(myFunc, window) &#125; // 封装 var throttle = function(fn, delay, mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay)&#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125; &#125;; &#125;; // 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次 window.onresize = throttle(myFunc, 50, 100);","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/JavaScript-提取数组对象中的某一个属性组成新数组","date":"2021-07-20T05:09:34.852Z","updated":"2021-06-04T03:48:42.351Z","comments":true,"path":"2021/07/20/大前端/JavaScript/JavaScript-提取数组对象中的某一个属性组成新数组/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%BB%84%E6%88%90%E6%96%B0%E6%95%B0%E7%BB%84/","excerpt":"","text":"【js】提取数组对象中的某一个属性组成新数组场景 ：批量新增的时候后台接收的数组对象只需要一两个参数的信息 antd table的多选会把整行的信息带去 处理 12345console.log(&quot;selectedRows--&quot;, selectedRows)let arrnew = selectedRows.map((item,index) =&gt; &#123; return Object.assign(&#123;&#125;,&#123;&#x27;group_Dr&#x27;:item.group_Dr,&quot;mapInterface_Dr&quot;:item.mapInterface_Dr&#125;)&#125;)console.log(&quot;arrnew--&quot;,arrnew)","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/JavaScript-如何判断是否为空对象","date":"2021-07-20T05:09:34.845Z","updated":"2021-06-02T03:40:07.440Z","comments":true,"path":"2021/07/20/大前端/JavaScript/JavaScript-如何判断是否为空对象/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"如何判断是否为空对象1.将对象转为字符串，然后判断是否等于’{}’如果等于’{}’则为空对象，如果不等于’{}’则不为空对象。 1234567var obj = &#123;&#125;;var objStr = JSON.stringify(obj);if(objStr === &#x27;&#123;&#125;&#x27;) &#123; console.log(&quot;空对象&quot;);&#125;else &#123; console.log(&quot;不是空对象&quot;);&#125; 输出： 1空对象 2、使用Object.getOwmPropertyNames()方法+length属性进行判断 Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象；然后通过使用数组的length属性来判断此对象是否为空对象。 1234567var obj = &#123;&#125;;var arr = Object.getOwnPropertyNames(obj);if (arr.length == 0)&#123; console.log(&quot;空对象&quot;);&#125;else &#123; console.log(&quot;不是空对象&quot;);&#125; 输出： 1空对象 3、使用es6的方法Object.keys()+length属性进行判断 这是ES6的新方法，Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 1234567var obj = &#123;&#125;;var arr = Object.keys(obj);if (arr.length == 0)&#123; console.log(&quot;空对象&quot;);&#125;else &#123; console.log(&quot;不是空对象&quot;);&#125; 输出： 1空对象","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/JavaScript-如何判断变量是否为数字","date":"2021-07-20T05:09:34.843Z","updated":"2021-06-16T01:26:08.952Z","comments":true,"path":"2021/07/20/大前端/JavaScript/JavaScript-如何判断变量是否为数字/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97/","excerpt":"","text":"简介JavaScript 是一种动态类型语言，这意味着解释器在运行时确定变量的类型。实际上，这也允许我们在相同的代码中使用相同的变量来存储不同类型的数据。如果没有文档和一致性，我们在使用代码时并不总是知道变量的类型。 当我们期望一个变量是数字时，对字符串或数组进行操作可能会在代码中导致奇怪的结果。在本文中，我们将会介绍一些判断变量是否为数字的函数。 像&quot;10&quot;之类的数字的字符串不应被接受。 在JavaScript中，诸如NaN，Infinity和-Infinity之类的特殊值也是数字类型的。 根据这些要求，最好使用的函数是内置Number对象中的isFinite()函数。但是，开发人员通常会使用其他函数，如Number.isNaN()和typeof()函数。 我们先创建一些变量： 1234567let intVar = 2;let floatVar = 10.5;let stringVar = &#x27;4&#x27;;let nanVar = NaN;let infinityVar = Infinity;let nullVar = null;let undefinedVar = undefined; 使用 Number.isFinite() 函数名Number.isFinite()函数检查变量是否为数字，还检查其是否为有限值。 因此，对于NaN，Infinity或-Infinity的数字，它返回false。 我们用上面定义的变量来检验一下: 1234567891011121314&gt; Number.isFinite(intVar);true&gt; Number.isFinite(floatVar);true&gt; Number.isFinite(stringVar);false&gt; Number.isFinite(nanVar);false&gt; Number.isFinite(infinityVar);false&gt; Number.isFinite(nullVar);false&gt; Number.isFinite(undefined);false 这正是我们想要的。特殊的非有限数以及非数字类型的任何变量都会被忽略。所以，如果你想检查一个变量是否是一个数字，最好的方法是使用Number.isFinite()函数。 使用 Number.isNaN() 方法标准Number对象有一个isNaN()方法。它接受一个参数，并确定其值是否为NaN。因为我们想检查一个变量是否是一个数字，所以我们将在检查中使用非操作符!。 1234567891011121314&gt; !Number.isNaN(intVar);true&gt; !Number.isNaN(floatVar);true&gt; !Number.isNaN(stringVar);true # Wrong&gt; !Number.isNaN(nanVar);false&gt; !Number.isNaN(infinityVar);true # Wrong&gt; !Number.isNaN(nullVar);true # Wrong&gt; !Number.isNaN(undefinedVar);true # Wrong 这个方法是相当宽松的，因为它接受根本不是数字的值。这种方法最适合于当你知道你有一个数字并且要检查它是否是一个NaN值时，而不是一般的数字检查。 使用 typeof() 方法typeof()函数是一个全局函数，它接受变量或值作为参数，并返回其类型的字符串表示。JavaScript 总共有9种类型 undefined boolean number string bigint symbol object null (typeof() 显示的是 object) function (一种特殊类型的 object) 为了验证变量是否为数字，我们只需要检查typeof()返回的值是否为`”number”。 让我们尝试一下测试变量： 1234567891011121314&gt; typeof(intVar) == &#x27;number&#x27;;true&gt; typeof(floatVar) == &#x27;number&#x27;;true&gt; typeof(stringVar) == &#x27;number&#x27;;false&gt; typeof(nanVar) == &#x27;number&#x27;;true # Wrong&gt; typeof(infinityVar) == &#x27;number&#x27;;true # Wrong&gt; typeof(nullVar) == &#x27;number&#x27;;false&gt; typeof(undefined) == &#x27;number&#x27;;false typeof()函数的性能比Number.isNaN()要好得多。它正确地确定了字符串变量null和undefined不是数字。但是，对于NaN和Infinity，它返回true。 尽管从技术上来说这是正确的结果，但NaN和Infinity是特殊的数字值，对于大多数使用情况，我们宁愿忽略它们。 总结在本文中，我们学习了如何检查JavaScript中的变量是否为数字。 Number.isNaN()函数仅在我们知道变量为数字并且需要验证它是否为NaN`时才适用。 如果代码中有NaN，Infinity或-Infinity以及其他数字，则 typeof()`函数适用。 Number.isFinite()方法捕获所有有限数，是最适合我们的要求。","categories":[],"tags":[]},{"title":"","slug":"大前端/JavaScript/JavaScript-各种js数组骚操作","date":"2021-07-20T05:09:34.842Z","updated":"2021-06-09T01:36:48.893Z","comments":true,"path":"2021/07/20/大前端/JavaScript/JavaScript-各种js数组骚操作/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-%E5%90%84%E7%A7%8Djs%E6%95%B0%E7%BB%84%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"","text":"各种js数组骚操作在开发中，数组的使用场景非常多，平日中也涉及到很多数组相关操作，对一些常见的操作方法进行总结和收藏，在开发中就能信手拈来，大大提高开发效率。 本文在github做了收录 github.com/Michael-lzg… 随机排序1、生成随机数遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素 1234567891011121314function randomSort1(arr)&#123; for (let i = 0, l = arr.length; i &lt; l; i++) &#123; let rc = parseInt(Math.random() * l) // 让当前循环的数组元素和随机出来的数组元素交换位置 const empty = arr[i] arr[i] = arr[rc] arr[rc] = empty &#125; return arr;&#125;var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]// 下面两次的结果肯定是不一样的；console.log(randomSort1(arr1))console.log(randomSort1(arr1)) 2、生成新数组 申明一个新的空数组,利用 while 循环，如果数组长度大于 0，就继续循环； 每次循环都随机一个在数组长度范围内的数，将随机数位置上的元素 push 到新数组里， 并利用 splice（对 splice 不太理解的同学可以看这里）截取出随机数位置上的元素，同时也修改了原始数组的长度； 12345678910111213function randomSort2(arr) &#123; var mixedArr = [] while (arr.length &gt; 0) &#123; let rc = parseInt(Math.random() * arr.length) mixedArr.push(arr[rc]) arr.splice(rc, 1) &#125; return mixedArr&#125;// 例子var arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(randomSort2(arr1)) 3、 arr.sort 如果 compareFunction(a, b)的返回值 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b)的返回值 等于 0 ，那么 a 和 b 的相对位置不变； 如果 compareFunction(a, b)的返回值 大于 0 ，那么 b 会被排列到 a 之前； 123456789function randomSort3(arr)&#123; arr.sort(function(a,b)&#123; return Math.random() - 0.5 &#125;) return arr;&#125;//例子var arr1 = [1,2,3,4,5,6,7,8,9]console.log(randomSort3(arr1)) 数组对象排序1、单个属性排序12345678910111213function compare(property)&#123; return function(a,b)&#123; let value1 = a[property] let value2 = b[property] return value1 - value2 &#125;&#125;let arr = [ &#123;name:&#x27;zopp&#x27;,age:10&#125;, &#123;name:&#x27;gpp&#x27;,age:18&#125;, &#123;name:&#x27;yjj&#x27;,age:8&#125;]console.log(arr.sort(compare(&#x27;age&#x27;))) 2、多个属性排序123456789101112131415161718function by(name, minor) &#123; return function(o, p) &#123; let a, b if (o &amp;&amp; p &amp;&amp; typeof o === &#x27;object&#x27; &amp;&amp; typeof p === &#x27;object&#x27;) &#123; a = o[name] b = p[name] if (a === b) &#123; return typeof minor === &#x27;function&#x27; ? minor(o, p) : 0 &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1 &#125; return typeof a &lt; typeof b ? -1 : 1 &#125; else &#123; thro(&#x27;error&#x27;) &#125; &#125;&#125;, 数组扁平化1、调用 ES6 中的 flat 方法12array = arr.flat(Infinity);console.log([1,[2,3,[4,5,[6,7]]]].flat(Infinity)); 2、普通递归1234567891011121314let result = []let flatten = function(arr)&#123; for(let i = 0;i &lt; arr.length;i++)&#123; let item = arr[i]; if(Array.isArray(arr[i]))&#123; flatten(item) &#125;else&#123; result.push(item) &#125; &#125; return result;&#125;let arr = [1,2,[3,4],[5,[6,7]]]console.log(flatten(arr)) 3、利用reduce函数迭代1234567function flatten(arr)&#123; return arr.reduce((pre,cur)=&gt;&#123; return pre.concat(Array.isArray(cur) ? flatten(cur) : cur) &#125;,[])&#125;let arr = [1,2,[3,4],5,[6,7]]console.log(flatten(arr)) 4、扩展运算符12345678function flatten(arr)&#123; while(arr.some((item)=&gt;Array.isArray(item)))&#123; arr = [].concat(...arr) &#125; return arr&#125;let arr = [1,2,[3,4],[5,[6,7]]]console.log(flatten(arr)) 数组去重1、利用数组的indexOf下标属性来查询12345678910function unique(arr)&#123; var newArr = [] for(var i = 0; i &lt; arr.length; i++)&#123; if(newArr.indexOf(arr[i]) === -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr&#125;console.log(unique([1,1,2,3,5,3,1,5,6,7,4])) 2、先将原数组排序，在与相邻的进行比较，如果不同则存入新数组1234567891011function unique(arr)&#123; var formArr = arr.sort() var newArr = [formArr[0]] for(let i = 1;i&lt; formArr.length;i++)&#123; if(formArr[i] !== formArr[i - 1])&#123; newArr.push(formArr[i] &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 3、利用对象属性存在的特性，如果没有该属性则存入新数组。123456789101112function unique(arr) &#123; var obj = &#123;&#125; var newArr = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; obj[arr[i]] = 1 newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 4、利用数组原型对象上的includes方法12345678910function unique(arr) &#123; var newArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!newArr.includes(arr[i])) &#123; newArr.push(arr[i]) &#125; &#125; return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 5、利用数组原型对象上的filter和includes方法12345678function unique(arr)&#123; var newArr = [] newArr = arr.filter(function (item)&#123; return newArr.includes(item) ? &#x27;&#x27; : newArr.push(item) &#125;) return newArr&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 6、利用 ES6 的 set 方法。1234function unique(arr) &#123; return Array.from(new Set(arr)) // 利用Array.from将Set结构转换成数组&#125;console.log(unique([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])) 根据属性去重方法一 1234function unique(arr) &#123; const res = new Map() return arr.filter((item) =&gt; !res.has(item.productName) &amp;&amp; res.set(item.productName, 1))&#125; 方法二 12345678910function unique(arr) &#123; let result = &#123;&#125; let obj = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i].key]) &#123; result.push(arr[i]) obj[arr[i].key] = true &#125; &#125;&#125; 交集/并集/差集1、includes 方法结合 filter 方法1234567891011121314let a = [1,2,3]let b = [2,4,5]// 并集let union = a.concat(b.filter((v) =&gt; !a.includes(v)))// [1,2,3,4,5]// 交集let intersection = a.filter((v) =&gt; b.includes(v))// [2]// 差集let difference = a.concat(b).filter((v) =&gt; !a.includes(v) || !b.includes(v))// [1,3,4,5] 2、ES6的Set数据结构1234567891011121314let a = new Set([1, 2, 3])let b = new Set([2, 4, 5])// 并集let union = new Set([...a, ...b])// Set &#123;1, 2, 3, 4,5&#125;// 交集let intersect = new Set([...a].filter((x) =&gt; b.has(x)))// set &#123;2&#125;// a 相对于 b 的）差集let difference = new Set([...a].filter((x) =&gt; !b.has(x)))// Set &#123;1, 3&#125; 数组求和1、万能的for循环123456789function sum(arr) &#123; var s = 0 for (var i = arr.length - 1; i &gt;= 0; i--) &#123; s += arr[i] &#125; return s&#125;sum([1, 2, 3, 4, 5]) // 15 2、递归方法1234567891011function sum(arr)&#123; var len = arr.length if(len == 0)&#123; return 0 &#125; else if(len == 1)&#123; return arr[0] &#125; else &#123; return arr[0] + sum(arr.slice(1)) &#125;&#125;sum([1, 2, 3, 4, 5]) // 15 3、ES6的reduce方法1234567function sum(arr) &#123; return arr.reduce(function (prev, curr) &#123; return prev + curr &#125;, 0)&#125;sum([1, 2, 3, 4, 5]) // 15 类数组转化1、Array的slice方法1let arr = Array.prototype.slice.call(arguments) 2、ES6 的 Array.from()1let arr = Array.from(arguments) 3、扩展运算符1let arr = [...arguments] 数组上下移动123456789101112131415161718function swapItems(arr, index1, index2) &#123; arr[index1] = arr.splice(index2, 1, arr[index1])[0] return arr&#125;function up(arr, index) &#123; if (index === 0) &#123; return &#125; this.swapItems(arr, index, index - 1)&#125;function down(arr, index) &#123; if (index === this.list.length - 1) &#123; return &#125; this.swapItems(arr, index, index + 1)&#125; 数组转化为树形结构将如下数据转化为树状结构 123456789101112131415161718192021222324252627282930313233343536let arr = [ &#123; id: 1, name: &#x27;1&#x27;, pid: 0, &#125;, &#123; id: 2, name: &#x27;1-1&#x27;, pid: 1, &#125;, &#123; id: 3, name: &#x27;1-1-1&#x27;, pid: 2, &#125;, &#123; id: 4, name: &#x27;1-2&#x27;, pid: 1, &#125;, &#123; id: 5, name: &#x27;1-2-2&#x27;, pid: 4, &#125;, &#123; id: 6, name: &#x27;1-1-1-1&#x27;, pid: 3, &#125;, &#123; id: 7, name: &#x27;2&#x27;, &#125;,] 实现方法 123456789101112131415161718function toTree(data, parentId = 0) &#123; var itemArr = [] for (var i = 0; i &lt; data.length; i++) &#123; var node = data[i] if (node.pid === parentId) &#123; var newNode = &#123; ...node, name: node.name, id: node.id, children: toTree(data, node.id), &#125; itemArr.push(newNode) &#125; &#125; return itemArr&#125;console.log(toTree(arr))","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/聚光灯","date":"2021-07-20T05:09:34.823Z","updated":"2021-05-31T02:39:48.765Z","comments":true,"path":"2021/07/20/大前端/07-HTML5和CSS3/聚光灯/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/%E8%81%9A%E5%85%89%E7%81%AF/","excerpt":"","text":"案例来源本例来自CodingStartup的视频：[CSS] 聚光灯效果 学到知识 关于after伪元素中content内容的设置，除了直接写在后面，也可以将其值写在html自定义的属性值中，利用attr()函数通过属性名，获取属性值。 after伪元素的所在位置相当于是所使用的元素的子元素，所以可以使用父元素相对定位，伪元素绝对定位的方法，调整伪元素的位置。 使用clip-path来实现遮罩效果，本例中属性值为ellipse(100px 100px at 0% 50%)，前两个参数为椭圆的x轴长度和y轴高度，at后的两个参数为相对于自身元素的x轴位置和y轴位置。 注意：使用这个属性时，需要注意浏览器的兼容情况，例如：Safari需要加前缀-webkit- 在使用兼容前缀的时候，一定要保留原css（非前缀）代码，不可删去。 设置对文字设置背景时，默认是文字所在的块级元素覆盖背景，如果想要将背景仅作用于文字上，类似color的效果，可以使用背景遮罩 background-clip: text; 同样要注意兼容问题。 想要实现以上效果，背景仅覆盖文字区域，还需要将文字的color设置成transparent，表示全透明色彩。 网站分享：caniuse查看css属性在各种浏览器中的支持情况，以及需要使用的前缀。 主要代码html123&lt;body&gt; &lt;h1 dot-light=&quot;Macbook Pro&quot;&gt;Macbook Pro&lt;/h1&gt;&lt;/body&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445body &#123; margin: 0; display: flex; justify-content: center; align-items: center; background-color: #222; min-height: 100vh;&#125;h1 &#123; font-size: 9rem; font-family: Helvetica; letter-spacing: -.3rem; color: #333; position: relative;&#125;h1::after &#123; content: attr(dot-light); position: absolute; top: 0; left: 0; color: transparent; clip-path: ellipse(100px 100px at 0% 50%); animation: SpotLight 5s infinite; background-image: url(&quot;https://images.unsplash.com/photo-1568279898331-4870e84677dd?ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTh8fGxpbmVhcnxlbnwwfHwwfHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=60&quot;); background-size: 150%; background-position: center center; -webkit-background-clip: text; background-clip: text;&#125;@keyframes SpotLight &#123; 0% &#123; clip-path: ellipse(100px 100px at 0% 50%); &#125; 50% &#123; clip-path: ellipse(100px 100px at 100% 50%); &#125; 100% &#123; clip-path: ellipse(100px 100px at 0% 50%); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"大前端/07-HTML5和CSS3/@media媒体查询","date":"2021-07-20T05:09:34.820Z","updated":"2021-06-16T01:49:08.271Z","comments":true,"path":"2021/07/20/大前端/07-HTML5和CSS3/@media媒体查询/","link":"","permalink":"https://alloceee.github.io/2021/07/20/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/@media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"12345678910111213141516/* 小屏适配 */@media screen and (max-width: 995px) &#123; .layui-layout-admin .layui-body&#123; left: 0; padding-left: 0; &#125; .layui-layout-admin .layui-body .layadmin-tabsbody-item&#123; left: 0 !important; &#125; .layui-header .hos_logo,.layui-header .layui-system:after&#123; display: none; &#125; .layui-header .layui-system&#123; margin-left: 10px; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Architecture/JWT","date":"2021-07-20T05:09:30.536Z","updated":"2020-05-11T07:01:26.000Z","comments":true,"path":"2021/07/20/Architecture/JWT/","link":"","permalink":"https://alloceee.github.io/2021/07/20/Architecture/JWT/","excerpt":"","text":"使用JWT实现Token认证32018.08.15 15:42:39字数 187阅读 77373 为什么使用JWT？随着技术的发展，分布式web应用的普及，通过session管理用户登录状态成本越来越高，因此慢慢发展成为token的方式做登录身份校验，然后通过token去取redis中的缓存的用户信息，随着之后jwt的出现，校验方式更加简单便捷化，无需通过redis缓存，而是直接根据token取出保存的用户信息，以及对token可用性校验，单点登录更为简单。 JWT架构图 JWT架构图.png 使用JWT核心代码：maven依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt; JWT工具类：用于生成Token，和Token验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class JwtUtils &#123; /** * 签发JWT * @param id * @param subject 可以是JSON数据 尽可能少 * @param ttlMillis * @return String * */ public static String createJWT(String id, String subject, long ttlMillis) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); SecretKey secretKey = generalKey(); JwtBuilder builder = Jwts.builder() .setId(id) .setSubject(subject) // 主题 .setIssuer(&quot;user&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey); // 签名算法以及密匙 if (ttlMillis &gt;= 0) &#123; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); builder.setExpiration(expDate); // 过期时间 &#125; return builder.compact(); &#125; /** * 验证JWT * @param jwtStr * @return */ public static CheckResult validateJWT(String jwtStr) &#123; CheckResult checkResult = new CheckResult(); Claims claims = null; try &#123; claims = parseJWT(jwtStr); checkResult.setSuccess(true); checkResult.setClaims(claims); &#125; catch (ExpiredJwtException e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_EXPIRE); checkResult.setSuccess(false); &#125; catch (SignatureException e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_FAIL); checkResult.setSuccess(false); &#125; catch (Exception e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_FAIL); checkResult.setSuccess(false); &#125; return checkResult; &#125; public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.decode(SystemConstant.JWT_SECERT); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * * 解析JWT字符串 * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 如何使用？代码实例： 12345678910111213141516171819202122232425262728public class LoginController &#123; @Autowired UserRepository userRepository; @ApiOperation(value=&quot;用户登陆&quot;) @RequestMapping(value=&quot;login&quot;,method = RequestMethod.POST) public ReturnVo login(String username, String password,HttpServletResponse response) &#123; User user = userRepository.findByUsername(username); if(user!=null)&#123; if(user.getPassword().equals(password))&#123; //把token返回给客户端--&gt;客户端保存至cookie--&gt;客户端每次请求附带cookie参数 String JWT = JwtUtils.createJWT(&quot;1&quot;, username, SystemConstant.JWT_TTL); return ReturnVo.ok(JWT); &#125;else&#123; return ReturnVo.error(); &#125; &#125;else&#123; return ReturnVo.error(); &#125; &#125; @ApiOperation(value=&quot;获取用户信息&quot;) @RequestMapping(value=&quot;description&quot;,method = RequestMethod.POST) public ReturnVo description(String username) &#123; User user = userRepository.findByUsername(username); return ReturnVo.ok(user.getDescription()); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Algorithm/数据结构与算法之美笔记","date":"2021-07-20T05:09:30.515Z","updated":"2021-04-12T06:53:53.289Z","comments":true,"path":"2021/07/20/Algorithm/数据结构与算法之美笔记/","link":"","permalink":"https://alloceee.github.io/2021/07/20/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.基础数据结构类型(1)线性结构数组、链表、栈、队列 (2)非线性结构树、图 2.数据结构变体数组扩展：散列表（散列表用的是数组支持按照下标随机访问数据的特性） 链表扩展：跳表 树扩展：二叉树（二叉查找树、平衡二叉树、红黑树、堆）、Trie树 3.各种数据结构适用场景或算法应用(1)数组数组需要分配连续的内存空间，对内存有较大要求，但是可以利用CPU的缓存机制，查询执行速度快于链表。 (2)链表不需要分配连续的内存空间，但需要保存指针。和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。 链表加多级索引的结构，就是跳表。跳表可以支持快速的插入、删除、查找。单链表插入、删除、查找一个数据时间复杂度是O(N)，跳表能做到O(logN)，相当于基于单链表实现了二分查找。 但比起链表要多O(N)的空间复杂度，不过索引结点只需要存储关键值和几个指针，并不需要存储对象。所以当存储对象比索引结点大很多时，索引占用的额外空间就可以忽略了。 (3)栈特性 栈是后进先出、先进后出的。常见应用于函数调用。 实现方式 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。 (4)队列队列是“先进先出”的。 队列有基于链表（链式队列）和基于数组（顺序队列）这两种实现方式。 队列可以应用在线程池请求排队的场景，还可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。 (5)树①二叉树二叉树重要的操作是前、中、后序遍历操作。二叉树中比较特殊的树是完全二叉树和满二叉树，满二叉树是完全二叉树的一种特殊情况。二叉树存储可以使用链式存储或者数组存储，完全二叉树适合使用数组存储。 二叉查找树是二叉树最常用的一种类型，支持快速查找。右子节点&gt;树中的任意一个结点值&gt;左子结点。极端情况下二叉查找树可能会退化成链表，时间复杂度会退化到 O(n)。 平衡二叉查找树可以解决复杂度退化问题。 AVL树符合平衡二叉查找树的严格定义，即任何节点的左右子树高度相差不超过 1，但AVL树维持平衡的成本很高。 红黑树是近似平衡，是一种不严格的平衡二叉查找树，在维护平衡的成本相对较低。在工程中更喜欢用红黑树而不是平衡二叉树。红黑树实现复杂，可以用跳表替代。 堆是完全二叉树，堆的重要应用有：优先级队列、求 Top K 和求中位数。 ②Trie树主要应用于多模式串匹配（在一个串中同时查找多个串），如搜索引擎。 扩展：AC自动机 (6)图图的存储方式有邻接矩阵和邻接表。邻接矩阵存储比较浪费空间，特别是存储是稀疏图（顶点多，边少），但查询效率高，而且方便矩阵运算（如弗洛伊德算法）。邻接表的存储方式比较节省存储空间，但链表不方便查找，可以通过跳表、红黑树、散列表等提高查询效率。 可以应用于存储社交网络的好友关系。 图基本的搜索算法是广度优先搜索算法和深度优先搜索算法。 其他算法：拓扑排序 (7)散列表①散列函数散列函数可以算出数据存放对应的数组下标，当出现散列冲突可以通过开放寻址法（适合数据量比较小、装载因子小的时候）、链表法（适合存储大对象、大数据量的散列表。可以用红黑树代替链表来优化）来解决。 当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了保证散列表的操作效率，一般情况下会保证散列表有一定比例的空闲槽位。 ②哈希算法将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。 哈希算法常见应用： 安全加密（MD5、SHA等） 唯一标识 对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。 数据校验 校验数据的完整性和正确性。如HTTPS中通过摘要算法保证数据的完整性 散列函数 散列函数中用到的散列算法更加看重的是散列的平均性和哈希算法的执行效率 负载均衡 通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到应该被路由到的服务器编号。 这样就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上，实现会话粘滞（session sticky）。 数据分片 通过哈希算法对数据分片，以实现采用多机分布式处理海量数据 分布式存储 针对海量数据的缓存，可以通过哈希算法对数据取哈希值，然后对机器个数取模，得到应该存储的缓存机器编号。 这种方法有个缺点就是当扩容或缩容，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。相当于缓存中的数据都失效了，可能发生雪崩效应，压垮数据库。可以采用一致性哈希算法来解决。 ③散列表和二叉查找树比较 散列表插入、删除、查找的时间复杂度是O(1)，而二叉查找树在比较平衡的基础上才能做到O(logN)。 但是散列表的数据是无序的，二叉查找树可以通过中序遍历在O(N)的时间复杂度内获得有序的数据。 散列表扩容耗时多，遇到散列冲突时，性能不稳定。平衡二叉树性能稳定，时间复杂度稳定在 O(logn)。 ④为什么散列表经常和链表一起使用（如LinkedHashMap）？ 散列表数据存储是无序的，无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序，再遍历。可以通过维护一个链表维持顺序，实现LRU淘汰算法。 借助散列表和双向链表可以实现O(1)的查询、删除操作 4.排序算法(1)非线性排序算法 算法 最好时间复杂度 最坏时间复杂度 平均时间复杂度 是否原地排序 是否稳定 适用场景 冒泡排序 O(n) O(n2) O(n2) 是 是 小规模数据排序 插入排序 O(n) O(n2) O(n2) 是 是 小规模数据排序 选择排序 O(n2) O(n2) O(n2) 是 否 小规模数据排序 快速排序 O(nlogn) O(n2) O(nlogn) 是 否 大规模数据排序 归并排序 O(nlogn) O(nlogn) O(nlogn) 否 是 大规模数据排序 堆排序 O(nlogn) O(nlogn) O(nlogn) 是 否 优先级队列、 Top K 、求中位数 ps：为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。 (2)线性排序算法 算法 时间复杂度 是否原地排序 是否稳定 排序数据要求 适用场景 桶排序 O(n)（选择快排） 否 是 ①要排序的数据需要很容易就能划分成 m 个桶②数据在各个桶之间的分布是比较均匀的 外部排序 计数排序 O(n+k) k是数据范围 否 是 非负整数 数据范围不大 基数排序 O(dn) d是维度 否 是 ①需要可以分割出独立的“位”来比较，而且位之间有递进的关系 ②位之间有递进的关系 ③每一位的数据范围不能太大，要可以用线性排序算法来排序 数据范围较大 ps：桶排序中时间复杂度、是否原地排序、是否稳定取决于桶内选取的排序算法；桶排序其实是一种算法思想；计数排序是一种特殊的桶排序 5.字符串匹配算法(1)单模式串匹配（在一个主串中查找一个模式串）①BF（Brute Force）算法暴力匹配/朴素匹配算法。 思路：把主串的长度记作 n，模式串的长度记作 m。在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。 时间复杂度：最坏情况时间复杂度是 O(n*m)。 适用场景:适合主串和模式串都不太长的情况。在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。 ②RK算法RK 算法是借助哈希算法对 BF 算法进行改造。 思路：对主串中每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。 时间复杂度：O(n)。极端情况下，如果哈希算法存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。 适用场景：字符集范围不要太大且模式串不要太长， 否则hash值可能冲突。但设计一个良好的哈希算法会比较困难。 ③BM算法借助“坏字符规则”和“好后缀规则”，在每一轮比较时，让模式串尽可能多移动几位，减少无谓的比较。 a.坏字符规则从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候。把这个没有匹配的字符叫作坏字符（主串中的字符）。 ps：坏字符的位置越靠右，下一轮模式串的挪动跨度就可能越长，节省的比较次数也就越多。这就是BM算法从右向左检测的好处。 把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作xi。如果不存在， xi 记作 -1。模式串往后移动的位数就等于 si-xi。如果坏字符在模式串里多处出现，选择最靠后的那个作为xi 。 时间复杂度：利用坏字符规则，BM 算法**最好时间复杂度是 O(n/m)**。【 n是主串长度，m是模式串长度 】 单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。 b.好后缀规则 遇到无法匹配的坏字符后，看好后缀在模式串中，是否有另一个匹配的子串。如果有，则按如下滑动： 如果没有则从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的。 时间复杂度：好后缀预处理最坏时间复杂度**O(m * m)，匹配O(n)**【m是模式串长度，n是主串长度】 如何运用坏字符和好后缀规则？分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法可以避免根据坏字符规则计算得到的往后滑动的位数有可能是负数的情况。 好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，可以只用好后缀规则来实现 BM 算法，但算法效率就会下降一些。 适用场景：坏字符规则需要占用较多的空间，适合字符集不是很大的情况。 坏字符和好后缀都需要对模式串进行预处理，所以模式串最好不要太长。 ④KMP算法KMP算法与BM算法类似，也是让模式串尽可能多移动几位，减少无谓的比较，KMP算法重点放在已匹配前缀上。 思路：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，在好前缀的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，就把 j 更新为 k，i 不变，然后继续比较。 时间复杂度：**O(m+n)（其中构建next数组是O(m)，借助next数组匹配是O(n)**）【m是模式串长度，n是主串长度】。 可结合小灰大牛这篇来食用： 漫画：什么是KMP算法？ (2)多模式串匹配（在一个主串中查找多个模式串）①Trie 树Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。 其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。 时间复杂度：构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 **O(n)**【n 表示所有字符串的长度和 】。 构建好 Trie 树后，在其中查找字符串的时间复杂度是 **O(k)**【k 表示要查找的字符串的长度】。 空间复杂度：空间复杂度取决于子节点存储大小。Trie 树有可能很浪费内存，为了解决内存问题，可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。比如有序数组、跳表、散列表、红黑树等。 适用场景:精确匹配查找更适合用散列表或者红黑树来解决，Trie 树比较适合的是查找前缀匹配的字符串，适合多模式串公共前缀较多的匹配，如实现搜索关键词的提示功能。 ②AC 自动机AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上。 时间复杂度：构建Trie 树的时间复杂度是 **O(m * len)**【 len 表示敏感词的平均长度，m 表示敏感词的个数】。 失败指针的构建过程就是 **O(k * len)【 k是 Trie 树中总的节点个数】。 AC 自动机做匹配的时间复杂度O(n * len)，因为敏感词并不会很长，实际情况下，可能近似于 O(n)**。【n是主串长度】 适用场景:适合大量文本中多模式串的精确匹配查找，如敏感词过滤 6.二分查找(1)特点二分查找依赖的是顺序表结构，也就是数组，并且针对的是有序数据。时间复杂度为O(logN)。 (2)使用场景①二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中 ②数据量太小不适合，此时使用顺序查找就足够了。数据量太大也不适合，二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。 ③如果数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找。比如对于大字符串间的比较，可以尽量减少比较次数 7.其他算法思想(1)贪心算法贪心算法实际上是动态规划算法的一种特殊情况。针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。 适用场景：指导设计基础算法。比如Prim 和 Kruskal 最小生成树算法 、Dijkstra 单源最短路径算法、霍夫曼编码（Huffman Coding）（一种十分有效的编码方法，广泛用于数据压缩中）。 (2)分治算法分治算法（divide and conquer）的核心思想是分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。 分治算法一般都比较适合用递归来实现。 适用场景：用来指导编码，降低问题求解的时间复杂度（如归并排序求逆序对） 解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。 (3)回溯算法回溯相当于穷举搜索。穷举所有的解，找到满足期望的解。通过把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。 时间复杂度非常高，是指数级别的。 适用场景：用来解决广义的搜索问题：从一组可能的解中，选择出一个满足要求的解。（如八皇后、0-1背包问题、正则表达式匹配等） 时间复杂度高，只能用来解决小规模数据的问题。 适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。 (4)动态规划把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。 动态规划是一种空间换时间的算法思想。执行效率较回溯高，但是空间复杂度也高。 能解决的问题符合一个模型，三个特征的问题。 一个模型 多阶段决策最优解模型。解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。 三个特征 最优子结构：可以通过子问题的最优解，推导出问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。 无后效性：在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的；某阶段状态一旦确定，就不受之后阶段的决策影响。 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态 解题思路 状态转移表法：回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码 状态转移方程法：找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码 适用场景：用来求解最优问题，比如求最大值、最小值等等。","categories":[],"tags":[]},{"title":"","slug":"Algorithm/Start","date":"2021-07-20T05:09:30.506Z","updated":"2021-03-16T03:38:58.808Z","comments":true,"path":"2021/07/20/Algorithm/Start/","link":"","permalink":"https://alloceee.github.io/2021/07/20/Algorithm/Start/","excerpt":"","text":"难易程度： E - Easy M - Medium H - Hard 重点程度：1 ~ 10分 第一阶段 复杂度分析（M 10分） 数组、栈、队列（E 8分） 链表（M 9分） 递归（M 10分） 排序、二分查询（E 7分） 第二阶段 散列表（M 8分） 二叉树（M 9分） 堆和堆排序（M 8分） BF/RK字符串匹配算法（E 7分） Trie树（M 7分） 图的表示（E 8分） 深度广度优先搜索（H 8分） 第三阶段 四种算法思想（M 10分） 跳表（M 6分） 拓扑排序、Dijksta算法、A*算法（H 5分） B+树（M 5分） 位图（E 6分） 第四阶段 BM、KMP、AC自动机（H 3分） 红黑树（H 3分） 哈希算法（E 3分） 高级篇、实战篇 01|为什么要学习数据结构和算法? 02|如何抓住重点，系统高效地学习数据结构与算法? 03|复杂度分析(上):如何分析、统计算法的执行效率和资源消耗? 04|复杂度分析(下):浅析最好、最坏、平均、均摊时间复杂度 回到顶部(go to top) 基础篇(38讲)05|数组:为什么很多编程语言中数组都从0开始编号? 06|链表(上) :如何实现LRU缓存淘汰算法? 07|链表(下) :如何轻松写出正确的链表代码? 08|栈:如何实现浏览器的前进和后退功能? 09|队列:队列在线程池等有限资源池中的应用 10|递归:如何用三行代码找到“最终推荐人”? 11|排序(上):为什么插入排序比冒泡排序更受欢迎? 12|排序(下):如何用快排思想在O(n)内查找第K大元素? 13|线性排序:如何根据年龄给100万用户数据排序? 14|排序优化:如何实现一个通用的、高性能的排序函数? 15|二分查找(上) :如何用最省内存的方式实现快速查找功能? 16|二分查找(下) :如何快速定位IP对应的省份地址? 17|跳表:为什么Redis一定要用跳表来实现有序集合? 18|散列表(上) : Word文档中的单词拼写检查功能是如何实现的? 19|散列表(中):如何打造一个工业级水平的散列表? 20|散列表(下):为什么散列表和链表经常会一起使用? 21|哈希算法(上):如何防止数据库中的用户信息被脱库? 22|哈希算法(下):哈希算法在分布式，系统中有哪些应用? 23|二叉树基础(上) :什么样的二叉树适合用数组来存储? 24|二叉树基础(下) :有了如此高效的散列表，为什么还需要二叉树? 25|红黑树(上) :为什么工程中都用红黑树这种二叉树? 26|红黑树(下) :掌握这些技巧，你也可以实现-个红黑树 27|递归树:如何借助树来求解递归算法的时间复杂度? 28|堆和堆排序:为什么说 堆排序没有快速排序快? 29|堆的应用:如何快速获取到Top 10最热门门]的搜索关键词? 30|图的表示:如何存储微博、微信等社交网络中的好友关系? 31|深度和广度优先搜索:如何找出社交网络中的三度好友关系? 32|字符串匹配基础(上) :如何借助哈希算法实现高效字符串匹配? 33|字符串匹配基础(中) :如何实现文本编辑器中的查找功能? 34|字符串匹配基础(下) :如何借助BM算法轻松理解KMP算法? 35|Trie树: 如何实现搜索引擎的搜索关键词提示功能? 36|AC自动机:如何用多模式串匹配实现敏感词过滤功能? 37|贪心算法:如何用贪心算法实现Huffman压缩编码? 38|分治算法:谈一谈大规模计算框架MapReduce中的分治思想 39|回溯算法:从电影《蝴蝶效应》中学习回溯算法的核心思想. 40|初识动态规划:如何巧妙解决“双十一”购物时的凑单问题? 41|动态规划理论:一篇文章带你彻底搞懂:最优子结构、无后效性和重复子问题 42|动态规划实战:如何实现搜索引擎中的拼写纠错功能? 回到顶部(go to top) 高级篇(9讲)43|拓扑排序:如何确定代码源文件的编译依赖关系? 44|最短路径:地图软件是如何计算出最优出行路径的? 45|位图:如何实现网页爬虫中的URL去重功能? 46|概率统计:如何利用朴素贝叶斯算法过滤垃圾短信? 47|向量空间:如何实现一个简单的音乐推荐系统? 48| B+树: MySQL数据库索引是如何实现的? 49|搜索:如何用A*搜索算法实现游戏中的寻路功能? 50|索引: 如何在海量数据中快速查找某个数据? 51|并行算法:如何利用并行处理提高算法的执行效率? 回到顶部(go to top) 实战篇(5讲)52|算法实战(一) :剖析Redis常用数据类型对应的数据结构 53|算法实战(二) :剖析搜索引擎背后的经典数据结构和算法 54|算法实战(三) :剖析高性能队列Disruptor背后的数据结构和算法 55|算法实战(四):剖析微服务接口鉴权限流背后的数据结构和算法 56|算法实战(五) :如何用学过的数据结构和算法实现一个短网址系统?","categories":[],"tags":[]},{"title":"","slug":"Algorithm/leetcode","date":"2021-07-20T05:09:30.504Z","updated":"2020-07-28T08:56:54.000Z","comments":true,"path":"2021/07/20/Algorithm/leetcode/","link":"","permalink":"https://alloceee.github.io/2021/07/20/Algorithm/leetcode/","excerpt":"","text":"给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。示例 2： 输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。示例 3： 输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 方法二：动态规划 时间复杂度O(n)动态求和公式：temp[i] = temp[i-1] + nums[i]; 12345678910class Solution &#123; public int[] runningSum(int[] nums) &#123; int temp[] = new int[nums.length]; temp[0] = nums[0]; for(int i = 1;i &lt; nums.length ;i++)&#123; temp[i] = temp[i-1] + nums[i]; &#125; return temp; &#125; &#125; 1512. 好数对的数目给你一个整数数组 nums 。 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。 返回好数对的数目。 示例 1： 输入：nums = [1,2,3,1,1,3]输出：4解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始示例 2： 输入：nums = [1,1,1,1]输出：6解释：数组中的每组数字都是好数对示例 3： 输入：nums = [1,2,3]输出：0 方法一：暴力解法，时间复杂度：O(n^2) 12345678910111213class Solution &#123; public int numIdenticalPairs(int[] nums) &#123; int number = 0; for(int i=0;i&lt;=nums.length-2;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i] == nums[j] &amp;&amp; i &lt; j)&#123; number++; &#125; &#125; &#125; return number; &#125; &#125; 方法二：时间复杂度为O(n)好数对满足2个条件： nums[i] == nums[j] i &lt; j假如输入[1,1,1,1]我们从前往后遍历的时候，好数对的数量为：3：[0,1],[0,2],[0,3]2:[1,2],[1,3]1:[2,3]这里我们举的例子是[1,1,1,1]，如果我们的例子是[2,1,1,1,1,4]结果也是一样的所以当我们从前往后遍历的时候，我们把数值存放在temp数组中，实际上计算的结果顺序是从后往前的，即1 + 2 + 3 = 6；这个结果其实跟我们正常理解的3 + 2 + 1 = 6的结果是一致的 12345678910111213class Solution &#123; public int numIdenticalPairs(int[] nums) &#123; int[] temp = new int[101]; int ans = 0; for(int num : nums)&#123; //temp[num]存放的就是满足条件1的数目 temp[num]++; //temp[num]-1理解为：满足条件1的好数对的数目。只不过这里的求值过程为倒序的 ans+=temp[num]-1; &#125; return ans; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numIdenticalPairs(int[] nums) &#123; int ans = 0; //因为 1&lt;= nums[i] &lt;= 100 所以申请大小为100的数组 //temp用来记录num的个数 int[] temp = new int[100]; /* 从前面开始遍历nums 假设nums = [1,1,1,1] 第一遍 temp是[0,0,0,0] ans+=0; temp[0]++; 第二遍 temp是[1,0,0,0] ans+=1; temp[0]++; 第三遍 temp=[2,0,0,0] ans+=2; temp[0]++; 第四遍 temp=[3,0,0,0] ans+=3; temp[0]++; */ for (int num : nums) &#123; /* 这行代码可以写成 ans+=temp[num - 1]; temp[num - 1]++; */ ans += temp[num - 1]++; &#125; return ans; &#125;&#125; 1431. 拥有最多糖果的孩子给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3输出：[true,true,true,false,true]解释：孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1输出：[true,false,false,false,false]解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。示例 3： 输入：candies = [12,1,12], extraCandies = 10输出：[true,false,true] 12345678910111213class Solution &#123; public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) &#123; int max = 0; List&lt;Boolean&gt; result = new ArrayList&lt;&gt;(); for(int candy : candies)&#123; max = Math.max(candy,max); &#125; for(int candy : candies)&#123; result.add(( candy + extraCandies ) &gt;= max); &#125; return result; &#125;&#125; 1470. 重新排列数组给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3输出：[2,3,5,4,1,7]解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4输出：[1,4,2,3,3,2,4,1]示例 3： 输入：nums = [1,1,2,2], n = 2输出：[1,2,1,2] 1234567891011class Solution &#123; public int[] shuffle(int[] nums, int n) &#123; int[] result = new int[nums.length]; for(int i=0;i&lt;nums.length;i+=2)&#123; result[i] = nums[i/2]; result[i+1] = nums[n]; n++; &#125; return result; &#125;&#125; 1486. 数组异或操作给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 “^” 为按位异或 XOR 运算符。示例 2： 输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.示例 3： 输入：n = 1, start = 7输出：7示例 4： 输入：n = 10, start = 5输出：2 暴力法123456789class Solution &#123; public int xorOperation(int n, int start) &#123; int result = start; for(int i=1;i &lt; n; i++)&#123; result ^= start + 2*i; &#125; return result; &#125;&#125; 复杂度分析: 时间复杂度：O(n)， n是数组的长度 空间复杂度：O(1) 位运算（利用 XOR 的特性）XOR 有很多有用的特性： x \\oplus x = 0x⊕x=00 \\oplus x = x0⊕x=x2x \\oplus (2x+1) = 12x⊕(2x+1)=1我们来看看题目的要求：start \\oplus start + 2 \\oplus start + 4 … \\oplus start + 2n-2start⊕start+2⊕start+4…⊕start+2n−2 你会发现题目的要求和上面我们列举的特性 3 很像，只是异或元素每次都是递增 2。 因此，我们可以对题目进行一次处理，也就是对所有异或元素右移一位，得到 start/2 \\oplus start/2 + 1 \\oplus start/2 + 2 … \\oplus start/2 + n-1start/2⊕start/2+1⊕start/2+2…⊕start/2+n−1 相当于我们将最终结果向右移动了一位，那么最后一位是什么呢？我们会发现最后一位是由 startstart 和 数组长度 nn 决定的。这是由于 2,4,…2,4,… 这些转换成二进制后最后一位都是 0。 因此如果 start 是偶数，那么最后一位肯定是 0.如果 start 是奇数，但是 nn 是偶数，这里我们使用特性 1，得到最后一位也是 0.其他情况下，最后一位是 1.那么 start/2 \\oplus start/2 + 1 \\oplus start/2 + 2 … \\oplus start/2 + n-1start/2⊕start/2+1⊕start/2+2…⊕start/2+n−1 该怎么计算呢？我们可以按照特性 3 来补全： 如果 start/2start/2 是偶数，我们只需要看 nn 是否是偶数即可：如果 nn 是偶数，该公式结果就是 n/2n/2 个 1 进行异或。也就是 (n/2) &amp; 1(n/2)&amp;1如果 nn 是奇数，该公式结果就是 ((n/2) &amp; 1) \\oplus (start/2+n-1)((n/2)&amp;1)⊕(start/2+n−1)如果 start/2start/2 是奇数，那么我们可以在前面补充 (start/2-1) \\oplus (start/2-1)(start/2−1)⊕(start/2−1)，就回到了情况 1. 12345678910111213141516171819202122232425/** * @param &#123;number&#125; n * @param &#123;number&#125; start * @return &#123;number&#125; */ var xorOperation = function(n, start) &#123; let ans = 2 * xor(n, Math.floor(start/2)); if(n &amp; start &amp; 1) ans++; // 处理最后一位 return ans; function xor(n, start) &#123; // 将公式转换成情况 1 if(start &amp; 1) return (start-1) ^ helper(n+1, start-1); else return helper(n, start); &#125; function helper(n, start) &#123; // 情况 1 if(n % 2 === 0) return Math.floor(n/2) &amp; 1; else return Math.floor(n/2) &amp; 1 ^ (start+n-1); &#125; &#125;; 复杂度分析: 时间复杂度：O(1)， n是数组的长度 空间复杂度：O(1) 剑指 Offer 58 - II. 左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例 1： 输入: s = “abcdefg”, k = 2输出: “cdefgab” 12345678910class Solution &#123; public String reverseLeftWords(String s, int n) &#123; StringBuilder res = new StringBuilder(); for(int i = n; i &lt; s.length(); i++) res.append(s.charAt(i)); for(int i = 0; i &lt; n; i++) res.append(s.charAt(i)); return res.toString(); &#125;&#125; 若面试规定不允许使用 切片函数 ，则使用此方法。 算法流程：新建一个 list(Python)、StringBuilder(Java) ，记为 resres ；先向 resres 添加 “第 n + 1n+1 位至末位的字符” ；再向 resres 添加 “首位至第 nn 位的字符” ；将 resres 转化为字符串并返回。复杂度分析：时间复杂度 O(N)O(N) ： 线性遍历 ss 并添加，使用线性时间；空间复杂度 O(N)O(N) ： 新建的辅助 resres 使用 O(N)O(N) 大小的额外空间。 方法三：字符串遍历拼接若规定 Python 不能使用 join() 函数，或规定 Java 只能用 String ，则使用此方法。 此方法与 方法二 思路一致，区别是使用字符串代替列表。 复杂度分析：时间复杂度 O(N)O(N) ： 线性遍历 ss 并添加，使用线性时间；空间复杂度 O(N)O(N) ： 假设循环过程中内存会被及时回收，内存中至少同时存在长度为 NN 和 N-1N−1 的两个字符串（新建长度为 NN 的 resres 需要使用前一个长度 N-1N−1 的 resres ），因此至少使用 O(N)O(N) 的额外空间。 12345678910class Solution &#123; public String reverseLeftWords(String s, int n) &#123; String res = &quot;&quot;; for(int i = n; i &lt; s.length(); i++) res += s.charAt(i); for(int i = 0; i &lt; n; i++) res += s.charAt(i); return res; &#125;&#125; 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if((nums[i]+nums[j])==target)&#123; res[0] = i; res[1] = j; return res; &#125; &#125; &#125; return res; &#125;&#125; 线性表的两种存储结构各有哪些优缺点123线性表具有两种存储结构即顺序存储结构和链接存储结构。线性表的顺序存储结构可以直接存取数据元素，方便灵活、效率高，但插入、删除操作时将会引起元素的大量移动，因而降低效率而在链接存储结构中内存采用动态分配，利用率高，但需增设指示结点之间关系的指针域，存取数据元素不如顺序存储方便，但结点的插入、删除操作较简单。 1025. 除数博弈爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 题目解析对于这种博弈类的题目，如果没有思路的话我们不妨多举几个例子，尝试着从中找寻规律。 假设 N = 1，爱丽丝没得选择，直接失败，即 鲍勃获胜；假设 N = 2，爱丽丝有选择，她可以选择 x = 1，鲍勃面对的就是 N = 2 - 1 = 1，无法操作，爱丽丝获胜；假设 N = 3，爱丽丝只能选择 x = 1，因为选 x = 2 不满足 3 % 2 = 0，鲍勃面对的就是 N = 3 - 1 = 2，参考上面 N = 2 的情形，此时鲍勃为 N = 2 的先手，鲍勃获胜；假设 N = 4，爱丽丝可以选择 x = 1 来使鲍勃遇到 N = 3 的情况，爱丽丝获胜；貌似有个规律：N 为奇数时， 鲍勃获胜；N 为偶数时， 爱丽丝获胜。 是这样吗？ 是的。 事实上，无论 N 为多大，最终都是在 N = 2 这个临界点结束的。谁最后面对的是 N = 2 的情形，谁就能获胜（这句话不太理解的话，仔细看看 N = 2、N = 3 这两种情形）。 接下来，我们得知道一个数学小知识：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。 千万不要忽略 1 也是因子！ 爱丽丝是游戏开始时的先手。 当她面对的 N 为偶数时，她 一定可以 选到一个 N 的奇数因子 x（比如 1 ），将 N - x 这个奇数传给鲍勃；用 N - x 替换黑板上的数字 N ，鲍勃面对的就是奇数 N，只能选择 N 的奇数因子 x，奇数 - 奇数 = 偶数，此时传给爱丽丝的又是偶数。这样轮换下去爱丽丝会遇到 N = 2 的情形，然后获胜；当爱丽丝遇到的 N 是奇数时，只能传给鲍勃偶数或无法操作 (N = 1) ，无法获胜。 123public boolean divisorGame(int N) &#123; return N % 2 == 0; &#125; 461. 汉明距离两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 输入: x = 1, y = 4 输出: 2 解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 123456789 public int hammingDistance(int x, int y) &#123;int sum = 0; for(int i = 31;i &gt;= 0; i--)&#123; if((x &gt;&gt;&gt; i &amp; 1) != (y &gt;&gt;&gt; i &amp; 1))&#123; sum ++; &#125; &#125; return sum; &#125; 思路汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。 两个整数之间的汉明距离是对应位置上数字不同的位数。 根据以上定义，提出一种 XOR 的位运算，当且仅当输入位不同时输出为 1。 计算 x 和 y 之间的汉明距离，可以先计算 x XOR y，然后统计结果中等于 1 的位数。 现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。 方法一：内置位计数功能思路 大多数编程语言中，都存在各种内置计算等于 1 的位数函数。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。 但这是一个力扣问题，有人会认为使用内置函数就好像使用 使用 LinkedList 实现 LinkedList。对此，我们完全赞同。因此后面会有手工实现的位计数算法。 PythonJava 123class Solution: def hammingDistance(self, x: int, y: int) -&gt; int: return bin(x ^ y).count(&#x27;1&#x27;) 复杂度分析 时间复杂度：\\mathcal{O}(1)O(1)。 该算法有两个操作。计算 XOR 花费恒定时间。 调用内置的 bitCount 函数。最坏情况下，该函数复杂度为 \\mathcal{O}(k)O(k)，其中 kk 是整数的位数。在 Python 和 Java 中 Integer 是固定长度的。因此该算法复杂度恒定，与输入大小无关。 空间复杂度：\\mathcal{O}(1)O(1)，使用恒定大小的空间保存 XOR 的结果。 假设内置函数也使用恒定空间。方法二：移位思路 为了计算等于 1 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 1。 更准确的说，应该进行逻辑移位，移入零替换丢弃的位。 这里采用右移位，每个位置都会被移动到最右边。移位后检查最右位的位是否为 1 即可。检查最右位是否为 1，可以使用取模运算（i % 2）或者 AND 操作（i &amp; 1），这两个操作都会屏蔽最右位以外的其他位。 PythonJava 123456789101112131415class Solution(object): def hammingDistance(self, x, y): &quot;&quot;&quot; :type x: int :type y: int :rtype: int &quot;&quot;&quot; xor = x ^ y distance = 0 while xor: # mask out the rest bits if xor &amp; 1: distance += 1 xor = xor &gt;&gt; 1 return distance 复杂度分析 时间复杂度：\\mathcal{O}(1)O(1)，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。 空间复杂度：\\mathcal{O}(1)O(1)，使用恒定大小的空间。 方法三：布赖恩·克尼根算法思路 方法二是逐位移动，逐位比较边缘位置是否为 1。寻找一种更快的方法找出等于 1 的位数。 是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：10001000。 上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。 这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。 当我们在 number 和 number-1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。 基于以上思路，通过 2 次迭代就可以知道 10001000 中 1 的位数，而不需要 8 次。 PythonJava 123456789class Solution: def hammingDistance(self, x, y): xor = x ^ y distance = 0 while xor: distance += 1 # remove the rightmost bit of &#x27;1&#x27; xor = xor &amp; (xor - 1) return distance 注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 Brian W. Kernighan 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。 复杂度分析 时间复杂度：\\mathcal{O}(1)O(1)。 与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。 但是该方法需要的迭代操作更少。 空间复杂度：\\mathcal{O}(1)O(1)，与输入无关，使用恒定大小的空间。 方法一：二分查找思路与算法 假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在 O(\\log n)O(logn) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。 考虑这个插入的位置 \\textit{pos}pos，它成立的条件为： \\textit{nums}[pos-1]&lt;\\textit{target}\\le \\textit{nums}[pos]nums[pos−1]&lt;target≤nums[pos] 其中 \\textit{nums}nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 \\textit{pos}pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 \\textit{target}target 的下标」。 问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 \\textit{target}target 的下标 。下文给出的代码是笔者习惯的二分写法，\\textit{ans}ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是 \\textit{target}target 大于数组中的所有数，此时需要插入到数组长度的位置。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/ 12345678910111213141516class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int n = nums.length; int left = 0, right = n - 1, ans = n; while (left &lt;= right) &#123; int mid = ((right - left) &gt;&gt; 1) + left; if (target &lt;= nums[mid]) &#123; ans = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return ans; &#125;&#125; 复杂度分析 时间复杂度：O(\\log n)O(logn)，其中 nn 为数组的长度。二分查找所需的时间复杂度为 O(\\log n)O(logn)。 空间复杂度：O(1)O(1)。我们只需要常数空间存放若干变量。 42. 接雨水难度困难1491收藏分享切换为英文关注反馈 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 123public int trap(int[] height) &#123; &#125; 104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125;else&#123; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left,right)+1; &#125; &#125;&#125; 9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 方法一：反转一半数字思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 \\text{int.MAX}int.MAX，我们将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。 算法 首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。 现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。 现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？ 由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。 1234567891011121314151617181920212223class Solution &#123; public boolean isPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; &#125;&#125; 复杂度分析 时间复杂度：O(\\log n)O(logn)，对于每次迭代，我们会将输入除以 1010，因此时间复杂度为 O(\\log n)O(logn)。空间复杂度：O(1)O(1)。我们只需要常数空间存放若干变量。 解法二：进阶解法—数学解法通过取整和取余操作获取整数中对应的数字进行比较。 举个例子：1221 这个数字。 通过计算 1221 / 1000， 得首位1通过计算 1221 % 10， 可得末位 1进行比较再将 22 取出来继续比较 123456789101112131415161718class Solution &#123; public boolean isPalindrome(int x) &#123; //边界判断 if (x &lt; 0) return false; int div = 1; // while (x / div &gt;= 10) div *= 10; while (x &gt; 0) &#123; int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; &#125; return true; &#125;&#125; 解法三：进阶解法—巧妙解法直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。 所以这个解法的操作就是 取出后半段数字进行翻转。 这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。 具体做法如下： 每次进行取余操作 （ %10），取出最低的数字：y = x % 10将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y每取一个最低位数字，x 都要自除以 10判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。 123456789101112class Solution &#123; public boolean isPalindrome(int x) &#123; //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;","categories":[],"tags":[]},{"title":"谈谈MYSQL索引是如何提高查询效率的","slug":"MySQL数据库/谈谈MYSQL索引是如何提高查询效率的","date":"2021-05-30T13:43:36.000Z","updated":"2021-08-04T03:17:18.501Z","comments":true,"path":"2021/05/30/MySQL数据库/谈谈MYSQL索引是如何提高查询效率的/","link":"","permalink":"https://alloceee.github.io/2021/05/30/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B0%88%E8%B0%88MYSQL%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言我们都知道当查询数据库变慢时，需要建索引去优化。但是只知道索引能优化显然是不够的，我们更应该知道索引的原理，因为不是加了索引就一定会提升性能。那么接下来就一起探索MYSQL索引的原理吧。 什么是索引索引其实是一种能高效帮助MYSQL获取数据的数据结构，通常保存在磁盘文件中，好比一本书的目录，能加快数据库的查询速度。除此之外，索引是有序的，所以也能提高数据的排序效率。 通常MYSQL的索引包括聚簇索引，覆盖索引，复合索引，唯一索引，普通索引，通常底层是B+树的数据结构。 总结一下，索引的优势在于： 提高查询效率。 降低数据排序的成本。 缺点在于： 索引会占用磁盘空间。 索引会降低更新表的效率。因为在更新数据时，要额外维护索引文件。 索引的类型 聚簇索引 索引列的值必须是唯一的，并且不能为空，一个表只能有一个聚簇索引。 唯一索引 索引列的值是唯一的，值可以为空。 普通索引 没有什么限制，允许在定义索引的列中插入重复值和空值。 复合索引 也叫组合索引，用户可以在多个列上组合建立索引，遵循“最左匹配原则”，在条件允许的情况下使用复合索引可以替代多个单列索引的使用。 索引的数据结构我们都知道索引的底层数据结构采用的是B+树，但是在讲B+树之前，要先知道B树，因为B+树是在B树上面进行改进优化的。 首先讲一下B树的特点： B树的每个节点都存储了多个元素，每个内节点都有多个分支。 节点中元素包含键值和数据，节点中的键值从小到大排序。 父节点的数据不会出现在子节点中。 所有的叶子节点都在同一层，叶节点具有相同的深度。 在上面的B树中，假如我们要找值等于18的数据，查找路径就是磁盘块1-&gt;磁盘块3-&gt;磁盘块8。 过程如下： 第一次磁盘IO：首先加载磁盘块1到内存中，在内存中遍历比较，因为17&lt;18&lt;50，所以走中间P2，定位到磁盘块3。 第二次磁盘IO：加载磁盘块3到内存，依然是遍历比较，18&lt;25，所以走左边P1，定位到磁盘块8。 第三次磁盘IO：加载磁盘块8到内存，在内存中遍历，18=18，找到18，取出data。 如图所示： 如果data存储的是行数据，直接返回，如果存的是磁盘地址则根据磁盘地址到磁盘中取出数据。可以看出B树的查询效率是很高的。 B树存在着什么问题，需要改进优化呢？ 第一个问题：B树在范围查询时，性能并不理想。假如要查询13到30之间的数据，查询到13后又要回到根节点再去查询后面的数据，就会产生多次的查询遍历。 第二个问题：因为非叶子节点和叶子节点都会存储数据，所以占用的空间大，一个页可存储的数据量就会变少，树的高度就会变高，磁盘的IO次数就会变多。 基于以上两个问题，就出现了B树的升级版，B+树。 B+树与B树最大的区别在于两点： B+树只有叶子节点存储数据，非叶子节点只存储键值。而B树的非叶子节点和叶子节点都会存储数据。 B+树的最底层的叶子节点会形成一个双向有序链表，而B树不会。 如图所示： B+树的等值查询过程是怎么样的？ 如果在B+树中进行等值查询，比如查询等于13的数据。 查询路径为：磁盘块1-&gt;磁盘块2-&gt;磁盘块6。 第一次IO：加载磁盘块1，在内存中遍历比较，13&lt;17，走左边，找到磁盘块2。 第二次IO：加载磁盘块2，在内存中遍历比较，10&lt;13&lt;15，走中间，找到磁盘块6。 第三次IO：加载磁盘块6，依次遍历，找到13=13，取出data。 所以B+树在等值查询的效率是很高的。 B+树的范围查询过程又是怎么样呢？ 比如我们要进行范围查询，查询大于5并且小于15的数据。 查询路径为：磁盘块1-&gt;磁盘块2-&gt;磁盘块5-&gt;磁盘块6。 第一次IO：加载磁盘块1，比较得出5&lt;17，然后走左边，找到磁盘块2。 第二次IO：加载磁盘块2，比较5&lt;10，然后还是走左边，找到磁盘块5。 第三次IO：加载磁盘块5，然后找大于5的数据。 第四次IO：由于最底层是有序的双向链表，所以继续往右遍历即可，直到不符合小于15的数据为止。 过程如图所示： 所以在范围查询的时候，是不需要像B树一样，再回到根节点，这就是底层采用双向链表的好处。 所以B+树的优势在于，能保证等值查询和范围查询的快速查找。 InnoDB索引我们常用的MySQL存储引擎一般是InnoDB，所以接下来讲讲几种不同的索引的底层数据结构，以及查找过程。 聚簇索引前面讲过，每个InnoDB表有且仅有一个聚簇索引。除此之外，聚簇索引在表的创建有以下几点规则： 在表中，如果定义了主键，InnoDB会将主键索引作为聚簇索引。 如果没有定义主键，则会选择第一个不为NULL的唯一索引列作为聚簇索引。 如果以上两个都没有。InnoDB 会使用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增。 除了聚簇索引之外的索引都称为非聚簇索引，区别在于，聚簇索引的叶子节点存储的数据是整行数据，而非聚簇索引存储的是该行的主键值。 比如有一张user表，如图所示： 底层的数据结构就像这样： 当我们用主键值去查询的时候，查询效率是很快的，因为可以直接返回数据。 普通索引也就是用得最多的一种索引，比如我要为user表的age列创建索引，SQL语句可以这样写： 1CREATE INDEX INDEX_USER_AGE ON `user`(age); 普通索引属于非聚簇索引，所以叶子节点存储的是主键值，底层的数据结构大概长这个样子： 比如要查询age=33的数据，那么首先查到磁盘块7的age=33的数据，获取到主键值，主键值为4。 接着再通过主键值等于4，查询到该行的数据。所以总得来说，底层会进行两次查询。 这种先通过查询主键值，再通过主键值查询到数据的过程就叫做回表查询。 覆盖索引既然上面提到了回表查询，那么自然而然会想到，有没有什么办法能避免回表查询呢？答案肯定是有的，那就是使用覆盖索引。 覆盖索引不是一种索引的类型，而是一种使用索引的方式。假设你需要查询的列是建立了索引，查询的结果在索引列上就能获取，那就可以用覆盖索引。 比如上面的例子，我们通过age=33查询，我需要查询的结果就只要age这一列，那就可以用到覆盖索引，如图所示： 使用到覆盖索引的话，就能避免回表查询，所以在写SQL语句时尽量不要写SELECT *。 总结这篇文章主要讲的是索引的类型，索引的数据结构，以及InnoDB表中常用的几种索引。当然，除了上述讲的这些之外，还有很多关于索引的知识，比如索引失效的场景，索引创建的原则等等，由于篇幅过长，留着以后再讲。 那么这篇文章就写到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"}]},{"title":"什么是雪花ID？","slug":"MySQL数据库/什么是雪花ID？","date":"2021-05-30T13:32:44.000Z","updated":"2021-08-04T03:17:18.495Z","comments":true,"path":"2021/05/30/MySQL数据库/什么是雪花ID？/","link":"","permalink":"https://alloceee.github.io/2021/05/30/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%AA%E8%8A%B1ID%EF%BC%9F/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 为什么使用雪花ID在以前的项目中，最常见的两种主键类型是自增Id和UUID，在比较这两种ID之前首先要搞明白一个问题，就是为什么主键有序比无序查询效率要快，因为自增Id和UUID之间最大的不同点就在于有序性。 我们都知道，当我们定义了主键时，数据库会选择表的主键作为聚集索引(B+Tree)，mysql 在底层是以数据页为单位来存储数据的。 也就是说如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。如果主键是UUID，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的。 一句话总结就是，InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。 但是为什么很多情况又不用自增id作为主键呢？ 容易导致主键重复。比如导入旧数据时，线上又有新的数据新增，这时就有可能在导入时发生主键重复的异常。为了避免导入数据时出现主键重复的情况，要选择在应用停业后导入旧数据，导入完成后再启动应用。显然这样会造成不必要的麻烦。而UUID作为主键就不用担心这种情况。 不利于数据库的扩展。当采用自增id时，分库分表也会有主键重复的问题。UUID则不用担心这种问题。 那么问题就来了，自增id会担心主键重复，UUID不能保证有序性，有没有一种ID既是有序的，又是唯一的呢？ 当然有，就是雪花ID。 什么是雪花IDsnowflake是Twitter开源的分布式ID生成算法，结果是64bit的Long类型的ID，有着全局唯一和有序递增的特点。 最高位是符号位，因为生成的 ID 总是正数，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增ID，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 缺点也是有的，就是强依赖机器时钟，如果机器上时钟回拨，有可能会导致主键重复的问题。 Java实现雪花ID下面是用Java实现雪花ID的代码，供大家参考一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class SnowflakeIdWorker &#123; /** * 开始时间：2020-01-01 00:00:00 */ private final long beginTs = 1577808000000L; private final long workerIdBits = 10; /** * 2^10 - 1 = 1023 */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); private final long sequenceBits = 12; /** * 2^12 - 1 = 4095 */ private final long maxSequence = -1L ^ (-1L &lt;&lt; sequenceBits); /** * 时间戳左移22位 */ private final long timestampLeftOffset = workerIdBits + sequenceBits; /** * 业务ID左移12位 */ private final long workerIdLeftOffset = sequenceBits; /** * 合并了机器ID和数据标示ID，统称业务ID，10位 */ private long workerId; /** * 毫秒内序列，12位，2^12 = 4096个数字 */ private long sequence = 0L; /** * 上一次生成的ID的时间戳，同一个worker中 */ private long lastTimestamp = -1L; public SnowflakeIdWorker(long workerId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(&quot;WorkerId必须大于或等于0且小于或等于%d&quot;, maxWorkerId)); &#125; this.workerId = workerId; &#125; public synchronized long nextId() &#123; long ts = System.currentTimeMillis(); if (ts &lt; lastTimestamp) &#123; throw new RuntimeException(String.format(&quot;系统时钟回退了%d毫秒&quot;, (lastTimestamp - ts))); &#125; // 同一时间内，则计算序列号 if (ts == lastTimestamp) &#123; // 序列号溢出 if (++sequence &gt; maxSequence) &#123; ts = tilNextMillis(lastTimestamp); sequence = 0L; &#125; &#125; else &#123; // 时间戳改变，重置序列号 sequence = 0L; &#125; lastTimestamp = ts; // 0 - 00000000 00000000 00000000 00000000 00000000 0 - 00000000 00 - 00000000 0000 // 左移后，低位补0，进行按位或运算相当于二进制拼接 // 本来高位还有个0&lt;&lt;63，0与任何数字按位或都是本身，所以写不写效果一样 return (ts - beginTs) &lt;&lt; timestampLeftOffset | workerId &lt;&lt; workerIdLeftOffset | sequence; &#125; /** * 阻塞到下一个毫秒 * * @param lastTimestamp * @return */ private long tilNextMillis(long lastTimestamp) &#123; long ts = System.currentTimeMillis(); while (ts &lt;= lastTimestamp) &#123; ts = System.currentTimeMillis(); &#125; return ts; &#125; public static void main(String[] args) &#123; SnowflakeIdWorker snowflakeIdWorker = new SnowflakeIdWorker(7); for (int i = 0; i &lt; 10; i++) &#123; long id = snowflakeIdWorker.nextId(); System.out.println(id); &#125; &#125;&#125; main方法，测试结果如下： 12345678910184309536616640512184309536616640513184309536616640514184309536616640515184309536616640516184309536616640517184309536616640518184309536616640519184309536616640520184309536616640521 总结在大部分公司的开发项目中里，雪花ID是主流的ID生成策略，除了自己实现之外，目前市场上也有很多开源的实现，比如： 美团开源的Leaf 百度开源的UidGenerator 有兴趣的可以自行观摩一下，那么这篇文章就写到这里了，感谢大家的阅读。 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"}]},{"title":"OOM怎么办，教你生成dump文件以及查看","slug":"JVM核心知识/OOM怎么办，教你生成dump文件以及查看","date":"2021-05-30T13:32:13.000Z","updated":"2021-08-04T03:17:18.467Z","comments":true,"path":"2021/05/30/JVM核心知识/OOM怎么办，教你生成dump文件以及查看/","link":"","permalink":"https://alloceee.github.io/2021/05/30/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/OOM%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E6%95%99%E4%BD%A0%E7%94%9F%E6%88%90dump%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%9F%A5%E7%9C%8B/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 前言在日常开发中，即使代码写得有多谨慎，免不了还是会发生各种意外的事件，比如服务器内存突然飙高，又或者发生内存溢出(OOM)。当发生这种情况时，我们怎么去排查，怎么去分析原因呢？ 这时就引出这篇文章要讲的dump文件，各位看官且往下看。 什么是dump文件dump文件是一个进程或者系统在某一个给定的时间的快照。 dump文件是用来给驱动程序编写人员调试驱动程序用的，这种文件必须用专用工具软件打开。 dump文件中包含了程序运行的模块信息、线程信息、堆栈调用信息、异常信息等数据。 在服务器运行我们的Java程序时，是无法跟踪代码的，所以当发生线上事故时，dump文件就成了一个很关键的分析点。 如何生成dump文件这里介绍两种方式，一种是主动的，一种是被动的。 方式一主动生成dump文件。首先要查找运行的Java程序的pid。 使用top命令： 然后使用jmap命令生成dump文件。file后面是保存的文件名称，1246则是java程序的PID。 1jmap -dump:format=b,file=user.dump 1246 方式二其实在很多时候我们是不知道何时会发生OOM，所以需要在发生OOM时自动生成dump文件。 其实很简单，只需要在启动时加上如下参数即可。HeapDumpPath表示生成dump文件保存的目录。 1-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\\tmp 我们还需要模拟出OOM错误，以此触发产生dump文件，首先写个接口： 123456789private static Map&lt;String, String&gt; map = new HashMap&lt;&gt;();@RequestMapping(&quot;/oom&quot;)public String oom() throws Exception &#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(&quot;key&quot; + i, &quot;value&quot; + i); &#125; return &quot;oom&quot;;&#125; 然后在启动时设置堆内存大小为32M。 1-Xms32M -Xmx32M 因为要后台启动，并且输出日志，所以最后启动命令就是这样： 1nohup java -jar -Xms32M -Xmx32M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local user-0.0.1-SNAPSHOT.jar &gt; log.file 2&gt;&amp;1 &amp; 然后请求oom的接口，查看日志，果然发生了OOM错误。 查看保存dump的目录，果然生成了对应的dump文件。 如何查看dump文件这里我介绍使用Jprofiler，有可视化界面，功能也比较完善，能够打开JVM工具(通过-XX:+HeapDumpOnOutOfMemoryError JVM参数触发)创建的hporf文件。 安装过程这里就省略了，网上谷歌，百度自行查找。我们把刚刚自动生成的java_pid1257.hprof用Jprofiler打开，看到是这个样子。 明显可以看出HashMap的Node对象，还有String对象的实例很多，占用内存也是最多的。这里还不够明显，我们看Biggest Objects。 这里就看出是UserController类的HashMap占用了大量的内存。所以造成OOM的原因不难看出，就是在UserController里的Map集合。 总结当然线上的代码量，类的数量，实例的数量都非常庞大，所以没有那么简单就能找出报错的原因，但是要用什么工具，怎么用至少要知道，那么当遇到问题时，才不会慌张。 我问过一些技术大佬，为什么技术大佬代码写得不是很多，但是工资却特别高。大佬说，那是因为当线上出现问题时，大佬能解决大家解决不了的问题，这种能力就体现出他个人的价值。 一句话讲完，业务代码大部分程序员都会写，而线上排错能力并不是大部分程序员都会排。 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://alloceee.github.io/tags/JVM/"}]},{"title":"CSS实现一个简单的三角形","slug":"大前端/07-HTML5和CSS3/绘制三角形—border法","date":"2021-05-14T16:00:00.000Z","updated":"2021-08-04T03:09:26.535Z","comments":true,"path":"2021/05/15/大前端/07-HTML5和CSS3/绘制三角形—border法/","link":"","permalink":"https://alloceee.github.io/2021/05/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/07-HTML5%E5%92%8CCSS3/%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/","excerpt":"","text":"普通三角形使用CSS盒模型中的border（边框）即可实现如下所示的三角形： CSS实现简单三角形 实现原理：首先来看在为元素添加border时，border的样子；假设有如下代码： 1234567&lt;div&gt;&lt;/div&gt;div &#123; width: 50px; height: 50px; border: 2px solid orange;&#125; 效果图： border的一般使用 这是我们平常使用border最普遍的情况——往往只给border一个较小的宽度（通常为1-2px）；然而这样的日常用法就会容易让大家对border的形成方式产生误解，即认为元素的border是由四个矩形边框拼接而成。 然而事实并不是这样。实际上，元素的border是由三角形组合而成，为了说明这个问题，我们可以增大border的宽度，并为各border边设置不同的颜色： 123456div &#123; width: 50px; height: 50px; border: 40px solid; border-color: orange blue red green;&#125; 效果图： border的形成方式 既然如此，那么更进一步，把元素的内容尺寸设置为0会发生什么情况呢？ 123456div &#123; width: 0; height: 0; border: 40px solid; border-color: orange blue red green;&#125; 效果图： 元素内容尺寸为0 我们将惊奇地发现，此时元素由上下左右4个三角形“拼接”而成；那么，为了实现最终的效果，即保留最下方的三角形，还应该怎么做？很简单，我们只需要把其它border边的颜色设置为白色或透明色： 123456div &#123; width: 0; height: 0; border: 40px solid; border-color: transparent transparent red;&#125; 最终效果 Duang~ 最终的简单三角形就绘制出来了。同理，如果想要得到其它边上的三角形，只需要将剩余的border边颜色设置为白色或透明色即可。 不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）： 1234567div &#123; width: 0; height: 0; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent red;&#125; 实现带边框的三角形带边框的三角形是指为三角形添加其它颜色的边框，如同为元素添加border一样： 带边框的三角形 由于不能继续通过为已有三角形设置border的方法来为其设置边框（因为三角形本身就是利用border实现的），所以只好另想办法。而能想到的一个最自然的方法就是三角形叠放，即把当前三角形叠放在更大的三角形上方，上图所示的实现方法就是把黄色三角形放在了尺寸更大的蓝色三角形上。 为了实现这样的效果，需要利用绝对定位方法： 首先定义出外面的蓝色三角形： 12345678910&lt;div id=&quot;blue&quot;&gt;&lt;div&gt;#blue &#123; position:relative; width: 0; height: 0; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent blue;&#125; 效果为： 外围蓝色三角形 随后需要定义黄色三角形，由于黄色三角形的定位需要参考蓝色三角形的位置，所以需要用到绝对定位方法。为此还需要将黄色三角形作为蓝色三角形的子元素。一个可行的办法是在蓝色三角形内部定义一个额外的标签以表示黄色三角形，但为了节约标签起见，更好的办法是使用伪元素: 1234567891011#blue:after &#123; content: &quot;&quot;; width: 0; height: 0; position: absolute; top: 0px; left: 0px; border-width: 0 40px 40px; border-style: solid; border-color: transparent transparent yellow;&#125; 得到的效果为： 定义黄色三角形 需要特别注意此时定义出的黄色三角形与蓝色三角形之间位置的偏移关系，该偏移将受到top、left（本例中）以及黄色三角形本身border宽度的共同影响。 可能会有这样的疑问：为什么黄色三角形会向左偏移一段距离呢，按道理不应该完全重合在蓝色三角形上吗，就像下面这样？ 黄色三角形与蓝色三角形完全重合 如果有这样的疑问，说明还没有对绝对定位产生足够的认识。绝对定位的区域是基于绝对定位父元素的padding区域，然后在此基础上运用top、left、right、bottom等一系列属性来约束绝对定位子元素的位置。在本例中，由于蓝色三角形作为绝对定位父元素，其内容的尺寸为0，则内容区域就是该三角形的上顶点： 绝对定位区域 对于黄色三角形，由于设置了left: 0和top: 0，所以黄色三角形的所有内容（包括border、margin）将根据蓝色三角形的上顶点进行定位。可以把此时left: 0和top: 0分别看作是两面“隔墙”——即上隔墙和左隔墙，黄色三角形的所有内容只能在上隔墙的下方和左隔墙的右方区域。 由于黄色三角形的内容区域也位于其顶点处，且对其设置了左右各40px的border，所以黄色三角形的内容区域将向右偏移40px，从而形成了之前的效果。 想想看将黄色三角形的位置设置为left: 0和bottom: 0,会得到怎样的定位效果？（下图所示） 黄色三角形设置为left: 0和bottom: 0 搞懂了绝对定位后，只需要在原代码上稍作修改就可以将黄色三角形的顶点与蓝色三角形顶点相重合，同时还应该适当缩小黄色三角形的尺寸（按相似三角形等比例缩小）： 123456789#blue:after &#123; content: &quot;&quot;; position: absolute; top: 0px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent yellow;&#125; 得到： 黄色三角形与蓝色三角形顶点重合 在上面的代码中，特意删除了之前对width: 0和height: 0的设置，因为子元素具有position:absolute设置，这会使得元素尺寸在不显式设置宽度和高度的情况下，收缩到元素内容的尺寸，由于内容设置的是content: &quot;&quot;，所以子元素的尺寸默认也就是0了。故设置width: 0和height: 0就变得多余了。 最后一步就是利用top将黄色三角形向下移动至合适的位置： 123456789#blue:after &#123; content: &quot;&quot;; position: absolute; top: 1px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent yellow;&#125; 得到最终效果： 最终效果 学会了带边框三角形的绘制，那么实现类似如下三角形箭头自然也是不在话下了： 三角形箭头 实现代码： 123456789#blue:after &#123; content: &quot;&quot;; position: absolute; top: 2px; left: -38px; border-width: 0 38px 38px; border-style: solid; border-color: transparent transparent #fff;&#125; 绘制其它角度的三角形绘制其它角度的三角形，如： 右直角三角 或者： 左直角三角 就更简单了，其实它们都是基于之前绘制的三角形而来的。如果想绘制右直角三角，则将左border设置为0；如果想绘制左直角三角，将右border设置为0即可（其它情况同理）。","categories":[{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"https://alloceee.github.io/categories/web/css/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://alloceee.github.io/tags/CSS/"}],"author":"Alloceee"},{"title":"超详细的Sentinel入门","slug":"分布式/超详细的Sentinel入门","date":"2021-04-05T06:42:55.000Z","updated":"2021-08-04T03:17:18.539Z","comments":true,"path":"2021/04/05/分布式/超详细的Sentinel入门/","link":"","permalink":"https://alloceee.github.io/2021/04/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84Sentinel%E5%85%A5%E9%97%A8/","excerpt":"","text":"文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、什么是SentinelSentinel定位是分布式系统的流量防卫兵。目前互联网应用基本上都使用微服务，微服务的稳定性是一个很重要的问题，而限流、熔断降级是微服务保持稳定的一个重要的手段。 下面看官网的一张图，了解一下Sentinel的主要特性： 在Sentinel之前其实就有Hystrix做熔断降级的事情，我们都知道出现新的事物肯定是原来的东西有不足的地方。 那Hystrix有什么不足之处呢？ Hystrix常用的线程池隔离会造成线程上下切换的overhead比较大。 Hystrix没有监控平台，需要我们自己搭建。 Hystrix支持的熔断降级维度较少，不够细粒，而且缺少管理控制台。 Sentinel有哪些组成部分？ 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。 Sentinel有哪些特征？ 丰富的应用场景。控制突发流量在可控制的范围内，消息削峰填谷，集群流量控制，实时熔断下游不可用的应用等等。 完备的实时监控。Sentinel 提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 广泛的开源生态。Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 完善的 SPI 扩展点。Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。 二、Hello World一般要学一种没接触过的技术框架，肯定要先做个Hello World熟悉一下。 引入Maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 需要提醒一下，Sentinel仅支持JDK 1.8或者以上的版本 定义规则 通过定义规则来控制该资源每秒允许通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。 12345678910private static void initFlowRules()&#123; List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); FlowRule rule = new FlowRule(); rule.setResource(&quot;HelloWorld&quot;); rule.setGrade(RuleConstant.FLOW_GRADE_QPS); // Set limit QPS to 20. rule.setCount(20); rules.add(rule); FlowRuleManager.loadRules(rules);&#125; 编写Hello World代码 其实代码编写很简单，首先需要定义一个资源entry，然后用SphU.entry(&quot;HelloWorld&quot;)和entry.exit()把需要流量控制的代码包围起来。代码如下： 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; initFlowRules(); while (true) &#123; Entry entry = null; try &#123; entry = SphU.entry(&quot;HelloWorld&quot;); /*您的业务逻辑 - 开始*/ System.out.println(&quot;hello world&quot;); /*您的业务逻辑 - 结束*/ &#125; catch (BlockException e1) &#123; /*流控逻辑处理 - 开始*/ System.out.println(&quot;block!&quot;); /*流控逻辑处理 - 结束*/ &#125; finally &#123; if (entry != null) &#123; entry.exit(); &#125; &#125; &#125;&#125; 运行结果如下： 我们根据目录查看日志，文件名格式为${appName}-metrics.log.xxx： 123|--timestamp-|------date time----|-resource-|p |block|s |e|rt1616607101000|2021-03-25 01:31:41|HelloWorld|20|11373|20|0|1|0|0|01616607102000|2021-03-25 01:31:42|HelloWorld|20|24236|20|0|0|0|0|0 p 代表通过的请求。 block 代表被阻止的请求。 s 代表成功执行完成的请求个数。 e 代表用户自定义的异常。 rt 代表平均响应时长。 三、使用Sentinel的方式下面结合实际案例，写一个Controller接口进行示范练习。 123456789101112131415161718192021222324@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/list&quot;) public List&lt;User&gt; getUserList() &#123; return userService.getList(); &#125;&#125;@Servicepublic class UserServiceImpl implements UserService &#123; //模拟查询数据库数据，返回结果 @Override public List&lt;User&gt; getList() &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;1&quot;, &quot;周慧敏&quot;, 18)); userList.add(new User(&quot;2&quot;, &quot;关之琳&quot;, 20)); userList.add(new User(&quot;3&quot;, &quot;王祖贤&quot;, 21)); return userList; &#125;&#125; 假设我们要让这个查询接口限流，怎么做呢？ 1) 抛出异常的方式SphU 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 BlockException。这个时候可以捕捉异常，进行限流之后的逻辑处理。 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //资源名称 public static final String RESOURCE_NAME = &quot;userList&quot;; @Resource private UserService userService; @RequestMapping(&quot;/list&quot;) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; userList = null; Entry entry = null; try &#123; // 被保护的业务逻辑 entry = SphU.entry(RESOURCE_NAME); userList = userService.getList(); &#125; catch (BlockException e) &#123; // 资源访问阻止，被限流或被降级 return Collections.singletonList(new User(&quot;xxx&quot;, &quot;资源访问被限流&quot;, 0)); &#125; catch (Exception e) &#123; // 若需要配置降级规则，需要通过这种方式记录业务异常 Tracer.traceEntry(e, entry); &#125; finally &#123; // 务必保证 exit，务必保证每个 entry 与 exit 配对 if (entry != null) &#123; entry.exit(); &#125; &#125; return userList; &#125;&#125; 实际上还没写完，还要定义限流的规则。 1234567891011121314151617181920@SpringBootApplicationpublic class SpringmvcApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SpringmvcApplication.class, args); //初始化限流规则 initFlowQpsRule(); &#125; //定义了每秒最多接收2个请求 private static void initFlowQpsRule() &#123; List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); FlowRule rule = new FlowRule(UserController.RESOURCE_NAME); // set limit qps to 2 rule.setCount(2); rule.setGrade(RuleConstant.FLOW_GRADE_QPS); rule.setLimitApp(&quot;default&quot;); rules.add(rule); FlowRuleManager.loadRules(rules); &#125;&#125; 然后启动项目，测试。快速刷新几次，我们就看到触发限流的逻辑了。 2) 返回布尔值的方式抛出异常的方式是当被限流时以抛出异常的形式感知，我们通过捕获异常进行限流的处理，这种方式跟上面不同的在于不抛出异常，而是返回一个布尔值，我们通过判断布尔值来进行限流逻辑的处理。这样我们就可以很容易写出if-else结构的代码。 123456789101112131415161718public static final String RESOURCE_NAME_QUERY_USER_BY_ID = &quot;queryUserById&quot;;@RequestMapping(&quot;/get/&#123;id&#125;&quot;)public String queryUserById(@PathVariable(&quot;id&quot;) String id) &#123; if (SphO.entry(RESOURCE_NAME_QUERY_USER_BY_ID)) &#123; try &#123; //被保护的逻辑 //模拟数据库查询数据 return JSONObject.toJSONString(new User(id, &quot;Tom&quot;, 25)); &#125; finally &#123; //关闭资源 SphO.exit(); &#125; &#125; else &#123; //资源访问阻止，被限流或被降级 return &quot;Resource is Block!!!&quot;; &#125;&#125; 添加规则的代码跟前面的例子一样，我就不写了，然后启动项目，测试。 3) 注解的方式看了上面两种方式，肯定有人会说，代码侵入性太强了，如果原来旧的系统要接入的话，要改原来的代码。众所周知，旧代码是不能动的，否则后果很严重。 那么注解的方式就很好地解决了这个问题。注解式怎么写呢？ 1234567891011121314151617181920@Servicepublic class UserServiceImpl implements UserService &#123; //资源名称 public static final String RESOURCE_NAME_QUERY_USER_BY_NAME = &quot;queryUserByUserName&quot;; //value是资源名称，是必填项。blockHandler填限流处理的方法名称 @Override @SentinelResource(value = RESOURCE_NAME_QUERY_USER_BY_NAME, blockHandler = &quot;queryUserByUserNameBlock&quot;) public User queryByUserName(String userName) &#123; return new User(&quot;0&quot;, userName, 18); &#125; //注意细节，一定要跟原函数的返回值和形参一致，并且形参最后要加个BlockException参数 //否则会报错，FlowException: null public User queryUserByUserNameBlock(String userName, BlockException ex) &#123; //打印异常 ex.printStackTrace(); return new User(&quot;xxx&quot;, &quot;用户名称：&#123;&quot; + userName + &quot;&#125;,资源访问被限流&quot;, 0); &#125;&#125; 写完这个核心代码后，还要加个配置，否则不生效。 引入sentinel-annotation-aspectj的Maven依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-annotation-aspectj&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 然后将SentinelResourceAspect注册为一个Bean。 1234567@Configurationpublic class SentinelAspectConfiguration &#123; @Bean public SentinelResourceAspect sentinelResourceAspect() &#123; return new SentinelResourceAspect(); &#125;&#125; 别忘了添加规则，可以参考第一个例子，这里就不写了。 最后启动项目，测试，刷新多几次接口后，出发限流，可以看到以下结果。 4) 熔断降级除了可以对接口进行限流之外，当接口出现异常时，Sentinel也可以提供熔断降级的功能。 在@SentinelResource注解中有一个属性fallback，当抛出非BlockException的异常时，就会进入到fallback方法中，实现熔断机制，这有点类似于Hystrix的FallBack。 我们拿上面的例子做示范，如果userName为空则抛出RuntimeException。然后我们设置fallback属性的属性值，也就是fallback的方法，返回系统异常。 123456789101112131415@Override@SentinelResource(value = RESOURCE_NAME_QUERY_USER_BY_NAME, blockHandler = &quot;queryUserByUserNameBlock&quot;, fallback = &quot;queryUserByUserNameFallBack&quot;)public User queryByUserName(String userName) &#123; if (userName == null || &quot;&quot;.equals(userName)) &#123; //抛出异常 throw new RuntimeException(&quot;queryByUserName() command failed, userName is null&quot;); &#125; return new User(&quot;0&quot;, userName, 18);&#125;public User queryUserByUserNameFallBack(String userName, Throwable ex) &#123; //打印日志 ex.printStackTrace(); return new User(&quot;-1&quot;, &quot;用户名称：&#123;&quot; + userName + &quot;&#125;,系统异常，请稍后重试&quot;, 0);&#125; 然后启动项目，故意不传userName，进行测试，可以看到走了fallback的方法逻辑。 IDEA控制台也可以看到自定义的异常信息。 四、管理控制台上面讲完了Sentinel的基本用法，实际上重头戏在Sentinel的管理控制台，管理控制台提供了很多实用的功能。下面我们看看怎么使用。 首先下载控制台的jar包，当然你也可以通过下载源码编译得到。 12//下载页面地址https://github.com/alibaba/Sentinel/releases 然后使用以下命令启动： 1java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.1.jar 启动成功后，访问http://localhost:8080，默认登录的用户名和密码都是sentinel。 登录进去之后，可以看到主页面，有许多功能菜单，这里就不一一介绍了。 客户端接入控制台那么我们自己的应用怎么接入到控制台，使用控制台对应用的流量进行监控呢，诸位客官，请继续往下看。 首先添加maven依赖，客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-transport-simple-http&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 配置filter，把所有访问的 Web URL 自动统计为 Sentinel 的资源。 12345678910111213@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean sentinelFilterRegistration() &#123; FilterRegistrationBean&lt;Filter&gt; registration = new FilterRegistrationBean&lt;&gt;(); registration.setFilter(new CommonFilter()); registration.addUrlPatterns(&quot;/*&quot;); registration.setName(&quot;sentinelFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 在启动命令中加入以下配置，-Dcsp.sentinel.dashboard.server=consoleIp:port 指定控制台地址和端口，-Dcsp.sentinel.api.port=xxxx 指定客户端监控 API 的端口(默认是8019，因为控制台已经使用了8719，应用端为了防止冲突就使用8720)： 1-Dserver.port=8888 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dcsp.sentinel.api.port=8720 -Dproject.name=sentinelDemo 启动项目，我们可以看到多了一个应用名称sentinelDemo，点击机器列表，查看健康状况。 请求/user/list接口，然后我们可以看到实时监控的接口的QPS情况。 这样就代表客户端接入控制台成功了！ 动态规则Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功后可以动态增加各种流控降级规则。Sentinel 提供两种方式修改规则： 通过 API 直接修改 (loadRules) 通过 DataSource 适配不同数据源修改 手动通过API定义规则，前面Hello World的例子已经写过，是一种硬编码的形式，因为不够灵活，所以肯定不能应用于生产环境。 所以要引入DataSource，规则设置可以存储在数据源中，通过更新数据源中存储的规则，推送到Sentinel规则中心，客户端就可以实时获取最新的规则，根据最新的规则进行限流、降级。 一般DataSource拓展常见的实现方式有： 拉模式：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是SQL、文件等。优点是比较简单，缺点是无法及时获取变更。 推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证，比较推荐使用这种方式。 拉模式pull模式的数据源一般是可写入的(比如本地文件)。首先要在客户端注册数据源，将对应的读数据源注册至对应的 RuleManager；然后将写数据源注册至 transport 的 WritableDataSourceRegistry 中。 由此看出这是一个双向读写的过程，我们既可以在应用本地直接修改文件来更新规则，也可以通过 Sentinel 控制台推送规则。下图为控制台推送规则的流程图。 首先引入maven依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-extension&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 使用SPI机制进行扩展，创建一个实现类，实现InitFunc接口的init()方法。 12345678910111213141516171819202122232425public class FileDataSourceInit implements InitFunc &#123; public FileDataSourceInit() &#123; &#125; @Override public void init() throws Exception &#123; String filePath = System.getProperty(&quot;user.home&quot;) + &quot;\\\\sentinel\\\\rules\\\\sentinel.json&quot;; ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds = new FileRefreshableDataSource&lt;&gt;( filePath, source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123; &#125;) ); // 将可读数据源注册至 FlowRuleManager. FlowRuleManager.register2Property(ds.getProperty()); WritableDataSource&lt;List&lt;FlowRule&gt;&gt; wds = new FileWritableDataSource&lt;&gt;(filePath, this::encodeJson); // 将可写数据源注册至 transport 模块的 WritableDataSourceRegistry 中. // 这样收到控制台推送的规则时，Sentinel 会先更新到内存，然后将规则写入到文件中. WritableDataSourceRegistry.registerFlowDataSource(wds); &#125; private &lt;T&gt; String encodeJson(T t) &#123; return JSON.toJSONString(t); &#125;&#125; 在项目的 resources/META-INF/services 目录下创建文件，名为com.alibaba.csp.sentinel.init.InitFunc ，内容则是FileDataSourceInit的全限定名称： 1io.github.yehongzhi.springmvc.config.FileDataSourceInit 接着在${home}目录下，创建\\sentinel\\rules目录，再创建sentinel.json文件。 然后启动项目，发送请求，当客户端接收到请求后就会触发初始化操作。初始化完成后我们到控制台，然后设置流量限流规则。 新增后，本地文件sentinel.json同时也保存了规则内容（压缩成一行的json）。 1[&#123;&quot;clusterConfig&quot;:&#123;&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000&#125;,&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:3.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;userList&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10&#125;] 我们可以通过修改文件来更新规则内容，也可以通过控制台推送规则到文件中，这就是拉模式。缺点是不保证一致性，实时性不保证，拉取过于频繁也可能会有性能问题。 推模式刚刚说了拉模式实时性不能保证，推模式就解决了这个问题。除此之外还可以持久化，也就是数据保存在数据源中，即使重启也不会丢失之前的配置，这也解决了原始模式存在内存中不能持久化的问题。 可以和Sentinel配合使用的数据源有很多种，比如ZooKeeper，Nacos，Apollo等等。这里介绍使用Nacos的方式。 首先要启动Nacos服务器，然后登录到Nacos控制台，添加一个命名空间，添加配置。 接着我们就要改造Sentinel的源码。因为官网提供的Sentinel的jar是原始模式的，所以需要改造，所以我们需要拉取源码下来改造一下，然后自己编译jar包。 源码地址：https://github.com/alibaba/Sentinel 拉取下来之后，导入到IDEA中，然后我们可以看到以下目录结构。 首先修改sentinel-dashboard的pom.xml文件： 第二步，把test目录下的四个关于Nacos关联的类，移到rule目录下。 FlowRuleNacosProvider和FlowRuleNacosPublisher不需要怎么改造，本人不太喜欢名称后缀，所以去掉了后面的后缀。 接着NacosConfig添加Nacos的地址配置。 最关键的是FlowControllerV1的改造，这是规则配置的增删改查的一些接口。 把移动到rule目录下的两个服务，添加到FlowControllerV1类中。 123456@Autowired@Qualifier(&quot;flowRuleNacosProvider&quot;)private DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;@Autowired@Qualifier(&quot;flowRuleNacosPublisher&quot;)private DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher; 添加私有方法publishRules()，用于推送配置： 1234private void publishRules(/*@NonNull*/ String app) throws Exception &#123; List&lt;FlowRuleEntity&gt; rules = repository.findAllByApp(app); rulePublisher.publish(app, rules);&#125; 修改apiQueryMachineRules()方法。 修改apiAddFlowRule()方法。 修改apiUpdateFlowRule()方法。 修改apiDeleteFlowRule()方法。 Sentinel控制台的项目就改造完成了，用于生产环境就编译成jar包运行，如果是学习可以直接在IDEA运行。 我们在前面创建的HelloWord工程的pom.xml文件加上依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/dependency&gt; 然后在application.yml文件加上以下配置： 12345678910111213141516spring: cloud: sentinel: datasource: flow: nacos: server-addr: localhost:8848 namespace: 05f447bc-8a0b-4686-9c34-344d7206ea94 dataId: springmvc-sentinel-flow-rules groupId: SENTINEL_GROUP # 规则类型，取值见： # org.springframework.cloud.alibaba.sentinel.datasource.RuleType rule-type: flow data-type: json application: name: springmvc-sentinel-flow-rules 以上就完成了全部的配置和改造，启动Sentinel控制台，还有Java应用。 打开Nacos控制台，我们添加限流配置如下： 配置内容如下： 1[&#123;&quot;app&quot;:&quot;springmvc-sentinel-flow-rules&quot;,&quot;clusterConfig&quot;:&#123;&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000&#125;,&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:1.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;userList&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10&#125;,&#123;&quot;app&quot;:&quot;springmvc-sentinel-flow-rules&quot;,&quot;clusterConfig&quot;:&#123;&quot;acquireRefuseStrategy&quot;:0,&quot;clientOfflineTime&quot;:2000,&quot;fallbackToLocalWhenFail&quot;:true,&quot;resourceTimeout&quot;:2000,&quot;resourceTimeoutStrategy&quot;:0,&quot;sampleCount&quot;:10,&quot;strategy&quot;:0,&quot;thresholdType&quot;:0,&quot;windowIntervalMs&quot;:1000&#125;,&quot;clusterMode&quot;:false,&quot;controlBehavior&quot;:0,&quot;count&quot;:3.0,&quot;grade&quot;:1,&quot;limitApp&quot;:&quot;default&quot;,&quot;maxQueueingTimeMs&quot;:500,&quot;resource&quot;:&quot;queryUserByUserName&quot;,&quot;strategy&quot;:0,&quot;warmUpPeriodSec&quot;:10&#125;] 然后我们打开Sentinel控制台，能看到配置，证明Nacos的配置推送成功了。 我们尝试调用Java应用的接口，测试是否生效。 可以看到限流是生效的，再看看Sentinel监控的QPS情况。 从QPS监控的情况看，最高的QPS只有3，其他请求都被拒绝了，证明限流配置是实时生效的。 配置信息也被持久化到Nacos相关的配置表中。 这时候，再回头看Sentinel官网上关于推模式的架构图就比较清楚了。 总结本篇文章主要介绍了Sentinel的基本用法，还有动态规则的两种方式，除此之外当然还有许多功能，这里由于篇幅问题就不一一介绍了，有兴趣的朋友可以自己探索一下。我个人觉得Sentinel是一个非常优秀的组件，比原来用的Hystrix的确有着非常大的改进，值得推荐。 我们看到官网上登记的企业列表，也有很多知名企业在使用，相信以后Sentinel会越来越好。 这篇文章就讲到这里了，感谢大家的阅读，希望看完大家能有所收获！ 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"Sentinel","slug":"Sentinel","permalink":"https://alloceee.github.io/tags/Sentinel/"}]},{"title":"Vue项目动态px转化rem适配移动端","slug":"大前端/other/vue-动态移动端适配px转化为rem","date":"2021-03-01T16:00:00.000Z","updated":"2021-08-04T01:22:25.141Z","comments":true,"path":"2021/03/02/大前端/other/vue-动态移动端适配px转化为rem/","link":"","permalink":"https://alloceee.github.io/2021/03/02/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/vue-%E5%8A%A8%E6%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8Dpx%E8%BD%AC%E5%8C%96%E4%B8%BArem/","excerpt":"安装postcss-pxtorem依赖，添加动态setRem函数于main.js中","text":"安装postcss-pxtorem依赖，添加动态setRem函数于main.js中 下载依赖1npm install postcss-pxtorem -D 新建一个rem.js的文件，在main.js中引用。12345678910111213141516// 基准大小const baseSize = 32// 设置 rem 函数function setRem () &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。设计稿 const scale = document.documentElement.clientWidth / 750;//375 // 设置页面根节点字体大小 document.documentElement.style.fontSize = (baseSize * Math.min(scale, 2)) + &#x27;px&#x27;&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function () &#123; setRem()&#125; postcss.config.js123456789101112131415161718192021222324252627module.exports = &#123; plugins: &#123; // 兼容浏览器，添加前缀 autoprefixer: &#123; overrideBrowserslist: [ &quot;Android 4.1&quot;, &quot;iOS 7.1&quot;, &quot;Chrome &gt; 31&quot;, &quot;ff &gt; 31&quot;, &quot;ie &gt;= 8&quot;, &quot;last 10 versions&quot;, // 所有主流浏览器最近10版本用 ], grid: true, &#125;, &quot;postcss-pxtorem&quot;: &#123; rootValue: 16, //结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem propList: [&quot;*&quot;], //是一个存储哪些将被转换的属性列表，这里设置为[&#x27;*&#x27;]全部，假设需要仅对边框进行设置，可以写[&#x27;*&#x27;, &#x27;!border*&#x27;] unitPrecision: 5, //保留rem小数点多少位 //selectorBlackList: [&#x27;.radius&#x27;], //则是一个对css选择器进行过滤的数组，比如你设置为[&#x27;fs&#x27;]，那例如fs-xl类名，里面有关px的样式将不被转换，这里也支持正则写法。 replace: true, //这个真不知到干嘛用的。有知道的告诉我一下 mediaQuery: false, //媒体查询( @media screen 之类的)中不生效 minPixelValue: 12, //px小于12的不会被转换 &#125;, &#125;,&#125;;// 蓝湖上设计稿自定义为375px 测量值直接写入即可 若设计稿为750px 则rootValue: 32 PostCSS plugin postcss-pxtorem requires PostCSS 8.postcss-pxtorem使用方法：https://www.cnblogs.com/liangziaha/p/13636936.html 这里报错 postcss-pxtorem 需要 8. 我以为要使用postcss-pxtorem 8.以上的版本就去看了一下postcss-pxtorem版本最高才6.0 这里降低 &#x70;&#111;&#x73;&#x74;&#x63;&#x73;&#x73;&#x2d;&#112;&#x78;&#116;&#x6f;&#x72;&#101;&#109;&#x40;&#x35;&#46;&#49;&#x2e;&#49; 1npm i postcss-pxtorem@5.1.1 再次运行npm start 就可以了","categories":[{"name":"Vue","slug":"Vue","permalink":"https://alloceee.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://alloceee.github.io/tags/Vue/"},{"name":"移动端","slug":"移动端","permalink":"https://alloceee.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"Alloceee"},{"title":"Redis常见问题","slug":"数据库/Redis/Redis-雪崩、穿透、并发等5大难题解决方案","date":"2020-12-19T14:04:23.000Z","updated":"2021-08-04T01:52:48.907Z","comments":true,"path":"2020/12/19/数据库/Redis/Redis-雪崩、穿透、并发等5大难题解决方案/","link":"","permalink":"https://alloceee.github.io/2020/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%B9%B6%E5%8F%91%E7%AD%895%E5%A4%A7%E9%9A%BE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"Redis雪崩、穿透、并发等5大难题解决方案缓存雪崩数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。 雪崩的简单过程： redis集群大面积故障 缓存失效，但依然大量请求访问缓存服务redis redis大量失效后，大量请求转向到mysql数据库 mysql的调用量暴增，很快就扛不住了，甚至直接宕机 由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。 如何预防缓存雪崩： 缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。 2.缓存降级 可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。 当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。 降级的最终目的是保证核心服务可用，即使是有损的。 比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。 在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 3.Redis备份和快速预热 (1)Redis数据备份和恢复 (2)快速缓存预热 4.提前演练 最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。 缓存穿透缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决思路： 如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。 可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。 缓存并发这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。 缓存预热缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。 这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路： 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 目的就是在系统上线前，将数据加载到缓存中。 Redis为什么是单线程，高并发快的3大原因详解Redis的高并发和快速原因 redis是基于内存的，内存的读写速度非常快； redis是单线程的，省去了很多上下文切换线程的时间； redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。 下面重点介绍单线程设计和IO多路复用核心设计快的原因。 为什么Redis是单线程的？1.官方答案 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。 2.性能指标 关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 3.详细原因 1.不需要各种锁的性能消耗 Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 2.单线程多进程集群方案 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。 所以单线程、多进程的集群不失为一个时髦的解决方案。 3.CPU消耗 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？ 可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。 Redis单线程的优劣势单进程单线程优势 代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善； IO多路复用技术 redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。 多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。 Redis高并发快总结 Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。 Redis缓存和MySQL数据一致性方案详解 需求起因 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。 这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。 读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子： 如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。 如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。 缓存和数据库一致性解决方案1.第一种方案：采用延时双删策略 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。 伪代码如下： 123456public void write(String key,Object data)&#123; redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key);&#125; 具体的步骤就是： 先删除缓存；再写数据库；休眠500毫秒；再次删除缓存。 那么，这个500毫秒怎么确定的，具体该休眠多久呢？ 需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。 设置缓存过期时间 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 该方案的弊端 结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。 2、第二种方案：异步更新缓存(基于订阅binlog的同步机制) 技术整体思路： MySQL binlog增量订阅消费+消息队列+增量数据更新到redis 读Redis：热数据基本都在Redis 写MySQL:增删改都是操作MySQL 更新Redis数据：MySQL的数据操作binlog，来更新到Redis Redis更新 1）数据操作主要分为两大块： 一个是全量(将全部数据一次写入到redis)一个是增量（实时更新） 这里说的是增量,指的是mysql的update、insert、delate变更数据。 2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。 这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。 其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。 这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。 当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://alloceee.github.io/tags/redis/"}],"author":"Alloceee"},{"title":"三千字Apollo配置中心总结","slug":"分布式/三千字Apollo配置中心总结","date":"2020-10-21T14:05:25.000Z","updated":"2021-08-04T03:17:18.531Z","comments":true,"path":"2020/10/21/分布式/三千字Apollo配置中心总结/","link":"","permalink":"https://alloceee.github.io/2020/10/21/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%89%E5%8D%83%E5%AD%97Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%80%BB%E7%BB%93/","excerpt":"","text":"思维导图 文章已收录Github精选，欢迎Star：https://github.com/yehongzhi/learningSummary 一、概述Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。 目前Apollo在github有22.6k颗星，在官网登记的使用的公司有451家，算是很流行的配置中心的框架技术。所以接下来跟着我一起学习Apollo配置中心吧。 二、为什么使用配置中心首先，没有配置中心之前传统的配置都是写在配置文件中，比如各种yml、perproties、xml文件。 写在各种文件里最大的问题在于如果需要改配置信息，需要重新部署发布应用才能生效，这是第一个问题。 后面为了做到动态读取配置信息，后面有人改进一下把配置信息存储在数据库的一张表，程序读取表中的配置信息，这种方式很多公司都还在使用，因为简单，而且灵活(修改配置只需要执行个SQL语句，不需要重新部署发布)。但是也不是最完美的，因为**缺少了权限控制，没有管理界面进行统一配置，没有历史版本的配置信息，不支持回滚(防止误操作)**。 实际上配置中心在市面上已经有很多，比如Nacos、Consul、spring-cloud-config、Apollo等等。 相对其他的，我觉得选择Apollo的原因是，界面比较美观，操作简便，部署简单，依赖较少，开箱即用。 三、安装部署首先要讲一下Apollo部署三个服务apollo-configservice，apollo-adminservice，apollo-portal，后面我讲架构设计时会讲一下这三个服务是用来干嘛的。 这里部署建议不要用官网的Quick Start，我一开始使用QuickStart的方式，搞了几个钟头搞不定，总是在Eureka上多了一个UNKONWN的服务，然后又无法访问8070的管理界面，心态直接崩溃。上github找了一下，如下： 作者在下面的回答是这样的。 这个问题发现不止有一个issue(#2931)反映了，但是没有解决，作者建议使用标准部署。 所以接下来就讲标准部署，也就是分布式部署，有耐心的同学也可以直接去github看作者写的分布式部署指南。 先介绍一下环境依赖，Linux服务器(建议CentOS7)，MySQL(版本要求:5.6.5+)，部署的服务器需要安装JDK环境(java 1.8+)。 这里有两种安装方式，一种是下载安装包，另一种是通过源码构建。一般如果不需要对Apollo定制开发，直接用安装包部署即可。我这里演示的就是安装包部署的方式。 3.1 获取安装包先到官网下载安装包。 下载后解压，如下： 3.2 创建数据库使用MySQL数据库(版本要求:5.6.5+)。 3.2.1 创建ApolloPortalDB数据库使用github上面的sql脚本创建ApolloPortalDB数据库，导入相关的表以及数据。 3.2.2 创建ApolloConfigDB数据库使用github上面的sql脚本创建ApolloConfigDB数据库，导入相关的表以及数据。 3.3 修改配置需要改一下数据库连接信息，路径在/config下。 3.3.1 apollo-configservice配置修改apollo-configservice的数据库连接信息application-github.properties，如下： 1234# DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码 3.3.2 apollo-adminservice配置修改apollo-adminservice的数据库连接信息application-github.properties，如下： 1234# DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloConfigDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码 3.3.3 apollo-portal配置修改apollo-portal的数据库连接信息application-github.properties，如下： 1234# DataSourcespring.datasource.url = jdbc:mysql://192.168.0.107:3306/ApolloPortalDB?characterEncoding=utf8spring.datasource.username = 账号spring.datasource.password = 密码 再修改apollo-env.properties配置，这是关于环境配置的，如下： 12345678local.meta=http://localhost:8080## 开发环境dev.meta=http://192.168.0.107:8080## 不需要配置的环境参考$&#123;lpt_meta&#125;配置fat.meta=$&#123;fat_meta&#125;uat.meta=$&#123;uat_meta&#125;lpt.meta=$&#123;lpt_meta&#125;pro.meta=$&#123;pro_meta&#125; 3.4 部署然后把三个文件夹都上传到Linux服务器。 3.4.1 部署发布apollo-configservice部署发布服务有顺序，首先发布apollo-configservice，直接执行scripts/startup.sh。 有可能会出现这个错误(我就出现了)，不用担心，实际上进程还没有结束，还在启动，我们可以到日志记录的文件夹(下图来源于startup.sh脚本)查看日志。 启动时间比较长，因为这个服务包括启动Eureka注册中心，需要耐心等待。观察apollo-configservice.log文件，当看到如下信息后，表示启动成功。 Eureka注册中心启动成功，可以打开http://192.168.0.107:8080/查看： 3.4.2 部署发布apollo-adminservice接着发布apollo-adminservice，直接执行scripts/startup.sh。查看日志的方式跟上面一样。启动成功后，可以看到Eureka的服务列表中多了一个服务。 3.4.3 部署发布apollo-portal接着发布apollo-portal，直接执行scripts/startup.sh。portal是提供Web界面的服务，所以启动成功后，可以打开http://192.168.0.107:8070/登录web界面，默认账号密码是apollo/admin。 到此，安装就完成了！ 四、SpringBoot整合Apollo接下来，整一个Demo(相当于java客户端)，使用SpringBoot整合Apollo，实现动态读取配置。 4.1 Mave依赖12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 4.2 AppId在classpath路径下，创建/META-INF/app.properties文件。如下： 12# 应用的唯一标识，后面创建工程需要用到app.id=apollo-demo 4.3 Apollo Meta Server其实就是配置Apollo服务器的地址。官网提供的方式有很多，我这里选其中一种比较简单的方式。在classpath路径下创建apollo-env.properties文件，配置如下： 1234dev.meta=http://192.168.0.107:8080# fat.meta=http://apollo.fat.xxx.com# uat.meta=http://apollo.uat.xxx.com# pro.meta=http://apollo.xxx.com 4.4 Environment其实是配置环境，因为上面可以配置四种环境，这里配置具体选择哪个环境。这里介绍两种方式： 第一种通过Java System Property。 第二种通过配置文件。 到相对应的路径下创建server.properties，配置如下： 1env=DEV 4.5 @EnableApolloConfig在启动类上加上注解@EnableApolloConfig。 12345678@SpringBootApplication//开启apollo配置@EnableApolloConfigpublic class ApolloDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApolloDemoApplication.class, args); &#125;&#125; 4.6 测试类这样就完成了，接下来再创建一个Controller进行测试一下。 123456789101112@RestControllerpublic class ApolloController &#123; //冒号后面的是默认值 @Value(&quot;$&#123;configValue:default&#125;&quot;) private String configValue; @RequestMapping(&quot;/apollo/getConfig&quot;) public String getConfig() &#123; return configValue; &#125;&#125; 4.7 管理界面创建对应的配置第一步，创建项目。 第二步，创建配置。 第三步，发布。 4.8 测试启动项目apollo-demo，然后请求路径http://localhost:8888/apollo/getConfig，可以看到： 控制台可以看到推送配置信息的日志： 五、架构设计讲完了安装和SpringBoot整合的demo后，我们是时候探究一下原理，为什么要有三个服务，又是如何做到配置信息发布后，客户端实时获取到最新的配置的。继续往下看。 首先看一张官网的架构设计图。 5.1 基础模型作者在官网上有个基础模型的架构图，忽略掉很多细节后实际上非常简单： 用户在配置中心对配置进行修改并发布。 配置中心通知Apollo客户端有配置更新。 Apollo客户端从配置中心拉取最新的配置、更新本地配置并通知到应用。 5.2 架构模块如果我们把Apollo配置中心服务端展开的话，架构图如下： 看到这里，整个架构看起来就比较清晰了。接下来从上往下简单介绍一下： Portal服务：提供Web界面供用户管理配置，通过MetaServer获取AdminService服务列表（IP+Port），通过IP+Port访问AdminService服务。 Client：实际上就是我们创建的SpringBoot项目，引入ApolloClient的maven依赖，为应用提供配置获取、实时更新等功能。 Meta Server：从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client。主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件。Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致。 Eureka：注册中心。Config Service和Admin Service会向Eureka注册服务。为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的。 Config Service：提供配置获取接口。提供配置更新推送接口(基于Http long polling)。服务对象为Apollo客户端(Client)。 Admin Service：提供配置管理接口。提供配置发布、修改等接口。服务对象为Portal。 5.3 配置发布后的实时推送设计上面讲完各个角色的用途，那这些角色是怎么配合一起工作的呢，我们来看一张图： 上图简要描述了配置发布的大致过程： 用户在Portal操作配置发布。 Portal调用Admin Service的接口操作发布。 Admin Service发布配置后，发送ReleaseMessage给各个Config Service。 Config Service收到ReleaseMessage后，通知对应的客户端(Client)。 关键点在于AdminService发送ReleaseMessage给ConfigService，这一步是如何异步发送的呢，一般异步发送我们很容易想到消息队列，但是实际上我们在安装部署时并没有使用到消息队列。 答案在于： Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace。 然后Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录。 Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器，监听器得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端。 在实现上，考虑到Apollo的实际使用场景，以及为了尽可能减少外部依赖，我们没有采用外部的消息中间件，而是通过数据库实现了一个简单的消息队列。—-来自官网 5.4 高可用Apollo为了实现高可用，服务端使用了Eureka作为注册中心，这一点在官网也有谈到。 除此之外，客户端也做了高可用的一些架构设计，比如本地文件缓存。 这个缓存文件默认就放在C:\\opt\\data\\apollo-demo\\config-cache路径下： 这个文件的作用是，在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置。 六、絮叨这篇文章就讲到这里。其实Apollo配置中心算是一个比较容易上手，架构相对比较清晰的开源项目。目前很多互联网公司都在推行微服务架构，在使用微服务的架构时，配置信息就会成倍数增加，因为配置实际上代表的是“控制”，很多时候程序的运行是靠配置去决定行为的，而且要能实时生效的，所以就必须要有个配置中心。 有些公司体量大一些会自己公司开发一套配置中心，其实实现起来也不是特别难，我上一间公司就自己实现，使用MQ消息队列+数据库，再自己简单地搭了一个增删改查、刷新配置的web页面，就完成了一个配置中心。 但是我觉得如果有现成的开源的会更加舒服，不用自己造轮子耗费时间，精力，而且选一些像Apollo这种比较大众主流的技术框架，学习成本也比较低，网上有很多资料。 那么Apollo配置中心就讲到这里了，上面所有例子的代码都上传Github了： https://github.com/yehongzhi/mall 觉得有用就点个赞吧，你的点赞是我创作的最大动力~ 拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"https://alloceee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"配置中心","slug":"配置中心","permalink":"https://alloceee.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"}]},{"title":"经典面试题：环形链表的判断与定位","slug":"Algorithm/经典面试题：环形链表的判断与定位","date":"2020-08-11T02:39:02.000Z","updated":"2020-08-11T11:19:28.000Z","comments":true,"path":"2020/08/11/Algorithm/经典面试题：环形链表的判断与定位/","link":"","permalink":"https://alloceee.github.io/2020/08/11/Algorithm/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E6%96%AD%E4%B8%8E%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"今天这篇文章要讲解的题目是「环形链表」的两道题目： LeetCode 141. Linked List Cycle（Easy） LeetCode 142. Linked List Cycle II（Medium） 两道题目都分别有「哈希表」的朴素解法，以及「双指针」的巧妙解法。非常适合大家掌握面试中的答题思路。想顺利通过面试的同学，不要错过这篇文章哟。 判断链表是否有环链表是线性结构，怎么会出现环呢？实际上是这道题中的链表经过了特殊改造，链表尾部会额外增加一个指针，连接到链表中间的某个结点，如下图所示。 链表尾部额外增加一个指针，形成环路 我们今天要讲的这两道题，都是在这个结构的基础上出的题。 先看 141 题： LeetCode 141. Linked List Cycle（Easy） 给定一个链表，判断链表中是否有环。 示例： 输入： 输出：true 解释：链表中有一个环，其尾部连接到第二个结点。 这道题其实是一道非常新颖的题目，考察的是对链表知识的综合掌握。只靠背链表的遍历代码来解题的人，看到这道题会手足无措。因为链表加上环之后，普通的遍历代码根本就不管用了！ 12345void traverse(ListNode head) &#123; for (ListNode q = head; q != null; q = q.next) &#123; // ... &#125;&#125; 上面的这段遍历代码，在有环路的链表上，会陷入「无限循环」：指针 q 在环路中一直绕圈，永远到达不了结束条件 q == null 。 解题基本思路其实看到前面的链表遍历代码，很多同学应该已经想出这道题的解题关键点了： 我只要顺着链表遍历，如果循环能正常退出（遇到 q == null 的情况），那么链表无环；如果循环永远不能退出，那么链表有环。 那么难点又来了，如果循环永远不能退出，我们的代码根本结束不了，不能返回「链表有环」的结果…… 面试小贴士： 在面试中，我们经常会遇到以上的情况。自己有了一点思路，但是还不能确定思路对不对。这时候，我们要做的不是「闷头苦想」直到想出最终解法，而是应该及时把自己关键的思路说给面试官。 面试中最忌讳的是长时间的沉默。及时跟面试官反馈我们初步的思路，可以确定我们的思路是否正确。即使一开始一点思路都没有，也可以直接说出来，请面试官给一点提示。 此时，面试官会告诉我们，以上的思路是正确的。接下来，我们需要能够判断链表有环的情况，并及时退出循环。 那么究竟如何判断呢？可以使用朴素的「哈希表」方案，或者是巧妙的「双指针」方法，下面会分别介绍。 哈希表解法哈希表解法的基本思路是：把访问过的结点记录下来，如果在遍历中遇到了访问过的结点，那么可以确定链表中存在环。记录访问过的结点，最常用的方法就是使用哈希表了。 有了这一点思路之后，我们很快可以写出相应的题解代码： 12345678910111213public boolean hasCycle(ListNode head) &#123; // 记录已访问过的结点 Set&lt;ListNode&gt; seen = new HashSet&lt;&gt;(); for (ListNode q = head; q != null; q = q.next) &#123; if (seen.contains(q)) &#123; // 遇到已访问过的结点，确定链表存在环 return true; &#125; seen.add(q); &#125; // 遍历循环正常退出，链表不存在环 return false;&#125; 这样，我们就成功地解决了这道题目。 但接下来面试官会让我们分析算法的时间、空间复杂度。发现空间复杂度是 之后，面试官会让我们再写一个空间复杂度更低的解法，也就是说，我们不能使用哈希表这样的额外存储空间了。 双指针解法在面试中，做出上面的哈希表解法属于「基本达标」，可以打 70 分了，但是如果要让面试官青睐你，打到 90 分，还要能写出不使用额外存储空间的解法，也就是双指针解法。 实话说，要在面试中凭空想出双指针解法有点困难。因此，这要靠我们平时的积累，多见识不同的解题技巧，这样在面试中可以熟练运用。 链表中的双指针技巧也叫「快慢指针」，指的是用两个指针一快一慢同时遍历链表。 例如，寻找链表中点的操作。使用一快一慢两个指针。快指针一次前进两个结点，速度是慢指针的两倍。当快指针到达链表尾部时，慢指针正好到达的链表的中部，这样就找到的链表的中点，非常巧妙。遍历过程如下图所示。 使用快慢指针寻找链表中点（动图） 如果我们熟悉这个技巧，就可以在环形链表这道题中触类旁通，使用出快慢指针技巧。 我们让快指针一次前进两个结点，慢指针一次前进一个结点。当快慢指针都进入环路时，快指针会将慢指针「套圈」，从后面追上慢指针，如下图所示。 在环路中，快指针套圈慢指针（动图） 这样，如果快指针追上了慢指针，我们就可以判断链表中存在环路。而如果链表中不存在环的话，快指针会永远走在慢指针的前面，它们不会相遇。 依照这个思路，我们可以写出以下的题解代码。 1234567891011121314public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; // fast 和 slow 指向同一个结点，说明存在“套圈” if (fast == slow) &#123; return true; &#125; &#125; // fast 到达链表尾部，则不存在环 return false;&#125; 代码简洁，解释清晰，那么这道面试算法题，你可以得 100 分。 寻找链表环的起点LeetCode 142 这道题，其实相当于 141 的「第二问」。当你用双指针解决了「判断环形链表」的题目之后，面试官看你答得不错，可能会继续追问，如何寻找环形链表的环的起点？如果你能答出这一问，可以得 120 分。 LeetCode 142. Linked List Cycle II（Medium） 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。不允许修改给定的链表。 示例： 输入： 输出：结点 &lt;2&gt; 解释：链表中有一个环，其尾部连接到第二个结点。 如果用哈希表的方法，这道题其实和前一题是一样的，没什么难度。因此，面试官要求你用双指针的方法寻找链表环的起点。 乍一看来，这道题挺难的。我们可以用快慢指针的方法知道链表中是否存在环，但我们不知道两个指针相遇在什么位置，要找到环的起点就更难了。不过不要慌，我们先画个图看看两个指针相遇的过程： 两个指针相遇的过程 如上图所示，链表分为两段：无环段和有环段。我们设无环段的长度为 ，环的长度为 。当快慢指针相遇时，我们设慢指针已经走了 步，那么快指针这时候已经走了 步。快指针套圈了慢指针，也就是比慢指针多走了若干圈。我们可以列出公式： 其中， 可以是任意正整数，因为快指针可能套了慢指针不止一圈。将上式化简得到 这个 恰好是慢指针走的步数。也就是说，慢指针目前前进的 步，正好是环的长度 的整数倍。 那么，慢指针再走 步，就可以正好到达环的起点（图中的 S 点）。这是因为，，正好够从链表头部出发，走一段无环段（），再把有环段走 圈（）。 如果我们在此时再用一个指针 q 从链表头部出发。那么指针 q 和慢指针 slow 会在走了 步以后恰好在环的起点处相遇。这样，我们就可以知道环的起点了。 根据以上思路，我们可以写出下面的题解代码： 123456789101112131415161718192021public ListNode detectCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; // 快慢指针相遇，说明链表存在环 if (fast == slow) &#123; // 此时 slow 指针距离环的起点的距离恰好为 a ListNode q = head; while (q != slow) &#123; slow = slow.next; q = q.next; &#125; // slow 和 q 相遇的位置一定是环的起点 return slow; &#125; &#125; // 链表不存在环，返回 null return null;&#125; 如果你能思考出以上内容并写出结果，那么面试官会非常认可你，这场面试基本就比较稳了。 面试套路总结从以上的讲解过程中我们可以发现，这个环形链表的题目其实可以分成几个小问，难度层层递进： 用哈希表的方法判断链表是否存在环 用快慢指针的方法判断链表是否存在环 用快慢指针的方法寻找环的起点 在面试中，面试官往往会先抛出比较简单的一两个小问进行「试探」。当发现你回答得还不错，则会继续提更难的问题，知道你不会为止。如果你一开始就回答得不好，那么面试官可能会认为你在这一块的掌握很一般，很快转而问其他的问题。 把握清楚面试中的这个「层层递进」的规律，我们要注意两点： 第一，在平时复习的时候要注意基础。也许你能做出很多高难度的题目，但如果在简单的题目上回答不上来，面试官可能就不会继续问了，你解决难题的能力可能也发挥不上来。 第二，面试中如果遇到很难的题目、一点也答不上来，不要气馁。这时候很可能是面试官在试探你能力的边界在哪里，侧面说明了你前面可能表现得不错。所以说在面试的全程中都要不慌不忙，会就正常回答，不会就直接说不知道。例如本文例题「寻找环的起点」，其实能在面试中做出来的人不多，能把「判断环是否存在」做好就已经很不错了。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"RabbitMQ如何防止消息丢失","slug":"中间件/RabbitMQ如何防止消息丢失","date":"2020-08-08T06:47:49.000Z","updated":"2021-08-04T03:17:18.518Z","comments":true,"path":"2020/08/08/中间件/RabbitMQ如何防止消息丢失/","link":"","permalink":"https://alloceee.github.io/2020/08/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/","excerpt":"思维导图 一、分析数据丢失的原因分析RabbitMQ消息丢失的情况，不妨先看看一条消息从生产者发送到消费者消费的过程： 可以看出，一条消息整个过程要经历两次的网络传输：从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者。","text":"思维导图 一、分析数据丢失的原因分析RabbitMQ消息丢失的情况，不妨先看看一条消息从生产者发送到消费者消费的过程： 可以看出，一条消息整个过程要经历两次的网络传输：从生产者发送到RabbitMQ服务器，从RabbitMQ服务器发送到消费者。 在消费者未消费前存储在队列(Queue)中。 所以可以知道，有三个场景下是会发生消息丢失的： 存储在队列中，如果队列没有对消息持久化，RabbitMQ服务器宕机重启会丢失数据。 生产者发送消息到RabbitMQ服务器过程中，RabbitMQ服务器如果宕机停止服务，消息会丢失。 消费者从RabbitMQ服务器获取队列中存储的数据消费，但是消费者程序出错或者宕机而没有正确消费，导致数据丢失。 针对以上三种场景，RabbitMQ提供了三种解决的方式，分别是消息持久化，confirm机制，ACK事务机制。 二、消息持久化RabbitMQ是支持消息持久化的，消息持久化需要设置：Exchange为持久化和Queue持久化，这样当消息发送到RabbitMQ服务器时，消息就会持久化。 首先看Exchange交换机的类图： 看这个类图其实是要说明上一篇文章介绍的四种交换机都是AbstractExchange抽象类的子类，所以根据java的特性，创建子类的实例会先调用父类的构造器，父类也就是AbstractExchange的构造器是怎么样的呢？ 从上面的注释可以看到**durable参数表示是否持久化。默认是持久化(true)**。创建持久化的Exchange可以这样写： 12345@Bean public DirectExchange rabbitmqDemoDirectExchange() &#123; //Direct交换机 return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false); &#125; 接着是Queue队列，我们先看看Queue的构造器是怎么样的： 也是通过durable参数设置是否持久化，默认是true。所以创建时可以不指定： 12345@Bean public Queue fanoutExchangeQueueA() &#123; //只需要指定名称，默认是持久化的 return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A); &#125; 这就完成了消息持久化的设置，接下来启动项目，发送几条消息，我们可以看到： 怎么证明是已经持久化了呢，实际上可以找到对应的文件：找到对应磁盘中的目录：消息持久化可以防止消息在RabbitMQ Server中不会因为宕机重启而丢失。 三、消息确认机制3.1 confirm机制在生产者发送到RabbitMQ Server时有可能因为网络问题导致投递失败，从而丢失数据。我们可以使用confirm模式防止数据丢失。工作流程是怎么样的呢，看以下图解：从上图中可以看到是通过两个回调函数**confirm()、returnedMessage()**进行通知。 一条消息从生产者发送到RabbitMQ，首先会发送到Exchange，对应回调函数**confirm()。第二步从Exchange路由分配到Queue中，对应回调函数则是returnedMessage()**。 代码怎么实现呢，请看演示： 首先在application.yml配置文件中加上如下配置： 123456789spring: rabbitmq: publisher-confirms: true# publisher-returns: true template: mandatory: true# publisher-confirms：设置为true时。当消息投递到Exchange后，会回调confirm()方法进行通知生产者# publisher-returns：设置为true时。当消息匹配到Queue并且失败时，会通过回调returnedMessage()方法返回消息# spring.rabbitmq.template.mandatory: 设置为true时。指定消息在没有被队列接收时会通过回调returnedMessage()方法退回。 有个小细节，publisher-returns和mandatory如果都设置的话，优先级是以mandatory优先。可以看源码：接着我们需要定义回调方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class RabbitmqConfirmCallback implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback &#123; private Logger logger = LoggerFactory.getLogger(RabbitmqConfirmCallback.class); /** * 监听消息是否到达Exchange * * @param correlationData 包含消息的唯一标识的对象 * @param ack true 标识 ack，false 标识 nack * @param cause nack 投递失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if (ack) &#123; logger.info(&quot;消息投递成功~消息Id：&#123;&#125;&quot;, correlationData.getId()); &#125; else &#123; logger.error(&quot;消息投递失败，Id：&#123;&#125;，错误提示：&#123;&#125;&quot;, correlationData.getId(), cause); &#125; &#125; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; logger.info(&quot;消息没有路由到队列，获得返回的消息&quot;); Map map = byteToObject(message.getBody(), Map.class); logger.info(&quot;message body: &#123;&#125;&quot;, map == null ? &quot;&quot; : map.toString()); logger.info(&quot;replyCode: &#123;&#125;&quot;, replyCode); logger.info(&quot;replyText: &#123;&#125;&quot;, replyText); logger.info(&quot;exchange: &#123;&#125;&quot;, exchange); logger.info(&quot;routingKey: &#123;&#125;&quot;, exchange); logger.info(&quot;------------&gt; end &lt;------------&quot;); &#125; @SuppressWarnings(&quot;unchecked&quot;) private &lt;T&gt; T byteToObject(byte[] bytes, Class&lt;T&gt; clazz) &#123; T t; try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis)) &#123; t = (T) ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; return t; &#125;&#125; 我这里就简单地打印回调方法返回的消息，在实际项目中，可以把返回的消息存储到日志表中，使用定时任务进行进一步的处理。 我这里是使用RabbitTemplate进行发送，所以在Service层的RabbitTemplate需要设置一下： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class RabbitMQServiceImpl implements RabbitMQService &#123; @Resource private RabbitmqConfirmCallback rabbitmqConfirmCallback; @Resource private RabbitTemplate rabbitTemplate; @PostConstruct public void init() &#123; //指定 ConfirmCallback rabbitTemplate.setConfirmCallback(rabbitmqConfirmCallback); //指定 ReturnCallback rabbitTemplate.setReturnCallback(rabbitmqConfirmCallback); &#125; @Override public String sendMsg(String msg) throws Exception &#123; Map&lt;String, Object&gt; message = getMessage(msg); try &#123; CorrelationData correlationData = (CorrelationData) message.remove(&quot;correlationData&quot;); rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, message, correlationData); return &quot;ok&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; &#125; private Map&lt;String, Object&gt; getMessage(String msg) &#123; String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32); CorrelationData correlationData = new CorrelationData(msgId); String sendTime = sdf.format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msgId&quot;, msgId); map.put(&quot;sendTime&quot;, sendTime); map.put(&quot;msg&quot;, msg); map.put(&quot;correlationData&quot;, correlationData); return map; &#125;&#125; 大功告成！接下来我们进行测试，发送一条消息，我们可以控制台：假设发送一条信息没有路由匹配到队列，可以看到如下信息：这就是confirm模式。它的作用是为了保障生产者投递消息到RabbitMQ不会出现消息丢失。 3.2 事务机制(ACK)最开始的那张图已经讲过，消费者从队列中获取到消息后，会直接确认签收，假设消费者宕机或者程序出现异常，数据没有正常消费，这种情况就会出现数据丢失。 所以关键在于把自动签收改成手动签收，正常消费则返回确认签收，如果出现异常，则返回拒绝签收重回队列。代码怎么实现呢，请看演示： 首先在消费者的application.yml文件中设置事务提交为manual手动模式： 1234567spring: rabbitmq: listener: simple: acknowledge-mode: manual # 手动ack模式 concurrency: 1 # 最少消费者数量 max-concurrency: 10 # 最大消费者数量 然后编写消费者的监听器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Componentpublic class RabbitDemoConsumer &#123; enum Action &#123; //处理成功 SUCCESS, //可以重试的错误，消息重回队列 RETRY, //无需重试的错误，拒绝消息，并从队列中删除 REJECT &#125; @RabbitHandler @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC)) public void process(String msg, Message message, Channel channel) &#123; long tag = message.getMessageProperties().getDeliveryTag(); Action action = Action.SUCCESS; try &#123; System.out.println(&quot;消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：&quot; + msg); if (&quot;bad&quot;.equals(msg)) &#123; throw new IllegalArgumentException(&quot;测试：抛出可重回队列的异常&quot;); &#125; if (&quot;error&quot;.equals(msg)) &#123; throw new Exception(&quot;测试：抛出无需重回队列的异常&quot;); &#125; &#125; catch (IllegalArgumentException e1) &#123; e1.printStackTrace(); //根据异常的类型判断，设置action是可重试的，还是无需重试的 action = Action.RETRY; &#125; catch (Exception e2) &#123; //打印异常 e2.printStackTrace(); //根据异常的类型判断，设置action是可重试的，还是无需重试的 action = Action.REJECT; &#125; finally &#123; try &#123; if (action == Action.SUCCESS) &#123; //multiple 表示是否批量处理。true表示批量ack处理小于tag的所有消息。false则处理当前消息 channel.basicAck(tag, false); &#125; else if (action == Action.RETRY) &#123; //Nack，拒绝策略，消息重回队列 channel.basicNack(tag, false, true); &#125; else &#123; //Nack，拒绝策略，并且从队列中删除 channel.basicNack(tag, false, false); &#125; channel.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解释一下上面的代码，如果没有异常，则手动确认回复RabbitMQ服务端basicAck(消费成功)。 如果抛出某些可以重回队列的异常，我们就回复basicNack并且设置重回队列。 如果是抛出不可重回队列的异常，就回复basicNack并且设置从RabbitMQ的队列中删除。 接下来进行测试，发送一条普通的消息”hello”：解释一下ack返回的三个方法的意思。 ①成功确认 1void basicAck(long deliveryTag, boolean multiple) throws IOException; 消费者成功处理后调用此方法对消息进行确认。 deliveryTag：该消息的index multiple：是否批量.。true：将一次性ack所有小于deliveryTag的消息。 ②失败确认 1void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException; deliveryTag：该消息的index。 multiple：是否批量。true：将一次性拒绝所有小于deliveryTag的消息。 requeue：被拒绝的是否重新入队列。 ③失败确认 1void basicReject(long deliveryTag, boolean requeue) throws IOException; deliveryTag:该消息的index。 requeue：被拒绝的是否重新入队列。 basicNack()和basicReject()的区别在于：basicNack()可以批量拒绝，basicReject()一次只能拒接一条消息。 四、遇到的坑4.1 启用nack机制后，导致的死循环上面的代码我故意写了一个bug。测试发送一条”bad”，然后会抛出重回队列的异常。这就有个问题：重回队列后消费者又消费，消费抛出异常又重回队列，就造成了死循环。那怎么避免这种情况呢？ 既然nack会造成死循环的话，我提供的一个思路是不使用basicNack()，把抛出异常的消息落库到一张表中，记录抛出的异常，消息体，消息Id。通过定时任务去处理。 如果你有什么好的解决方案，也可以留言讨论~ 4.2 double ack有的时候比较粗心，不小心开启了自动Ack模式，又手动回复了Ack。那就会报这个错误： 123消费者RabbitDemoConsumer从RabbitMQ服务端消费消息：java技术爱好者2020-08-02 22:52:42.148 ERROR 4880 --- [ 127.0.0.1:5672] o.s.a.r.c.CachingConnectionFactory : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - unknown delivery tag 1, class-id=60, method-id=80)2020-08-02 22:52:43.102 INFO 4880 --- [cTaskExecutor-1] o.s.a.r.l.SimpleMessageListenerContainer : Restarting Consumer@f4a3a8d: tags=[&#123;amq.ctag-8MJeQ7el_PNbVJxGOOw7Rw=rabbitmq.demo.topic&#125;], channel=Cached Rabbit Channel: AMQChannel(amqp://guest@127.0.0.1:5672/,5), conn: Proxy@782a1679 Shared Rabbit Connection: SimpleConnection@67c5b175 [delegate=amqp://guest@127.0.0.1:5672/, localPort= 56938], acknowledgeMode=AUTO local queue size=0 出现这个错误，可以检查一下yml文件是否添加了以下配置： 1234567spring: rabbitmq: listener: simple: acknowledge-mode: manual concurrency: 1 max-concurrency: 10 如果上面这个配置已经添加了，还是报错，有可能你使用@Configuration配置了SimpleRabbitListenerContainerFactory，根据SpringBoot的特性，代码优于配置，代码的配置覆盖了yml的配置，并且忘记设置手动manual模式： 12345678@Bean public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); //设置手动ack模式 factory.setAcknowledgeMode(AcknowledgeMode.MANUAL); return factory; &#125; 如果你还是有报错，那可能是写错地方了，写在生产者的项目了。以上的配置应该配置在消费者的项目。因为ack模式是针对消费者而言的。我就是写错了，写在生产者，折腾了几个小时，泪目~ 4.3 性能问题其实手动ACK相对于自动ACK肯定是会慢很多，我在网上查了一些资料，性能相差大概有10倍。所以一般在实际应用中不太建议开手动ACK模式。不过也不是绝对不可以开，具体情况具体分析，看并发量，还有数据的重要性等等。 所以在实际项目中还需要权衡一下并发量和数据的重要性，再决定具体的方案。 4.4 启用手动ack模式，如果没有及时回复，会造成队列异常如果开启了手动ACK模式，但是由于代码有bug的原因，没有回复RabbitMQ服务端，那么这条消息就会放到Unacked状态的消息堆里，只有等到消费者的连接断开才会转到Ready消息。如果消费者一直没有断开连接，那Unacked的消息就会越来越多，占用内存就越来越大，最后就会出现异常。 这个问题，我没法用我的电脑演示，我的电脑太卡了。 五、总结通过上面的学习后，总结了RabbitMQ防止数据丢失有三种方式： 消息持久化 生产者消息确认机制(confirm模式) 消费者消息确认模式(ack模式) 上面所有例子的代码都上传github了： https://github.com/yehongzhi/mall 如果你觉得这篇文章对你有用，点个赞吧~ 你的点赞是我创作的最大动力~ 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://alloceee.github.io/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"https://alloceee.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"RabbitMQ入门","slug":"中间件/RabbitMQ入门","date":"2020-08-08T05:00:52.000Z","updated":"2021-08-04T03:17:18.516Z","comments":true,"path":"2020/08/08/中间件/RabbitMQ入门/","link":"","permalink":"https://alloceee.github.io/2020/08/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ%E5%85%A5%E9%97%A8/","excerpt":"思维导图 一、什么是消息队列消息指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。 “消息队列(Message Queue)”是在消息的传输过程中保存消息的容器。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。","text":"思维导图 一、什么是消息队列消息指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。 “消息队列(Message Queue)”是在消息的传输过程中保存消息的容器。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。 二、为什么使用消息队列主要有三个作用： 解耦。如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可。 异步。如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。 削峰。如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。 三、RabbitMQ的特点RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，官网可查： 可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。 灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。 支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。 多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。 支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。 可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。 插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。 四、RabbitMQ初の体验4.1 安装RabbitMQ (Win10系统)由于只是学习需要，所以安装在win10系统，就懒得开虚拟机。如果用Linux系统安装的话，我建议用Docker拉一个RabbitMQ的镜像下来，这样会方便一点。 4.1.1 安装erLang语言，配置环境变量首先到erlang官网下载win10版安装包。 下载完之后，就得到这个东西： 接着双击安装，一直点next(下一步)就行了，安装完之后，配置环境变量。 使用cmd命令，输入 erl -version 验证： 4.1.2 安装RabbitMQ服务端在RabbitMQ的gitHub项目中，下载window版本的服务端安装包。 下载后，就得到这个东西： 接着到双击安装，一直点下一步安装即可，安装完成后，找到安装目录： 在此目录下打开cmd命令，输入rabbitmq-plugins enable rabbitmq_management命令安装管理页面的插件： 然后双击rabbitmq-server.bat启动脚本，然后打开服务管理可以看到RabbitMQ正在运行： 这时，打开浏览器输入http://localhost:15672，账号密码默认是：guest/guest 到这一步，安装就大功告成了！ 4.2 永远的Hello Word服务端搭建好了之后肯定要用客户端去操作，接下来就用Java做一个简单的HelloWord演示。 因为我用的是SpringBoot，所以在生产者这边加入对应的starter依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 一般需要创建一个公共项目common，共享一些配置，比如队列主题，交换机名称，路由匹配键名称等等。 首先在application.yml文件加上RabbitMQ的配置信息： 123456spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 然后在生产者这边，加上common包的maven依赖，然后创建一个Direct交换机以及队列的配置类： 12345678910111213141516171819202122232425262728293031@Configurationpublic class DirectRabbitConfig &#123; @Bean public Queue rabbitmqDemoDirectQueue() &#123; /** * 1、name: 队列名称 * 2、durable: 是否持久化 * 3、exclusive: 是否独享、排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。 * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。 * */ return new Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC, true, false, false); &#125; @Bean public DirectExchange rabbitmqDemoDirectExchange() &#123; //Direct交换机 return new DirectExchange(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, true, false); &#125; @Bean public Binding bindDirect() &#123; //链式写法，绑定交换机和队列，并设置匹配键 return BindingBuilder //绑定队列 .bind(rabbitmqDemoDirectQueue()) //到交换机 .to(rabbitmqDemoDirectExchange()) //并设置匹配键 .with(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING); &#125;&#125; 然后再创建一个发送消息的Service类： 12345678910111213141516171819202122232425@Servicepublic class RabbitMQServiceImpl implements RabbitMQService &#123; //日期格式化 private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); @Resource private RabbitTemplate rabbitTemplate; @Override public String sendMsg(String msg) throws Exception &#123; try &#123; String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32); String sendTime = sdf.format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msgId&quot;, msgId); map.put(&quot;sendTime&quot;, sendTime); map.put(&quot;msg&quot;, msg); rabbitTemplate.convertAndSend(RabbitMQConfig.RABBITMQ_DEMO_DIRECT_EXCHANGE, RabbitMQConfig.RABBITMQ_DEMO_DIRECT_ROUTING, map); return &quot;ok&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; &#125;&#125; 然后根据业务放在需要用的地方，比如定时任务，或者接口。我这里就简单一点使用Controller层进行发送： 1234567891011121314@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController &#123; @Resource private RabbitMQService rabbitMQService; /** * 发送消息 * @author java技术爱好者 */ @PostMapping(&quot;/sendMsg&quot;) public String sendMsg(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception &#123; return rabbitMQService.sendMsg(msg); &#125;&#125; 生产者写完之后，就写消费者端的代码，消费者很简单。maven依赖，yml文件配置和生产者一样。只需要创建一个类，@RabbitListener注解写上监听队列的名称，如图所示： 这里有个小坑，一开始RabbitMQ服务器里还没有创建队列： 这时如果启动消费者，会报错： 要先启动生产者，发送一条消息： 最后再启动消费者，进行消费： 这时候就会持续监听队列的消息，只要生产者发送一条消息到MQ，消费者就消费一条。我这里尝试发送4条： 由于队列不存在，启动消费者报错的这个问题。最好的方法是生产者和消费者都尝试创建队列，怎么写呢，有很多方式，我这里用一个相对简单一点的： 生产者的配置类加点东西： 1234567891011121314151617181920212223242526//实现BeanPostProcessor类，使用Bean的生命周期函数@Componentpublic class DirectRabbitConfig implements BeanPostProcessor &#123; //这是创建交换机和队列用的rabbitAdmin对象 @Resource private RabbitAdmin rabbitAdmin; //初始化rabbitAdmin对象 @Bean public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) &#123; RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory); // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类 rabbitAdmin.setAutoStartup(true); return rabbitAdmin; &#125; //实例化bean后，也就是Bean的后置处理器 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; //创建交换机 rabbitAdmin.declareExchange(rabbitmqDemoDirectExchange()); //创建队列 rabbitAdmin.declareQueue(rabbitmqDemoDirectQueue()); return null; &#125;&#125; 这样启动生产者就会自动创建交换机和队列，不用等到发送消息才创建。 消费者需要加一点代码： 123456@Component//使用queuesToDeclare属性，如果不存在则会创建队列@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.RABBITMQ_DEMO_TOPIC))public class RabbitDemoConsumer &#123; //...省略&#125; 这样，无论生产者还是消费者先启动都不会出现问题了~ 代码地址：https://github.com/yehongzhi/mall 五、RabbitMQ中的组成部分从上面的HelloWord例子中，我们大概也能体验到一些，就是RabbitMQ的组成，它是有这几部分： Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。 Exchange：消息队列交换机。按一定的规则将消息路由转发到某个队列。 Queue：消息队列，存储消息的队列。 Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。 Consumer：消息消费者。消费队列中存储的消息。 这些组成部分是如何协同工作的呢，大概的流程如下，请看下图： 消息生产者连接到RabbitMQ Broker，创建connection，开启channel。 生产者声明交换机类型、名称、是否持久化等。 生产者发送消息，并指定消息是否持久化等属性和routing key。 exchange收到消息之后，根据routing key路由到跟当前交换机绑定的相匹配的队列里面。 消费者监听接收到消息之后开始业务处理。 六、Exchange的四种类型以及用法从上面的工作流程可以看出，实际上有个关键的组件Exchange，因为消息发送到RabbitMQ后首先要经过Exchange路由才能找到对应的Queue。 实际上Exchange类型有四种，根据不同的类型工作的方式也有所不同。在HelloWord例子中，我们就使用了比较简单的Direct Exchange，翻译就是直连交换机。其余三种分别是：Fanout exchange、Topic exchange、Headers exchange。 6.1 Direct Exchange见文知意，直连交换机意思是此交换机需要绑定一个队列，要求该消息与一个特定的路由键完全匹配。简单点说就是一对一的，点对点的发送。 完整的代码就是上面的HelloWord的例子，不再重复代码。 6.2 Fanout exchange这种类型的交换机需要将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。简单点说就是发布订阅。 代码怎么写呢，演示一下： 首先要先配置交换机和队列的名称： 1234567891011121314151617public class RabbitMQConfig &#123; /** * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 A 的名称 */ public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_A = &quot;fanout.A&quot;; /** * RabbitMQ的FANOUT_EXCHANG交换机类型的队列 B 的名称 */ public static final String FANOUT_EXCHANGE_QUEUE_TOPIC_B = &quot;fanout.B&quot;; /** * RabbitMQ的FANOUT_EXCHANG交换机类型的名称 */ public static final String FANOUT_EXCHANGE_DEMO_NAME = &quot;fanout.exchange.demo.name&quot;;&#125; 再配置FanoutExchange类型的交换机和A、B两个队列，并且绑定。这种类型不需要配置routing key： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class DirectRabbitConfig implements BeanPostProcessor &#123; @Resource private RabbitAdmin rabbitAdmin; @Bean public Queue fanoutExchangeQueueA() &#123; //队列A return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A, true, false, false); &#125; @Bean public Queue fanoutExchangeQueueB() &#123; //队列B return new Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B, true, false, false); &#125; @Bean public FanoutExchange rabbitmqDemoFanoutExchange() &#123; //创建FanoutExchange类型交换机 return new FanoutExchange(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, true, false); &#125; @Bean public Binding bindFanoutA() &#123; //队列A绑定到FanoutExchange交换机 return BindingBuilder.bind(fanoutExchangeQueueA()).to(rabbitmqDemoFanoutExchange()); &#125; @Bean public Binding bindFanoutB() &#123; //队列B绑定到FanoutExchange交换机 return BindingBuilder.bind(fanoutExchangeQueueB()).to(rabbitmqDemoFanoutExchange()); &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; //启动项目即创建交换机和队列 rabbitAdmin.declareExchange(rabbitmqDemoFanoutExchange()); rabbitAdmin.declareQueue(fanoutExchangeQueueB()); rabbitAdmin.declareQueue(fanoutExchangeQueueA()); return null; &#125;&#125; 创建service发布消息的方法： 123456789101112131415161718192021222324252627282930@Servicepublic class RabbitMQServiceImpl implements RabbitMQService &#123; private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); @Resource private RabbitTemplate rabbitTemplate; //发布消息 @Override public String sendMsgByFanoutExchange(String msg) throws Exception &#123; Map&lt;String, Object&gt; message = getMessage(msg); try &#123; rabbitTemplate.convertAndSend(RabbitMQConfig.FANOUT_EXCHANGE_DEMO_NAME, &quot;&quot;, message); return &quot;ok&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; &#125; //组装消息体 private Map&lt;String, Object&gt; getMessage(String msg) &#123; String msgId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;).substring(0, 32); String sendTime = sdf.format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msgId&quot;, msgId); map.put(&quot;sendTime&quot;, sendTime); map.put(&quot;msg&quot;, msg); return map; &#125;&#125; Controller接口： 12345678910111213@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController &#123; /** * 发布消息 * * @author java技术爱好者 */ @PostMapping(&quot;/publish&quot;) public String publish(@RequestParam(name = &quot;msg&quot;) String msg) throws Exception &#123; return rabbitMQService.sendMsgByFanoutExchange(msg); &#125;&#125; 接着在消费者项目这边，创建两个队列的监听类，监听队列进行消费： 12345678910@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_A))public class FanoutExchangeConsumerA &#123; @RabbitHandler public void process(Map&lt;String, Object&gt; map) &#123; System.out.println(&quot;队列A收到消息：&quot; + map.toString()); &#125;&#125; 123456789@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.FANOUT_EXCHANGE_QUEUE_TOPIC_B))public class FanoutExchangeConsumerB &#123; @RabbitHandler public void process(Map&lt;String, Object&gt; map) &#123; System.out.println(&quot;队列B收到消息：&quot; + map.toString()); &#125;&#125; 然后启动生产者和消费者两个项目，可以看到管理界面创建了一个FanoutExchange交换机和两个队列，并且绑定了： 使用POSTMAN进行发送消息，测试： 然后可以看到控制台，两个队列同时都收到了相同的消息，形成了发布订阅的效果： 6.3 Topic Exchange直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”*” 、 “#”。需要注意的是通配符前面必须要加上”.”符号。 * 符号：有且只匹配一个词。比如 a.*可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。 # 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。 废话不多说，代码演示一下： 依然是配置TopicExchange名称和三个队列的名称： 12345678910111213141516171819/** * RabbitMQ的TOPIC_EXCHANGE交换机名称 */public static final String TOPIC_EXCHANGE_DEMO_NAME = &quot;topic.exchange.demo.name&quot;;/** * RabbitMQ的TOPIC_EXCHANGE交换机的队列A的名称 */public static final String TOPIC_EXCHANGE_QUEUE_A = &quot;topic.queue.a&quot;;/** * RabbitMQ的TOPIC_EXCHANGE交换机的队列B的名称 */public static final String TOPIC_EXCHANGE_QUEUE_B = &quot;topic.queue.b&quot;;/** * RabbitMQ的TOPIC_EXCHANGE交换机的队列C的名称 */public static final String TOPIC_EXCHANGE_QUEUE_C = &quot;topic.queue.c&quot;; 然后还是老配方，配置交换机和队列，然后绑定，创建： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Componentpublic class DirectRabbitConfig implements BeanPostProcessor &#123; //省略... @Bean public TopicExchange rabbitmqDemoTopicExchange() &#123; //配置TopicExchange交换机 return new TopicExchange(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, true, false); &#125; @Bean public Queue topicExchangeQueueA() &#123; //创建队列1 return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A, true, false, false); &#125; @Bean public Queue topicExchangeQueueB() &#123; //创建队列2 return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B, true, false, false); &#125; @Bean public Queue topicExchangeQueueC() &#123; //创建队列3 return new Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C, true, false, false); &#125; @Bean public Binding bindTopicA() &#123; //队列A绑定到FanoutExchange交换机 return BindingBuilder.bind(topicExchangeQueueB()) .to(rabbitmqDemoTopicExchange()) .with(&quot;a.*&quot;); &#125; @Bean public Binding bindTopicB() &#123; //队列A绑定到FanoutExchange交换机 return BindingBuilder.bind(topicExchangeQueueC()) .to(rabbitmqDemoTopicExchange()) .with(&quot;a.*&quot;); &#125; @Bean public Binding bindTopicC() &#123; //队列A绑定到FanoutExchange交换机 return BindingBuilder.bind(topicExchangeQueueA()) .to(rabbitmqDemoTopicExchange()) .with(&quot;rabbit.#&quot;); &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; rabbitAdmin.declareExchange(rabbitmqDemoTopicExchange()); rabbitAdmin.declareQueue(topicExchangeQueueA()); rabbitAdmin.declareQueue(topicExchangeQueueB()); rabbitAdmin.declareQueue(topicExchangeQueueC()); return null; &#125;&#125; 然后写一个发送消息的service方法： 123456789101112131415@Servicepublic class RabbitMQServiceImpl implements RabbitMQService &#123; @Override public String sendMsgByTopicExchange(String msg, String routingKey) throws Exception &#123; Map&lt;String, Object&gt; message = getMessage(msg); try &#123; //发送消息 rabbitTemplate.convertAndSend(RabbitMQConfig.TOPIC_EXCHANGE_DEMO_NAME, routingKey, message); return &quot;ok&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; &#125;&#125; 写一个Controller接口： 12345678910111213141516@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController &#123; @Resource private RabbitMQService rabbitMQService; /** * 通配符交换机发送消息 * * @author java技术爱好者 */ @PostMapping(&quot;/topicSend&quot;) public String topicSend(@RequestParam(name = &quot;msg&quot;) String msg, @RequestParam(name = &quot;routingKey&quot;) String routingKey) throws Exception &#123; return rabbitMQService.sendMsgByTopicExchange(msg, routingKey); &#125;&#125; 生产者这边写完，就写消费端，消费端比较简单，写三个监听类： 1234567891011121314151617181920212223242526272829@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A))public class TopicExchangeConsumerA &#123; @RabbitHandler public void process(Map&lt;String, Object&gt; map) &#123; System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + map.toString()); &#125;&#125;@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B))public class TopicExchangeConsumerB &#123; @RabbitHandler public void process(Map&lt;String, Object&gt; map) &#123; System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_B+ &quot;]收到消息：&quot; + map.toString()); &#125;&#125;@Component@RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C))public class TopicExchangeConsumerC &#123; @RabbitHandler public void process(Map&lt;String, Object&gt; map) &#123; System.out.println(&quot;队列[&quot; + RabbitMQConfig.TOPIC_EXCHANGE_QUEUE_C + &quot;]收到消息：&quot; + map.toString()); &#125;&#125; 大功告成，然后启动项目开始调试。启动成功后可以看到队列和路由键绑定的关系： 通过POSTMAN进行测试，测试一下 rabbit.# 的路由键是否能够匹配成功： 测试成功，队列A消费到消息： 接着测试 a.* 路由键，发送 routingKey = a.b ： 比较常用的就是以上三种：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。 实际上稍微思考一下，可以发现通配符(TopicExchange)这种模式其实是可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果的。 FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一点。 6.4 Headers Exchange这种交换机用的相对没这么多。它跟上面三种有点区别，它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由。如图所示： 创建队列需要设置绑定的头部信息，有两种模式：全部匹配和部分匹配。如上图所示，交换机会根据生产者发送过来的头部信息携带的键值去匹配队列绑定的键值，路由到对应的队列。代码怎么实现呢，往下看演示代码： 首先还是需要定义交换机名称，队列名称： 1234567891011121314/** * HEADERS_EXCHANGE交换机名称 */public static final String HEADERS_EXCHANGE_DEMO_NAME = &quot;headers.exchange.demo.name&quot;;/** * RabbitMQ的HEADERS_EXCHANGE交换机的队列A的名称 */public static final String HEADERS_EXCHANGE_QUEUE_A = &quot;headers.queue.a&quot;;/** * RabbitMQ的HEADERS_EXCHANGE交换机的队列B的名称 */public static final String HEADERS_EXCHANGE_QUEUE_B = &quot;headers.queue.b&quot;; 然后设置交换机，队列，进行绑定： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class DirectRabbitConfig implements BeanPostProcessor &#123; @Bean public Queue headersQueueA() &#123; return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A, true, false, false); &#125; @Bean public Queue headersQueueB() &#123; return new Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B, true, false, false); &#125; @Bean public HeadersExchange rabbitmqDemoHeadersExchange() &#123; return new HeadersExchange(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, true, false); &#125; @Bean public Binding bindHeadersA() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key_one&quot;, &quot;java&quot;); map.put(&quot;key_two&quot;, &quot;rabbit&quot;); //全匹配 return BindingBuilder.bind(headersQueueA()) .to(rabbitmqDemoHeadersExchange()) .whereAll(map).match(); &#125; @Bean public Binding bindHeadersB() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;headers_A&quot;, &quot;coke&quot;); map.put(&quot;headers_B&quot;, &quot;sky&quot;); //部分匹配 return BindingBuilder.bind(headersQueueB()) .to(rabbitmqDemoHeadersExchange()) .whereAny(map).match(); &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; rabbitAdmin.declareExchange(rabbitmqDemoHeadersExchange()); rabbitAdmin.declareQueue(headersQueueA()); rabbitAdmin.declareQueue(headersQueueB()); return null; &#125;&#125; 再写一个Service方法发送消息: 1234567891011121314151617181920212223@Servicepublic class RabbitMQServiceImpl implements RabbitMQService &#123; @Resource private RabbitTemplate rabbitTemplate; @Override public String sendMsgByHeadersExchange(String msg, Map&lt;String, Object&gt; map) throws Exception &#123; try &#123; MessageProperties messageProperties = new MessageProperties(); //消息持久化 messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); messageProperties.setContentType(&quot;UTF-8&quot;); //添加消息 messageProperties.getHeaders().putAll(map); Message message = new Message(msg.getBytes(), messageProperties); rabbitTemplate.convertAndSend(RabbitMQConfig.HEADERS_EXCHANGE_DEMO_NAME, null, message); return &quot;ok&quot;; &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; &#125;&#125; 再写一个Controller接口： 123456789101112131415@RestController@RequestMapping(&quot;/mall/rabbitmq&quot;)public class RabbitMQController &#123; @Resource private RabbitMQService rabbitMQService; @PostMapping(&quot;/headersSend&quot;) @SuppressWarnings(&quot;unchecked&quot;) public String headersSend(@RequestParam(name = &quot;msg&quot;) String msg, @RequestParam(name = &quot;json&quot;) String json) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class); return rabbitMQService.sendMsgByHeadersExchange(msg, map); &#125;&#125; 生产者这边写完了，再写两个队列的监听类进行消费： 12345678910111213141516171819@Componentpublic class HeadersExchangeConsumerA &#123; @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A)) public void process(Message message) throws Exception &#123; MessageProperties messageProperties = message.getMessageProperties(); String contentType = messageProperties.getContentType(); System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_A + &quot;]收到消息：&quot; + new String(message.getBody(), contentType)); &#125;&#125;@Componentpublic class HeadersExchangeConsumerB &#123; @RabbitListener(queuesToDeclare = @Queue(RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B)) public void process(Message message) throws Exception &#123; MessageProperties messageProperties = message.getMessageProperties(); String contentType = messageProperties.getContentType(); System.out.println(&quot;队列[&quot; + RabbitMQConfig.HEADERS_EXCHANGE_QUEUE_B + &quot;]收到消息：&quot; + new String(message.getBody(), contentType)); &#125;&#125; 大功告成~启动项目，打开管理界面，我们可以看到交换机绑定队列的信息： 跟上面示意图一样~证明没有问题，一切尽在掌握之中。使用POSTMAN发送，测试全匹配的队列A： 再测试部分匹配的队列B： 总结这篇文章就先写到这里了。回顾一下学了哪些： 什么是消息队列？为什么使用消息队列？ RabbitMQ的特点、组成部分、工作流程 安装RabbitMQ，以及完成一个HelloWord小案例 RabbitMQ交换机的四种类型的特点，以及使用方法 实际上RabbitMQ还有事务机制和负载均衡这些还没讲，因为篇幅实在有点长了，差不多5千字了。所以放在下期讲吧，尽请期待一下。 上面所有例子的代码都上传github了： https://github.com/yehongzhi/mall 如果你觉得这篇文章对你有用，点个赞吧~ 你的点赞是我创作的最大动力~ 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://alloceee.github.io/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"https://alloceee.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"初识算法","slug":"Algorithm/初识算法","date":"2020-07-30T05:04:42.000Z","updated":"2020-08-06T02:59:02.000Z","comments":true,"path":"2020/07/30/Algorithm/初识算法/","link":"","permalink":"https://alloceee.github.io/2020/07/30/Algorithm/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150class Solution &#123; int[] dx = &#123;1, -1, 0, 0&#125;; int[] dy = &#123;0, 0, 1, -1&#125;; int n, m; public int minimalSteps(String[] maze) &#123; n = maze.length; m = maze[0].length(); // 机关 &amp; 石头 List&lt;int[]&gt; buttons = new ArrayList&lt;int[]&gt;(); List&lt;int[]&gt; stones = new ArrayList&lt;int[]&gt;(); // 起点 &amp; 终点 int sx = -1, sy = -1, tx = -1, ty = -1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (maze[i].charAt(j) == &#x27;M&#x27;) &#123; buttons.add(new int[]&#123;i, j&#125;); &#125; if (maze[i].charAt(j) == &#x27;O&#x27;) &#123; stones.add(new int[]&#123;i, j&#125;); &#125; if (maze[i].charAt(j) == &#x27;S&#x27;) &#123; sx = i; sy = j; &#125; if (maze[i].charAt(j) == &#x27;T&#x27;) &#123; tx = i; ty = j; &#125; &#125; &#125; int nb = buttons.size(); int ns = stones.size(); int[][] startDist = bfs(sx, sy, maze); // 边界情况：没有机关 if (nb == 0) &#123; return startDist[tx][ty]; &#125; // 从某个机关到其他机关 / 起点与终点的最短距离。 int[][] dist = new int[nb][nb + 2]; for (int i = 0; i &lt; nb; i++) &#123; Arrays.fill(dist[i], -1); &#125; // 中间结果 int[][][] dd = new int[nb][][]; for (int i = 0; i &lt; nb; i++) &#123; int[][] d = bfs(buttons.get(i)[0], buttons.get(i)[1], maze); dd[i] = d; // 从某个点到终点不需要拿石头 dist[i][nb + 1] = d[tx][ty]; &#125; for (int i = 0; i &lt; nb; i++) &#123; int tmp = -1; for (int k = 0; k &lt; ns; k++) &#123; int midX = stones.get(k)[0], midY = stones.get(k)[1]; if (dd[i][midX][midY] != -1 &amp;&amp; startDist[midX][midY] != -1) &#123; if (tmp == -1 || tmp &gt; dd[i][midX][midY] + startDist[midX][midY]) &#123; tmp = dd[i][midX][midY] + startDist[midX][midY]; &#125; &#125; &#125; dist[i][nb] = tmp; for (int j = i + 1; j &lt; nb; j++) &#123; int mn = -1; for (int k = 0; k &lt; ns; k++) &#123; int midX = stones.get(k)[0], midY = stones.get(k)[1]; if (dd[i][midX][midY] != -1 &amp;&amp; dd[j][midX][midY] != -1) &#123; if (mn == -1 || mn &gt; dd[i][midX][midY] + dd[j][midX][midY]) &#123; mn = dd[i][midX][midY] + dd[j][midX][midY]; &#125; &#125; &#125; dist[i][j] = mn; dist[j][i] = mn; &#125; &#125; // 无法达成的情形 for (int i = 0; i &lt; nb; i++) &#123; if (dist[i][nb] == -1 || dist[i][nb + 1] == -1) &#123; return -1; &#125; &#125; // dp 数组， -1 代表没有遍历到 int[][] dp = new int[1 &lt;&lt; nb][nb]; for (int i = 0; i &lt; 1 &lt;&lt; nb; i++) &#123; Arrays.fill(dp[i], -1); &#125; for (int i = 0; i &lt; nb; i++) &#123; dp[1 &lt;&lt; i][i] = dist[i][nb]; &#125; // 由于更新的状态都比未更新的大，所以直接从小到大遍历即可 for (int mask = 1; mask &lt; (1 &lt;&lt; nb); mask++) &#123; for (int i = 0; i &lt; nb; i++) &#123; // 当前 dp 是合法的 if ((mask &amp; (1 &lt;&lt; i)) != 0) &#123; for (int j = 0; j &lt; nb; j++) &#123; // j 不在 mask 里 if ((mask &amp; (1 &lt;&lt; j)) == 0) &#123; int next = mask | (1 &lt;&lt; j); if (dp[next][j] == -1 || dp[next][j] &gt; dp[mask][i] + dist[i][j]) &#123; dp[next][j] = dp[mask][i] + dist[i][j]; &#125; &#125; &#125; &#125; &#125; &#125; int ret = -1; int finalMask = (1 &lt;&lt; nb) - 1; for (int i = 0; i &lt; nb; i++) &#123; if (ret == -1 || ret &gt; dp[finalMask][i] + dist[i][nb + 1]) &#123; ret = dp[finalMask][i] + dist[i][nb + 1]; &#125; &#125; return ret; &#125; public int[][] bfs(int x, int y, String[] maze) &#123; int[][] ret = new int[n][m]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(ret[i], -1); &#125; ret[x][y] = 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); queue.offer(new int[]&#123;x, y&#125;); while (!queue.isEmpty()) &#123; int[] p = queue.poll(); int curx = p[0], cury = p[1]; for (int k = 0; k &lt; 4; k++) &#123; int nx = curx + dx[k], ny = cury + dy[k]; if (inBound(nx, ny) &amp;&amp; maze[nx].charAt(ny) != &#x27;#&#x27; &amp;&amp; ret[nx][ny] == -1) &#123; ret[nx][ny] = ret[curx][cury] + 1; queue.offer(new int[]&#123;nx, ny&#125;); &#125; &#125; &#125; return ret; &#125; public boolean inBound(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m; &#125;&#125; 给定一组唯一的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 示例 1: 输入: [“abcd”,”dcba”,”lls”,”s”,”sssll”]输出: [[0,1],[1,0],[3,2],[2,4]]解释: 可拼接成的回文串为 [“dcbaabcd”,”abcddcba”,”slls”,”llssssll”]","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HTTP常用的14种状态码","slug":"计算机网络/HTTP-常见状态码","date":"2020-07-30T05:04:42.000Z","updated":"2021-08-04T01:33:00.339Z","comments":true,"path":"2020/07/30/计算机网络/HTTP-常见状态码/","link":"","permalink":"https://alloceee.github.io/2020/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。","text":"状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。 状态码的类别： 类别 原因 1XX Informational（信息性状态码） 接受的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX——表明请求被正常处理了1、200 OK：请求已正常处理。 2、204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 3、206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 3XX——表明浏览器需要执行某些特殊的处理以正确处理请求4、301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 5、302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。 6、303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。 当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 7、304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。 8、307 Temporary Redirect：临时重定向。与302有相同的含义。 4XX——表明客户端是发生错误的原因所在。9、400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。 10、401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。 11、403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等） 12、404 Not Found：服务器上没有请求的资源。路径错误等。 5XX——服务器本身发生错误13、500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。 14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/tags/HTTP/"}],"author":"Alloceee"},{"title":"ZooKeeper入门","slug":"分布式/ZooKeeper入门","date":"2020-07-26T06:06:28.000Z","updated":"2021-08-04T03:17:18.527Z","comments":true,"path":"2020/07/26/分布式/ZooKeeper入门/","link":"","permalink":"https://alloceee.github.io/2020/07/26/%E5%88%86%E5%B8%83%E5%BC%8F/ZooKeeper%E5%85%A5%E9%97%A8/","excerpt":"","text":"思维导图 前言在很多时候，我们都可以在各种框架应用中看到ZooKeeper的身影，比如Kafka中间件，Dubbo框架，Hadoop等等。为什么到处都看到ZooKeeper？ 一、什么是ZooKeeperZooKeeper是一个分布式服务协调框架，提供了分布式数据一致性的解决方案，基于ZooKeeper的数据结构，Watcher，选举机制等特点，可以实现数据的发布/订阅，软负载均衡，命名服务，统一配置管理，分布式锁，集群管理等等。 二、为什么使用ZooKeeperZooKeeper能保证： 更新请求顺序进行。来自同一个client的更新请求按其发送顺序依次执行 数据更新原子性。一次数据更新要么成功，要么失败 全局唯一数据视图。client无论连接到哪个server，数据视图都是一致的 实时性。在一定时间范围内，client读到的数据是最新的 三、数据结构ZooKeeper的数据结构和Unix文件系统很类似，总体上可以看做是一棵树，每一个节点称之为一个ZNode，每一个ZNode默认能存储1M的数据。每一个ZNode可通过唯一的路径标识。如下图所示： 创建ZNode时，可以指定以下四种类型，包括： PERSISTENT，持久性ZNode。创建后，即使客户端与服务端断开连接也不会删除，只有客户端主动删除才会消失。 PERSISTENT_SEQUENTIAL，持久性顺序编号ZNode。和持久性节点一样不会因为断开连接后而删除，并且ZNode的编号会自动增加。 EPHEMERAL，临时性ZNode。客户端与服务端断开连接，该ZNode会被删除。 EPEMERAL_SEQUENTIAL，临时性顺序编号ZNode。和临时性节点一样，断开连接会被删除，并且ZNode的编号会自动增加。 四、监听通知机制Watcher是基于观察者模式实现的一种机制。如果我们需要实现当某个ZNode节点发生变化时收到通知，就可以使用Watcher监听器。 客户端通过设置监视点（watcher）向 ZooKeeper 注册需要接收通知的 znode，在 znode 发生变化时 ZooKeeper 就会向客户端发送消息。 这种通知机制是一次性的。一旦watcher被触发，ZooKeeper就会从相应的存储中删除。如果需要不断监听ZNode的变化，可以在收到通知后再设置新的watcher注册到ZooKeeper。 监视点的类型有很多，如监控ZNode数据变化、监控ZNode子节点变化、监控ZNode 创建或删除。 五、选举机制ZooKeeper是一个高可用的应用框架，因为ZooKeeper是支持集群的。ZooKeeper在集群状态下，配置文件是不会指定Master和Slave，而是在ZooKeeper服务器初始化时就在内部进行选举，产生一台做为Leader，多台做为Follower，并且遵守半数可用原则。 由于遵守半数可用原则，所以5台服务器和6台服务器，实际上最大允许宕机数量都是3台，所以为了节约成本，集群的服务器数量一般设置为奇数。 如果在运行时，如果长时间无法和Leader保持连接的话，则会再次进行选举，产生新的Leader，以保证服务的可用。 六、初の体验首先在官网下载ZooKeeper，我这里用的是3.3.6版本。 然后解压，复制一下/conf目录下的zoo_sample.cfg文件，重命名为zoo.cfg。 修改zoo.cfg中dataDir的值，并创建对应的目录： 最后到/bin目录下启动，我用的是window系统，所以启动zkServer.cmd，双击即可： 启动成功的话就可以看到这个对话框： 可视化界面的话，我推荐使用ZooInspector，操作比较简便： 6.1 使用java连接ZooKeeper首先引入Maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 接着我们写一个Main方法，进行操作： 12345678910111213141516171819202122232425262728//连接地址及端口号private static final String SERVER_HOST = &quot;127.0.0.1:2181&quot;;//会话超时时间private static final int SESSION_TIME_OUT = 2000;public static void main(String[] args) throws Exception &#123; //参数一：服务端地址及端口号 //参数二：超时时间 //参数三：监听器 ZooKeeper zooKeeper = new ZooKeeper(SERVER_HOST, SESSION_TIME_OUT, new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; //获取事件的状态 Event.KeeperState state = watchedEvent.getState(); //判断是否是连接事件 if (Event.KeeperState.SyncConnected == state) &#123; Event.EventType type = watchedEvent.getType(); if (Event.EventType.None == type) &#123; System.out.println(&quot;zk客户端已连接...&quot;); &#125; &#125; &#125; &#125;); zooKeeper.create(&quot;/java&quot;, &quot;Hello World&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); System.out.println(&quot;新增ZNode成功&quot;); zooKeeper.close();&#125; 创建一个持久性ZNode，路径是/java，值为”Hello World”： 七、API概述7.1 创建1public String create(final String path, byte data[], List&lt;ACL&gt; acl, CreateMode createMode) 参数解释： path ZNode路径 data ZNode存储的数据 acl ACL权限控制 createMode ZNode类型 ACL权限控制，有三个是ZooKeeper定义的常用权限，在ZooDefs.Ids类中： 1234567891011121314151617/** * This is a completely open ACL. * 完全开放的ACL，任何连接的客户端都可以操作该属性znode */public final ArrayList&lt;ACL&gt; OPEN_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)));/** * This ACL gives the creators authentication id&#x27;s all permissions. * 只有创建者才有ACL权限 */public final ArrayList&lt;ACL&gt; CREATOR_ALL_ACL = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, AUTH_IDS)));/** * This ACL gives the world the ability to read. * 只能读取ACL */public final ArrayList&lt;ACL&gt; READ_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE))); createMode就是前面讲过的四种ZNode类型： 123456789101112131415161718public enum CreateMode &#123; /** * 持久性ZNode */ PERSISTENT (0, false, false), /** * 持久性自动增加顺序号ZNode */ PERSISTENT_SEQUENTIAL (2, false, true), /** * 临时性ZNode */ EPHEMERAL (1, true, false), /** * 临时性自动增加顺序号ZNode */ EPHEMERAL_SEQUENTIAL (3, true, true);&#125; 7.2 查询123456789//同步获取节点数据public byte[] getData(String path, boolean watch, Stat stat)&#123; ...&#125;//异步获取节点数据public void getData(final String path, Watcher watcher, DataCallback cb, Object ctx)&#123; ...&#125; 同步getData()方法中的stat参数是用于接收返回的节点描述信息： 12345678910public byte[] getData(final String path, Watcher watcher, Stat stat)&#123; //省略... GetDataResponse response = new GetDataResponse(); //发送请求到ZooKeeper服务器，获取到response ReplyHeader r = cnxn.submitRequest(h, request, response, wcb); if (stat != null) &#123; //把response的Stat赋值到传入的stat中 DataTree.copyStat(response.getStat(), stat); &#125;&#125; 使用同步getData()获取数据： 1234567//数据的描述信息，包括版本号，ACL权限，子节点信息等等Stat stat = new Stat();//返回结果是byte[]数据，getData()方法底层会把描述信息复制到stat对象中byte[] bytes = zooKeeper.getData(&quot;/java&quot;, false, stat);//打印结果System.out.println(&quot;ZNode的数据data:&quot; + new String(bytes));//Hello WorldSystem.out.println(&quot;获取到dataVersion版本号:&quot; + stat.getVersion());//默认数据版本号是0 7.3 更新123public Stat setData(final String path, byte data[], int version)&#123; ...&#125; 值得注意的是第三个参数version，使用CAS机制，这是为了防止多个客户端同时更新节点数据，所以需要在更新时传入版本号，每次更新都会使版本号+1，如果服务端接收到版本号，对比发现不一致的话，则会抛出异常。 所以，在更新前需要先查询获取到版本号，否则你不知道当前版本号是多少，就没法更新： 1234567//获取节点描述信息Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, false, stat);System.out.println(&quot;更新ZNode数据...&quot;);//更新操作，传入路径，更新值，版本号三个参数,返回结果是新的描述信息Stat setData = zooKeeper.setData(&quot;/java&quot;, &quot;fly!!!&quot;.getBytes(), stat.getVersion());System.out.println(&quot;更新后的版本号为：&quot; + setData.getVersion());//更新后的版本号为：1 更新后，版本号增加了： 如果传入的版本参数是”-1”，就是告诉zookeeper服务器，客户端需要基于数据的最新版本进行更新操作。但是-1并不是一个合法的版本号，而是一个标识符。 7.4 删除123public void delete(final String path, int version)&#123; ...&#125; path 删除节点的路径 version 版本号 这里也需要传入版本号，调用getData()方法即可获取到版本号，很简单： 1234Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, false, stat);//删除ZNodezooKeeper.delete(&quot;/java&quot;, stat.getVersion()); 7.5 watcher机制在上面第三点提到，ZooKeeper是可以使用通知监听机制，当ZNode发生变化会收到通知消息，进行处理。基于watcher机制，ZooKeeper能玩出很多花样。怎么使用？ ZooKeeper的通知监听机制，总的来说可以分为三个过程： ①客户端注册 Watcher②服务器处理 Watcher③客户端回调 Watcher客户端。 注册 watcher 有 4 种方法，new ZooKeeper()、getData()、exists()、getChildren()。下面演示一下使用exists()方法注册watcher： 首先需要实现Watcher接口，新建一个监听器： 1234567891011121314public class MyWatcher implements Watcher &#123; @Override public void process(WatchedEvent event) &#123; //获取事件类型 Event.EventType eventType = event.getType(); //通知状态 Event.KeeperState eventState = event.getState(); //节点路径 String eventPath = event.getPath(); System.out.println(&quot;监听到的事件类型:&quot; + eventType.name()); System.out.println(&quot;监听到的通知状态:&quot; + eventState.name()); System.out.println(&quot;监听到的ZNode路径:&quot; + eventPath); &#125;&#125; 然后调用exists()方法，注册监听器： 123zooKeeper.exists(&quot;/java&quot;, new MyWatcher());//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1); 然后在控制台就可以看到打印的信息： 这里我们可以看到Event.EventType对象就是事件类型，我们可以对事件类型进行判断，再配合Event.KeeperState通知状态，做相关的业务处理，事件类型有哪些？ 打开EventType、KeeperState的源码查看： 1234567891011121314151617181920//事件类型是一个枚举public enum EventType &#123; None (-1),//无 NodeCreated (1),//Watcher监听的数据节点被创建 NodeDeleted (2),//Watcher监听的数据节点被删除 NodeDataChanged (3),//Watcher监听的数据节点内容发生变更 NodeChildrenChanged (4);//Watcher监听的数据节点的子节点列表发生变更&#125;//通知状态也是一个枚举public enum KeeperState &#123; Unknown (-1),//属性过期 Disconnected (0),//客户端与服务端断开连接 NoSyncConnected (1),//属性过期 SyncConnected (3),//客户端与服务端正常连接 AuthFailed (4),//身份认证失败 ConnectedReadOnly (5),//返回这个状态给客户端，客户端只能处理读请求 SaslAuthenticated(6),//服务器采用SASL做校验时 Expired (-112);//会话session失效&#125; 7.5.1 watcher的特性 一次性。一旦watcher被触发，ZK都会从相应的存储中移除。 12345678910zooKeeper.exists(&quot;/java&quot;, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; System.out.println(&quot;我是exists()方法的监听器&quot;); &#125;&#125;);//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), -1);//企图第二次触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;spring&quot;.getBytes(), -1); 串行执行。客户端Watcher回调的过程是一个串行同步的过程，这是为了保证顺序。123456789101112131415zooKeeper.exists(&quot;/java&quot;, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; System.out.println(&quot;我是exists()方法的监听器&quot;); &#125;&#125;);Stat stat = new Stat();zooKeeper.getData(&quot;/java&quot;, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; System.out.println(&quot;我是getData()方法的监听器&quot;); &#125;&#125;, stat);//对ZNode进行更新数据的操作，触发监听器zooKeeper.setData(&quot;/java&quot;, &quot;fly&quot;.getBytes(), stat.getVersion()); 打印结果，说明先调用exists()方法的监听器，再调用getData()方法的监听器。因为exists()方法先注册了。 轻量级。WatchedEvent是ZK整个Watcher通知机制的最小通知单元。WatchedEvent包含三部分：通知状态，事件类型，节点路径。Watcher通知仅仅告诉客户端发生了什么事情，而不会说明事件的具体内容。 写在最后我记得B站的UP主李永乐说过，只有你让更多的人生活变得更美好时，自己的生活才能变得更美好。 这句话也是我今年开始写技术分享的一个动力源泉，希望这篇文章对你有用~ 著名的飞行家马老师说过：回城是收费的，而点赞是免费的~","categories":[],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://alloceee.github.io/tags/zookeeper/"},{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"}]},{"title":"从秒杀聊到ZooKeeper分布式锁","slug":"分布式/从秒杀聊到ZooKeeper分布式锁","date":"2020-07-26T06:03:52.000Z","updated":"2021-08-04T03:17:18.533Z","comments":true,"path":"2020/07/26/分布式/从秒杀聊到ZooKeeper分布式锁/","link":"","permalink":"https://alloceee.github.io/2020/07/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%BB%8E%E7%A7%92%E6%9D%80%E8%81%8A%E5%88%B0ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"思维导图 前言经过《ZooKeeper入门》后，我们学会了ZooKeeper的基本用法。 实际上ZooKeeper的应用是非常广泛的，实现分布式锁只是其中一种。接下来我们就ZooKeeper实现分布式锁解决秒杀超卖问题进行展开。 一、什么是秒杀超卖问题秒杀活动应该都不陌生，不用过多解释。 不难想象，在这种”秒杀”的场景中，实际上会出现多个用户争抢”资源”的情况，也就是多个线程同时并发，这种情况是很容易出现数据不准确，也就是超卖问题。 1.1 项目演示下面使用程序演示，我使用了SpringBoot2.0、Mybatis、Mybatis-Plus、SpringMVC搭建了一个简单的项目，github地址： https://github.com/yehongzhi/mall 创建一个商品信息表： 12345678CREATE TABLE `tb_commodity_info` ( `id` varchar(32) NOT NULL, `commodity_name` varchar(512) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `commodity_price` varchar(36) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品价格&#x27;, `number` int(10) DEFAULT &#x27;0&#x27; COMMENT &#x27;商品数量&#x27;, `description` varchar(2048) DEFAULT &#x27;&#x27; COMMENT &#x27;商品描述&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;商品信息表&#x27;; 添加一个商品[叉烧包]进去： 核心的代码逻辑是这样的： 1234567891011121314151617181920@Overridepublic boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception &#123; //1.先查询数据库中商品的数量 TbCommodityInfo commodityInfo = commodityInfoMapper.selectById(commodityId); //2.判断商品数量是否大于0，或者购买的数量大于库存 Integer count = commodityInfo.getNumber(); if (count &lt;= 0 || number &gt; count) &#123; //商品数量小于或者等于0，或者购买的数量大于库存，则返回false return false; &#125; //3.如果库存数量大于0，并且购买的数量小于或者等于库存。则更新商品数量 count -= number; commodityInfo.setNumber(count); boolean bool = commodityInfoMapper.updateById(commodityInfo) == 1; if (bool) &#123; //如果更新成功，则打印购买商品成功 System.out.println(&quot;购买商品[ &quot; + commodityInfo.getCommodityName() + &quot; ]成功,数量为：&quot; + number); &#125; return bool;&#125; 逻辑示意图如下： 上面这个逻辑，如果单线程请求的话是没有问题的。 但是多线程的话就出现问题了。现在我就创建多个线程，通过HttpClient进行请求，看会发生什么： 1234567891011121314public static void main(String[] args) throws Exception &#123; //请求地址 String url = &quot;http://localhost:8080/mall/commodity/purchase&quot;; //请求参数，商品ID，数量 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;); map.put(&quot;number&quot;, &quot;1&quot;); //创建10个线程通过HttpClient进行发送请求，测试 for (int i = 0; i &lt; 10; i++) &#123; //这个线程的逻辑仅仅是发送请求 CommodityThread commodityThread = new CommodityThread(url, map); commodityThread.start(); &#125;&#125; 说明一下，叉烧包的数量是100，这里有10个线程同时去购买，假设都购买成功的话，库存数量应该是90。 实际上，10个线程的确都购买成功了： 但是数据库的商品库存，却不准确： 二、尝试使用本地锁上面的场景，大概流程如下所示： 可以看出问题的关键在于两个线程”同时”去查询剩余的库存，然后更新库存导致的。要解决这个问题，其实只要保证多个线程在这段逻辑是顺序执行即可，也就是加锁。 本地锁JDK提供有两种：synchronized和Lock锁。 两种方式都可以，我这里为了简便，使用synchronized： 12345//使用synchronized修饰方法@Overridepublic synchronized boolean purchaseCommodityInfo(String commodityId, Integer number) throws Exception &#123; //省略...&#125; 然后再测试刚刚多线程并发抢购的情况，看看结果： 问题得到解决！！！ 你以为事情就这样结束了吗，看了看进度条，发现事情并不简单。 我们知道在实际项目中，往往不会只部署一台服务器，所以不妨我们启动两台服务器，端口号分别是8080、8081，模拟实际项目的场景： 写一个交替请求的测试脚本，模拟多台服务器分别处理请求，用户秒杀抢购的场景： 123456789101112131415public static void main(String[] args) throws Exception &#123; //请求地址 String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;; //请求参数，商品ID，数量 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;); map.put(&quot;number&quot;, &quot;1&quot;); //创建10个线程通过HttpClient进行发送请求，测试 for (int i = 0; i &lt; 10; i++) &#123; //8080、8081交替请求，每个服务器处理5个请求 String port = &quot;808&quot; + (i % 2); CommodityThread commodityThread = new CommodityThread(String.format(url, port), map); commodityThread.start(); &#125;&#125; 首先看购买的情况，肯定都是购买成功的: 关键是库存数量是否正确： 有10个请求购买成功，库存应该是90才对，这里库存是95。事实证明本地锁是不能解决多台服务器秒杀抢购出现超卖的问题。 为什么会这样呢，请看示意图： 其实和多线程问题是差不多的原因，多个服务器去查询数据库，获取到相同的库存，然后更新库存，导致数据不正确。要保证库存的数量正确，关键在于多台服务器要保证只能一台服务器在执行这段逻辑，也就是要加分布式锁。 这也体现出分布式锁的作用，就是要保证多台服务器只能有一台服务器执行。 分布式锁有三种实现方式，分别是redis、ZooKeeper、数据库(比如mysql)。 三、使用ZooKeeper实现分布式锁3.1 原理实际上是利用ZooKeeper的临时顺序节点的特性实现分布式锁。怎么实现呢？ 假设现在有一个客户端A，需要加锁，那么就在”/Lock”路径下创建一个临时顺序节点。然后获取”/Lock”下的节点列表，判断自己的序号是否是最小的，如果是最小的序号，则加锁成功！ 现在又有另一个客户端，客户端B需要加锁，那么也是在”/Lock”路径下创建临时顺序节点。依然获取”/Lock”下的节点列表，判断自己的节点序号是否最小的。发现不是最小的，加锁失败，接着对自己的上一个节点进行监听。 怎么释放锁呢，其实就是把临时节点删除。假设客户端A释放锁，把节点01删除了。那就会触发节点02的监听事件，客户端就再次获取节点列表，然后判断自己是否是最小的序号，如果是最小序号则加锁。 如果多个客户端其实也是一样，一上来就会创建一个临时节点，然后开始判断自己是否是最小的序号，如果不是就监听上一个节点，形成一种排队的机制。也就形成了锁的效果，保证了多台服务器只有一台执行。 假设其中有一个客户端宕机了，根据临时节点的特点，ZooKeeper会自动删除对应的临时节点，相当于自动释放了锁。 3.2 手写代码实现分布式锁首先加入Maven依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.4&lt;/version&gt;&lt;/dependency&gt; 接着按照上面分析的思路敲代码，创建ZkLock类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class ZkLock implements Lock &#123; //计数器，用于加锁失败时，阻塞 private static CountDownLatch cdl = new CountDownLatch(1); //ZooKeeper服务器的IP端口 private static final String IP_PORT = &quot;127.0.0.1:2181&quot;; //锁的根路径 private static final String ROOT_NODE = &quot;/Lock&quot;; //上一个节点的路径 private volatile String beforePath; //当前上锁的节点路径 private volatile String currPath; //创建ZooKeeper客户端 private ZkClient zkClient = new ZkClient(IP_PORT); public ZkLock() &#123; //判断是否存在根节点 if (!zkClient.exists(ROOT_NODE)) &#123; //不存在则创建 zkClient.createPersistent(ROOT_NODE); &#125; &#125; //加锁 public void lock() &#123; if (tryLock()) &#123; System.out.println(&quot;加锁成功！！&quot;); &#125; else &#123; // 尝试加锁失败，进入等待 监听 waitForLock(); // 再次尝试加锁 lock(); &#125; &#125; //尝试加锁 public synchronized boolean tryLock() &#123; // 第一次就进来创建自己的临时节点 if (StringUtils.isBlank(currPath)) &#123; currPath = zkClient.createEphemeralSequential(ROOT_NODE + &quot;/&quot;, &quot;lock&quot;); &#125; // 对节点排序 List&lt;String&gt; children = zkClient.getChildren(ROOT_NODE); Collections.sort(children); // 当前的是最小节点就返回加锁成功 if (currPath.equals(ROOT_NODE + &quot;/&quot; + children.get(0))) &#123; return true; &#125; else &#123; // 不是最小节点 就找到自己的前一个 依次类推 释放也是一样 int beforePathIndex = Collections.binarySearch(children, currPath.substring(ROOT_NODE.length() + 1)) - 1; beforePath = ROOT_NODE + &quot;/&quot; + children.get(beforePathIndex); //返回加锁失败 return false; &#125; &#125; //解锁 public void unlock() &#123; //删除节点并关闭客户端 zkClient.delete(currPath); zkClient.close(); &#125; //等待上锁，加锁失败进入阻塞，监听上一个节点 private void waitForLock() &#123; IZkDataListener listener = new IZkDataListener() &#123; //监听节点更新事件 public void handleDataChange(String s, Object o) throws Exception &#123; &#125; //监听节点被删除事件 public void handleDataDeleted(String s) throws Exception &#123; //解除阻塞 cdl.countDown(); &#125; &#125;; // 监听上一个节点 this.zkClient.subscribeDataChanges(beforePath, listener); //判断上一个节点是否存在 if (zkClient.exists(beforePath)) &#123; //上一个节点存在 try &#123; System.out.println(&quot;加锁失败 等待&quot;); //加锁失败，阻塞等待 cdl.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 释放监听 zkClient.unsubscribeDataChanges(beforePath, listener); &#125; public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; public void lockInterruptibly() throws InterruptedException &#123; &#125; public Condition newCondition() &#123; return null; &#125;&#125; 在Controller层加上锁： 12345678910111213141516171819@PostMapping(&quot;/purchase&quot;)public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception &#123; boolean bool; //获取ZooKeeper分布式锁 ZkLock zkLock = new ZkLock(); try &#123; //上锁 zkLock.lock(); //调用秒杀抢购的service方法 bool = commodityInfoService.purchaseCommodityInfo(commodityId, number); &#125; catch (Exception e) &#123; e.printStackTrace(); bool = false; &#125; finally &#123; //解锁 zkLock.unlock(); &#125; return bool;&#125; 测试，依然起两台服务器，8080、8081。然后跑测试脚本： 123456789101112131415public static void main(String[] args) throws Exception &#123; //请求地址 String url = &quot;http://localhost:%s/mall/commodity/purchase&quot;; //请求参数，商品ID，数量 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;commodityId&quot;, &quot;4f863bb5266b9508e0c1f28c61ea8de1&quot;); map.put(&quot;number&quot;, &quot;1&quot;); //创建10个线程通过HttpClient进行发送请求，测试 for (int i = 0; i &lt; 10; i++) &#123; //8080、8081交替请求 String port = &quot;808&quot; + (i % 2); CommodityThread commodityThread = new CommodityThread(String.format(url, port), map); commodityThread.start(); &#125;&#125; 结果正确： 3.3 造好的轮子Curator是Apache开源的一个操作ZooKeeper的框架。其中就有实现ZooKeeper分布式锁的功能。 当然分布式锁的实现只是这个框架的其中一个很小的部分，除此之外还有很多用途，大家可以到官网去学习。 首先添加Maven依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 还是一样在需要加锁的地方进行加锁： 12345678910111213141516171819202122232425@PostMapping(&quot;/purchase&quot;)public boolean purchaseCommodityInfo(@RequestParam(name = &quot;commodityId&quot;) String commodityId, @RequestParam(name = &quot;number&quot;) Integer number) throws Exception &#123; boolean bool = false; //设置重试策略 RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;127.0.0.1:2181&quot;, retryPolicy); // 启动客户端 client.start(); InterProcessMutex mutex = new InterProcessMutex(client, &quot;/locks&quot;); try &#123; //加锁 if (mutex.acquire(3, TimeUnit.SECONDS)) &#123; //调用抢购秒杀service方法 bool = commodityInfoService.purchaseCommodityInfo(commodityId, number); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //解锁 mutex.release(); client.close(); &#125; return bool;&#125; 四、遇到的坑我尝试用原生的ZooKeeper写分布式锁，有点炸裂。遇到不少坑，最终放弃了，用zkclient的API。可能我太菜了不太会用。 下面我分享我遇到的一些问题，希望你们在遇到同类型的异常时能迅速定位问题。 4.1 Session expired这个错误是使用原生ZooKeeper的API出现的错误。主要是我在进入debug模式进行调试出现的。 因为原生的ZooKeeper需要设定一个会话超时时间，一般debug模式我们都会卡在一个地方去调试，肯定就超出了设置的会话时间~ 4.2 KeeperErrorCode = ConnectionLoss这个也是原生ZooKeeper的API的错误，怎么出现的呢？ 主要是创建的ZooKeeper客户端连接服务器时是异步的，由于连接需要时间，还没连接成功，代码已经开始执行create()或者exists()，然后就报这个错误。 解决方法：使用CountDownLatch计数器阻塞，连接成功后再停止阻塞，然后执行create()或者exists()等操作。 4.3 并发查询更新出现数据不一致这个错误真的太炸裂了~ 一开始我是把分布式锁加在service层，然后以为搞定了。接着启动8080、8081进行并发测试。10个线程都是购买成功，结果居然是不正确！ 第一反应觉得自己实现的代码有问题，于是换成curator框架实现的分布式锁，开源框架应该没问题了吧。没想到还是不行~ 既然不是锁本身的问题，是不是事务问题。上一个事务更新库存的操作还没提交，然后下一个请求就进来查询。于是我就把加锁的范围放大一点，放在Controller层。居然成功了！ 你可能已经注意到，我在上面的例子就是把分布式锁加在Controller层，其实我不太喜欢在Controller层写太多代码。 也许有更加优雅的方式，可惜本人能力不足，如果你有更好的实现方式，可以分享一下~ 补充：下面评论有位大佬说，在原来的方法外再包裹一层，亲测是可以的。这应该是事务的问题。 上面放在Controller层可以成功是不是因为Controller层没有事务，原来写在service我是写了一个@Transactional注解在类上，所以整个类里面的都有事务，所以解锁后还没提交事务去更新数据库，然后下一个请求进来就查到了没更新的数据。 为了优雅一点，就把@Transactional注解放在抢购的service方法上 然后再包裹一个没有事务的方法，用于上锁。 五、总结最后，我们回顾总结一下吧： 首先我们模拟单机多线程的秒杀场景，单机的话可以使用本地锁解决问题。 接着模拟多服务器多线程的场景，思路是使用ZooKeeper实现分布式锁解决。 图解ZooKeeper实现分布式锁的原理。 然后动手写代码，实现分布式锁。 最后总结遇到的坑。 希望这篇文章对你有用 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://alloceee.github.io/tags/zookeeper/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://alloceee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]},{"title":"HTTP和HTTPS的区别","slug":"计算机网络/HTTP和HTTPS的区别","date":"2020-07-15T03:21:02.000Z","updated":"2020-07-15T03:23:42.000Z","comments":true,"path":"2020/07/15/计算机网络/HTTP和HTTPS的区别/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"HTTP和HTTPS的区别HTTP明文传输，不安全 数据容易被拦截、篡改和攻击 HTTPS数据加密 身份验证 数据完整性 对称加密对称加密就是一个密钥，可以加密也可以解密 非对称加密非对称加密就是公钥加密，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密 HTTPS 请求HTTPS连接获取证书（公钥） 客户端给服务器发送（对称加密&lt;公钥&gt;）：随机数 的密文 客户端同时给服务器发送：（对称加密&lt;公钥&gt;）：随机数 + 私钥 的密文 服务器根据公钥解密出随机数，同时解密出私钥 客户端使用非对称加密进行数据传输，客户端使用公钥加密，服务器使用私钥解密","categories":[],"tags":[{"name":"HTTP和HTTPS","slug":"HTTP和HTTPS","permalink":"https://alloceee.github.io/tags/HTTP%E5%92%8CHTTPS/"}]},{"title":"ElasticSearch的使用","slug":"搜索引擎/搜索引擎-ElasticSearch","date":"2020-07-15T03:21:02.000Z","updated":"2020-07-15T03:22:04.000Z","comments":true,"path":"2020/07/15/搜索引擎/搜索引擎-ElasticSearch/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-ElasticSearch/","excerpt":"","text":"ElasticSearchWindows下安装elasticsearch在安装Elasticsearch引擎之前，必须安装ES需要的软件环境 注意：安装elasticsearch7.4运行需要jdk11及以上 elasticsearch与jdk有依赖关系 下载地址 配置环境变量 测试运行 点击/bin目录下的elasticsearch.bat开始安装 安装elasticsearch的head插件 es5以上版本安装head需要安装node和grunt(之前的直接用plugin命令即可安装) (一)从地址：https://nodejs.org/en/download/ 下载相应系统的msi，双击安装。 （二）安装完成用cmd进入安装目录执行 node -v可查看版本号 （三）执行 npm install -g grunt-cli 安装grunt ，安装完成后执行grunt -version查看是否安装成功，会显示安装的版本号 （四）开始安装head① 进入安装目录下的config目录，修改elasticsearch.yml文件.在文件的末尾加入以下代码 http.cors.enabled: true http.cors.allow-origin: “*” node.master: true node.data: true 然后去掉network.host: 192.168.0.1的注释并改为network.host: 0.0.0.0，去掉cluster.name；node.name；http.port的注释（也就是去掉#） elasticsearch-7.1.1 版本 yml文件需要这个 cluster.initial_master_nodes: [“node-1”] ②双击elasticsearch.bat重启es③在https://github.com/mobz/elasticsearch-head中下载head插件，选择下载zip ④解压到指定文件夹下，G:\\elasticsearch-6.4.1\\elasticsearch-head-master 进入该文件夹，修改G:\\elasticsearch-6.4.1\\elasticsearch-head-master\\Gruntfile.js 在对应的位置加上hostname:’*’ ⑤在G:\\elasticsearch-6.6.2\\elasticsearch-head-master 下执行npm install 安装完成后执行grunt server 或者npm run start 运行head插件，如果不成功重新安装grunt。成功如下 ⑥浏览器下访问http://localhost:9100/ 整合springboot参考博客 https://segmentfault.com/a/1190000018625101?utm_source=tag-newest https://blog.csdn.net/chen_2890/article/details/83895646 properties 123spring.data.elasticsearch.cluster-name=elasticsearchspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300spring.data.elasticsearch.repositories.enabled=true pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--集合工具包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;19.0&lt;/version&gt; &lt;/dependency&gt; ```java/** * * @Description:matchQuery *@Author: https://blog.csdn.net/chen_2890 */ @Test public void testMathQuery()&#123; // 创建对象 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 在queryBuilder对象中自定义查询 //matchQuery:底层就是使用的termQuery queryBuilder.withQuery(QueryBuilders.matchQuery(&quot;title&quot;,&quot;坚果&quot;)); //查询，search 默认就是分页查找 Page&lt;Item&gt; page = this.itemRepository.search(queryBuilder.build()); //获取数据 long totalElements = page.getTotalElements(); System.out.println(&quot;获取的总条数:&quot;+totalElements); for(Item item:page)&#123; System.out.println(item); &#125; } 12345678910111213141516171819202122 ```java /** * @Description: * termQuery:功能更强大，除了匹配字符串以外，还可以匹配 * int/long/double/float/.... * @Author: https://blog.csdn.net/chen_2890 */ @Test public void testTermQuery()&#123; NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery(QueryBuilders.termQuery(&quot;price&quot;,998.0)); // 查找 Page&lt;Item&gt; page = this.itemRepository.search(builder.build()); for(Item item:page)&#123; System.out.println(item); &#125; &#125; 12345678910111213/** * @Description:布尔查询 * @author: https://blog.csdn.net/chen_2890 */ @Test public void testBooleanQuery() &#123; NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery(QueryBuilders.boolQuery().must(QueryBuilders.matchQuery(&quot;title&quot;,&quot;华为&quot;)).must(QueryBuilders.matchQuery(&quot;brand&quot;, &quot;华为&quot;))); // 查找 Page&lt;Item&gt; page = this.itemRepository.search(builder.build()); for (Item item : page) &#123; System.out.println(item); &#125; &#125; 123456789101112131415/** * @Description:模糊查询 uthor: https://blog.csdn.net/chen_2890 */ @Test public void testFuzzyQuery()&#123; NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery(QueryBuilders.fuzzyQuery(&quot;title&quot;,&quot;faceoooo&quot;)); Page&lt;Item&gt; page = this.itemRepository.search(builder.build()); for(Item item:page)&#123; System.out.println(item); &#125; &#125; Elasticsearch－基础介绍及索引原理分析最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。 介绍Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作: 分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。 实时分析的分布式搜索引擎。 可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。 基本概念先说Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据： 12345678&#123; &quot;name&quot; : &quot;John&quot;, &quot;sex&quot; : &quot;Male&quot;, &quot;age&quot; : 25, &quot;birthDate&quot;: &quot;1990/05/01&quot;, &quot;about&quot; : &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]&#125; 用Mysql这样的数据库存储就会容易想到建立一张User表，有balabala的字段等，在Elasticsearch里这就是一个文档，当然这个文档会属于一个User的类型，各种各样的类型存在于一个索引当中。这里有一份简易的将Elasticsearch和关系型数据术语对照表: 123关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)Elasticsearch ⇒ 索引(Index) ⇒ 类型(type) ⇒ 文档(Docments) ⇒ 字段(Fields) 一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求： 12345678PUT /megacorp/employee/1 &#123; &quot;name&quot; : &quot;John&quot;, &quot;sex&quot; : &quot;Male&quot;, &quot;age&quot; : 25, &quot;about&quot; : &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]&#125; 更新，查询也是类似这样的操作，具体操作手册可以参见Elasticsearch权威指南 索引Elasticsearch最关键的就是提供强大的索引能力了，其实InfoQ的这篇时间序列数据库的秘密(2)——索引写的非常好，我这里也是围绕这篇结合自己的理解进一步梳理下，也希望可以帮助大家更好的理解这篇文章。 Elasticsearch索引的精髓： 一切设计都是为了提高搜索的性能 另一层意思：为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了。前面看到往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如上面例子中的name, sex, age, about, interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默1的为这些字段建立索引–倒排索引，因为Elasticsearch最核心功能是搜索。 Elasticsearch是如何做到快速索引的InfoQ那篇文章里说Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？ 什么是B-Tree索引?上大学读书时老师教过我们，二叉树查找效率是logN，同时插入新的节点不必移动全部节点，所以用树型结构存储索引，能同时兼顾插入和查询的性能。因此在这个基础上，再结合磁盘的读取特性(顺序读/随机读)，传统关系型数据库采用了B-Tree/B+Tree这样的数据结构： 为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，一次寻道读取多个数据，同时也降低树的高度。 什么是倒排索引? 继续上面的例子，假设有这么几条数据(为了简单，去掉about, interests这两个field): 12345| ID | Name | Age | Sex || -- |:------------:| -----:| -----:| | 1 | Kate | 24 | Female| 2 | John | 24 | Male| 3 | Bill | 29 | Male ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下: Name: 12345| Term | Posting List || -- |:----:|| Kate | 1 || John | 2 || Bill | 3 | Age: 1234| Term | Posting List || -- |:----:|| 24 | [1,2] || 29 | 3 | Sex: 1234| Term | Posting List || -- |:----:|| Female | 1 || Male | [2,3] | Posting ListElasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。 看到这里，不要认为就结束了，精彩的部分才刚开始… 通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？ Term DictionaryElasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B-Tree的查询快呢？ Term IndexB-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树： 这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。 所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。 这时候爱提问的小明又举手了:”那个FST是神马东东啊?” 一看就知道小明是一个上大学读书的时候跟我一样不认真听课的孩子，数据结构老师一定讲过什么是FST。但没办法，我也忘了，这里再补下课： FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output. 假设我们现在要将mop, moth, pop, star, stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;string, integer=””&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：FST(理论依据在此，但我相信99%的人不会认真看完的) ⭕️表示一种状态 –&gt;表示状态的变化过程，上面的字母/数字表示状态变化和权重 将单词分成单个字母通过⭕️和–&gt;表示出来，0权重不显示。如果⭕️后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号。 FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output. FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。 后面的更精彩，看累了的同学可以喝杯咖啡…… 压缩技巧Elasticsearch里除了上面说到用FST压缩term index外，对posting list也有压缩技巧。小明喝完咖啡又举手了:”posting list不是已经只存储文档id了吗？还需要压缩？” 嗯，我们再看回最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时传统关系型数据库已经哭晕在厕所……)，会怎样？如果有上千万个同学，而世界上只有男/女这样两个性别，每个posting list都会有至少百万个文档id。 Elasticsearch是如何有效的对这些文档id压缩的呢？ Frame Of Reference 增量编码压缩，将大数变小数，按字节存储 首先，Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)，这样做的一个好处是方便压缩，看下面这个图例： 如果数学不是体育老师教的话，还是比较容易看出来这种压缩技巧的。 原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。 Roaring bitmaps说到Roaring bitmaps，就必须先从bitmap说起。Bitmap是一种数据结构，假设有某个posting list： [1,3,4,7,10] 对应的bitmap就是： [1,0,1,1,0,0,1,0,0,1] 非常直观，用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构。 Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性： 将posting list按照65535为界限分块，比如第一块所包含的文档id范围在065535之间，第二块的id范围是65536131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。 细心的小明这时候又举手了:”为什么是以65535为界限?” 程序员的世界里除了1024外，65535也是一个经典值，因为它=2^16-1，正好是用2个字节能表示的最大数，一个short的存储单位，注意到上图里的最后一行“If a block has more than 4096 values, encode as a bit set, and otherwise as a simple array using 2 bytes per value”，如果是大块，用节省点用bitset存，小块就豪爽点，2个字节我也不计较了，用一个short[]存着方便。 那为什么用4096来区分大块还是小块呢？ 个人理解：都说程序员的世界是二进制的，4096*2bytes ＝ 8192bytes &lt; 1KB, 磁盘一次寻道可以顺序把一个小块的内容都读出来，再大一位就超过1KB了，需要两次读。 联合索引上面说了半天都是单field索引，如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？ 利用跳表(Skip list)的数据结构快速做“与”运算，或者 利用上面提到的bitset按位“与” 先看看跳表的数据结构： 将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如55，先找到level2的31，再找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的。 假设有下面三个posting list需要联合索引： 如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。 如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。 总结和思考Elasticsearch的索引思路: 将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。 所以，对于使用Elasticsearch进行索引时需要注意: 不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的 同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的 选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询 关于最后一点，个人认为有多个因素: 其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高； 另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数，具体可以参考这篇如何选择一个高效的全局ID方案(评论也很精彩) 1.启动内存不足 12345678[es@VM_0_6_centos bin]$ ./elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=NOpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (mmap) failed to map 986513408 bytes for committing reserved memory.# An error report file with more information is saved as:# /home/tom/data/elasticsearch-6.2.2/hs_err_pid1439.log 123[es@VM_0_6_centos config]$ lselasticsearch.yml jvm.options log4j2.properties[es@VM_0_6_centos config]$ vim jvm.options #修改内容 -Xms200m -Xmx200m 12[es@VM_0_6_centos bin]$ ./elasticsearch -d[es@VM_0_6_centos bin]$ OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N 启动正常","categories":[],"tags":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://alloceee.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}]},{"title":"HTTPS","slug":"计算机网络/HTTPS","date":"2020-07-15T03:21:02.000Z","updated":"2020-07-16T03:30:10.000Z","comments":true,"path":"2020/07/15/计算机网络/HTTPS/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/","excerpt":"","text":"下面我们来一起学习一下 HTTPS ，首先问你一个问题，为什么有了 HTTP 之后，还需要有 HTTPS ？我突然有个想法，为什么我们面试的时候需要回答标准答案呢？为什么我们不说出我们自己的想法和见解，却要记住一些所谓的标准回答呢？技术还有正确与否吗？ HTTPS 为什么会出现一个新技术的出现必定是为了解决某种问题的，那么 HTTPS 解决了 HTTP 的什么问题呢？ HTTPS 解决了什么问题一个简单的回答可能会是 HTTP 它不安全。由于 HTTP 天生明文传输的特性，在 HTTP 的传输过程中，任何人都有可能从中截获、修改或者伪造请求发送，所以可以认为 HTTP 是不安全的；在 HTTP 的传输过程中不会验证通信方的身份，因此 HTTP 信息交换的双方可能会遭到伪装，也就是没有用户验证；在 HTTP 的传输过程中，接收方和发送方并不会验证报文的完整性，综上，为了解决上述问题，HTTPS 应用而生。 什么是 HTTPS你还记得 HTTP 是怎么定义的吗？HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol) 协议，它 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范，那么我们看一下 HTTPS 是如何定义的 HTTPS 的全称是 Hypertext Transfer Protocol Secure，它用来在计算机网络上的两个端系统之间进行安全的交换信息(secure communication)，它相当于在 HTTP 的基础上加了一个 Secure 安全的词眼，那么我们可以给出一个 HTTPS 的定义：HTTPS 是一个在计算机世界里专门在两点之间安全的传输文字、图片、音频、视频等超文本数据的约定和规范。HTTPS 是 HTTP 协议的一种扩展，它本身并不保传输的证安全性，那么谁来保证安全性呢？在 HTTPS 中，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。 HTTPS 做了什么HTTPS 协议提供了三个关键的指标 加密(Encryption)， HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息。 数据一致性(Data integrity)，数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么。 身份认证(Authentication)，是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。 有了上面三个关键指标的保证，用户就可以和服务器进行安全的交换信息了。那么，既然你说了 HTTPS 的种种好处，那么我怎么知道网站是用 HTTPS 的还是 HTTP 的呢？给你两幅图应该就可以解释了。 HTTPS 协议其实非常简单，RFC 文档很小，只有短短的 7 页，里面规定了新的协议名，默认端口号443，至于其他的应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。 也就是说，除了协议名称和默认端口号外（HTTP 默认端口 80），HTTPS 协议在语法、语义上和 HTTP 一样，HTTP 有的，HTTPS 也照单全收。那么，HTTPS 如何做到 HTTP 所不能做到的安全性呢？关键在于这个 S 也就是 SSL/TLS 。 什么是 SSL/TLS认识 SSL/TLSTLS(Transport Layer Security) 是 SSL(Secure Socket Layer) 的后续版本，它们是用于在互联网两台计算机之间用于身份验证和加密的一种协议。 注意：在互联网中，很多名称都可以进行互换。 我们都知道一些在线业务（比如在线支付）最重要的一个步骤是创建一个值得信赖的交易环境，能够让客户安心的进行交易，SSL/TLS 就保证了这一点，SSL/TLS 通过将称为 X.509 证书的数字文档将网站和公司的实体信息绑定到加密密钥来进行工作。每一个密钥对(key pairs) 都有一个 私有密钥(private key) 和 公有密钥(public key)，私有密钥是独有的，一般位于服务器上，用于解密由公共密钥加密过的信息；公有密钥是公有的，与服务器进行交互的每个人都可以持有公有密钥，用公钥加密的信息只能由私有密钥来解密。 什么是 X.509：X.509 是公开密钥证书的标准格式，这个文档将加密密钥与（个人或组织）进行安全的关联。 X.509 主要应用如下 SSL/TLS 和 HTTPS 用于经过身份验证和加密的 Web 浏览 通过 S/MIME 协议签名和加密的电子邮件 代码签名：它指的是使用数字证书对软件应用程序进行签名以安全分发和安装的过程。 通过使用由知名公共证书颁发机构（例如SSL.com）颁发的证书对软件进行数字签名，开发人员可以向最终用户保证他们希望安装的软件是由已知且受信任的开发人员发布；并且签名后未被篡改或损害。 还可用于文档签名 还可用于客户端认证 政府签发的电子身份证（详见 https://www.ssl.com/article/pki-and-digital-certificates-for-government/） 我们后面还会讨论。 HTTPS 的内核是 HTTPHTTPS 并不是一项新的应用层协议，只是 HTTP 通信接口部分由 SSL 和 TLS 替代而已。通常情况下，HTTP 会先直接和 TCP 进行通信。在使用 SSL 的 HTTPS 后，则会先演变为和 SSL 进行通信，然后再由 SSL 和 TCP 进行通信。也就是说，HTTPS 就是身披了一层 SSL 的 HTTP。（我都喜欢把骚粉留在最后。。。） SSL 是一个独立的协议，不只有 HTTP 可以使用，其他应用层协议也可以使用，比如 SMTP(电子邮件协议)、Telnet(远程登录协议) 等都可以使用。 探究 HTTPS我说，你起这么牛逼的名字干嘛，还想吹牛批？你 HTTPS 不就抱上了 TLS/SSL 的大腿么，咋这么牛批哄哄的，还想探究 HTTPS，瞎胡闹，赶紧改成 TLS 是我主，赞美我主。 SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层，SSL 在 1999 年被 IETF(互联网工程组)更名为 TLS ，即传输安全层，直到现在，TLS 一共出现过三个版本，1.1、1.2 和 1.3 ，目前最广泛使用的是 1.2，所以接下来的探讨都是基于 TLS 1.2 的版本上的。 TLS 用于两个通信应用程序之间提供保密性和数据完整性。TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术（如果你觉得一项技术很简单，那你只是没有学到位，任何技术都是有美感的，牛逼的人只是欣赏，并不是贬低）。 说了这么半天，我们还没有看到 TLS 的命名规范呢，下面举一个 TLS 例子来看一下 TLS 的结构（可以参考 https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml） 1ECDHE-ECDSA-AES256-GCM-SHA384 这是啥意思呢？我刚开始看也有点懵啊，但其实是有套路的，因为 TLS 的密码套件比较规范，基本格式就是 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 组成的一个密码串，有时候还有分组模式，我们先来看一下刚刚是什么意思 使用 ECDHE 进行密钥交换，使用 ECDSA 进行签名和认证，然后使用 AES 作为对称加密算法，密钥的长度是 256 位，使用 GCM 作为分组模式，最后使用 SHA384 作为摘要算法。 TLS 在根本上使用对称加密和 非对称加密 两种形式。 对称加密在了解对称加密前，我们先来了解一下密码学的东西，在密码学中，有几个概念：明文、密文、加密、解密 明文(Plaintext)，一般认为明文是有意义的字符或者比特集，或者是通过某种公开编码就能获得的消息。明文通常用 m 或 p 表示 密文(Ciphertext)，对明文进行某种加密后就变成了密文 加密(Encrypt)，把原始的信息（明文）转换为密文的信息变换过程 解密(Decrypt)，把已经加密的信息恢复成明文的过程。 对称加密(Symmetrical Encryption)顾名思义就是指加密和解密时使用的密钥都是同样的密钥。只要保证了密钥的安全性，那么整个通信过程也就是具有了机密性。 TLS 里面有比较多的加密算法可供使用，比如 DES、3DES、AES、ChaCha20、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。目前最常用的是 AES-128, AES-192、AES-256 和 ChaCha20。 DES 的全称是 Data Encryption Standard(数据加密标准) ，它是用于数字数据加密的对称密钥算法。尽管其 56 位的短密钥长度使它对于现代应用程序来说太不安全了，但它在加密技术的发展中具有很大的影响力。 3DES 是从原始数据加密标准（DES）衍生过来的加密算法，它在 90 年代后变得很重要，但是后面由于更加高级的算法出现，3DES 变得不再重要。 AES-128, AES-192 和 AES-256 都是属于 AES ，AES 的全称是Advanced Encryption Standard(高级加密标准)，它是 DES 算法的替代者，安全强度很高，性能也很好，是应用最广泛的对称加密算法。 ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。 （其他可自行搜索） 加密分组对称加密算法还有一个分组模式 的概念，对于 GCM 分组模式，只有和 AES，CAMELLIA 和 ARIA 搭配使用，而 AES 显然是最受欢迎和部署最广泛的选择，它可以让算法用固定长度的密钥加密任意长度的明文。 最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。 比如 ECDHE_ECDSA_AES128_GCM_SHA256 ，表示的是具有 128 位密钥， AES256 将表示 256 位密钥。GCM 表示具有 128 位块的分组密码的现代认证的关联数据加密（AEAD）操作模式。 我们上面谈到了对称加密，对称加密的加密方和解密方都使用同一个密钥，也就是说，加密方必须对原始数据进行加密，然后再把密钥交给解密方进行解密，然后才能解密数据，这就会造成什么问题？这就好比《小兵张嘎》去送信（信已经被加密过），但是嘎子还拿着解密的密码，那嘎子要是在途中被鬼子发现了，那这信可就是被完全的暴露了。所以，对称加密存在风险。 非对称加密非对称加密(Asymmetrical Encryption) 也被称为公钥加密，相对于对称加密来说，非对称加密是一种新的改良加密方式。密钥通过网络传输交换，它能够确保及时密钥被拦截，也不会暴露数据信息。非对称加密中有两个密钥，一个是公钥，一个是私钥，公钥进行加密，私钥进行解密。公开密钥可供任何人使用，私钥只有你自己能够知道。 使用公钥加密的文本只能使用私钥解密，同时，使用私钥加密的文本也可以使用公钥解密。公钥不需要具有安全性，因为公钥需要在网络间进行传输，非对称加密可以解决密钥交换的问题。网站保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。 非对称加密算法的设计要比对称算法难得多（我们不会探讨具体的加密方式），常见的比如 DH、DSA、RSA、ECC 等。 其中 RSA 加密算法是最重要的、最出名的一个了。例如 DHE_RSA_CAMELLIA128_GCM_SHA256。它的安全性基于 整数分解，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。 ECC（Elliptic Curve Cryptography）也是非对称加密算法的一种，它基于椭圆曲线离散对数的数学难题，使用特定的曲线方程和基点生成公钥和私钥， ECDHE 用于密钥交换，ECDSA 用于数字签名。 TLS 是使用对称加密和非对称加密 的混合加密方式来实现机密性。 混合加密RSA 的运算速度非常慢，而 AES 的加密速度比较快，而 TLS 正是使用了这种混合加密方式。在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE ，首先解决密钥交换的问题。然后用随机数产生对称算法使用的会话密钥（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。 现在我们使用混合加密的方式实现了机密性，是不是就能够安全的传输数据了呢？还不够，在机密性的基础上还要加上完整性、身份认证的特性，才能实现真正的安全。而实现完整性的主要手段是 摘要算法(Digest Algorithm) 摘要算法如何实现完整性呢？在 TLS 中，实现完整性的手段主要是 摘要算法(Digest Algorithm)。摘要算法你不清楚的话，MD5 你应该清楚，MD5 的全称是 Message Digest Algorithm 5，它是属于密码哈希算法(cryptographic hash algorithm)的一种，MD5 可用于从任意长度的字符串创建 128 位字符串值。尽管 MD5 存在不安全因素，但是仍然沿用至今。MD5 最常用于验证文件的完整性。但是，它还用于其他安全协议和应用程序中，例如 SSH、SSL 和 IPSec。一些应用程序通过向明文加盐值或多次应用哈希函数来增强 MD5 算法。 什么是加盐？在密码学中，盐就是一项随机数据，用作哈希数据，密码或密码的单向函数的附加输入。盐用于保护存储中的密码。例如 什么是单向？就是在说这种算法没有密钥可以进行解密，只能进行单向加密，加密后的数据无法解密，不能逆推出原文。 我们再回到摘要算法的讨论上来，其实你可以把摘要算法理解成一种特殊的压缩算法，它能够把任意长度的数据压缩成一种固定长度的字符串，这就好像是给数据加了一把锁。 除了常用的 MD5 是加密算法外，SHA-1(Secure Hash Algorithm 1) 也是一种常用的加密算法，不过 SHA-1 也是不安全的加密算法，在 TLS 里面被禁止使用。目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。 SHA-2 的全称是Secure Hash Algorithm 2 ，它在 2001 年被推出，它在 SHA-1 的基础上做了重大的修改，SHA-2 系列包含六个哈希函数，其摘要（哈希值）分别为 224、256、384 或 512 位：SHA-224, SHA-256, SHA-384, SHA-512。分别能够生成 28 字节、32 字节、48 字节、64 字节的摘要。 有了 SHA-2 的保护，就能够实现数据的完整性，哪怕你在文件中改变一个标点符号，增加一个空格，生成的文件摘要也会完全不同，不过 SHA-2 是基于明文的加密方式，还是不够安全，那应该用什么呢？ 安全性更高的加密方式是使用 HMAC，在理解什么是 HMAC 前，你需要先知道一下什么是 MAC。 MAC 的全称是message authentication code，它通过 MAC 算法从消息和密钥生成，MAC 值允许验证者（也拥有秘密密钥）检测到消息内容的任何更改，从而保护了消息的数据完整性。 HMAC 是 MAC 更进一步的拓展，它是使用 MAC 值 + Hash 值的组合方式，HMAC 的计算中可以使用任何加密哈希函数，例如 SHA-256 等。 现在我们又解决了完整性的问题，那么就只剩下一个问题了，那就是认证，认证怎么做的呢？我们在向服务器发送数据的过程中，黑客（攻击者）有可能伪装成任何一方来窃取信息。它可以伪装成你，来向服务器发送信息，也可以伪装称为服务器，接受你发送的信息。那么怎么解决这个问题呢？ 认证如何确定你自己的唯一性呢？我们在上面的叙述过程中出现过公钥加密，私钥解密的这个概念。提到的私钥只有你一个人所有，能够辨别唯一性，所以我们可以把顺序调换一下，变成私钥加密，公钥解密。使用私钥再加上摘要算法，就能够实现数字签名，从而实现认证。 到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了加密、数据认证、认证，那么是不是就安全了呢？非也，这里还存在一个数字签名的认证问题。因为私钥是是自己的，公钥是谁都可以发布，所以必须发布经过认证的公钥，才能解决公钥的信任问题。 所以引入了 CA，CA 的全称是 Certificate Authority，证书认证机构，你必须让 CA 颁布具有认证过的公钥，才能解决公钥的信任问题。 全世界具有认证的 CA 就几家，分别颁布了 DV、OV、EV 三种，区别在于可信程度。DV 是最低的，只是域名级别的可信，EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。不同的信任等级的机构一起形成了层级关系。 通常情况下，数字证书的申请人将生成由私钥和公钥以及证书签名请求（CSR）组成的密钥对。CSR是一个编码的文本文件，其中包含公钥和其他将包含在证书中的信息（例如域名，组织，电子邮件地址等）。密钥对和 CSR生成通常在将要安装证书的服务器上完成，并且 CSR 中包含的信息类型取决于证书的验证级别。与公钥不同，申请人的私钥是安全的，永远不要向 CA（或其他任何人）展示。 生成 CSR 后，申请人将其发送给 CA，CA 会验证其包含的信息是否正确，如果正确，则使用颁发的私钥对证书进行数字签名，然后将其发送给申请人。 总结 本篇文章我们主要讲述了 HTTPS 为什么会出现 ，HTTPS 解决了 HTTP 的什么问题，HTTPS 和 HTTP 的关系是什么，TLS 和 SSL 是什么，TLS 和 SSL 解决了什么问题？如何实现一个真正安全的数据传输？","categories":[],"tags":[{"name":"HTTP和HTTPS","slug":"HTTP和HTTPS","permalink":"https://alloceee.github.io/tags/HTTP%E5%92%8CHTTPS/"}]},{"title":"输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树","slug":"Algorithm/Leetcode-输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:32:44.000Z","comments":true,"path":"2020/07/15/Algorithm/Leetcode-输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Algorithm/Leetcode-%E8%BE%93%E5%85%A5%E6%9F%90%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E8%AF%B7%E9%87%8D%E5%BB%BA%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/一、题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 限制： 10 &lt;= 节点个数 &lt;= 5000 二、题目解析首先，我们先来复习一下前序遍历、中序遍历。（在下方的视频中分布讲解） 前序遍历二叉树的前序遍历顺序是：根节点、左子树、右子树，每个子树的遍历顺序同样满足前序遍历顺序。 中序遍历二叉树的中序遍历顺序是：左子树、根节点、右子树，每个子树的遍历顺序同样满足中序遍历顺序。 复习过后，我们可以得出以下结论： 在二叉树的 前序遍历 序列中，第一个数字总是树的根结点的值； 在二叉树的 中序遍历 序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边 以本题的序列为例，前序遍历序列的第一个数字 3 就是根结点的值，在中序遍历序列，找到根结点值的位置。根据中序遍历特点，在根结点的值 3 前面的数字都是左子树结点的值，在根结点的值 3 后面的数字都是右子树结点的值。 二叉树很重要的一个性质是递归，在找到了左子树、右子树的前序遍历序列和中序遍历序列后，我们可以按照同样的方法去确定 子左子树 和 子右子树 的构建。 具体的代码编写思路如下（来源于 Krahets’s Blog）： 递推参数： 前序遍历中根节点的索引pre_root_idx、中序遍历左边界in_left_idx、中序遍历右边界in_right_idx。 终止条件： 当 in_left_idx &gt; in_right_idx ，子树中序遍历为空，说明已经越过叶子节点，此时返回 null 。 递推工作： 建立根节点 root ： 值为前序遍历中索引为pre_root_idx的节点值。 搜索根节点 root 在中序遍历的索引 i ： 为了提升搜索效率，本题解使用哈希表 map 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)。 构建根节点 root的左子树和右子树：通过调用 recursive() 方法开启下一层递归。 左子树： 根节点索引为 pre_root_idx + 1 ，中序遍历的左右边界分别为 in_left_idx 和 i - 1。 右子树： 根节点索引为 i - in_left_idx + pre_root_idx + 1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和 in_right_idx。 返回值： 返回 root，含义是当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。 三、动画描述四、图片描述 五、参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; //在中序序列中查找与前序序列首结点相同元素的时候，如果使用 while 循环去一个个找效率很慢 //这里我们借助数据结构 HashMap 来辅助查找，在开始递归之前把所有的中序序列的元素和它们所在的下标存到一个 map 中，这样查找的时间复杂度是 O(logn) HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //保留的前序遍历 int[] preorder; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; //在开始递归之前把所有的中序序列的元素和它们所在的下标存到一个 map 中 for (int i = 0; i &lt; preorder.length; i++) &#123; map.put(inorder[i], i); &#125; //二叉树的重要性质是递归 return recursive(0,0,inorder.length-1); &#125; /** 根据前序遍历序列和中序遍历序列重新组建二叉树 * @param pre_root_idx 前序遍历的索引 * @param in_left_idx 中序遍历左边界的索引 * @param in_right_idx 中序遍历右边界的索引 */ public TreeNode recursive(int pre_root_idx, int in_left_idx, int in_right_idx) &#123; //子树中序遍历为空，说明已经越过叶子节点，此时返回 nul if (in_left_idx &gt; in_right_idx) &#123; return null; &#125; //root_idx是在前序里面的 TreeNode root = new TreeNode(preorder[pre_root_idx]); // 通过 map ，根据前序的根节点的值，在中序中获取当前根的索引 int idx = map.get(preorder[pre_root_idx]); //左子树的根节点就是 左子树的(前序遍历）第一个，就是 +1 ,左边边界就是 left ，右边边界是中间区分的idx-1 root.left = recursive(pre_root_idx + 1, in_left_idx, idx - 1); //右子树的根，就是右子树（前序遍历）的第一个,就是当前根节点 加上左子树的数量 root.right = recursive(pre_root_idx + (idx-1 - in_left_idx +1) + 1, idx + 1, in_right_idx); return root; &#125;&#125; 这段代码的一个难点就是 root.left 与 root.right ，我这里抽离出来详细解释一下。 1、root.left 2、root.right 六、复杂度分析时间复杂度时间复杂度为 O(N)。 空间复杂度空间复杂度为 O(N)。 七、相关标签 树 递归 哈希表 八、参考来源 1、https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/ 题解区 2、https://krahets.gitee.io/views/sword-for-offer/2020-02-24-sword-for-offer-07.html","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://alloceee.github.io/tags/Leetcode/"}]},{"title":"算法-基础","slug":"Algorithm/算法-常用算法","date":"2020-07-15T02:39:02.000Z","updated":"2020-08-08T03:57:10.000Z","comments":true,"path":"2020/07/15/Algorithm/算法-常用算法/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Algorithm/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法的基本要素 对数据对象的运算和操作 算法的控制结构 朴素模式匹配算法斐波那契数列不能使用递归f(n) = f(n-1) + f(n-2)的原因：会造成大量重复计算，导致时间复杂度为O(2^n)。 使用动态规划消除重复计算，可使时间复杂度优化至O(n)。可用数组保存计算结果，则空间复杂度为O(n)。此处进一步简化，只使用两个变量保存结果，因此空间复杂度为O(1)。 123456789class Solution &#123; public int fib(int N) &#123; int curr = 0, next = 1; while(N-- &gt; 0) &#123; next = next + curr; curr = next - curr; &#125; return curr; &#125; 约瑟夫环在对问题的解空间树进行搜索的方法中，一个结点有多次机会成为活结点的是回溯法分支限界思想： 以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树 分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点，其中导致不可行解或导致非最优解的儿子结点被舍弃其余儿子结点被加入活结点表中 然后从活结点表中取下一结点成为扩展结点 重复上述结点扩展过程，直至到找到所需要的解或活结点表为止 广度优先且不满足的被舍弃，满足的找其儿子结点，所以其不可能再次成为活结点。 回溯法：深度优先自然可以回到此节点。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"面试算法基础","slug":"Algorithm/算法-面试算法题","date":"2020-07-15T02:39:02.000Z","updated":"2020-08-08T03:58:22.000Z","comments":true,"path":"2020/07/15/Algorithm/算法-面试算法题/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Algorithm/%E7%AE%97%E6%B3%95-%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"树的遍历有几种，实现下层次遍历判断对称二叉树如何判断链表有环如何确定环长度如何确定入环位置","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"单点登录","slug":"Architecture/单点登录","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:41:38.000Z","comments":true,"path":"2020/07/15/Architecture/单点登录/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Architecture/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","excerpt":"","text":"1.认证（Authentication）和授权（Authorization）的区别是什么？2.什么是Cookie？Cookie的作用是什么？如何使用在服务端使用Cookis? 3.Cookie和Session有什么区别？如何使用Session进行身份验证？ 4.如果没有Cookie的话Session还能用吗？ 5.为什么Cookie无法防止CSRF攻击，而Token可以？ 6.什么是Token?什么是JWT？如何基于Token进行身份验证？ 7.什么是OAuth2.0? 8.什么是SSO？ 单点登录实现原理（SSO）简介 单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统的保护资源，若用户在某个应用系统中进行注销登录，所有的应用系统都不能再直接访问保护资源，像一些知名的大型网站，如：淘宝与天猫、新浪微博与新浪博客等都用到了这个技术。 原理 单点登录 有一个独立的认证中心，只有认证中心才能接受用户的用户名和密码等信息进行认证，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，当用户提供的用户名和密码通过认证中心认证后，认证中心会创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌即得到了授权，然后创建局部会话。 示例： 下面对上图进行解释： 当用户还没进行用户登录的时候 用户去访问系统1的保护资源 ，系统1检测到用户还没登录，跳转至SSO认证中心，SSO认证中心也发现用户没有登录，就跳转到用户至认证中心的登录页面 用户在登录页面提交用户相应信息后，认证中心会校验用户信息，如果用户信息正确的话认证中心就会创建与该用户的全局会话（全局会话过期的时候，用户就需要重新登录了。全局会话中存的信息可能有令牌，用户信息，及该在各个系统的一些情况），同时创建授权令牌，然后进行下一步，否则认证中心给出提示（用户信息有误），待用户再次点击登录的时候，再一次进行校验用户信息 认证中心带着令牌跳转到用户最初请求的地址（系统1），系统1拿到令牌后去SSO认证中心校验令牌是否有效，SSO认证中心校验令牌，若该令牌有效则进行下一步 注册系统1，然后系统1使用该令牌创建和用户的局部会话（若局部会话过期，跳转至SSO认证中心，SSO认证中心发现用户已经登录，然后执行第3步），返回受保护资源 用户已经通过认证中心的认证后用户访问系统2的保护资源，系统2发现用户未登录，跳转至SSO认证中心，SSO认证中心发现用户已经登录，就会带着令牌跳转回系统2，系统2拿到令牌后去SSO认证中心校验令牌是否有效，SSO认证中心返回有效，注册系统2，系统2使用该令牌创建与用户的局部会话，返回受保护资源。 如果系统1的局部会话存在的话，当用户去访问系统1的保护资源时，就直接返回保护资源，不需要去认证中心验证了 局部会话存在，全局会话一定存在；全局会话存在，局部会话不一定存在；全局会话销毁，局部会话必须销毁如果在校验令牌过程中发现客户端令牌和服务器端令牌不一致或者令牌过期的话，则用户之前的登录就过期了，用户需要重新登录 关于令牌可参考：基于跨域单点登录令牌的设计与实现 单点注销 在一个子系统中注销，全局会话也会被注销，所有子系统的会话都会被注销 示例：用户向系统1发出注销请求，系统1根据用户与系统1建立的会话id从会话中拿到令牌，向SSO认证中心发起注销请求，认证中心校验令牌有效，会销毁全局会话，同时取出此令牌注册的系统地址，认证中心向所有注册系统发出注销请求，各系统收到注销请求后销毁局部会话，认证中心引导用户跳转值登录页面。 整体陈述 单点登录涉及SSO认证中心与多个子系统，子系统与SSO认证中心需要通信（交换令牌、校验令牌及发起注销请求等），子系统中包含SSO的客户端，SSO认证中心是服务端 认证中心与客户端通信可通过 httpClient、web service、rpc、restful api（url是其中一种） 等实现 客户端与服务器端的功能 客户端： 拦截子系统未登录用户请求，跳转至sso认证中心 接收并存储sso认证中心发送的令牌 与服务器端通信，校验令牌的有效性 建立局部会话 拦截用户注销请求，向sso认证中心发送注销请求 接收sso认证中心发出的注销请求，销毁局部会话 服务器端： 验证用户的登录信息 创建全局会话 创建授权令牌 与客户端通信发送令牌 校验客户端令牌有效性 系统注册 接收客户端注销请求，注销所有会话 一、oauth2与单点登陆的区别 1、oauth2，不同的企业之间的登陆，应用之间的信任度较低 2、单点登陆，是同一企业的产品系列间的登陆，相互信任度较高 二、session-cookie机制 1、session-cookie机制出现的根源， http连接是无状态的连接 ——– 同一浏览器向服务端发送多次请求，服务器无法识别，哪些请求是同一个浏览器发出的 2、为了标识哪些请求是属于同一个人 ———- 需要在请求里加一个标识参数 方法1———–直接在url里加一个标识参数(对前端开发有侵入性)，如: token 方法2———–http请求时，自动携带浏览器的cookie（对前端开发无知觉），如：jsessionid=dfdfdfdfdf 3、浏览器标识在网络上的传输，是明文的，不安全的 ———–安全措施：改https来保障 4、cookie的使用限制—依赖域名 ————– 顶级域名下cookie，会被二级以下的域名请求，自动携带 ————– 二级域名的cookie，不能携带被其它域名下的请求携带 5、在服务器后台，通过解读标识信息（token或jsessionid），来对应会话是哪个session ————— 一个tomcat，被1000个用户登陆，tomcat里一定有1000个session ——-》存储格式map《sessionid，session对象》 ————— 通过前端传递的jsessionid，来对应取的session —— 动作发生时机request.getsession 三、session共享方式，实现的单点登陆 1、多个应用共用同一个顶级域名，sessionid被种在顶级域名的cookie里 2、后台session通过redis实现共享，即每个tomcat都在请求开始时，到redis查询session;在请求返回时，将自身session对象存入redis 3、当请求到达服务器时，服务器直接解读cookie中的sessionid，然后通过sessionid到redis中查找到对应会话session对象 4、后台判断请求是否已登陆，主要校验session对象中，是否存在登陆用户信息 5、整个校验过程，通过filter过滤器来拦截切入，如下图： 6、登陆成功时，后台需要给页面种cookie方法如下： response里，反映的种cookie效果如下： 7、为了request.getsession时，自动能拿到redis中共享的session， 我们需要重写request的getsession方法（使用HttpServletRequestWrapper包装原request） 四、cas单点登陆方案 1、对于完全不同域名的系统，cookie是无法跨域名共享的 2、cas方案，直接启用一个专业的用来登陆的域名（比如：cas.com）来供所有的系统登陆。 3、当业务系统（如b.com）被打开时，借助cast系统来登陆，过程如下： cas登陆的全过程： （1）、b.com打开时，发现自己未登陆 —-》 于是跳转到cas.com去登陆 （2）、cas.com登陆页面被打开，用户输入帐户/密码登陆成功 （3）、cas.com登陆成功，种cookie到cas.com域名下 ———–》把sessionid放入后台redis《ticket，sesssionid》—页面跳回b.com （4）、b.com重新被打开，发现仍然是未登陆，但是有了一个ticket值 （5）、b.com用ticket值，到redis里查到sessionid，并做session同步 —— 》种cookie给自己，页面原地重跳 （6）、b.com打开自己页面，此时有了cookie，后台校验登陆状态，成功 （7）整个过程交互，列图如下： 4、cas.com的登陆页面被打开时,如果此时cas.com本来就是登陆状态的,则自动返回生成ticket给业务系统 ​ 整个单点登陆的关键部位，是利用cas.com的cookie保持cas.com是登陆状态,此后任何第三个系统跳入,都将自动完成登陆过程 5,本示例中,使用了redis来做cas的服务接口,请根据工作情况,自行替换为合适的服务接口(主要是根据sessionid来判断用户是否已登陆) 6,为提高安全性,ticket应该使用过即作废(本例中,会用有效期机制)","categories":[],"tags":[{"name":"认证","slug":"认证","permalink":"https://alloceee.github.io/tags/%E8%AE%A4%E8%AF%81/"}]},{"title":"常用的负载均衡方法","slug":"Architecture/架构-负载均衡","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:42:56.000Z","comments":true,"path":"2020/07/15/Architecture/架构-负载均衡/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Architecture/%E6%9E%B6%E6%9E%84-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"在单一的服务器上执行WEB应用程序有一些重大的问题,当网站成功建成并开始接受大量请求时,单一服务器终究无法满足需要处理的负荷量,所以就有点显得有点力不从心了｡另外一个常见的问题是会产生单点故障,如果该服务器坏掉,那么网站就立刻无法运作了｡不论是因为要有较佳的扩充性还是容错能力,我们都会想在一台以上的服务器计算机上执行WEB应用程序｡所以,这时候我们就需要用到负载均衡技术了。负载均衡有哪些技术，nat123是如何实现负载均衡的？ 方法/步骤 端口映射：端口映射是NAT的一种，功能是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。 负载均衡：负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 常用的负载均衡技术： 对网络连接进行负载均衡 当1 GB每秒的网络带宽不够用，而你又不想再花一大笔钱来安装10 GB的网络时，这时怎么办？可以装两个1 GB的网络，然后将它们当成一个来使用！ 软件负载均衡技术 该技术适用于一些中小型网站系统，可以满足一般的均衡负载需求。软件负载均衡技术是在一个或多个交互的网络系统中的堕胎服务器上安装一个或多个相应的负载均衡软件来实现的一种均衡负载技术。软件可以很方便的安装在服务器上，并且实现一定的均衡负载功能。软件负载均衡技术配置简单、操作也方便，最重要的是成本很低。 硬件负载均衡技术 由于硬件负载均衡技术需要额外的增加负载均衡器，成本比较高，所以适用于流量高的大型网站系统。硬件负载均衡技术是在多台服务器间安装相应的负载均衡设备，也就是负载均衡器来完成均衡负载技术，与软件负载均衡技术相比，能达到更好的负载均衡效果。 本地负载均衡技术 本地负载均衡技术是对本地服务器群进行负载均衡处理。该技术通过对服务器进行性能优化，使流量能够平均分配在服务器群中的各个服务器上，本地负载均衡技术不需要购买昂贵的服务器或优化现有的网络结构。 全局负载均衡技术 全局负载均衡技术适用于拥有多个低于的服务器集群的大型网站系统。全局负载均衡技术是对分布在全国各个地区的多个服务器进行负载均衡处理，该技术可以通过对访问用户的IP地理位置判定，自动转向地域最近点。很多大型网站都使用的这种技术。 nat123均衡映射启用方法： 1.登录网站/用户中心/用户参数设置，选择启用映射均衡。 8 2.登录软件，映射图标右键/本地设置/启用端口映射负载均衡与故障转移。可自定义优先级和权重。 优先级：最大优先级为1。多点登录设置的优先级一样时，是负载均衡；优先级不一样时，是故障转移。 权重：优先级一样时生效。最小权重1。权重越小，映射访问比例越少；权重一样时，是平均负载均衡。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://alloceee.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"几种消息中间件的对比","slug":"消息中间件/消息中间件-对比","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:48:58.000Z","comments":true,"path":"2020/07/15/消息中间件/消息中间件-对比/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%AF%B9%E6%AF%94/","excerpt":"","text":"本次主要对比：ActiveMQ、kafka、RocketMQ、RabbitMQ衡量消息中间件的指标：服务性能，数据存储，集群架构 1.ActiveMQActiveMQ是Apache出品的，最流行的能力，强劲的开源消息总线，并且他完全支持Java的JMs规范。丰富的API，多种集群构建模式使得它成为业界老牌的消息中间件，在中小型企业应用广泛。但是相比于kafka，rabbitmq等MQ来说，性能太弱，在如今的高并发，大数据处理的场景下显得力不从心，经常会出现一些小问题，消息延迟，堆积，堵塞等，不过其多种集群架构是优势。 如下所示主要的两种集群架构 image ActiveMQ的两种集群架构 master-slave模式:通过zk确立一个主节点，主节点对外提供服务，从节点不对外提供服务。当主节点不可用，另外一个节点就转成主节点，对外提供服务，已达到高可用的目的。 network模式就相当于两组master-slave组合在一起。 2.kafkakafka是linkedin开源的分布式发布-订阅消息系统，目前归属于Apache的顶级项目。主要特点是基于pull模式来处理消息消费，追求高吞吐量，一开始的目的是日志的收集和传输。0.8版本开始支持复制，不支持事务，对消息的丢失，重复，错误没有严格要求 适用于产生大量数据的互联网服务的数据收集业务。在廉价的服务器上都能有很高的性能，这个主要是基于操作系统底层的pagecache，不用内存胜似使用内存。 image Kafka集群 Kafka集群也是采用zk进行集群，当一个数据存放在一个节点中，会通过relicate同步到其他节点，所以我们不需要更多的关注kafka有可能丢失消息，因为其他节点会有这份数据，除非你这个地区的kafka都挂了。可靠性高的场景不适用。 3.RocketMQRocketMQ是阿里开源的，目前是也是Apache的顶级项目，纯Java开发，具有高吞吐量，高可用，适合大规模分布式系统应用的特点。其思路起源于kafka，它对消息的可靠传输以及事务性做了优化，目前在阿里被广泛应用于交易/充值/流计算/消息推送/日志流式处理/Binglog分发等场景。不过其维护是一个痛点。不过它能保证消息的顺序性，集群模式也丰富，在双十一等高并发场景承受上亿访问，三大指标都很好，但是它的商业版要收费！！！ image RocketMQ集群 它刚开始也是依赖zk做集群的，但是觉得太慢就自己开发了Name Server。 4.RabbitMQRabbitMQ是使用erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息/队列/路由(包括点对点的发布/订阅)可靠性，安全。AMQP协议更多用在企业系统内，对数据一致性/稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。rabbitMQ的可靠性很高，性能比不上kafka，但是也很高了，集群模式也有多种。 image 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，吞吐量比RabbitMQ和Kafka要低一个数量级 万级，吞吐量比RocketMQ和Kafka要低一个数量级 topic数量对吞吐量的影响 可用性 消息可靠性 时效性 功能支持 优劣总结 ActiveMQ比较成熟，文档齐全，但是目前维护较少，社区活跃，RabbitMQ性能很强，RocketMQ和ali有很大关系，可用性很高，性能不错，非常稳定成熟。Kafka在大数据领域应用较多。","categories":[],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"消息中间件-常见面试题","slug":"消息中间件/消息中间件-常见面试题","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:48:10.000Z","comments":true,"path":"2020/07/15/消息中间件/消息中间件-常见面试题/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"概述 什么是消息中间件？和RPC有何区别？ 消息中间件使用场景介绍 消息中间件(ActiveMQ、RabbitMQ、RocketMQ、Kafka)简介及对比 消息中间件的编年史ActiveMq JMS规范 什么是JMS（Java Messaging Service）规范？ 包含要素 消息类型 P2P模型 Topic(PUB\\SUB)模型 ActiveMQ使用 安装和部署 原生ActiveMQ的API编程 与Spring集成 Xml配置方式 SpringBoot Request-Response模式 实战：用户注册的异步处理 ActiveMQ高级特性和用法 嵌入式MQ 消息存储的持久化机制 消息持久订阅 消息的可靠性 通配符式分层订阅 死信队列DLQ(Dead Letter Queue) 镜像队列 虚拟主题 组合Destinations 实战：限时订单 企业级高可用集群部署方案 Shared File System DB Replicated LevelDB Store Broker-ClusterRabbitMq AMQP规范和RabbitMQ基本概念 要素 生产者、消费者、消息 信道 交换器、队列、绑定、路由键 消息的确认 交换器类型 Direct Fanout Topic 虚拟主机 RabbitMQ在Windows下安装和运行 原生Java客户端使用 消息发布时的权衡 失败通知 发布者确认 事务 备用交换器 消息消费时的权衡 消息的获得方式 QoS预取模式 可靠性和性能的权衡 消息的拒绝 消息的拒绝方式 死信交换器 控制队列 临时队列 永久队列 队列级别消息过期 消息的属性 属性列表 消息的持久化 与Spring集成 Xml配置方式 SpringBoot 实战：应用解耦 安装配置 下载安装和日常管理 web监控平台 集群化与镜像队列Kafka Kafka入门 Kafka中的基本概念 为什么选择Kafka Kafka的安装和配置参数 Kafka的生产者和消费者 消息的发送和接收 生产者和消费者的配置 消费者群组和再均衡 消费者中的提交和偏移量 序列化和反序列化 深入理解Kafka 控制器和复制 请求处理流程 物理存储原理 保证Kafka的可靠数据传递 数据管道和流式处理入门 数据管道基本概念 流式处理基本概念和设计模式常见面试题 为什么使用消息队列 消息队列有什么优点和缺点? 常见消息队列的比较 消息的去重 消息的可靠性传输 消息的顺序性","categories":[],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"网络架构基础","slug":"计算机网络/网络架构基础","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:47:36.000Z","comments":true,"path":"2020/07/15/计算机网络/网络架构基础/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"海量数据的解决方案 缓存和页面静态化 数据库优化 表结构优化 SQL语句优化 分区 分表：mycat 分库分表中间件 索引优化 使用存储过程代替直接操作 分离活跃数据：可以根据最后一次查询时间，判断非活跃用户，将活跃数据单独分到一个表中作为默认表，不活跃数据分到另一个表中，先从默认表中查找数据，找不到再从不活跃表中查找数据，提高查询效率。 批量读取和延迟修改：原理是通过减少操作的次数来提高效率。批量读取是将多次查询合并到一次中进行，比如对同一个请求中的数据批量读取，在高并发的情况下还可以将多个请求的查询合并到一次进行，如3-5s内请求合并一起统一查询一次数据库。延迟修改主要针对高并发并且频繁修改（包括新增）的数据，如一些统计数据，这种情况可以先将需要修改的数据暂时保存到缓存中，然后定时将缓存中的数据保存到数据库找那个，程序在读取数据时可以同时读取数据中的缓存中的数据。 读写分离：读写分离的本质是对数据库进行集群，这样就可以在高并发的情况下将数据库的操作分配到多个数据库服务器去处理从而降低单台服务器的压力，不过由于数据库的特殊性——每台服务器所保存的数据都需要一致，所以数据同步就成了数据库集群中最核心的问题。一般情况是将写操作交给专门的一台服务器处理，这台专门负责写的服务器叫做主服务器。主服务器数据进行增删查改之后将数据从底层同步到别的服务器（从服务器），读数据的时候到从服务器读取，从服务器可以多台，如果从服务器过多，主服务器可以先同步一部分从服务器，然后再同步另外一部分。 分布式数据库：是将不同的表存放到不同的数据库中然后再放到不同的服务器。这样在处理请求时，如果需要调用多个表，则可以让多态服务器同时处理，从而提高处理速度。 数据库集群（读写分离）的作用是将多个请求分配到不同的服务器处理，从而减轻单台服务器的压力，而分布式数据是解决单个请求本身就非常复杂的问题，他可以将单个请求分配到多个处理器处理，使用分布式后的每个节点还可以同时使用读写分离，从而组成多个节点群。 NoSQL和Hadoop：Hadoop专门针对大数据处理，底层数据的存储思路类似于分布式加集群，不过Hadoop是将同一个表中的数据分成多块保存到多个节点（分布式），而且每一块数据都有多个节点保存（集群），这里集群除了可以并行处理相同的数据，还可以保证数据的稳定性，在其中一个节点出问题后数据不会丢失。 高并发的解决方案 应用和静态资源分离：将静态资源保存到专门的服务器中，一般会使用专门的域名去访问，通过不同的域名可以让浏览器直接访问资源服务器而不需要再访问应用服务器了 页面缓存：是将应用生成的页面缓存起来，这样就不需要每次都重新生成页面了。可以使用Nginx服务器就可以使用它自带的缓存功能，当然也可以使用专门的Squid服务器。 集群和分布式：集群是每台服务器都具有相同的功能，处理请求时调用哪台服务器都可以，主要起到分流作用，分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要用到多台服务器，这样就可以提高一个请求的处理速度，而且集群和分布式也可以同时使用。集群有两个方式：一种是静态资源集群，另一种是应用程序集群。 反向代理：指的是客户端直接访问的服务器并不是真正提供服务，它从别的度武器获取资源然后将结果返回给用户的。 CDN：其实是一种特殊的集群页面缓存服务器，它和普通集群的多台页面缓冲服务器比主要是它存放的位置分布在全国各地，当接收到用户的请求后会将请求分配到最合适的CDN服务器节点获取数据。 底层优化：通过网络传输协议进行优化。 小结：网站架构的整个演变过程主要是围绕大数据和高并发这两个问题展开的。解决方案主要分为使用缓存和使用多资源两种类型。多资源主要指多存储（包括多内存）、多CPU和多网络，对于多资源来说又可以分为单个资源处理一个完整的请求和多个资源各做处理一个请求两种类型，如多存储和多CPU中的集群和分布式，多网络中的CDN和静态资源分离。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://alloceee.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"HTTP协议","slug":"计算机网络/计算机网络-HTTP协议","date":"2020-07-15T02:39:02.000Z","updated":"2021-08-04T01:32:11.327Z","comments":true,"path":"2020/07/15/计算机网络/计算机网络-HTTP协议/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"HTTP协议是应用层协议，在TCP/IP协议接受到数据之后需要通过HTTP协议来解析才可以使用。","text":"HTTP协议是应用层协议，在TCP/IP协议接受到数据之后需要通过HTTP协议来解析才可以使用。 请求报文和响应报文：请求报文1234请求行：方法（请求类型） URL HTTP版本头部：键值对的属性主体 响应报文1234请求行：HTTP版本 状态码 简短原因头部：键值对的属性主体 常见的状态码 200 OK 客户端请求成功 301 Moved Permanently （永久移除），请求的URL已移走。Response中应该包含一个Location URL,说明资源现在所处的位置 302 found 重定向 400 Bad Request 客户端请求有语法错误，不能被服务器解析 404 表示没有找到请求的资源 500 表示服务端内部错误 方法 典型用法 典型状态码 安全？ 幂等？ GET - 获取表示- 变更时获取表示（缓存） 200（OK） - 表示已在响应中发出204（无内容） - 资源有空表示301（Moved Permanently） - 资源的 URI 已被更新303（See Other） - 其他（如，负载均衡）304（not modified）- 资源未更改（缓存）400 （bad request）- 指代坏请求（如，参数错误）404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务端当前无法处理请求 是 是 DELETE - 删除资源 200 （OK）- 资源已被删除301 （Moved Permanently）- 资源的 URI 已更改 303 （See Other）- 其他，如负载均衡400 （bad request）- 指代坏请求 t 404 （not found）- 资源不存在 409 （conflict）- 通用冲突500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务端当前无法处理请求 否 是 PUT - 用客户端管理的实例号创建一个资源- 通过替换的方式更新资源- 如果未被修改，则更新资源（乐观锁） 200 （OK）- 如果已存在资源被更改 201 （created）- 如果新资源被创建301（Moved Permanently）- 资源的 URI 已更改303 （See Other）- 其他（如，负载均衡）400 （bad request）- 指代坏请求404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示 /p&gt;409 （conflict）- 通用冲突412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务当前无法处理请求 否 是 POST - 使用服务端管理的（自动产生）的实例号创建资源- 创建子资源- 部分更新资源- 如果没有被修改，则不过更新资源（乐观锁） 200（OK）- 如果现有资源已被更改 201（created）- 如果新资源被创建 202（accepted）- 已接受处理请求但尚未完成（异步处理）301（Moved Permanently）- 资源的 URI 被更新 303（See Other）- 其他（如，负载均衡）400（bad request）- 指代坏请求 404 （not found）- 资源不存在 406 （not acceptable）- 服务端不支持所需表示 409 （conflict）- 通用冲突 412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突） 415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应 503 （Service Unavailable）- 服务当前无法处理请求 否 否","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/tags/HTTP/"}],"author":"Alloceee"},{"title":"Ping命令的使用","slug":"计算机网络/计算机网络-Ping","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:42:26.000Z","comments":true,"path":"2020/07/15/计算机网络/计算机网络-Ping/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Ping/","excerpt":"","text":"一、概览对于 ping 命令，想必只要是程序员都知道吧？当我们检查网络情况的时候，最先使用的命令肯定是 ping 命令吧？一般我们用 ping 查看网络情况，主要是检查两个指标，第一个是看看是不是超时，第二个看看是不是延迟太高。如果超时那么肯定是网络有问题啦（禁 ping 情况除外），如果延迟太高，网络情况肯定也是很糟糕的。那么对于 ping 命令的原理，ping 是如何检查网络的？大家之前有了解吗？接下来我们来跟着 ping 命令走一圈，看看 ping 是如何工作的。 二、环境准备和抓包2.1 环境准备 1.抓包工具。我这里使用 Wireshark。 2.我准备了两台电脑，进行 ping 的操作。ip 地址分别为： A 电脑：192.168.2.135 MAC 地址：98:22:EF:E8:A8:87 B 电脑：192.168.2.179 MAC 地址：90:A4:DE:C2:DF:FE 2.2 抓包操作 打开 Wireshark，选取指定的网卡进行抓包，进行 ping 操作，在 A 电脑上 ping B 电脑的 ip。 抓包情况如下： 这里先简单的介绍下 Wireshark 的控制面板，这个面板包含 7 个字段，分别是： NO：编号 Time：包的时间戳 Source：源地址 Destination：目标地址 Protocol：协议 Length：包长度 Info：数据包附加信息 三、深入解析上图中抓包编号 54-132 显示的就是整个 ping 命令的过程，我们知道 ping 命令不是依托于 TCP 或者 UDP 这种传输层协议的，而是依托于 ICMP 协议实现的，那么什么是 ICMP 协议呢？这里简单介绍下： 3.1 ICMP 协议的产生背景 [RFC792] 中说明了 ICMP 产生的原因：由于互联网之间通讯会涉及很多网关和主机，为了能够报告数据错误，所以产生了 ICMP 协议。也就是说 ICMP 协议就是为了更高效的转发 IP 数据报和提高交付成功的机会。 3.2 ICMP 协议的数据格式 根据上图我们知道了 ICMP 协议头包含 4 个字节，头部主要用来说明类型和校验 ICMP 报文。下图是对应的类型和代码释义列表，我们后面分析抓包的时候会用到。 简单介绍完了 ICMP，那么抓包过程中出现的 ARP 协议是什么呢？我们同样来简单解释下： 3.3 ARP 协议 我们知道，在一个局域网中，计算机通信实际上是依赖于 MAC 地址进行通信的，那么 ARP（Address Resolution Protocol）的作用就是根据 IP 地址查找出对应 ip 地址的 MAC 地址。 3.4 Ping 过程解析 了解了上面的基础概念后，我们来分析下抓包的数据。图 b 的流程如下： A 电脑（192.168.2.135）发起 ping 请求，ping 192.168.2.179。 A 电脑广播发起 ARP 请求，查询 192.168.2.179 的 MAC 地址。 B 电脑应答 ARP 请求，向 A 电脑发起单向应答，告诉 A 电脑自己的 MAC 地址为 90:A4:DE:C2:DF:FE。 知道了 MAC 地址后，开始进行真正的 ping 请求，由于 B 电脑可以根据 A 电脑发送的请求知道源 MAC 地址，所有就可以根据源 MAC 地址进行响应了。 上面的请求过程我画成流程图比较直观一点： 观察仔细的朋友可能已经发现，Ping4 次请求和响应结束后，还有一次 B 电脑对 A 电脑的 ARP 请求，这是为什么呢？这里我猜测应该是有 2 个原因： 1.由于 ARP 有缓存机制，为了防止 ARP 过期，结束后重新更新下 ARP 缓存，保证下次请求能去往正确的路径，如果 ARP 过期就会导致出现一次错误，从而影响测试准确性。 2.由于 ping 命令的响应时间是根据请求包和响应包的时间戳计算出来的，所以一次 ARP 过程也是会消耗时间。这里提前缓存最新的 ARP 结果就是节省了下次 ping 的 arp 时间。 为了验证我们的猜测，我再进行一次 ping 操作，抓包看看是不是和我们猜测的一样。此时，计算机里面已经有了 ARP 的缓存，我们执行 ARP -a 看看缓存的 arp 列表： 我们看看第二次 ping 的抓包： 我们看到上图中在真正 ping 之前并没有进行一次 ARP 请求，这也就是说，直接拿了缓存中的 arp 来执行了，另外当 B 计算机进行响应之前还是进行了一次 ARP 请求，它还是要确认下之前的 ARP 缓存是否为正确的。然后结束 ping 操作之后，同样在发一次 ARP 请求，更新下自己的 ARP 缓存。这里和我们的猜想基本一致。 弄懂了 ping 的流程之后我们来解析下之前解释的 ICMP 数据结果是否和抓包的一致。我们来点击一个 ping request 看看 ICMP 协议详情： 图中红框内就行 ICMP 协议的详情了，这里的 Type=8, code=0, 校验是正确。我们对比就知道了这是一个请求报文。我们再点击 Response frame:57，这里说明响应报文在序号 57。详情如下： 上图的响应报文，Type=0, code=0。这里知道就是响应报文了，然后最后就是根据请求和响应的时间戳计算出来的响应延迟。3379.764 ms-3376.890 ms=2.874 ms。 四、总结我们分析了一次完整的 ping 请求过程，ping 命令是依托于 ICMP 协议的，ICMP 协议的存在就是为了更高效的转发 IP 数据报和提高交付成功的机会。ping 命令除了依托于 ICMP，在局域网下还要借助于 ARP 协议，ARP 协议能根据 IP 地址查出计算机 MAC 地址。ARP 是有缓存的，为了保证 ARP 的准确性，计算机会更新 ARP 缓存。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://alloceee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"TCP的三次握手和四次挥手","slug":"计算机网络/计算机网络-TCP的三次握手和四次挥手","date":"2020-07-15T02:39:02.000Z","updated":"2021-08-04T01:35:49.430Z","comments":true,"path":"2020/07/15/计算机网络/计算机网络-TCP的三次握手和四次挥手/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"TCP的三次握手和四次挥手过程","text":"TCP的三次握手和四次挥手过程 TCP的三次握手和四次挥手两个序号和三个标志位 seq 表示所传数据的序号 TCP传输时每一个字节都有一个序号，发送数据时会将数据的第一个序号发送给对方，接收方会按序号检查是否接受完整了，如果没有接受完整就需要重新传送，这样就可以保证数据的完整性。 ack 表示确认号 ACK 确认位 SYN 同步位 FIN 终止位 用来在数据传输完毕后释放连接 创建TCP连接 客户端 - 发送带有SYN标志的数据包 - 一次握手 - 服务端 服务端 - 发送带有SYN/ACK标志的数据包 - 二次握手 - 客户端 客户端 - 发送带有ACK标志的数据包 - 三次握手 - 服务端 四次挥手 断开TCP连接","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/tags/HTTP/"}],"author":"Alloceee"},{"title":"WebSocket的介绍和使用","slug":"计算机网络/计算机网络-WebSocket","date":"2020-07-15T02:39:02.000Z","updated":"2021-08-04T01:42:19.617Z","comments":true,"path":"2020/07/15/计算机网络/计算机网络-WebSocket/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-WebSocket/","excerpt":"WebSocket协议RFC 6455提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它来自HTTP的不同TCP协议，但设计为使用端口80和443通过HTTP工作，并允许重用现有的防火墙规则。运行在TLS之上时，默认使用443端口。 WebSocket使客户端和服务器之间的数据交换变得更加简单，允许服务器主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。","text":"WebSocket协议RFC 6455提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它来自HTTP的不同TCP协议，但设计为使用端口80和443通过HTTP工作，并允许重用现有的防火墙规则。运行在TLS之上时，默认使用443端口。 WebSocket使客户端和服务器之间的数据交换变得更加简单，允许服务器主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 介绍WebSocket交互以HTTP请求开始，该HTTP请求使用HTTP &quot;Upgrade&quot;标头升级，或者在这种情况下切换到WebSocket协议： 12345678GET / spring-websocket-portfolio / portfolio HTTP / 1.1Host：localhost：8080Upgrade：websocket Connection：UpgradeSec-WebSocket-Key：Uc9l9TMkWGbHFD2qnFHltg ==Sec-WebSocket-Protocol：v10.stomp，v11.stompSec-WebSocket-Version：13Origin：http：// localhost：8080 Connection必须设置为Upgrade，表示客户端希望连接升级 Upgrade字段必须设施webSocket，表示连接升级到WebSocket协议 Sec-WebSocket-Key是随机字符串，服务器会用这些数据来构造出一个SHA-1的信息摘要。如此操作，避免普通HTTP请求被误以为WebScoket协议 Sec-WebSocket-Version表示支持的版本。RFC6455要求使用的版本是13，之前的版本均应当弃用 Origin字段可选，通常用来表示在浏览器中发起此WebSocket连接所在的页面，类似Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。 WebSocket和Socket的区别Socket是传输控制层协议，WebScoket是应用层协议。 SpringBoot中的使用客户端介绍WebSocket 对象创建1var socket = new WebSocket(url,[protocol]); 参数 描述 url 指定连接的URL protocol 参数可选，指定可接收的子协议 WebSocket 方法 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 12345function sendMessage() &#123; if (socket.readyState === 1) &#123; socket.send(JSON.stringify(message)); &#125; &#125; 需要先打开连接再调用send方法，因此最好先做状态判断 WebSocket 事件 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 WebSocket 属性 属性 描述 Socket.readyState 只读属性readyState表示连接状态，可以是以下值： 0 -表示连接尚未建立 1 -表示连接已建立，可以进行通信 2 -表示连接正在进行关闭 3 -表示连接已经关闭或者连接不能打开 Socket.bufferedAmount 只读属性bufferedAmount已被send()放入正在队列中等待传输，但是还没有发出的UTF-8文本字节数 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; $(function () &#123; var socket; function openWebSocket() &#123; //判断浏览器是否支持websocket if ((typeof WebSocket) == &quot;undefined&quot;) &#123; console.log(&quot;您的浏览器不支持WebSocket&quot;); &#125; else &#123; var socketUrl = &#x27;ws://192.168.2.234:1234/socket/$&#123;user.uuid&#125;&#x27;; socket = new WebSocket(socketUrl); socket.onopen = function (ev) &#123; console.log(&quot;websocket open&quot;); &#125;; socket.onmessage = function (ev) &#123; console.log(&quot;收到的信息 : &quot;+ev.data) socket.onerror = function (ev) &#123; console.log(&quot;websocket 已经关闭&quot;) &#125;; socket.onclose = function (ev) &#123; console.log(&quot;websocket 发生了错误&quot;) &#125;; &#125; &#125;; openWebSocket(); $(&quot;#sendContent&quot;).on(&#x27;click&#x27;,function () &#123; //声明一个消息 var message = &#123; nickname: &#x27;$&#123;user.nickname&#125;&#x27;, content: $(&#x27;#message&#x27;).html() &#125;; if (socket.readyState === 1) &#123; console.log(&quot;发送的信息 : &quot;+JSON.stringify(message)); socket.send(JSON.stringify(message)); &#125; &#125;); &#125;)&lt;/script&gt; 服务端介绍方法注解 方法 作用 @ServerEndpoint() 服务端的路由映射 @OnOpen() 当客户端握手时被调用，只会被调用一次 @OnMessage() 当客户端发来消息时被调用 @OnClose() 当客户端被关闭时调用 @OnError() 当发生错误时被调用 1234567891011121314151617181920@OnOpenpublic void onOpen(Session session, @PathParam(&quot;userId&quot;)String userId)&#123; this.session = session;&#125;@OnMessagepublic void onMessage(String message,Session session) &#123; //注入的参数为前端传过来的数据 System.out.println(message); &#125;@OnClosepublic void onClose (@PathParam(&quot;userId&quot;)String userId)&#123; webSocketList.remove(userId); //在线人数减一 subOnlineCount();&#125;@OnErrorpublic void onError(Session session,Throwable error)&#123; System.out.println(&quot;发生错误&quot;); error.printStackTrace();&#125; Session代表会话，一次连接就是一个会话。意味着，N个客户端有N个session WebSocket + SpringBoot实现即时通信（群聊） 因为websocket注册的bean默认是自己管理，没有托管给spring，所以，此类是为了将websocket的bean托管给spring容器 123456789101112131415@Configuration@ConditionalOnWebApplicationpublic class WebSocketConfig &#123; //使用boot内置tomcat时需要注入此bean @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125; @Bean public MySpringConfigurator mySpringConfigurator() &#123; return new MySpringConfigurator(); &#125;&#125; 123456789101112131415161718/** * 以websocketConfig.java注册的bean是由自己管理的，需要使用配置托管给spring管理 * @author AlmostLover */public class MySpringConfigurator extends ServerEndpointConfig.Configurator implements ApplicationContextAware &#123; private static volatile BeanFactory context; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; MySpringConfigurator.context = applicationContext; &#125; @Override public &lt;T&gt; T getEndpointInstance(Class&lt;T&gt; clazz) throws InstantiationException &#123; return context.getBean(clazz); &#125;&#125;0 异常解决java.io.EOFException java.lang.IllegalStateException: The WebSocket session [1] has been closed and no method (apart from close()) may be called on a closed session","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://alloceee.github.io/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://alloceee.github.io/tags/WebSocket/"}],"author":"Alloceee"},{"title":"JS原型和原型链","slug":"大前端/JavaScript/Javascript-原型链","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:32:28.000Z","comments":true,"path":"2020/07/15/大前端/JavaScript/Javascript-原型链/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/Javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"js的原型和原型链构造函数创建对象： 123456function Person() &#123;&#125;var person = new Person();person.name = &#x27;Kevin&#x27;;console.log(person.name) // Kevin Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person prototype每个函数都有一个 prototype 属性 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &#x27;Kevin&#x27;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin image.png proto每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true image.png constructor每个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true image.png 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型12345678910111213function Person() &#123;&#125;Person.prototype.name = &#x27;Kevin&#x27;;var person = new Person();person.name = &#x27;Daisy&#x27;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 原型与原型123var obj = new Object();obj.name = &#x27;Kevin&#x27;console.log(obj.name) // Kevin image.png 原型链1console.log(Object.prototype.__proto__ === null) // true image.png JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://alloceee.github.io/tags/JavaScript/"}]},{"title":"JavaScript-常用功能","slug":"大前端/JavaScript/Javascript-常用功能","date":"2020-07-15T02:39:02.000Z","updated":"2021-08-06T04:45:17.666Z","comments":true,"path":"2020/07/15/大前端/JavaScript/Javascript-常用功能/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript/Javascript-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/","excerpt":"","text":"一键复制clipboard.min.js123456789101112131、引入clipboard.min.js2、&lt;button class=&quot;copyBtn&quot; data-clipboard-text=&quot;&quot; data-clipboard-action=&quot;copy&quot;&gt;点击复制&lt;/button&gt;3、$(&quot;button&quot;).attr(&quot;data-clipboard-text&quot;, &quot;jiaomeichen.github.io&quot;); var clipboard = new Clipboard(&#x27;.copyBtn&#x27;); clipboard.on(&#x27;success&#x27;, function(e) &#123; layer.msg(&quot;已复制成功&quot; + e.text); &#125;); clipboard.on(&#x27;error&#x27;, function(e) &#123; layer.open(&#123; title: &#x27;提示&#x27;, content: &#x27;您的浏览器可能不支持，请手动复制~&#x27; &#125;); &#125;); 判断微端与PC端123456var UA = window.navigator.userAgent.toLowerCase();var isAndroid = UA.indexOf(&#x27;android&#x27;)&gt;0;var isIOS = /iphone|ipad|ipod|ios/.test(UA);if(!(isAndroid ||isIOS))&#123; // &#125; 123456789101112131415161718192021222324252627282930313233343536var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核 presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核 webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1,//火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Adr&#x27;) &gt; -1, //android终端 iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad webApp: u.indexOf(&#x27;Safari&#x27;) == -1, //是否web应该程序，没有头部与底部 weixin: u.indexOf(&#x27;MicroMessenger&#x27;) &gt; -1, //是否微信 （2015-01-22新增） qq: u.match(/\\sQQ/i) == &quot; qq&quot; //是否QQ &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125; //判断是否IE内核if(browser.versions.trident)&#123; alert(&quot;is IE&quot;); &#125;//判断是否webKit内核if(browser.versions.webKit)&#123; alert(&quot;is webKit&quot;); &#125;//判断是否移动端if(browser.versions.mobile||browser.versions.android||browser.versions.ios)&#123; alert(&quot;移动端&quot;); &#125;//检测浏览器语言 currentLang = navigator.language; //判断除IE外其他浏览器使用语言if(!currentLang)&#123;//判断IE浏览器使用语言 currentLang = navigator.browserLanguage;&#125;alert(currentLang); 将阿拉伯数字转化为中文1234567891011121314151617toChinesNum: function (num) &#123; let changeNum = [&#x27;零&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;, &#x27;九&#x27;]; //changeNum[0] = &quot;零&quot; let unit = [&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;千&quot;, &quot;万&quot;]; num = parseInt(num); let getWan = (temp) =&gt; &#123; let strArr = temp.toString().split(&quot;&quot;).reverse(); let newNum = &quot;&quot;; for (var i = 0; i &lt; strArr.length; i++) &#123; newNum = (i == 0 &amp;&amp; strArr[i] == 0 ? &quot;&quot; : (i &gt; 0 &amp;&amp; strArr[i] == 0 &amp;&amp; strArr[i - 1] == 0 ? &quot;&quot; : changeNum[strArr[i]] + (strArr[i] == 0 ? unit[0] : unit[i]))) + newNum; &#125; return newNum; &#125;; let overWan = Math.floor(num / 10000); let noWan = num % 10000; if (noWan.toString().length &lt; 4) noWan = &quot;0&quot; + noWan; return overWan ? getWan(overWan) + &quot;万&quot; + getWan(noWan) : getWan(num); &#125; 获取url参数1234567891011getQueryVariable: function (variable) &#123; var query = window.location.search.substring(1); var vars = query.split(&quot;&amp;&quot;); for (var i = 0; i &lt; vars.length; i++) &#123; var pair = vars[i].split(&quot;=&quot;); if (pair[0] == variable) &#123; return pair[1]; &#125; &#125; return (false); &#125; JQUERY获取html标签自定义属性值或data值//获取属性值 1 12&lt;div id=&quot;text&quot; value=&quot;黑哒哒的盟友&quot;&gt;&lt;div&gt; $(&quot;#text&quot;).attr(&quot;value&quot;); //获取自定义属性值 2 12&lt;div id=&quot;text&quot; value=&quot;123&quot; data_obj=&quot;黑哒哒的盟友&quot;&gt;&lt;div&gt; $(&quot;#text&quot;).attr(&quot;data_obj&quot;); //获取data值 3 12&lt;div id=&quot;text&quot; value=&quot;123&quot; data-name=&quot;黑哒哒的盟友&quot;&gt;&lt;div&gt; $(&quot;#text&quot;).data(&quot;name&quot;); 让select下拉click事件不能让select下来，只需要在你添加点击事件的元素上加pointer-events: none样式，代表该元素不再是点击目标直接穿过，就可以直接点击到下面的元素","categories":[{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"JavaScript","slug":"web/JavaScript","permalink":"https://alloceee.github.io/categories/web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://alloceee.github.io/tags/JavaScript/"}],"author":"Alloceee"},{"title":"前端小技巧：CSS雪碧图","slug":"大前端/other/前端小技巧：CSS雪碧图","date":"2020-07-15T02:39:02.000Z","updated":"2021-08-04T01:48:38.808Z","comments":true,"path":"2020/07/15/大前端/other/前端小技巧：CSS雪碧图/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E5%A4%A7%E5%89%8D%E7%AB%AF/other/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9ACSS%E9%9B%AA%E7%A2%A7%E5%9B%BE/","excerpt":"CSS Sprite，中文翻译为雪碧图，Ta主要解决的是小图片过多以及耗费网络资源的问题，核心原理就是将图片合并成一张大图下发到客户程序，并利用属性来对其进行定位和切割的技术。","text":"CSS Sprite，中文翻译为雪碧图，Ta主要解决的是小图片过多以及耗费网络资源的问题，核心原理就是将图片合并成一张大图下发到客户程序，并利用属性来对其进行定位和切割的技术。 当在浏览器里输入一个URL地址的时候，你会感觉无数张图片“唰唰唰”的闪出来了。在这个过程中，浏览器会把这个网站的主资源（就是Html文件）拉取回来，然后开始分析网页中的Js，Img之类的标签，然后再去拉取这些图片和资源，这些后拉取的资源称为「子资源」。 「主资源」和「子资源」只是我们人类对资源定义的不同方式，其实对于浏览器来说，他们的请求方式都是发起一个Http请求，经历三次握手，并把文件拉取回来，一般的浏览器内核只能同时并发4，5个网络请求，所以大量的小图片特别影响性能，不但网页加载完成时间慢，还可能影响一些重要的JS逻辑，使得网页响应也变慢，卡死等等。对于浏览器来说，发起一个Http请求，来回几百毫秒的耗时，已经是相当高的资源耗费，只是人类不曾感受到，其实浏览器已经无数次喊叫：“太NMD慢了，哪个SB写的代码……”。 例如上图，一个网页的一小块区域，就三张小图标，浏览器要辛辛苦苦三次才能把这些小图标取回来，如果是50张呢，显然不可接受。面对这样的情况就只能束手就擒吗？显然优化的关键途径就是减少网络请求次数，并且还得把图片都下发下来，并能够灵活使用，那就把所有小图标拼成一张大图吧，如下图。 当前，用一次网络请求就可以下载下来三张图片了，而且文件的大小也较三张图片小一些（因为很多文件的格式信息和头信息已经共用了），大大降低了网络请求和带宽的消耗。然后呢，如何在Html或CSS中引用这些图片呢？ 这就不得不提到一个CSS属性叫做background-position，利用Ta，可以指定图片的位置，也就能把这张图片作为一个背景放在某个位置了，我们来看两句CSS代码。 利用这个属性，来标识图片相对于容器的位置（图中的坐标分别标识X，Y两个方向的偏移，这些都是示意的值哦，不是真实的值），最后再把这个类选择器应用到相应的容器就好了。 这种技术就称为CSS Sprite，中文翻译为雪碧图，Ta主要解决的是小图片过多以及耗费网络资源的问题，核心原理就是将图片合并成一张大图下发到客户程序，并利用属性来对其进行定位和切割的技术。 其实在游戏当中，很多也是利用了类似的思想，比如一个小人走路的时候，一共由8张图片组成，那么一般这8张图片会合并为一张大图，每一帧都循环播放这张大图中的不同坐标下的小图片来构建小人的行走动作。 其实在追求高性能的app中，很多也是利用了类似的思想，比如对性能极致要求的话，一个Titlebar上有5个icon，那5个icon是可以合并为一张大图的，这样只会有一次IO，减少了IO次数，会对效率提升比较大，分割图片都是内存操作，会非常迅速。","categories":[{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"https://alloceee.github.io/categories/web/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://alloceee.github.io/tags/css/"},{"name":"web","slug":"web","permalink":"https://alloceee.github.io/tags/web/"}],"author":"Alloceee"},{"title":"数据库索引模块","slug":"数据库/MySQL/数据库索引模块","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:46:42.000Z","comments":true,"path":"2020/07/15/数据库/MySQL/数据库索引模块/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9D%97/","excerpt":"","text":"如何设计一个关系型数据库程序实例： 存储管理 减少对数据的访问，提供缓存机制（全页缓存） SQL解析 日志管理：缓存不易过大，提供淘汰策略，在数据库修改之后及时修改缓存，进行主从同步和灾难恢复 权限划分 容灾机制 索引管理 锁管理 影响数据的运行瓶颈就是IO 存储（文件系统）索引模块为什么使用索引原始数据的查询方法就是将全表放入内存中，全表扫描轮询找到需要查找的数据，少量数据可以，大量数据严重影响性能。 什么样的信息能成为索引主键：唯一键以及普通键 索引的数据结构生成索引，建立二叉查找树进行二分查找（二叉树–平衡二叉树–红黑树）因为是二分查找，时间复杂度为O(logn) 生成索引，建立B-Tree结构进行查找因为添加结点导致二叉树的深度增加，虽然进行旋转可以使其继续维持平衡，但是增加了IO，降低了性能，因此提供了B-Tree结构（平衡多路查找树）。 每个结点最多有m个孩子，这个结点就是M阶B树 每个存储块包括关键字和指向结点的指针，最多有几个孩子取决于存储块的容量和数据库的相关配置 生成索引，建立B+-Tree结构进行查找 生成索引，建立Hash结构进行查找 密集索引和稀疏索引的区别密集索引密集索引文件中每一个搜索码值都对应一个索引值，就是叶子节点保存的不只是键值，还保存了位于同一行记录里的其他列信息，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引。 稀疏索引稀疏索引文件只为索引码的某些值建立索引项，比如InnoDB的其他索引只存了键位信息和主键，MyISAM的所有索引都是稀疏索引。 MyISAM–》 主键索引，唯一键索引，还是普通索引 —都是 稀疏索引 额外知识InnoDB 若一个主键被定义，该主键则作为密集索引 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引 若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引） 非主键索引存储相关键位和其对应的主键值，包含两次查找 InnoDB聚簇表分布myisam在磁盘存储上有三个文件，每个文件名以表名开头，扩展名指出文件类型。.frm 用于存储表的定义.MYD 用于存放数据.MYI 用于存放表索引 可以看到—–》 Innodb索引与数据放在一起 慢查询/索引101.数据库索引的实现(B+树介绍、和B树、R树区别) 参考文章：数据库索引的实现原理 - 辉仔 の专栏 - 博客频道 - CSDN.NET由浅入深理解数据库中索引的底层实现 | 学步园 102.SQL性能优化 参考文章：高手详解SQL性能优化十条经验 - 51CTO.COMOracle SQL性能优化 - 一江水 - 博客园 103.数据库索引的优缺点以及什么时候数据库索引失效 参考文章：数据库索引的作用和优点缺点以及索引的11中用法 - 技术与人生 - 博客园正确高效使用数据库不可不知的索引失效问题 - simplefrog - 博客园SQL优化避免索引失效 - OPEN 开发经验库Colin Lau Oracle哪些情况下索引会失效？ - 曾是土木人 - 博客园","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"索引的使用和含义","slug":"数据库/MySQL/高级SQL","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:41:58.000Z","comments":true,"path":"2020/07/15/数据库/MySQL/高级SQL/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%AB%98%E7%BA%A7SQL/","excerpt":"","text":"索引索引（Index）是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。MySQL索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特殊指明，一般都是B树结构组织的索引（B+Tree索引） 索引是什么?索引是帮助MySQL高效获取数据的数据结构。 索引能干什么?提高数据查询的效率。 索引：排好序的快速查找数据结构！索引会影响where后面的查找，和order by 后面的排序。公众号：Java后端 发布过几十篇 MySQL 文章，其中包括索引的文章，可以关注后后台回复 666 获取。 一、索引的分类 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。 从应用层次来分：普通索引，唯一索引，复合索引。 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。 1 中所描述的是索引存储时保存的形式，2 是索引使用过程中进行的分类，两者是不同层次上的划分。不过平时讲的索引类型一般是指在应用层次的划分。 就像手机分类，安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引唯一索引：索引列的值必须唯一，但允许有空值复合索引：即一个索引包含多个列聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。非聚簇索引：不是聚簇索引，就是非聚簇索引（认真脸）。二、索引的底层实现 mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。不谈存储引擎，只讨论实现(抽象)Hash索引 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。 B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。 是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。 案例：假设有一张学生表，id为主键 在MyISAM引擎中的实现（二级索引也是这样实现的） 在InnoDB中的实现 三、问题 问：为什么索引结构默认使用B-Tree，而不是hash，二叉树，红黑树？hash：虽然可以快速定位，但是没有顺序，IO复杂度高。二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。红黑树：树的高度随着数据量增加而增加，IO代价高。问：为什么官方建议使用自增长主键作为索引。结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。插入连续的数据： 插入非连续的数据 视图触发器count(1)、count(*)和count(字段)区别https://zhuanlan.zhihu.com/p/28397595","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"缓存雪崩、缓存击穿和缓存穿透","slug":"数据库/Redis/缓存雪崩、缓存穿透和缓存击穿","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:42:10.000Z","comments":true,"path":"2020/07/15/数据库/Redis/缓存雪崩、缓存穿透和缓存击穿/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/","excerpt":"","text":"缓存雪崩、缓存穿透和缓存击穿的区别是什么，各自有什么解决方案缓存穿透一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的Key，请求量很大，就会对后端系统造成很大的压力，这就叫做缓存穿透。 如何避免 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据Insert了之后清理缓存。 对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的bitmap中，查询时通过该bitmap过滤。 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。 如何避免 在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 做二级缓存，A1为原始数据，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 缓存击穿对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。 如何避免 使用互斥锁，当缓存失效时，不立即去load DB，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时在进行Load DB的操作并回设缓存，否则重试get缓存的方法 永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新） 使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤。 缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。解决方案：为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的话更新缓存时间。这样每次取session,都会延长30分钟，相对来说，就减少了缓存过期的几率 缓存一致性要求数据更新的同时缓存数据也能够实时更新。 解决方案：在数据更新的同时立即去更新缓存，首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。","categories":[],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://alloceee.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"TCP&UDP","slug":"计算机网络/计算机网络-TCP&UDP","date":"2020-07-15T02:39:02.000Z","updated":"2020-07-16T03:42:34.000Z","comments":true,"path":"2020/07/15/计算机网络/计算机网络-TCP&UDP/","link":"","permalink":"https://alloceee.github.io/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP&UDP/","excerpt":"","text":"OSI七层模型各层的作用 层名 作用 应用层 网络服务与最终用户的一个接口 表示层 把应用层提供的信息变换为能够共同理解的形式 会话层 建立、管理、终止会话。 传输层 定义传输数据的协议端口号，以及流控和差错校验。 网络层 路由选择和中继，在一条数据链路上复用多条网络连接 数据链路层 数据链路的建立，拆除，对数据的检错，纠错是数据链路层的基本任务。 物理层 物理层并不是物理媒体本身，它只是开放系统中利用物理媒体实现物理连接的功能描述和执行连接的规程。 TCP/IP协议Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。协议采用了4层的层级结构。然而在很多情况下，它是利用 IP 进行通信时所必须用到的协议群的统称。 TCP 和 UDPTCP 是面向连接的、可靠的流协议，通过三次握手建立连接，通讯完成时要拆除连接。UDP是面向无连接的通讯协议，UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象。 TCP UDP 面向连接 无连接，即发送数据前不需要建立连接 提供可靠服务，也就是说，通过TCP传输的数据无差错，不丢失，不重复，且按顺序到达 尽最大努力交付，即不保证可靠交付 面向字节流 面向报文，并且网络出现阻塞不会使得发送速率降低，因此会出现丢包 只能1对1 支持1对1，1对多 首部较大，为20字节 8字节 三次握手和四次分手 TCP/IP中的数据包 包是全能性术语； 帧用于表示数据链路层中包的单位； 片是 IP中数据的单位； 段则表示 TCP 数据流中的信息； 消息是指应用协议中数据的单位。 TCP 中通过序列号与确认应答提高可靠性 HTTP请求的传输过程 一次完整http请求的7个过程 建立 TCP 连接（之前可能还有一次DNS域名解析） 客户端向服务器发送请求命令 客户端发送请求头信息 服务服务器应答器 返回响应头信息 服务器向客户端发送数据 服务器关闭 TCP 连接 HTTP 协议报文结构 请求报文结构 响应报文结构 SocketSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 短连接： 连接-&gt;传输数据-&gt;关闭连接 HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 长连接： 连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 什么时候用长连接，短连接？ ​ 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。 总之，长连接和短连接的选择要视情况而定。 Linux网络IO模型同步和异步，阻塞和非阻塞 阻塞I/O（blocking I/O） 进程会一直阻塞，直到数据拷贝完成 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。 当调用recv()函数时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。当数据准备好后，将数据从系统缓冲区复制到用户空间，然后该函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数就会处于等待状态。 非阻塞IO模型 非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的； 我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。上述模型绝不被推荐。 ​ 把SOCKET设置为非阻塞模式，即通知系统内核：在调用Windows Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。图所示，一个非阻塞模式套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此，该函数立即返回WSAEWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中，recv()函数返回成功指示，应用程序开始处理数据。 IO复用模型 select和epoll；对一个socket，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个socket进行处理。 ​ 简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听； ​ I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。 当用户进程调用了select，那么整个进程会被block；而同时，kernel会“监视”所有select负责的socket；当任何一个socket中的数据准备好了，select就会返回。这个时候，用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 信号驱动IO 套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 ​ 简介：两次调用，两次返回； ​ 首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 异步IO模型 当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。 5个I/O模型的比较： select、poll、epoll的区别 5个I/O模型的比较select、poll、epoll的区别？： 1、支持一个进程所能打开的最大连接数 select 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），可以对进行修改，然后重新编译内核，但是性能可能会受到影响。 poll poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 epoll 连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接 2、FD剧增后带来的IO效率问题 select 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。 poll 同上 epoll 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 3、 消息传递方式 select 内核需要将消息传递到用户空间，都需要内核拷贝动作 poll 同上 epoll epoll通过内核和用户空间共享一块内存来实现的。 补充知识点：Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！ Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！ select(),poll()模型都是水平触发模式，信号驱动IO是边缘触发模式，epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发。 原生JDK网络编程 原生JDK网络编程- AIO 原生JDK网络编程- NIO之Reactor模式 原生JDK网络编程- NIO 原生JDK网络编程- Buffer 114.TCP和UDP区别 参考TCP和UDP的区别（转） - bizhu - 博客园 socket通信（tcp/udp区别及JAVA的实现方式）TCP——传输控制协议，具有极高的可靠性，保证数据包按照顺序准确到达，但其也有着很高的额外负担。UDP——使用者数据元协议，并不能保证数据包会被成功的送达，也不保证数据包到达的顺序，但其传输速度很快。大多数我们会使用TCP，偶尔才会动用UDP，如声音讯号，即使少量遗失，也无关紧要。 TCP什么是TCP粘包和拆包 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包 将发送数据大于MSS(最大报文长度)，TCP在传输前将进行拆包 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包 TCP粘包和拆包的解决方法 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了 发送端将每个数据包封装为固定长度（不够可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包分开","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://alloceee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"初始排序算法","slug":"Algorithm/算法-排序算法","date":"2020-07-15T02:39:02.000Z","updated":"2020-08-10T06:00:30.000Z","comments":true,"path":"2020/07/15/Algorithm/算法-排序算法/","link":"","permalink":"https://alloceee.github.io/2020/07/15/Algorithm/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法可以分为两大类： 1、非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 2、线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 内部排序 内部排序：全部数据可同时放入内存进行的排序。 外部排序：文件中数据太多，无法全部调入内存进行的排序。 插入类： 直接插入排序。最坏情况是数据递减序，数据比较和移动量最大，达到O(n2)，最好是数据是递增序，比较和移动最少为O(n)。趟数是固定的n-1，即使有序，也要依次从第二个元素开始。排序趟数不等于时间复杂度。 折半插入排序 。由于插入第i个元素到r[1]到r[i-1]之间时，前i个数据是有序的，所以可以用折半查找确定插入位置，然后插入。 希尔排序。缩小增量排序。5-3-1。在实际应用中，步长的选取可简化为开始为表长n的一半（n/2），以后每次减半，最后为1。插入的改进，最后一趟已基本有序，比较次数和移动次数相比直接插入最后一趟更少 交换类： 冒泡排序。O(n 2 )通常认为冒泡是比较差的，可以加些改进，比如在一趟中无数据的交换，则结束等措施。 在数据已基本有序时，冒泡是一个较好的方法 在数据量较少时（15个左右）可以用冒泡 快速排序。 时间复杂度。最好情况：每次支点总在中间，O(nlog2n)，平均O(nlog2n)。最坏，数据已是递增或递减，O(n2)。pivotkey的选择越靠近中央，即左右两个子序列长度越接近，排序速度越快。越无序越快。 空间复杂度。需栈空间以实现递归，最坏情况：S(n)=O(n)；一般情况：S(n)=O(log2n) 在序列已是有序的情况下，时间复杂度最高。原因：支点选择不当。改进：随机选取支点或最左、最右、中间三个元素中的值处于中间的作为支点，通常可以避免最坏情况。所以，快速排序在表已基本有序的情况下不合适。 在序列长度已较短时，采用直接插入排序、起泡排序等排序方法。序列的个数通常取10左右。 选择类排序： 简单选择排序。O(n2)。总比较次数n(n-1)/2。 堆排序。建堆 O(n)，筛选排序O(nlogn)。找出若干个数中最大/最小的前K个数，用堆排序是最好。小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2]。时间复杂度不会因为待排序序列的有序程度而改变，但是待排序序列的有序程度会影响比较次数。 归并排序。时间：与表长成正比，若一个表表长是m，另一个是n，则时间是O(m+n)。单独一个数组归并，时间：O(nlogn)，空间：O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。归并排序算法比较占用内存，但却是效率高且稳定的排序算法。在外排序中使用。归并的趟数是logn。 基数排序。在一般情况下，每个结点有 d 位关键字，必须执行 t = d次分配和收集操作。分配的代价：O(n)；收集的代价：O(rd) （rd是基数）；总的代价为：O( d ×(n + rd))。适用于以数字和字符串为关键字的情况。 枚举排序，通常也被叫做秩排序，比较计数排序。对每一个要排序的元素，统计小于它的所有元素的个数，从而得到该元素在整个序列中的位置，时间复杂度为O(n2) 比较法分类的下界：O(nlogn) 排序算法的一些特点： 堆排序、冒泡排序、快速排序在每趟排序过程中,都会有一个元素被放置在其最终的位置上。 有字符序列 ｛Q,H,C,Y,P,A,M,S,R,D,F,X｝ ,新序列{F,H,C,D,P,A,M,Q,R,S,Y,X}，是快速排序算法一趟扫描的结果。(拿Q作为分割点,快速排序一轮。二路归并，第一趟排序，得到 n / 2 个长度为 2 的各自有序的子序列，第二趟排序，得到 n / 4 个长度为 4 的各自有序的子序列H Q C Y A P M S D R F X。如果是快速排序的话，第一个元素t将会被放到一个最准确的位置，t前的数均小于t，后面的数均大于t。希尔排序每个小分组内将会是有序的。堆排序，把它构成一颗二叉树的时候，该堆要么就是大根堆，要么就是小根堆，第一趟Y排在最后；冒泡，那么肯定会有数据下沉的动作，第一趟有A在第一位。) 在文件”局部有序”或文件长度较小的情况下,最佳内部排序的方法是直接插入排序。（归并排序要求待排序列已经部分有序，而部分有序的含义是待排序列由若干有序的子序列组成，即每个子序列必须有序，并且其时间复杂度为O(nlog2n)；直接插入排序在待排序列基本有序时，每趟的比较次数大为降低，即n-1趟比较的时间复杂度由O(n^2)降至O(n)。在待排序的元素序列基本有序或者每个元素距其最终位置不远也可用插入排序，效率最高的排序方法是插入排序） 排序趟数与序列的原始状态有关的排序方法是优化冒泡和快速排序法。(插入排序和选择排序不管序列的原始状态是什么都要执行n-1趟，优化冒泡和快排不一定。仔细理解排序的次数和比较次数的区别) 不稳定的排序方法：快排，堆排，希尔，选择 要与关键字的初始排列次序无关,那么就是最好、最坏、一般的情况下排序时间复杂度不变, 总共有堆排序,归并排序,选择排序,基数排序 快速排序、Shell 排序、归并排序、直接插入排序的关键码比较次数与记录的初始排列有关。折半插入排序、选择排序无关。(直接插入排序在完全有序的情况下每个元素只需要与他左边的元素比较一次就可以确定他最终的位置；折半插入排序，比较次数是固定的，与初始排序无关；快速排序，初始排序不影响每次划分时的比较次数，都要比较n次，但是初始排序会影响划分次数，所以会影响总的比较次数，但快排平均比较次数最小；归并排序在归并的时候，如果右路最小值比左路最大值还大，那么只需要比较n次，如果右路每个元素分别比左路对应位置的元素大，那么需要比较2*n-1次，所以与初始排序有关) 精俭排序，即一对数字不进行两次和两次以上的比较，插入和归并是“精俭排序”。插入排序，前面是有序的，后面的每一个元素与前面有序的元素比较，比较过的就是有序的了，不会再比较一次。归并每次合并后，内部都是有序的，内部的元素之间不用再比较。选择排序，每次在后面的元素中找到最小的，找最小元素的过程是在没有排好序的那部分进行，所有肯定会比较多次。堆排序也需比较多次。 外部排序 生成合并段（run）：读入文件的部分记录到内存－&gt;在内存中进行内部排序－&gt;将排好序的这些记录写入外存，形成合并段－&gt;再读入该文件的下面的记录，往复进行，直至文件中的记录全部形成合并段为止。 外部合并：将上一阶段生成的合并段调入内存，进行合并，直至最后形成一个有序的文件。 外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序 不管初始序列是否有序, 冒泡、选择排序时间复杂度是O(n^2),归并、堆排序时间复杂度是O(nlogn） 外部排序的总时间 = 内部排序（产出初始归并段）所需时间 + 外存信息读取时间 + 内部归并所需的时间 外排中使用置换选择排序的目的,是为了增加初始归并段的长度。减少外存读写次数需要减小归并趟数 根据内存容量设若干个输入缓冲区和一个输出缓冲区。若采用二路归并，用两个输入缓冲。 归并的方法类似于归并排序的归并算法。增加的是对缓冲的监视，对于输入，一旦缓冲空，要到相应文件读后续数据，对于输出缓冲，一旦缓冲满，要将缓冲内容写到文件中去。 外排序和内排序不只是考虑内外排序算法的性能，还要考虑IO数据交换效率的问题，内存存取速度远远高于外存。影响外排序的时间因素主要是内存与外设交换信息的总次数 有效的算法设计 贪心法。Dijkstra的最短路径(时间复杂度O(n2))；Prim求最小生成树邻接表存储时是O(n+e),图O(n2)；关键路径及关键活动的求法。 回溯法 分支限界法 分治法。分割、求解、合并。二分查找、归并排序、快速排序。 动态规划。Floyd-Warshall算法求解图中所有点对之间最短路径时间复杂度为O(n3) 动态规划解题的方法是一种高效率的方法，其时间复杂度通常为O(n2)，O(n3)等，可以解决相当大的信息量。（数塔在n&lt;=100层时，可以在很短的时间内得到问题解） 适用的原则：原则为优化原则，即整体优化可以分解为若干个局部优化。 动态规划比穷举法具有较少的计算次数 递归算法需要很大的栈空间，而动态规划不需要栈空间 贪心和动态规划的差别： 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 在动态规划算法中，每步所作的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能作出选择。而在贪心算法中，仅在当前状态下作出最好选择，即局部最优选择。然后再去解作出这个选择后产生的相应的子问题。 贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为一个规模更小的子问题。 P问题 P问题，如果它可以通过运行多项式次(即运行时间至多是输入量大小的多项式函数的一种算法获得解决），可以找到一个能在多项式的时间里解决它的算法。—-确定性问题 NP问题，虽然可以用计算机求解，但是对于任意常数k，它们不能在O(nk)时间内得到解答，可以在多项式的时间里验证一个解的问题。所有的P类问题都是NP问题。 NP完全问题，知道有效的非确定性算法，但是不知道是否存在有效的确定性算法，同时，不能证明这些问题中的任何一个不存在有效的确定性算法。这类问题称为NP完全问题。 插入排序直接插入排序插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有数据，算法适用于少量数据的排序，时间复杂度为0（n^2），是稳定的排序方法。 算法思路： 设置监视哨temp，将待插入记录的值赋值为temp； 设置开始查找的位置j； 在数组arr中进行搜索，搜索中将第j个记录后移，直到temp&gt;=arr[j]为止； 将temp插入arr[j+1]的位置上 123456789101112131415161718public static int[] insertSort(int[] arr) &#123; //外层循环确定待比较数值 //必须从1开始，因为第一次是第二个数与第一个数比较 for (int i = 0; i &lt; arr.length; i++) &#123; //待比较的数值 int temp = arr[i]; int j = i - 1; //内层循环为待比较数值确定其最终位置 //待比较数值比前面的小就往前插一位 for (; j &gt; 0 &amp;&amp; arr[j] &gt; temp; j--) &#123; //将大于temp的值整体后移一位 arr[j + 1] = arr[j]; &#125; //待比较的数值比前面的大，最终位置无误 arr[j + 1] = temp; &#125; return arr; &#125; 希尔排序希尔排序（Shell’s Sort）是插入排序的一种，又称缩小增量排序（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。 算法思路： 把数组下标的一定增量分组； 对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的值越来越多，当增量减至1时，整个文件被分为一组，算法便终止。 123456789101112131415161718public static int[] shellSort(int[] arr) &#123; int d = arr.length; while (d &gt;= 1) &#123; d = d / 2; for (int x = 0; x &lt; d; x++) &#123; //按小标的一定增量分组然后进行排序 for (int i = x + d; i &lt; arr.length; i = i + d) &#123; int temp = arr[i]; int j; for (j = i - d; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j = j - d) &#123; arr[j + d] = arr[j]; &#125; arr[j + d] = temp; &#125; &#125; &#125; return arr; &#125; 交换排序冒泡排序在一组数据中，相邻元素依次比较大小，最大的放后面，最小的冒上来。 算法思路： 比较相邻的元素，如果第一个比第二个大，就交换 对每一对相邻元素做相同的工作，从开始第一对到结尾的最后一对。 针对所有元素重复以上步骤，除了最后一个 未排好序的元素再次进行冒泡 123456789101112131415private static int[] bubbleSort(int[] array) &#123; if (array.length == 0) &#123; return array; &#125; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j + 1] &lt; array[j]) &#123; int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; &#125; &#125; &#125; return array; &#125; 优化：鸡尾酒排序鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。 此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。 排序过程： 先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端 再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端 以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束 思想：像摆钟一样，第一轮从右向左排序，第二轮从左向右排序，以此类推，没有元素交换，则说明有序。 鸡尾酒排序优缺点 优点是能够在特定的情况下减少回合数，缺点为代码量大，适用于大部分元素已经有序的情况下。 继续优化：针对有序区快速排序快速排序（QuickSort）是对冒泡排序的一种改进。 通过一次排序将数组分成两个子数组，其中一个数字的值都比另外一个数组的值小，然后再对这两子数组分别进行快速排序，整个排序过程可以递归进行，依次达到整个数据变成有序序列。 算法思路分治法： 定义i=0，j = A.length-1，i为第一个数的下标，j为最后一个数下标 从数组的最后一个数Aj从右往左找，找到第一个小于key的数，记为Aj 从数组的第一个数Ai从左往右找，找到第一个大于key的数，记为Ai 交换Ai和Aj 重复这个过程，直到i=j 调整key的位置，把A[i]和key交换 123456789101112131415161718192021222324public static void quickSort(int[] a, int left, int right) &#123; if (left &gt; right) return; int pivot = a[left];//定义基准值为数组第一个数 int i = left; int j = right; while (i &lt; j) &#123; while (pivot &lt;= a[j] &amp;&amp; i &lt; j)//从右往左找比基准值小的数 j--; while (pivot &gt;= a[i] &amp;&amp; i &lt; j)//从左往右找比基准值大的数 i++; if (i &lt; j) //如果i&lt;j，交换它们 &#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; a[left] = a[i]; a[i] = pivot;//把基准值放到合适的位置 quickSort(a, left, i - 1);//对左边的子数组进行快速排序 quickSort(a, i + 1, right);//对右边的子数组进行快速排序 &#125; 选择排序简单选择排序选择排序selection-sort是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存档在排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，以此类推，直到所有元素均排序完毕。 算法思路： 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾 以此类推，直到所有元素均排序完毕 1234567891011121314151617private static void selectSort(int[] arr) &#123; int minIndex = 0; int temp; for (int i=0;i&lt;arr.length;i++)&#123; minIndex = i; for (int j = i+1;j&lt;arr.length;j++)&#123; //找到当前循环最小值索引 if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; temp = arr[i]; //交换当前循环起点值和最小值索引位置的值 arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; 堆排序堆排序HeapSort是指利用堆这种数据结构所涉及的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点） 简单来说： 堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法 最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子 那么处于最大堆的根节点的元素一定是这个堆中的最大值 算法思路： 最大堆调整（MaxHeapify）：将堆的末端子节点作调整，某个节点的值最多和其父节点的值一样大； 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序，堆中的最大元素存放在根节点中； 堆排序（HeapSort）：移除位的第一个数据的根节点，并做最大堆调整的递归运算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;33, 42, 1, 44, 4, 63, 3, 32&#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void heapSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //每次建堆就可以排除一个元素了 buildMaxHeap(arr, arr.length - i); //交换 int temp = arr[0]; arr[0] = arr[(arr.length - 1) - i]; arr[(arr.length - 1) - i] = temp; &#125; &#125; /** * 建堆 * * @param arr 看作是完全二叉树 * @param parent 当前父节点位置 * @param length 节点总数 */ private static void heapAdjust(int[] arr, int parent, int length) &#123; if (parent &lt; length) &#123; //左子树和右字数的位置 int left = 2 * parent + 1; int right = 2 * parent + 2; //把当前父节点位置看成是最大的 int max = parent; if (left &lt; length) &#123; //如果比当前根元素要大，记录它的位置 if (arr[max] &lt; arr[left]) &#123; max = left; &#125; &#125; if (right &lt; length) &#123; //如果比当前根元素要大，记录它的位置 if (arr[max] &lt; arr[right]) &#123; max = right; &#125; &#125; //如果最大的不是根元素位置，那么就交换 if (max != parent) &#123; int temp = arr[max]; arr[max] = arr[parent]; arr[parent] = temp; //继续比较，直到完成一次建堆 heapAdjust(arr, max, length); &#125; &#125; &#125; /** * 完成一次建堆，最大值在堆的顶部(根节点) * */ private static void buildMaxHeap(int[] arr, int size) &#123; // 从数组的尾部开始，直到第一个元素(角标为0) for (int i = size - 1; i &gt;= 0; i--) &#123; heapAdjust(arr, i, size); &#125; &#125;&#125; 参考：https://www.cnblogs.com/Java3y/p/8639937.html 递归排序二路归并排序归并排序MergeSort是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 若将两个有序表合并成一个有序表，称为二路归并。例如，将2个有序数组合并，比较两个数组的第一个数，谁小就先取谁，取了后就在对应数组中删除这个数，然后再进行比较，如果数组为空，那直接将另一个数组一次取出即可。 算法思路： 将数组分成A、B两个数组，如果这两个数组都是有序的，那么就可以很方便的将这两个数组进行排序 让着两个数组有序，可以将A、B组各自再分成两个数组。以此类推，当分出来的数组只有一个数据时，可以认为数组已经达到了有序 然后再合并相邻的两个数组，这通过先递归的分解数组，再合并数组就完成了归并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MergeSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;33, 42, 1, 44, 4, 63, 3, 32&#125;; mergeSort(array); System.out.println(Arrays.toString(array)); &#125; private static void mergeSort(int[] arr) &#123; //临时数组 int[] temp = new int[arr.length]; sort(arr, temp, 0, arr.length - 1); &#125; private static void sort(int[] arr, int[] temp, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int mid = left + (right - left) / 2; sort(arr, temp, left, mid); sort(arr, temp, mid + 1, right); merge(arr, temp, left, mid, right); &#125; private static void merge(int[] arr, int[] temp, int leftStart, int leftEnd, int rightEnd) &#123; int rightStart = leftEnd + 1; //从左开始算 int tempIndex = leftStart; //元素个数 int len = rightEnd - leftStart + 1; while (leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd) &#123; if (arr[leftStart] &lt;= arr[rightStart]) &#123; temp[tempIndex++] = arr[leftStart++]; &#125; else &#123; temp[tempIndex++] = arr[rightStart++]; &#125; &#125; //左边如果有剩余，将左边剩余的归并 while (leftStart &lt;= leftEnd) &#123; temp[tempIndex++] = arr[leftStart++]; &#125; //右边如果有剩余，将右边剩余的归并 while (rightStart &lt;= rightEnd) &#123; temp[tempIndex++] = arr[rightStart++]; &#125; //从临时数组拷贝到原数组 for (int i = 0; i &lt; len; i++) &#123; arr[rightEnd] = temp[rightEnd]; rightEnd--; &#125; &#125;&#125; 计数排序计数排序CountingSort不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中，作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法思路： 求出待排序数组的最大值max和最小值min 实例化辅助计数数组temp，temp数组中每个下标对应arr中的一个元素，temp用来记录每个元素出现的次数 计算arr中每个元素在temp中的位置postion = arr[i] - min 根据temp数组求得排序后的数组 1234567891011121314151617181920212223242526272829303132333435public class CountSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;33, 42, 1, 44, 4, 63, 3, 32&#125;; countSort(array); System.out.println(Arrays.toString(array)); &#125; private static void countSort(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return; &#125; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //找出数组中的最大最小值 for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); &#125; int[] temp = new int[max]; //找出每个数字出现的次数 for (int i = 0; i &lt; arr.length; i++) &#123; //每个元素在temp中的位置 position = arr[i] - min int position = arr[i] - min; temp[position]++; &#125; int index = 0; for (int i = 0; i &lt; temp.length; i++) &#123; //temp[i] 大于0表示有重复元素 while (temp[i]-- &gt; 0) &#123; arr[index++] = i + min; &#125; &#125; &#125;&#125; 桶排序桶排序BucketSort的工作原理是将数组分到有限数量的桶里。每个桶再分别排序（有可能再使用别的排序算法或者是以递归方式继续使用桶排序进行排序）。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O（n）），但桶排序并不是比较排序，他不受O(nlogn)下限的印象，桶排序可用于最大最小值相差较大的数据情况。 算法思路： 找出待排序数组中的最大值max和最小值min 我们使用动态数组ArrayList作为桶，桶里放的元素也用ArrayList存储。桶的数量为（max - min）/ arr.length + 1 遍历数组arr，计算每个元素arr[i]放的桶 每个桶各自排序 遍历桶数组，把排序好的元素放进输出数组 1234567891011121314151617181920212223242526272829303132333435363738public class BucketSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;33, 42, 1, 44, 4, 63, 3, 32&#125;; bucketSort(array); System.out.println(Arrays.toString(array)); &#125; private static void bucketSort(int[] arr) &#123; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for(int i=0;i&lt;arr.length;i++)&#123; max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); &#125; //桶数 int bucketNum = (max-min) /arr.length +1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum); for(int i=0;i&lt;bucketNum;i++)&#123; bucketArr.add(new ArrayList&lt;&gt;()); &#125; //将每个元素放入桶 for(int i=0;i&lt;arr.length;i++)&#123; int num = (arr[i] - min)/arr.length; bucketArr.get(num).add(arr[i]); &#125; //对每个桶进行排序 for(int i=0;i&lt;bucketNum;i++)&#123; Collections.sort(bucketArr.get(i)); &#125; int position = 0; //合并桶 for(int i=0;i&lt;bucketNum;i++)&#123; for(int j=0;j&lt;bucketArr.get(i).size();j++)&#123; arr[position++] = bucketArr.get(i).get(j); &#125; &#125; &#125;&#125; 基数排序基数排序RadixSort是桶排序的扩展，基本思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序法是属于稳定性的排序，其时间复杂度为O(nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其他的稳定性排序法。 算法思路： 取得数组中的最大数，并取得位数 arr为原始数组，从最低位开始取每个位数为radix数组 对radix进行计数排序（利用计数排序适用于小范围数的特点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RadixSort &#123; public static void main(String[] args) &#123; int[] array = new int[]&#123;33, 42, 1, 44, 4, 63, 3, 32&#125;; radixSort(array); System.out.println(Arrays.toString(array)); &#125; private static void radixSort(int[] array) &#123; //数组arr中的最大值 int max = getMax(array); for (int exp = 1; max / exp &gt; 0; exp *= 10) &#123; //从个位开始，对数组arr按“exp指数”进行排序 countSort(array, exp); &#125; &#125; private static void countSort(int[] array, int exp) &#123; //存储“被排序数据”的临时数组 int[] temp = new int[array.length]; int[] buckets = new int[10]; //将数据出现的次数存储在buckets[]中 for (int i = 0; i &lt; array.length; i++) &#123; buckets[(array[i] / exp) % 10]++; &#125; //计算数据在temp[]中的位置 0 1 2 3 --&gt; 0 1 3 5 8 for (int i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; //将数据存储到临时数组temp[]中 for (int i = array.length - 1; i &gt;= 0; i--) &#123; temp[buckets[(array[i]) / exp % 10] - 1] = array[i]; buckets[(array[i] / exp) % 10]--; &#125; //将排好序的数据赋值给arr[] for (int i = 0; i &lt; array.length; i++) &#123; array[i] = temp[i]; &#125; &#125; private static int getMax(int[] array) &#123; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; return max; &#125;&#125; 大部分元素有序排序地精排序 Gnome 排序（地精排序），起初由 Hamid Sarbazi-Azad 于 2000 年提出，并被称为 stupid排序，后来被 Dick Grune 描述并命名为 “地精排序” 。 地精排序和插入排序类似，除了移动一个元素到最终的位置，是通过交换一系列的元素实现，就像冒泡排序一样。概念上十分简单，不需要嵌套循环。时间复杂度为O(n2)，但是如果初始数列基本有序，时间复杂度将降为O(n)。实际上 Gnome 算法可以和插入排序算法一样快。平均运行时间为O(n^2)。 将无序数列：6，2，4，1，5，使用地精排序使其从小到大排序。 通过设计标识 i = 0 ，然后从头开始判断，什么时候 ( i &lt; 4 ) 不成立,什么时候排序结束。 这里的核心点就是 如何控制 i 的值。 第一轮操作「i = 0」 先让 i 自增 1 ，达到值为 1 才开始比较 ： 交换前 [ 6 2 4 1 ] 『 i = 0 』 交换后 [ 6 2 4 1 ] 『 i = 1 』 第二轮操作「i = 1」 比较 6 和 2 ，发生交换，只要发生交换 i 就减 1 。 交换前 [ 6 2 4 1 ]『 i = 1 』 交换后 [ 2 6 4 1 ]『 i = 0 』 第三轮操作「i = 0」 i 变成 0 了，啥也不干，自增变成 1 再说。 交换前 [ 2 6 4 1 ]『 i = 0 』 交换后 [ 2 6 4 1 ]『 i = 1 』 第四轮操作「i = 1」 比较 2 和 6 ，不交换，只要不要换就自增 1。 交换前 [ 2 6 4 1 ]『 i = 1 』 交换后 [ 2 6 4 1 ]『 i = 2 』 第五轮操作「i = 2」 比较 6 和 4 ，发生交换，只要发生交换 i 就减 1 。 交换前 [ 2 6 4 1 ]『 i = 2 』 交换后 [ 2 4 6 1 ]『 i = 1 』 第六轮操作「i = 1」 比较 2 和 4 ，不交换，只要不要换就自增 1 。 交换前 [ 2 6 4 1 ]『 i = 1 』 交换后 [ 2 4 6 1 ]『 i = 2 』 第七轮操作「i = 2」 比较 4 和 6 ，不交换，只要不要换就自增 1 。 交换前 [ 2 4 6 1 ]『 i = 2 』 交换后 [ 2 4 6 1 ]『 i = 3 』 第八轮操作「i = 3」 比较 6 和 1 ，发生交换，只要发生交换 i 就减 1 。 交换前 [ 2 4 6 1 ]『 i = 3 』 交换后 [ 2 4 1 6 ]『 i = 2 』 第九轮操作「i = 2」 比较 4 和 1 ，发生交换，只要发生交换 i 就减 1 。 交换前 [ 2 4 1 6 ]『 i = 2 』 交换后 [ 2 1 4 6 ]『 i = 1 』 第十轮操作「i = 1」 比较 2 和 1 ，发生交换，只要发生交换 i 就减 1 。 交换前 [ 2 1 4 6 ]『 i = 1 』 交换后 [ 1 2 4 6 ]『 i = 0 』 第十一轮操作「i = 0」 啥也不干，先让 i 自增1，达到值为 1 才开始真正的比较。 『 i = 1 』时，比较 1 和 2 ，不交换，只要不交换就自增 1 。『 i = 2 』时，比较 2 和 4 ，不交换，只要不交换就自增 1 。『 i = 3 』时，比较 4 和 6 ，不交换，只要不交换就自增 1 。『 i = 4 』时，表达式 （ i &lt; n ) 不成立，排序结束。 顺序输出为 [ 1 2 4 6 ]。 地精排序算法代码123456789101112template &lt;class T&gt;void gnome_sort_1(T data[], int n, bool comparator(T, T))&#123; int i = 1; while (i &lt; n)&#123; if (i &gt; 0 &amp;&amp; comparator(data[i], data[i-1]))&#123; swap(data[i], data[i-1]); i--; &#125;else&#123; i++; &#125; &#125;&#125; 这种地精排序算法还有很多优化的空间，这里小吴就不展开来讲了。 End鸡尾酒排序和地精排序虽然被程序员小吴归为奇葩排序一类，但是它们还是有一定的使用场景的。 在「大部分元素有序」的情况下，使用鸡尾酒排序可以减少排序的回合数。 地精排序最著名的特点是代码只有一层循环，在「大部分元素有序」的情况下，可以减少排序回合数。 今日问题除了鸡尾酒排序和地精排序以外，你还知道哪些排序适合用于「大部分元素有序」的序列进行排序？","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"hash一致性","slug":"Algorithm/hash一致性","date":"2020-07-13T16:34:39.000Z","updated":"2020-07-14T13:01:10.000Z","comments":true,"path":"2020/07/14/Algorithm/hash一致性/","link":"","permalink":"https://alloceee.github.io/2020/07/14/Algorithm/hash%E4%B8%80%E8%87%B4%E6%80%A7/","excerpt":"","text":"普通的Hash平均分配算法的缺陷 普通的hash均匀分配算法：hash(object) mod N // 其中 N 为节点数目 无论是增加还是减少节点，都有可能会改变映射关系，造成大量请求的 miss。那是否能避免大量的 miss 呢？答案也是肯定的，一致性哈希解决了节点增减造成大量 hash 重定位的问题。 一致性Hash的原理一致性哈希的原理如下： 将每个节点(node)映射到数值空间 [0, 2^32 - 1]，映射的规则可为 IP、hostname 等。 将每个 object 映射到数值空间 [0, 2^32 - 1]。 对于某个 object，对于所有满足 hash(node) &lt;= hash(object) 的节点，选择 hash(node) 最大的节点存放 object。如果没有满足上述条件的节点，选择 hash(node) 最小的节点存放该 object，如下图。 当某个节点宕机时，仅有该节点的对象被重哈希到相邻节点上。 与此类似，当新增一个节点时，仅有一个节点的部分 object 需要重哈希。 虚节点与平衡性节点的位置是由自身哈希值决定的，它们的分布并非均匀，特别当节点数目很少时，容易造成 object 的分布不均匀，即平衡性低，例如： 为了解决这个问题，我们引入虚拟节点，虚拟节点实际上是物理节点的复制品，一个物理节点包含多个虚拟节点，我们将这些虚拟节点映射到数值空间 [0, 2^32 - 1]，对于某个 object，我们根据上节步骤计算该 object 存放的虚拟节点，进而得出物理节点。如下图共有 2 个物理节点，每个物理节点有三个虚拟机节点。当虚拟节点越多，虚拟节点的位置分布越均匀，相应的，映射到物理节点的 object 数目也越均匀，提高了平衡性。 参考文章 理解 Consistent Hashing 一致性哈希算法的理解与实践 Github地址 Doist/hash_ring 一致性哈希算法的理解与实践Jun 9 2016 0. 概述在维基百科中，是这么定义的 一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。 1. 引出我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？那么我们引出一个问题： 假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。 看一看普通Hash算法的原理： 算法的核心计算如下 123456for item in range(ITEMS): k = md5(str(item)).digest() h = unpack_from(&quot;&gt;I&quot;, k)[0] # 通过取余的方式进行映射 n = h % NODES node_stat[n] += 1 具体的完整实现请参考normal_hash.py，输出是这样的： Ave: 100000Max: 100695 (0.69%)Min: 99073 (0.93%) 从上述结果可以发现，普通的Hash算法均匀地将这些数据项打散到了这些节点上，并且分布最少和最多的存储节点数据项数目小于1%。之所以分布均匀，主要是依赖Hash算法（实现使用的MD5算法）能够比较随机的分布。 然而，我们看看存在一个问题，由于该算法使用节点数取余的方法，强依赖node的数目，因此，当是node数发生变化的时候，item所对应的node发生剧烈变化，而发生变化的成本就是我们需要在node数发生变化的时候，数据需要迁移，这对存储产品来说显然是不能忍的，我们观察一下增加node后，数据项移动的情况： 123456789for item in range(ITEMS): k = md5(str(item)).digest() h = unpack_from(&quot;&gt;I&quot;, k)[0] # 原映射结果 n = h % NODES # 现映射结果 n_new = h % NEW_NODES if n_new != n: change += 1 详细实现代码在normal_hash_add.py输出是这样的： Change: 9900989 (99.01%) 翻译一下就是，如果有100个item，当增加一个node，之前99%的数据都需要重新移动。 这显然是不能忍的，普通哈希算法的问题我们已经发现了，如何对其进行改进呢？没错，我们的一致性哈希算法闪亮登场。 2. 登场我们上节介绍了普通Hash算法的劣势，即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。 那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量的降到最低。 一致性Hash算法的原理是这样的： 12345678910for n in range(NODES): h = _hash(n) ring.append(h) ring.sort() hash2node[h] = nfor item in range(ITEMS): h = _hash(item) n = bisect_left(ring, h) % NODES node_stat[hash2node[ring[n]]] += 1 我们依然对其进行了实现consist_hash_add.py，并且观察了数据迁移的结果： Change: 58897 (0.59%) 虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据项分布的均匀性，进行了一致性Hash算法的实现consist_hash.py： Ave: 100000Max: 596413 (496.41%)Min: 103 (99.90%) 这结果简直是简直了，确实非常结果差，分配的很不均匀。我们思考一下，一致性哈希算法分布不均匀的原因是什么？从最初的1000w个数据项经过一般的哈希算法的模拟来看，这些数据项“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据项本身的哈希值并未发生变化，变化的是判断数据项哈希应该落到哪个节点的算法变了。因此，主要是因为这100个节点Hash后，在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一造成的。 3. 改进-虚节点当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。 详细实现请见virtual_consist_hash.py 1234567891011121314for n in range(NODES): for v in range(VNODES): h = _hash(str(n) + str(v)) # 构造ring ring.append(h) # 记录hash所对应节点 hash2node[h] = nring.sort()for item in range(ITEMS): h = _hash(str(item)) # 搜索ring上最近的hash n = bisect_left(ring, h) % (NODES*VNODES) node_stat[hash2node[ring[n]]] += 1 输出结果是这样的： Ave: 100000Max: 116902 (16.90%)Min: 9492 (90.51%) 因此，通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。同时，观察增加节点后数据变动情况，详细的代码请见virtual_consist_hash_add.py： 123456for item in range(ITEMS): h = _hash(str(item)) n = bisect_left(ring, h) % (NODES*VNODES) n2 = bisect_left(ring2, h) % (NODES2*VNODES) if hash2node[ring[n]] != hash2node2[ring2[n2]]: change += 1 100000101000Change: 104871 (1.05%) 3. 另一种改进然而，虚节点这种靠数量取胜的策略增加了存储这些虚节点信息所需要的空间。在OpenStack的Swift组件中，使用了一种比较特殊的方法来解决分布不均的问题，改进了这些数据分布的算法，将环上的空间均匀的映射到一个线性空间，这样，就保证分布的均匀性。代码实现见part_consist_hash.py 123456789for part in range(2 ** LOG_NODE): ring.append(part) part2node[part] = part % NODESfor item in range(ITEMS): h = _hash(item) &gt;&gt; PARTITION part = bisect_left(ring, h) n = part % NODES node_stat[n] += 1 Ave: 100000Max: 157298 (57.30%)Min: 77405 (22.59%) 可以看到，数据分布是比较理想的。如果节点数刚好和分区数相等，理论上是可以均匀分布的。而观察下增加节点后的数据移动比例，代码实现见part_consist_hash_add.py 1234567891011121314for part in range(2 ** LOG_NODE): ring.append(part) part2node[part] = part % NODES part2node2[part] = part % NODES2change = 0for item in range(ITEMS): h = _hash(item) &gt;&gt; PARTITION p = bisect_left(ring, h) p2 = bisect_left(ring, h) n = part2node[p] % NODES n2 = part2node2[p] % NODES2 if n2 != n: change += 1 结果如下所示： Change: 2190208 (21.90%) 可以看到，移动也是比较理想的。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Netty进阶之粘包和拆包","slug":"网络编程/Netty进阶之粘包和拆包","date":"2020-07-07T16:20:05.000Z","updated":"2021-08-05T07:05:28.682Z","comments":true,"path":"2020/07/08/网络编程/Netty进阶之粘包和拆包/","link":"","permalink":"https://alloceee.github.io/2020/07/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/","excerpt":"","text":"一、什么是粘包和拆包TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。(来自百度百科) 发送端为了将多个发给接收端的数据包，更有效地发送到接收端，会使用Nagle算法。Nagle算法会将多次时间间隔较小且数据量小的数据合并成一个大的数据块进行发送。虽然这样的确提高了效率，但是因为面向流通信，数据是无消息保护边界的，就会导致接收端难以分辨出完整的数据包了。 所谓的粘包和拆包问题，就是因为TCP消息无保护边界导致的。 1.1 图解粘包和拆包正常发送消息是三次发送三个数据包，这种情况没有问题。 粘包，则是其中有多个数据包合并成一个数据包进行发送，也就是上图的第二种情况。 拆包，则是其中一个数据包被拆成了多段，发送的数据包只包含了一个完整数据包的一部分。也就是上图的第三种情况。 1.2 程序演示首先准备客户端负责发送消息，连续发送5次消息，代码如下： 1234for (int i = 1; i &lt;= 5; i++) &#123; ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + &quot; &quot;, Charset.forName(&quot;utf-8&quot;)); ctx.writeAndFlush(byteBuf);&#125; 然后服务端作为接收方，接收并且打印结果： 12345678910111213//count变量，用于计数private int count = 0;@Overrideprotected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123; byte[] bytes = new byte[msg.readableBytes()]; //把ByteBuf的数据读到bytes数组中 msg.readBytes(bytes); String message = new String(bytes, Charset.forName(&quot;utf-8&quot;)); System.out.println(&quot;服务器接收到数据：&quot; + message); //打印接收的次数 System.out.println(&quot;接收到的数据量是：&quot; + (++this.count));&#125; 启动服务端，再启动两个客户端发送消息,服务端的控制台可以看到这样： 粘包的问题其实是随机的，所以每次结果都不太一样。 二、解决方案总体思路可以分为三种： 在数据的末尾添加特殊的符号标识数据包的边界。通常会加\\n\\r、\\t或者其他的符号。 在数据的头部声明数据的长度，按长度获取数据。 规定报文的长度，不足则补空位。读取时按规定好的长度来读取。 2.1 使用LineBasedFrameDecoder这是Netty内置的一个解码器，对应的编码器是LineEncoder。 原理是上面讲的第一种思路，在数据末尾加上特殊符号以标识边界。默认是使用换行符\\n。 用法很简单，发送方加上编码器： 123456@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; //添加编码器，使用默认的符号\\n，字符集是UTF-8 ch.pipeline().addLast(new LineEncoder(LineSeparator.DEFAULT, CharsetUtil.UTF_8)); ch.pipeline().addLast(new TcpClientHandler());&#125; 接收方加上解码器： 1234567@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; //解码器需要设置数据的最大长度，我这里设置成1024 ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); //给pipeline管道设置业务处理器 ch.pipeline().addLast(new TcpServerHandler());&#125; 然后在发送方，发送消息时在末尾加上标识符： 12345678@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for (int i = 1; i &lt;= 5; i++) &#123; //在末尾加上默认的标识符\\n ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED, Charset.forName(&quot;utf-8&quot;)); ctx.writeAndFlush(byteBuf); &#125;&#125; 于是我们再次启动服务端和客户端，在服务端的控制台可以看到： 粘包、拆包的问题就轻松得到解决。 注意点：数据末尾一定是分隔符，分隔符后面不要再加上数据，否则会当做下一条数据的开始部分。下面是错误演示： 12345678@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for (int i = 1; i &lt;= 5; i++) &#123; //在分隔符后面加上一段字符串 ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;msg No&quot; + i + StringUtil.LINE_FEED + &quot;[我是分隔符后面的字符串]&quot;, Charset.forName(&quot;utf-8&quot;)); ctx.writeAndFlush(byteBuf); &#125;&#125; 服务端的控制台就会看到这样的打印信息： 2.2 使用自定义长度帧解码器使用这个解码器解决粘包问题的原理是上面讲的第二种，在数据的头部声明数据的长度，按长度获取数据。这个解码器构造器需要定义5个参数，相对较为复杂一点，先看参数的解释： maxFrameLength 发送数据包的最大长度 lengthFieldOffset 长度域的偏移量。长度域位于整个数据包字节数组中的开始下标。 lengthFieldLength 长度域的字节数长度。长度域的字节数长度。 lengthAdjustment 长度域的偏移量矫正。如果长度域的值，除了包含有效数据域的长度外，还包含了其他域（如长度域自身）长度，那么，就需要进行矫正。矫正的值为：包长 - 长度域的值 – 长度域偏移 – 长度域长。 initialBytesToStrip 丢弃的起始字节数。丢弃处于此索引值前面的字节。 前面三个参数比较简单，可以用下面这张图进行演示： 矫正偏移量是什么意思呢？意思是假设你的长度域设置的值除了包括有效数据的长度还有其他域的长度包含在里面，那么就要设置这个值进行矫正，否则解码器拿不到有效数据。矫正值的公式就是上面写着了。 丢弃的起始字节数。这个比较简单，就是在这个索引值前面的数据都丢弃，只要后面的数据。一般都是丢弃长度域的数据。当然如果你希望得到全部数据，那就设置为0。 下面就在消息接收端使用自定义长度帧解码器，解决粘包的问题： 12345678910@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; //数据包最大长度是1024 //长度域的起始索引是0 //长度域的数据长度是4 //矫正值为0，因为长度域只有 有效数据的长度的值 //丢弃数据起始值是4，因为长度域长度为4，我要把长度域丢弃，才能得到有效数据 ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4)); ch.pipeline().addLast(new TcpClientHandler());&#125; 接着编写发送端代码，根据解码器的设置，进行发送： 12345678910111213@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for (int i = 1; i &lt;= 5; i++) &#123; String str = &quot;msg No&quot; + i; ByteBuf byteBuf = Unpooled.buffer(1024); byte[] bytes = str.getBytes(Charset.forName(&quot;utf-8&quot;)); //设置长度域的值，为有效数据的长度 byteBuf.writeInt(bytes.length); //设置有效数据 byteBuf.writeBytes(bytes); ctx.writeAndFlush(byteBuf); &#125;&#125; 然后启动服务端，客户端，我们可以看到控制台打印结果： 可以看到，利用自定义长度帧解码器解决了粘包问题。 2.3 使用Google Protobuf编解码器Netty官网上是明显写着支持Google Protobuf的，如图所示： 2.3.1 Google Protobuf是什么 摘自官网的原话：Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. 翻译一下：Protocol buffers是Google公司的与语言无关、平台无关、可扩展的序列化数据的机制，类似XML，但是更小、更快、更简单。您只需定义一次数据的结构化方式，然后就可以使用特殊生成的源代码，轻松地将结构化数据写入和读取到各种数据流中，并支持多种语言。 Google Protobuf官网 2.3.2 使用Google Protobuf首先先下载编译器，我使用的是win系统，所以下载的是win版本。下载编译器链接，版本是v3.6.1 如果官网下载慢的话，我已经下载了一个，并且上传到百度网盘，网盘链接，提取码：8b1r。公众号什么的随缘关注吧，哈哈~ 以下步骤参考Google Protobuf的github项目的指南。 第一步：添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt;&lt;/dependency&gt; 第二步：编写proto文件Message.proto如何编写.proto文件的相关文档说明，可以去官网查看 下面我写一个例子，请看示范： 1234567syntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;MessagePojo&quot;;//生成的外部类名，同时也是文件名message Message &#123; int32 id = 1;//Message类的一个属性，属性名称是id，序号为1 string content = 2;//Message类的一个属性，属性名称是content，序号为2&#125; 第三步：使用编译器，通过.proto文件生成代码解压前面下载下来的压缩包protoc-3.6.1-win32.zip,然后打开\\protoc-3.6.1-win32\\bin目录下，可以看到有一个protoc.exe程序。如图所示： 然后复制前面写好的Message.proto文件到此目录下，如图所示： 接着在此目录下打开命令行cmd，输入命令：protoc.exe –java_out=. Message.proto 然后就可以看到生成的MessagePojo.java文件。最后把文件复制到IDEA项目中。 第四步：在发送端添加编码器，在接收端添加解码器客户端添加编码器，对消息进行编码。 123456@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; //在发送端添加Protobuf编码器 ch.pipeline().addLast(new ProtobufEncoder()); ch.pipeline().addLast(new TcpClientHandler());&#125; 服务端添加解码器，对消息进行解码。 1234567@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; //添加Protobuf解码器，构造器需要指定解码具体的对象实例 ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance())); //给pipeline管道设置处理器 ch.pipeline().addLast(new TcpServerHandler());&#125; 第五步：发送消息客户端发送消息，代码如下： 1234567891011@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //使用的是构建者模式进行创建对象 MessagePojo.Message message = MessagePojo .Message .newBuilder() .setId(1) .setContent(&quot;芜湖大司马，起飞~&quot;) .build(); ctx.writeAndFlush(message);&#125; 服务端接收到数据，并且打印： 12345@Overrideprotected void channelRead0(ChannelHandlerContext ctx, MessagePojo.Message messagePojo) throws Exception &#123; System.out.println(&quot;id:&quot; + messagePojo.getId()); System.out.println(&quot;content:&quot; + messagePojo.getContent());&#125; 测试结果正确： 2.3.3 分析Protocol的粘包、拆包实际上直接使用Protocol编解码器还是存在粘包问题的。 证明一下，发送端循环一百次发送100条”大司马，起飞”的消息，请看发送端代码演示： 123456789101112@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123; for (int i = 1; i &lt;= 100; i++) &#123; MessagePojo.Message message = MessagePojo .Message .newBuilder() .setId(i) .setContent(i + &quot;号大司马，起飞~&quot;) .build(); ctx.writeAndFlush(message); &#125;&#125; 这时，启动服务端，客户端后，你会在控制台看到如下错误： com.google.protobuf.InvalidProtocolBufferException: While parsing a protocol message, the input ended unexpectedly in the middle of a field. This could mean either that the input has been truncated or that an embedded message misreported its own length. 意思是：分析protocol消息时，输入意外地在字段中间结束。这可能意味着输入被截断，或者嵌入的消息误报了自己的长度。 其实就是粘包问题，多条数据合并成一条数据了，导致解析出现异常。 2.3.4 解决Protocol的粘包、拆包问题只需要在发送端加上编码器ProtobufVarint32LengthFieldPrepender 123456@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender()); ch.pipeline().addLast(new ProtobufEncoder()); ch.pipeline().addLast(new TcpClientHandler());&#125; 接收方加上解码器ProtobufVarint32FrameDecoder 1234567@Overrideprotected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ProtobufVarint32FrameDecoder()); ch.pipeline().addLast(new ProtobufDecoder(MessagePojo.Message.getDefaultInstance())); //给pipeline管道设置处理器 ch.pipeline().addLast(new TcpServerHandler());&#125; 然后再启动服务端和客户端，我们可以看到马老师成功地起飞了~~~ ProtobufVarint32LengthFieldPrepender编码器的工作如下： 123456789101112131415161718 * BEFORE ENCODE (300 bytes) AFTER ENCODE (302 bytes) * +---------------+ +--------+---------------+ * | Protobuf Data |--------------&gt;| Length | Protobuf Data | * | (300 bytes) | | 0xAC02 | (300 bytes) | * +---------------+ +--------+---------------+@Sharablepublic class ProtobufVarint32LengthFieldPrepender extends MessageToByteEncoder&lt;ByteBuf&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception &#123; int bodyLen = msg.readableBytes(); int headerLen = computeRawVarint32Size(bodyLen); //写入请求头，消息长度 out.ensureWritable(headerLen + bodyLen); writeRawVarint32(out, bodyLen); //写入数据 out.writeBytes(msg, msg.readerIndex(), bodyLen); &#125;&#125; ProtobufVarint32FrameDecoder解码器的工作如下： 123456789101112131415161718192021222324252627282930 * BEFORE DECODE (302 bytes) AFTER DECODE (300 bytes) * +--------+---------------+ +---------------+ * | Length | Protobuf Data |-----&gt;| Protobuf Data | * | 0xAC02 | (300 bytes) | | (300 bytes) | * +--------+---------------+ +---------------+public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder &#123; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; //标记读取的下标位置 in.markReaderIndex(); //获取读取的下标位置 int preIndex = in.readerIndex(); //解码，获取消息的长度,并且移动读取的下标位置 int length = readRawVarint32(in); //比较解码前和解码后的下标位置，如果相等。表示字节数不够读取，跳到下一轮 if (preIndex == in.readerIndex()) &#123; return; &#125; //如果消息的长度小于0，抛出异常 if (length &lt; 0) &#123; throw new CorruptedFrameException(&quot;negative length: &quot; + length); &#125; //如果不够读取一个完整的数据，reset还原下标位置。 if (in.readableBytes() &lt; length) &#123; in.resetReaderIndex(); &#125; else &#123; //否则，把数据写入到out，接收端就拿到了完整的数据了 out.add(in.readRetainedSlice(length)); &#125; &#125; 总结一下： 发送端通过编码器在发送的时候在消息体前面加上一个描述数据长度的数据块。 接收方通过解码器先获取描述数据长度的数据块，知道完整数据的长度，然后根据数据长度获取一条完整的数据。 总结创作不易，觉得有用就关注一下吧。 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Netty","slug":"网络编程/Netty","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/"}],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"Netty","slug":"Netty","permalink":"https://alloceee.github.io/tags/Netty/"}],"author":"Alloceee"},{"title":"超详细Netty入门","slug":"网络编程/超详细Netty入门","date":"2020-07-07T16:00:00.000Z","updated":"2021-08-05T07:04:52.219Z","comments":true,"path":"2020/07/08/网络编程/超详细Netty入门/","link":"","permalink":"https://alloceee.github.io/2020/07/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%B6%85%E8%AF%A6%E7%BB%86Netty%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。 一、Netty概述官方的介绍： Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。 二、为什么使用Netty从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？ 2.1 NIO的缺点对于这个问题，之前我写了一篇文章《NIO入门》对NIO有比较详细的介绍，NIO的主要问题是： NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。 臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。 2.2 Netty的优点相对地，Netty的优点有很多： API使用简单，学习成本低。 功能强大，内置了多种解码编码器，支持多种协议。 性能高，对比其他主流的NIO框架，Netty的性能最优。 社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。 Dubbo、Elasticsearch都采用了Netty，质量得到验证。 三、架构图 上面这张图就是在官网首页的架构图，我们从上到下分析一下。 绿色的部分Core核心模块，包括零拷贝、API库、可扩展的事件模型。 橙色部分Protocol Support协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。 红色的部分Transport Services传输服务，包括Socket、Datagram、Http Tunnel等等。 以上可看出Netty的功能、协议、传输方式都比较全，比较强大。 四、永远的Hello Word首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据： 4.1 引入Maven依赖使用的版本是4.1.20，相对比较稳定的一个版本。 12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.20.Final&lt;/version&gt;&lt;/dependency&gt; 4.2 创建服务端启动类1234567891011121314151617181920212223242526272829303132333435public class MyServer &#123; public static void main(String[] args) throws Exception &#123; //创建两个线程组 boosGroup、workerGroup EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; //创建服务端的启动对象，设置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //设置两个线程组boosGroup和workerGroup bootstrap.group(bossGroup, workerGroup) //设置服务端通道实现类型 .channel(NioServerSocketChannel.class) //设置线程队列得到连接个数 .option(ChannelOption.SO_BACKLOG, 128) //设置保持活动连接状态 .childOption(ChannelOption.SO_KEEPALIVE, true) //使用匿名内部类的形式初始化通道对象 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //给pipeline管道设置处理器 socketChannel.pipeline().addLast(new MyServerHandler()); &#125; &#125;);//给workerGroup的EventLoop对应的管道设置处理器 System.out.println(&quot;java技术爱好者的服务端已经准备就绪...&quot;); //绑定端口号，启动服务端 ChannelFuture channelFuture = bootstrap.bind(6666).sync(); //对关闭通道进行监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 4.3 创建服务端处理器12345678910111213141516171819202122232425/** * 自定义的Handler需要继承Netty规定好的HandlerAdapter * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式 **/public class MyServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //获取客户端发送过来的消息 ByteBuf byteBuf = (ByteBuf) msg; System.out.println(&quot;收到客户端&quot; + ctx.channel().remoteAddress() + &quot;发送的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8)); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //发送消息给客户端 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;服务端已收到消息，并给你发送一个问号?&quot;, CharsetUtil.UTF_8)); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; //发生异常，关闭通道 ctx.close(); &#125;&#125; 4.4 创建客户端启动类123456789101112131415161718192021222324252627282930public class MyClient &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup eventExecutors = new NioEventLoopGroup(); try &#123; //创建bootstrap对象，配置参数 Bootstrap bootstrap = new Bootstrap(); //设置线程组 bootstrap.group(eventExecutors) //设置客户端的通道实现类型 .channel(NioSocketChannel.class) //使用匿名内部类初始化通道 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //添加客户端通道的处理器 ch.pipeline().addLast(new MyClientHandler()); &#125; &#125;); System.out.println(&quot;客户端准备就绪，随时可以起飞~&quot;); //连接服务端 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666).sync(); //对通道关闭进行监听 channelFuture.channel().closeFuture().sync(); &#125; finally &#123; //关闭线程组 eventExecutors.shutdownGracefully(); &#125; &#125;&#125; 4.5 创建客户端处理器123456789101112131415public class MyClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; //发送消息到服务端 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;, CharsetUtil.UTF_8)); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //接收服务端发送过来的消息 ByteBuf byteBuf = (ByteBuf) msg; System.out.println(&quot;收到服务端&quot; + ctx.channel().remoteAddress() + &quot;的消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8)); &#125;&#125; 4.6 测试先启动服务端，再启动客户端，就可以看到结果： MyServer打印结果: MyClient打印结果： 五、Netty的特性与重要组件5.1 taskQueue任务队列如果Handler处理器有一些长时间的业务处理，可以交给taskQueue异步处理。怎么用呢，请看代码演示： 12345678910111213141516171819public class MyServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //获取到线程池eventLoop，添加线程，执行 ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; //长时间操作，不至于长时间的业务操作导致Handler阻塞 Thread.sleep(1000); System.out.println(&quot;长时间的业务处理&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。 5.2 scheduleTaskQueue延时任务队列延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示： 123456789101112ctx.channel().eventLoop().schedule(new Runnable() &#123; @Override public void run() &#123; try &#123; //长时间操作，不至于长时间的业务操作导致Handler阻塞 Thread.sleep(1000); System.out.println(&quot;长时间的业务处理&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;,5, TimeUnit.SECONDS);//5秒后执行 依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中 5.3 Future异步机制在搭建HelloWord工程的时候，我们看到有一行这样的代码： 1ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6666); 很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？ ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示： 1234567891011121314//添加监听器channelFuture.addListener(new ChannelFutureListener() &#123; //使用匿名内部类，ChannelFutureListener接口 //重写operationComplete方法 @Override public void operationComplete(ChannelFuture future) throws Exception &#123; //判断是否操作成功 if (future.isSuccess()) &#123; System.out.println(&quot;连接成功&quot;); &#125; else &#123; System.out.println(&quot;连接失败&quot;); &#125; &#125;&#125;); 5.4 Bootstrap与ServerBootStrapBootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图： 可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。 一般来说，使用Bootstrap创建启动器的步骤可分为以下几步： 5.4.1 group()在上一篇文章《Reactor模式》中，我们就讲过服务端要使用两个线程组： bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。 workerGroup用于处理每一个连接发生的读写事件。 一般创建线程组直接使用以下new就完事了： 12EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup(); 有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码： 1234567891011121314151617//使用一个常量保存private static final int DEFAULT_EVENT_LOOP_THREADS;static &#123; //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量 DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS); &#125;&#125; protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; //如果不传入，则使用常量的值，也就是cpu核数的两倍 super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);&#125; 通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器： 1234//设置bossGroup线程数为1EventLoopGroup bossGroup = new NioEventLoopGroup(1);//设置workerGroup线程数为16EventLoopGroup workerGroup = new NioEventLoopGroup(16); 5.4.2 channel()这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。 使用debug模式可以看到 通道类型有以下： NioSocketChannel： 异步非阻塞的客户端 TCP Socket 连接。 NioServerSocketChannel： 异步非阻塞的服务器端 TCP Socket 连接。 常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。 OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。 OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。 稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下： 12345678910111213//server端代码，跟上面几乎一样，只需改三个地方//这个地方使用的是OioEventLoopGroupEventLoopGroup bossGroup = new OioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(bossGroup)//只需要设置一个线程组boosGroup .channel(OioServerSocketChannel.class)//设置服务端通道实现类型//client端代码，只需改两个地方//使用的是OioEventLoopGroupEventLoopGroup eventExecutors = new OioEventLoopGroup();//通道类型设置为OioSocketChannelbootstrap.group(eventExecutors)//设置线程组 .channel(OioSocketChannel.class)//设置客户端的通道实现类型 NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。NioSctpServerChannel： 异步的 Sctp 服务器端连接。 本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。 5.4.3 option()与childOption()首先说一下这两个的区别。 option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。 childOption()是提供给父管道接收到的连接，也就是workerGroup线程。 搞清楚了之后，我们看一下常用的一些设置有哪些： SocketChannel参数，也就是childOption()常用的参数： SO_RCVBUF Socket参数，TCP数据接收缓冲区大小。TCP_NODELAY TCP参数，立即发送数据，默认值为Ture。SO_KEEPALIVE Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。 ServerSocketChannel参数，也就是option()常用参数： SO_BACKLOG Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。 由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。 5.4.4 设置流水线(重点)ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。 在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下： 12345678//使用匿名内部类的形式初始化通道对象bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; //给pipeline管道设置自定义的处理器 socketChannel.pipeline().addLast(new MyServerHandler()); &#125;&#125;); 处理器Handler主要分为两种： ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器) 入站指的是数据从底层java NIO Channel到Netty的Channel。 出站指的是通过Netty的Channel来操作底层的java NIO Channel。 ChannelInboundHandlerAdapter处理器常用的事件有： 注册事件 fireChannelRegistered。 连接建立事件 fireChannelActive。 读事件和读完成事件 fireChannelRead、fireChannelReadComplete。 异常通知事件 fireExceptionCaught。 用户自定义事件 fireUserEventTriggered。 Channel 可写状态变化事件 fireChannelWritabilityChanged。 连接关闭事件 fireChannelInactive。 ChannelOutboundHandler处理器常用的事件有： 端口绑定 bind。 连接服务端 connect。 写事件 write。 刷新时间 flush。 读事件 read。 主动断开连接 disconnect。 关闭 channel 事件 close。 还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。 5.4.5 bind()提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。 有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。 5.4.6 优雅地关闭EventLoopGroup123//释放掉所有的资源，包括创建的线程bossGroup.shutdownGracefully();workerGroup.shutdownGracefully(); 会关闭所有的child Channel。关闭之后，释放掉底层的资源。 5.5 ChannelChannel是什么？不妨看一下官方文档的说明： A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind 翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。 如果上面这段说明比较抽象，下面还有一段说明： A channel provides a user: the current state of the channel (e.g. is it open? is it connected?),the configuration parameters of the channel (e.g. receive buffer size),the I/O operations that the channel supports (e.g. read, write, connect, and bind), andthe ChannelPipeline which handles all I/O events and requests associated with the channel. 翻译大意： channel为用户提供： 通道当前的状态（例如它是打开？还是已连接？） channel的配置参数（例如接收缓冲区的大小） channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。 5.5.1 获取channel的状态1234boolean isOpen(); //如果通道打开，则返回trueboolean isRegistered();//如果通道注册到EventLoop，则返回trueboolean isActive();//如果通道处于活动状态并且已连接，则返回trueboolean isWritable();//当且仅当I/O线程将立即执行请求的写入操作时，返回true。 以上就是获取channel的四种状态的方法。 5.5.2 获取channel的配置参数获取单条配置信息，使用getOption()，代码演示： 1234ChannelConfig config = channel.config();//获取配置参数//获取ChannelOption.SO_BACKLOG参数,Integer soBackLogConfig = config.getOption(ChannelOption.SO_BACKLOG);//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128 获取多条配置信息，使用getOptions()，代码演示： 123456789101112ChannelConfig config = channel.config();Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123; System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());&#125;/**SO_REUSEADDR : falseWRITE_BUFFER_LOW_WATER_MARK : 32768WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)SO_BACKLOG : 128以下省略...*/ 5.5.3 channel支持的IO操作写操作，这里演示从服务端写消息发送到客户端： 1234@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;这波啊，这波是肉蛋葱鸡~&quot;, CharsetUtil.UTF_8));&#125; 客户端控制台： 1//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~ 连接操作，代码演示： 1ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用 通过channel获取ChannelPipeline，并做相关的处理： 1234//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler()); 5.6 Selector在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前《NIO入门》中，我已经讲过Selector了。 Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。 5.7 PiPeline与ChannelPipeline在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。 于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。 在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。 5.8 ChannelHandlerContext在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。 于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。 通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。 实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了： 123456789101112//ChannelPipeline实现类DefaultChannelPipeline的构造器方法protected DefaultChannelPipeline(Channel channel) &#123; this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;); succeededFuture = new SucceededChannelFuture(channel, null); voidPromise = new VoidChannelPromise(channel, true); //设置头结点head，尾结点tail tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head;&#125; 下面我用一张图来表示，会更加清晰一点： 5.9 EventLoopGroup我们先看一下EventLoopGroup的类图： 其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。 从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。 每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。 5.9.1 轮询机制的实现原理我们不妨看一段DefaultEventExecutorChooserFactory的源码： 12345678private final AtomicInteger idx = new AtomicInteger();private final EventExecutor[] executors;@Overridepublic EventExecutor next() &#123; //idx.getAndIncrement()相当于idx++，然后对任务长度取模 return executors[idx.getAndIncrement() &amp; executors.length - 1];&#125; 这段代码可以确定执行的方式是轮询机制，接下来debug调试一下： 它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。 1234@Overridepublic EventExecutor next() &#123; return executors[Math.abs(idx.getAndIncrement() % executors.length)];&#125; 写在最后参考Netty官网文档：API文档 创作不易，觉得有用就点个赞吧。 我不要下次一定，希望这次一定素质三连，感谢！ 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Netty","slug":"网络编程/Netty","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/"}],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"Netty","slug":"Netty","permalink":"https://alloceee.github.io/tags/Netty/"}],"author":"Alloceee"},{"title":"Reactor模式","slug":"网络编程/Reactor模式","date":"2020-07-01T14:13:02.000Z","updated":"2021-08-05T07:07:36.627Z","comments":true,"path":"2020/07/01/网络编程/Reactor模式/","link":"","permalink":"https://alloceee.github.io/2020/07/01/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Reactor%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、Reactor模式介绍本文主要参考Doug Lea(大神)的“Scalable IO in Java”中讲述的Reactor模式。 原文地址：http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf 有兴趣的可以看看这本书，受益匪浅！ 1.1 什么是Reactor模式Reactor模式一般翻译成”反应器模式“，也有人称为”分发者模式“。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由一个线程来接收所有的请求，然后派发这些请求到相关的工作线程中。 1.2 为什么使用Reactor模式在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。 那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。由于以上的问题，提出了Reactor模式。 基于Java，Doug Lea（Java并发包作者）提出了三种形式，单Reactor单线程，单Reactor多线程和多Reactor多线程。 二、Reactor模式的演进过程在介绍三种Reactor模式前，先简单地说明三个角色： Reactor：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。 Handler：事件处理器。负责执行对应事件对应的业务逻辑。 Acceptor：绑定了 connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。 2.1 单Reactor单线程 工作流程 只有一个select循环接收请求，客户端（client）注册进来由Reactor接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。 通俗解释一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。 单Reactor单线程的特点单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。 这种模式仅仅只能处理Handler比较快速完成的场景。 2.2 单Reactor多线程 工作流程 在单Reactor多线程中，注册接收事件都是由Reactor来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的Reactor还是单线程。 通俗解释相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。 单Reactor多线程的特点对比单Reactor单线程模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。 缺点：Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。 2.3 多Reactor多线程 工作流程 1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。2、subReactor 将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。 通俗解释相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。 多Reactor多线程的特点mainReactor 主要是用来处理客户端请求连接建立的操作。subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。 这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。 三、在Netty中的应用Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。这个架构实际上跟多Reactor多线程模型比较像。 1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。 2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。 3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。 4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。 写在最后其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。 最后借用大神Doug Lea的名言： 分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。 创作不易，觉得有用就点个赞吧。 下一篇讲Netty框架，想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让大家记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"NIO","slug":"网络编程/NIO","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO/"}],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"NIO","slug":"NIO","permalink":"https://alloceee.github.io/tags/NIO/"}]},{"title":"NIO入门","slug":"网络编程/NIO入门","date":"2020-06-25T15:14:45.000Z","updated":"2021-08-05T07:07:57.653Z","comments":true,"path":"2020/06/25/网络编程/NIO入门/","link":"","permalink":"https://alloceee.github.io/2020/06/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO%E5%85%A5%E9%97%A8/","excerpt":"","text":"1 NIO概述1.1 定义java.nio全称java non-blocking IO，是指JDK1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络(来源于百度百科)。 1.2 为什么使用NIO在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是BIO(阻塞式IO)，也就是我们常用的IO流。 BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，不能充分利用机器资源。但是这样就会有人提出疑问了，那我使用多线程不就可以了吗？ 但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。 而NIO只有在连接/通道真正有读写事件发生时(事件驱动)，才会进行读写，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。 避免了多个线程之间的上下文切换，导致资源的浪费。 2 NIO的三大核心 NIO的核心 对应的类或接口 应用 作用 缓冲区 java.nio.Buffer 文件IO/网络IO 存储数据 通道 java.nio.channels.Channel 文件IO/网络IO 运输 选择器 java.nio.channels.Selector 网络IO 控制器 2.1缓冲区(Buffer)2.1.1 什么是缓冲区我们先看以下这张类图，可以看到Buffer有七种类型。 Buffer是一个内存块。在NIO中，所有的数据都是用Buffer处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向Stream流，NIO而是面向缓冲区(Buffer)。 2.1.2 常用的类型ByteBuffer一般我们常用的类型是ByteBuffer，把数据转成字节进行处理。实质上是一个byte[]数组。 1234567891011public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;&#123; //存储数据的数组 final byte[] hb; //构造器方法 ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset) &#123; super(mark, pos, lim, cap); //初始化数组 this.hb = hb; this.offset = offset; &#125;&#125; 2.1.3 创建Buffer的方式主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。 创建堆内内存块(非直接缓冲区)的方法是： 123456//创建堆内内存块HeapByteBufferByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);String msg = &quot;java技术爱好者&quot;;//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBufferByteBuffer byteBuffer2 = ByteBuffer.wrap(msg.getBytes()); 创建堆外内存块(直接缓冲区)的方法： 12//创建堆外内存块DirectByteBufferByteBuffer byteBuffer3 = ByteBuffer.allocateDirect(1024); 2.1.3.1 HeapByteBuffer与DirectByteBuffer的区别其实根据类名就可以看出，HeapByteBuffer所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而DirectByteBuffer是直接操作操作系统本地代码创建的内存缓冲数组。 DirectByteBuffer的使用场景： java程序与本地磁盘、socket传输数据 大文件对象，可以使用。不会受到堆内存大小的限制。 不需要频繁创建，生命周期较长的情况，能重复使用的情况。 HeapByteBuffer的使用场景： 除了以上的场景外，其他情况还是建议使用HeapByteBuffer，没有达到一定的量级，实际上使用DirectByteBuffer是体现不出优势的。 2.1.3.2 Buffer的初体验接下来，使用ByteBuffer做一个小例子，熟悉一下： 1234567891011121314151617181920212223public static void main(String[] args) throws Exception &#123; String msg = &quot;java技术爱好者，起飞！&quot;; //创建一个固定大小的buffer(返回的是HeapByteBuffer) ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byte[] bytes = msg.getBytes(); //写入数据到Buffer中 byteBuffer.put(bytes); //切换成读模式，关键一步 byteBuffer.flip(); //创建一个临时数组，用于存储获取到的数据 byte[] tempByte = new byte[bytes.length]; int i = 0; //如果还有数据，就循环。循环判断条件 while (byteBuffer.hasRemaining()) &#123; //获取byteBuffer中的数据 byte b = byteBuffer.get(); //放到临时数组中 tempByte[i] = b; i++; &#125; //打印结果 System.out.println(new String(tempByte));//java技术爱好者，起飞！ &#125; 这上面有一个flip()方法是很重要的。意思是切换到读模式。上面已经提到缓存区是双向的，既可以往缓冲区写入数据，也可以从缓冲区读取数据。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？ 2.1.4 三个重要参数123456//位置，默认是从第一个开始private int position = 0;//限制，不能读取或者写入的位置索引private int limit;//容量，缓冲区所包含的元素的数量private int capacity; 那么我们以上面的例子，一句一句代码进行分析： 123String msg = &quot;java技术爱好者，起飞！&quot;;//创建一个固定大小的buffer(返回的是HeapByteBuffer)ByteBuffer byteBuffer = ByteBuffer.allocate(1024); 当创建一个缓冲区时，参数的值是这样的： 当执行到byteBuffer.put(bytes)，当put()进入多少数据，position就会增加多少，参数就会发生变化： 接下来关键一步byteBuffer.flip()，会发生如下变化： flip()方法的源码如下： 123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this; &#125; 为什么要这样赋值呢？因为下面有一句循环条件判断： 123456byteBuffer.hasRemaining();public final boolean hasRemaining() &#123; //判断position的索引是否小于limit。 //所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置 return position &lt; limit;&#125; 接下来就是在while循环中get()读取数据，读取完之后。 最后当position等于limit时，循环判断条件不成立，就跳出循环，读取完毕。 所以可以看出实质上capacity容量大小是不变的，实际上是通过控制position和limit的值来控制读写的数据。 2.2 管道(Channel)首先我们看一下Channel有哪些子类： 常用的Channel有这四种： FileChannel，读写文件中的数据。SocketChannel，通过TCP读写网络中的数据。ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。DatagramChannel，通过UDP读写网络中的数据。 Channel本身并不存储数据，只是负责数据的运输。必须要和Buffer一起使用。 2.2.1 获取通道的方式2.2.1.1 FileChannelFileChannel的获取方式，下面举个文件复制拷贝的例子进行说明： 首先准备一个”1.txt”放在项目的根目录下，然后编写一个main方法： 123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; //获取文件输入流 File file = new File(&quot;1.txt&quot;); FileInputStream inputStream = new FileInputStream(file); //从文件输入流获取通道 FileChannel inputStreamChannel = inputStream.getChannel(); //获取文件输出流 FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;)); //从文件输出流获取通道 FileChannel outputStreamChannel = outputStream.getChannel(); //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了 ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length()); //把输入流通道的数据读取到缓冲区 inputStreamChannel.read(byteBuffer); //切换成读模式 byteBuffer.flip(); //把数据从缓冲区写入到输出流通道 outputStreamChannel.write(byteBuffer); //关闭通道 outputStream.close(); inputStream.close(); outputStreamChannel.close(); inputStreamChannel.close(); &#125; 执行后，我们就获得一个”2.txt”。执行成功。 以上的例子，可以用一张示意图表示，是这样的： 2.2.1.2 SocketChannel接下来我们学习获取SocketChannel的方式。 还是一样，我们通过一个例子来快速上手： 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; //获取ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666); //绑定地址，端口号 serverSocketChannel.bind(address); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (true) &#123; //获取SocketChannel SocketChannel socketChannel = serverSocketChannel.accept(); while (socketChannel.read(byteBuffer) != -1)&#123; //打印结果 System.out.println(new String(byteBuffer.array())); //清空缓冲区 byteBuffer.clear(); &#125; &#125; &#125; 然后运行main()方法，我们可以通过telnet命令进行连接测试： 通过上面的例子可以知道，通过ServerSocketChannel.open()方法可以获取服务器的通道，然后绑定一个地址端口号，接着accept()方法可获得一个SocketChannel通道，也就是客户端的连接通道。 最后配合使用Buffer进行读写即可。 这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器Selector。 2.3 选择器(Selector)Selector翻译成选择器，有些人也会翻译成多路复用器，实际上指的是同一样东西。 只有网络IO才会使用选择器，文件IO是不需要使用的。 选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现单线程管理多个Channel的目的。 2.3.1 核心API API方法名 作用 Selector.open() 打开一个选择器。 select() 选择一组键，其相应的通道已为 I/O 操作准备就绪。 selectedKeys() 返回此选择器的已选择键集。 以上的API会在后面的例子用到，先有个印象。 3 NIO快速入门3.1 文件IO3.1.1 通道间的数据传输这里主要介绍两个通道与通道之间数据传输的方式： transferTo()：把源通道的数据传输到目的通道中。 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; //获取文件输入流 File file = new File(&quot;1.txt&quot;); FileInputStream inputStream = new FileInputStream(file); //从文件输入流获取通道 FileChannel inputStreamChannel = inputStream.getChannel(); //获取文件输出流 FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;)); //从文件输出流获取通道 FileChannel outputStreamChannel = outputStream.getChannel(); //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); //把输入流通道的数据读取到输出流的通道 inputStreamChannel.transferTo(0, byteBuffer.limit(), outputStreamChannel); //关闭通道 outputStream.close(); inputStream.close(); outputStreamChannel.close(); inputStreamChannel.close(); &#125; transferFrom()：把来自源通道的数据传输到目的通道。 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; //获取文件输入流 File file = new File(&quot;1.txt&quot;); FileInputStream inputStream = new FileInputStream(file); //从文件输入流获取通道 FileChannel inputStreamChannel = inputStream.getChannel(); //获取文件输出流 FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;)); //从文件输出流获取通道 FileChannel outputStreamChannel = outputStream.getChannel(); //创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); //把输入流通道的数据读取到输出流的通道 outputStreamChannel.transferFrom(inputStreamChannel,0,byteBuffer.limit()); //关闭通道 outputStream.close(); inputStream.close(); outputStreamChannel.close(); inputStreamChannel.close(); &#125; 3.1.2 分散读取和聚合写入我们先看一下FileChannel的源码： 123public abstract class FileChannel extends AbstractInterruptibleChannel implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel &#123; &#125; 从源码中可以看出实现了GatheringByteChannel, ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子： 我们写一个main方法来实现复制1.txt文件，文件内容是： 1abcdefghijklmnopqrstuvwxyz//26个字母 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) throws Exception &#123; //获取文件输入流 File file = new File(&quot;1.txt&quot;); FileInputStream inputStream = new FileInputStream(file); //从文件输入流获取通道 FileChannel inputStreamChannel = inputStream.getChannel(); //获取文件输出流 FileOutputStream outputStream = new FileOutputStream(new File(&quot;2.txt&quot;)); //从文件输出流获取通道 FileChannel outputStreamChannel = outputStream.getChannel(); //创建三个缓冲区，分别都是5 ByteBuffer byteBuffer1 = ByteBuffer.allocate(5); ByteBuffer byteBuffer2 = ByteBuffer.allocate(5); ByteBuffer byteBuffer3 = ByteBuffer.allocate(5); //创建一个缓冲区数组 ByteBuffer[] buffers = new ByteBuffer[]&#123;byteBuffer1, byteBuffer2, byteBuffer3&#125;; //循环写入到buffers缓冲区数组中，分散读取 long read; long sumLength = 0; while ((read = inputStreamChannel.read(buffers)) != -1) &#123; sumLength += read; Arrays.stream(buffers) .map(buffer -&gt; &quot;posstion=&quot; + buffer.position() + &quot;,limit=&quot; + buffer.limit()) .forEach(System.out::println); //切换模式 Arrays.stream(buffers).forEach(Buffer::flip); //聚合写入到文件输出通道 outputStreamChannel.write(buffers); //清空缓冲区 Arrays.stream(buffers).forEach(Buffer::clear); &#125; System.out.println(&quot;总长度:&quot; + sumLength); //关闭通道 outputStream.close(); inputStream.close(); outputStreamChannel.close(); inputStreamChannel.close(); &#125; 打印结果： 123456789posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=5,limit=5posstion=1,limit=5总长度:26 可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。 这就是分散读取，聚合写入的过程。 使用场景就是可以使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗。网络IO也可以使用，这里就不写例子演示了。 3.1.3 非直接/直接缓冲区非直接缓冲区的创建方式： 1static ByteBuffer allocate(int capacity) 直接缓冲区的创建方式： 1static ByteBuffer allocateDirect(int capacity) 非直接/直接缓冲区的区别示意图： 从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。 接下来我们来对比一下效率，以一个136 MB的视频文件为例： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; long starTime = System.currentTimeMillis(); //获取文件输入流 File file = new File(&quot;D:\\\\小电影.mp4&quot;);//文件大小136 MB FileInputStream inputStream = new FileInputStream(file); //从文件输入流获取通道 FileChannel inputStreamChannel = inputStream.getChannel(); //获取文件输出流 FileOutputStream outputStream = new FileOutputStream(new File(&quot;D:\\\\test.mp4&quot;)); //从文件输出流获取通道 FileChannel outputStreamChannel = outputStream.getChannel(); //创建一个直接缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(5 * 1024 * 1024); //创建一个非直接缓冲区 //ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024); //写入到缓冲区 while (inputStreamChannel.read(byteBuffer) != -1) &#123; //切换读模式 byteBuffer.flip(); outputStreamChannel.write(byteBuffer); byteBuffer.clear(); &#125; //关闭通道 outputStream.close(); inputStream.close(); outputStreamChannel.close(); inputStreamChannel.close(); long endTime = System.currentTimeMillis(); System.out.println(&quot;消耗时间：&quot; + (endTime - starTime) + &quot;毫秒&quot;);&#125; 结果： 直接缓冲区的消耗时间：283毫秒 非直接缓冲区的消耗时间：487毫秒 3.2 网络IO其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用Socket。而Socket是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。 主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。 3.2.1 使用Selector的小例子接下来趁热打铁，我们来做一个服务器接受客户端消息的例子： 首先服务端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class NIOServer &#123; public static void main(String[] args) throws Exception &#123; //打开一个ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666); //绑定地址 serverSocketChannel.bind(address); //设置为非阻塞 serverSocketChannel.configureBlocking(false); //打开一个选择器 Selector selector = Selector.open(); //serverSocketChannel注册到选择器中,监听连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //循环等待客户端的连接 while (true) &#123; //等待3秒，（返回0相当于没有事件）如果没有事件，则跳过 if (selector.select(3000) == 0) &#123; System.out.println(&quot;服务器等待3秒，没有连接&quot;); continue; &#125; //如果有事件selector.select(3000)&gt;0的情况,获取事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); //获取迭代器遍历 Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; //获取到事件 SelectionKey selectionKey = it.next(); //判断如果是连接事件 if (selectionKey.isAcceptable()) &#123; //服务器与客户端建立连接，获取socketChannel SocketChannel socketChannel = serverSocketChannel.accept(); //设置成非阻塞 socketChannel.configureBlocking(false); //把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区 socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024)); &#125; //如果是读事件 if (selectionKey.isReadable()) &#123; //获取通道 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); //获取关联的ByteBuffer ByteBuffer buffer = (ByteBuffer) selectionKey.attachment(); //打印从客户端获取到的数据 socketChannel.read(buffer); System.out.println(&quot;from 客户端：&quot; + new String(buffer.array())); &#125; //从事件集合中删除已处理的事件，防止重复处理 it.remove(); &#125; &#125; &#125;&#125; 客户端代码： 12345678910111213141516171819202122public class NIOClient &#123; public static void main(String[] args) throws Exception &#123; SocketChannel socketChannel = SocketChannel.open(); InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666); socketChannel.configureBlocking(false); //连接服务器 boolean connect = socketChannel.connect(address); //判断是否连接成功 if(!connect)&#123; //等待连接的过程中 while (!socketChannel.finishConnect())&#123; System.out.println(&quot;连接服务器需要时间，期间可以做其他事情...&quot;); &#125; &#125; String msg = &quot;hello java技术爱好者！&quot;; ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes()); //把byteBuffer数据写入到通道中 socketChannel.write(byteBuffer); //让程序卡在这个位置，不关闭连接 System.in.read(); &#125;&#125; 接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息： 12345服务器等待3秒，没有连接服务器等待3秒，没有连接from 客户端：hello java技术爱好者！ 服务器等待3秒，没有连接服务器等待3秒，没有连接 通过这个例子我们引出以下知识点。 3.2.2 SelectionKey在SelectionKey类中有四个常量表示四种事件，来看源码： 12345678910public abstract class SelectionKey &#123; //读事件 public static final int OP_READ = 1 &lt;&lt; 0; //2^0=1 //写事件 public static final int OP_WRITE = 1 &lt;&lt; 2; // 2^2=4 //连接操作,Client端支持的一种操作 public static final int OP_CONNECT = 1 &lt;&lt; 3; // 2^3=8 //连接可接受操作,仅ServerSocketChannel支持 public static final int OP_ACCEPT = 1 &lt;&lt; 4; // 2^4=16&#125; 附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。 1public final SelectionKey register(Selector sel, int ops, Object att) 从selectionKey中获取附件对象可以使用attachment()方法 123public final Object attachment() &#123; return attachment;&#125; 4 使用NIO实现多人聊天室接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。 服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class GroupChatServer &#123; private Selector selector; private ServerSocketChannel serverSocketChannel; public static final int PORT = 6667; //构造器初始化成员变量 public GroupChatServer() &#123; try &#123; //打开一个选择器 this.selector = Selector.open(); //打开serverSocketChannel this.serverSocketChannel = ServerSocketChannel.open(); //绑定地址，端口号 this.serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT)); //设置为非阻塞 serverSocketChannel.configureBlocking(false); //把通道注册到选择器中 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 监听，并且接受客户端消息，转发到其他客户端 */ public void listen() &#123; try &#123; while (true) &#123; //获取监听的事件总数 int count = selector.select(2000); if (count &gt; 0) &#123; Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); //获取SelectionKey集合 Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); //如果是获取连接事件 if (key.isAcceptable()) &#123; SocketChannel socketChannel = serverSocketChannel.accept(); //设置为非阻塞 socketChannel.configureBlocking(false); //注册到选择器中 socketChannel.register(selector, SelectionKey.OP_READ); System.out.println(socketChannel.getRemoteAddress() + &quot;上线了~&quot;); &#125; //如果是读就绪事件 if (key.isReadable()) &#123; //读取消息，并且转发到其他客户端 readData(key); &#125; it.remove(); &#125; &#125; else &#123; System.out.println(&quot;等待...&quot;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获取客户端发送过来的消息 private void readData(SelectionKey selectionKey) &#123; SocketChannel socketChannel = null; try &#123; //从selectionKey中获取channel socketChannel = (SocketChannel) selectionKey.channel(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //把通道的数据写入到缓冲区 int count = socketChannel.read(byteBuffer); //判断返回的count是否大于0，大于0表示读取到了数据 if (count &gt; 0) &#123; //把缓冲区的byte[]转成字符串 String msg = new String(byteBuffer.array()); //输出该消息到控制台 System.out.println(&quot;from 客户端：&quot; + msg); //转发到其他客户端 notifyAllClient(msg, socketChannel); &#125; &#125; catch (Exception e) &#123; try &#123; //打印离线的通知 System.out.println(socketChannel.getRemoteAddress() + &quot;离线了...&quot;); //取消注册 selectionKey.cancel(); //关闭流 socketChannel.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; /** * 转发消息到其他客户端 * msg 消息 * noNotifyChannel 不需要通知的Channel */ private void notifyAllClient(String msg, SocketChannel noNotifyChannel) throws Exception &#123; System.out.println(&quot;服务器转发消息~&quot;); for (SelectionKey selectionKey : selector.keys()) &#123; Channel channel = selectionKey.channel(); //channel的类型实际类型是SocketChannel，并且排除不需要通知的通道 if (channel instanceof SocketChannel &amp;&amp; channel != noNotifyChannel) &#123; //强转成SocketChannel类型 SocketChannel socketChannel = (SocketChannel) channel; //通过消息，包裹获取一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes()); socketChannel.write(byteBuffer); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; GroupChatServer chatServer = new GroupChatServer(); //启动服务器，监听 chatServer.listen(); &#125;&#125; 客户端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class GroupChatClinet &#123; private Selector selector; private SocketChannel socketChannel; private String userName; public GroupChatClinet() &#123; try &#123; //打开选择器 this.selector = Selector.open(); //连接服务器 socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, GroupChatServer.PORT)); //设置为非阻塞 socketChannel.configureBlocking(false); //注册到选择器中 socketChannel.register(selector, SelectionKey.OP_READ); //获取用户名 userName = socketChannel.getLocalAddress().toString().substring(1); System.out.println(userName + &quot; is ok~&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //发送消息到服务端 private void sendMsg(String msg) &#123; msg = userName + &quot;说：&quot; + msg; try &#123; socketChannel.write(ByteBuffer.wrap(msg.getBytes())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //读取服务端发送过来的消息 private void readMsg() &#123; try &#123; int count = selector.select(); if (count &gt; 0) &#123; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey selectionKey = iterator.next(); //判断是读就绪事件 if (selectionKey.isReadable()) &#123; SocketChannel channel = (SocketChannel) selectionKey.channel(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //从服务器的通道中读取数据到缓冲区 channel.read(byteBuffer); //缓冲区的数据，转成字符串，并打印 System.out.println(new String(byteBuffer.array())); &#125; iterator.remove(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; GroupChatClinet chatClinet = new GroupChatClinet(); //启动线程，读取服务器转发过来的消息 new Thread(() -&gt; &#123; while (true) &#123; chatClinet.readMsg(); try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); //主线程发送消息到服务器 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; String msg = scanner.nextLine(); chatClinet.sendMsg(msg); &#125; &#125;&#125; 先启动服务端的main方法，再启动两个客户端的main方法： 然后使用两个客户端开始聊天了~ 以上就是使用NIO实现多人聊天室的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。 写在最后创作不易，觉得有用就点个赞吧。 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个努力让别人记住的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"NIO","slug":"网络编程/NIO","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO/"}],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"NIO","slug":"NIO","permalink":"https://alloceee.github.io/tags/NIO/"}],"author":"Alloceee"},{"title":"List集合的坑","slug":"遇到的坑/List集合的坑","date":"2020-06-21T09:24:09.000Z","updated":"2021-08-04T03:17:18.650Z","comments":true,"path":"2020/06/21/遇到的坑/List集合的坑/","link":"","permalink":"https://alloceee.github.io/2020/06/21/%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/","excerpt":"学如逆水行舟，不进则退 经过几年的工作经验，我发现List有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。","text":"学如逆水行舟，不进则退 经过几年的工作经验，我发现List有很多坑，之前公司有些实习生一不小心就踩到了，所以我打算写一篇文章总结一下，希望看到这篇文章的人能不再踩到坑，代码没bug。做个快乐的程序员。 迭代时删除元素使用for-each迭代遍历时，删除集合中的元素，会报错。 1234567891011121314151617private static List&lt;String&gt; list = new ArrayList&lt;&gt;(); static &#123; //初始化集合 for (int i = 1; i &lt;= 10; i++) &#123; list.add(String.valueOf(i)); &#125; &#125; public static void main(String[] args) &#123; //使用for-each迭代时删除元素 for (String str : list) &#123; if (&quot;1&quot;.equals(str)) &#123; list.remove(str); &#125; &#125; &#125; 或者你使用迭代器Iterator遍历时，删除元素。 12345678910public static void main(String[] args) &#123; //使用Iterator迭代器遍历时，删除元素 Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String str = it.next(); if (&quot;1&quot;.equals(str)) &#123; list.remove(str); &#125; &#125; &#125; 以上两种情况都会报这个错： 123Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 这就是不正确的删除姿势，那怎么删呢？ 使用for-i循环遍历删除(亲测有效)： 12345678910public static void main(String[] args) &#123; //使用Iterator迭代器遍历时，删除元素 for (int i = 0; i &lt; list.size(); i++) &#123; String s = list.get(i); if (&quot;1&quot;.equals(s)) &#123; list.remove(s); &#125; &#125; list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10 &#125; 使用for-i循环倒序遍历，删除元素。 12345678910public static void main(String[] args) &#123; //使用for-i倒序遍历，删除元素 for (int i = list.size() - 1; i &gt;= 0; i--) &#123; String str = list.get(i); if (&quot;1&quot;.equals(str)) &#123; list.remove(str); &#125; &#125; list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10 &#125; 使用Iterator的remove()方法删除。 1234567891011public static void main(String[] args) &#123; //使用Iterator迭代器遍历时，删除元素 Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String str = it.next(); if (&quot;1&quot;.equals(str)) &#123; it.remove(); &#125; &#125; list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10 &#125; 要么潇洒一点，用Lambda表达式。在java8中，List增加了一个removeIf()方法用于删除。 12345public static void main(String[] args) &#123; //使用removeIf()遍历时，删除元素。删除集合中为1的元素 list.removeIf(str -&gt; &quot;1&quot;.equals(str)); list.forEach(System.out::println);//2 3 4 5 6 7 8 9 10 &#125; 使用asList()获得集合删除/增加看代码演示： 1234public static void main(String[] args) &#123; List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6); nums.add(7); &#125; 1234public static void main(String[] args) &#123; List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6); nums.remove(1); &#125; 如果你进行以上操作，就会看到报错： 12Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) 为什么会报这个错，看一下源代码就知道了！ 123private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; &#125; ArrayList不是util包的ArrayList，而是Arrays的一个内部类。因为继承了AbstractList抽象类，但是又没有实现add()、remove()方法。所以会调用抽象类的add()和remove()。你猜猜抽象类的add()怎么着？ 1234567public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125;public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; 所以不能用asList()得到的集合去增删了！ 通过subList()方法获得集合后增删当使用subList()方法获得集合后删除，原(父)集合也会被删除。 12345678public static void main(String[] args) &#123; List&lt;String&gt; subList = list.subList(0, 5); System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] System.out.println(subList);//[1, 2, 3, 4, 5] subList.remove(&quot;1&quot;); System.out.println(list);//[2, 3, 4, 5, 6, 7, 8, 9, 10] System.out.println(subList);//[2, 3, 4, 5] &#125; 当使用subList()方法获得集合后增加元素，原(父)集合也会增加。 12345678public static void main(String[] args) &#123; List&lt;String&gt; subList = list.subList(0, 5); System.out.println(list);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] System.out.println(subList);//[1, 2, 3, 4, 5] subList.add(&quot;11&quot;); System.out.println(list);//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10] System.out.println(subList);//[1, 2, 3, 4, 5, 11] &#125; 大家看一下源码就知道什么原因了。 1234567891011121314151617181920private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); //父集合添加元素 parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); //父集合删除元素 E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125;&#125; 如果希望截取的集合是和原集合互不干扰的话，可以这样： 1List&lt;String&gt; subList = new ArrayList&lt;&gt;(list.subList(0, 5)); 使用Collections.unmodifiableList()创建不可变集合也是可变的。当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码： 1234567public static void main(String[] args) &#123; List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list); System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] //删除原集合元素 list.remove(&quot;1&quot;); System.out.println(unmodifiableList);//[2, 3, 4, 5, 6, 7, 8, 9, 10] &#125; 看源码就知道原因了： 1234UnmodifiableList(List&lt;? extends E&gt; list) &#123; super(list); this.list = list; &#125; 因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变。 解决方式：使用Guava工具包的ImmutableList.copyOf()方法创建。 12345public static void main(String[] args) throws Exception &#123; List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list); list.remove(&quot;1&quot;); System.out.println(unmodifiableList);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] &#125; 创作不易，觉得有用就点个赞吧。 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"集合","slug":"集合","permalink":"https://alloceee.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"经验总结","slug":"经验总结","permalink":"https://alloceee.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"}]},{"title":"SpringMVC全局异常处理","slug":"必学的优秀技术框架/SpringMVC全局异常处理","date":"2020-06-14T07:13:07.000Z","updated":"2021-08-04T03:17:18.595Z","comments":true,"path":"2020/06/14/必学的优秀技术框架/SpringMVC全局异常处理/","link":"","permalink":"https://alloceee.github.io/2020/06/14/%E5%BF%85%E5%AD%A6%E7%9A%84%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"SpringMVC全局异常处理SpringMVC除了可以做URL映射和请求拦截外，还可以做全局异常的处理。全局异常处理可能我们平时比较少机会接触，但是每个项目都肯定会做这个处理。比如在上一间公司，是前后端分离的架构，所以后端只要有运行时异常就会报“系统异常，请稍后再试”。如果想要走上架构师的话，这个肯定是要学会的。 SpringMVC全局异常处理机制首先，要知道全局异常处理，SpringMVC提供了两种方式： 实现HandlerExceptionResolver接口，自定义异常处理器。 使用HandlerExceptionResolver接口的子类，也就是SpringMVC提供的异常处理器。 所以，总得来说就两种方式，一种是自定义异常处理器，第二种是SpringMVC提供的。接下来先说SpringMVC提供的几种异常处理器的使用方式，然后再讲自定义异常处理器。 SpringMVC提供的异常处理器有哪些呢？我们可以直接看源码的类图。 可以看出有四种： DefaultHandlerExceptionResolver，默认的异常处理器。根据各个不同类型的异常，返回不同的异常视图。 SimpleMappingExceptionResolver，简单映射异常处理器。通过配置异常类和view的关系来解析异常。 ResponseStatusExceptionResolver，状态码异常处理器。解析带有@ResponseStatus注释类型的异常。 ExceptionHandlerExceptionResolver，注解形式的异常处理器。对@ExceptionHandler注解的方法进行异常解析。 DefaultHandlerExceptionResolver这个异常处理器是SprngMVC默认的一个处理器，处理一些常见的异常，比如：没有找到请求参数，参数类型转换异常，请求方式不支持等等。 接着我们看DefaultHandlerExceptionResolver类的doResolveException()方法： 12345678910111213141516171819202122232425@Override@Nullableprotected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response,@Nullable Object handler, Exception ex) &#123; try &#123; if (ex instanceof HttpRequestMethodNotSupportedException) &#123; return handleHttpRequestMethodNotSupported((HttpRequestMethodNotSupportedException) ex, request, response, handler); &#125; else if (ex instanceof HttpMediaTypeNotSupportedException) &#123; return handleHttpMediaTypeNotSupported((HttpMediaTypeNotSupportedException) ex, request, response, handler); &#125; else if (ex instanceof HttpMediaTypeNotAcceptableException) &#123; return handleHttpMediaTypeNotAcceptable((HttpMediaTypeNotAcceptableException) ex, request, response, handler); &#125; //省略...以下还有十几种异常的else-if &#125;catch (Exception handlerException) &#123; //是否打开日志，如果打开，那就记录日志 if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Handling of [&quot; + ex.getClass().getName() + &quot;] resulted in Exception&quot;, handlerException); &#125; &#125; return null;&#125; 通过if-else判断，判断继承什么异常就显示对应的错误码和错误提示信息。由此可以知道，处理一般有两步，一是设置响应码，二是在响应头设置异常信息。下面是MissingServletRequestPartException的处理的源码： 123456789protected ModelAndView handleMissingServletRequestPartException(MissingServletRequestPartException ex, HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException &#123; //设置响应码，设置异常信息，SC_BAD_REQUEST就是400(bad request) response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage()); return new ModelAndView();&#125;//响应码public static final int SC_BAD_REQUEST = 400; 为什么要存在这个异常处理器呢？ 从框架的设计理念来看，这种公共的、常见的异常应该交给框架本身来完成，是一些必需处理的异常。比如参数类型转换异常，如果程序员不处理，还有框架提供默认的处理方式，不至于出现这种错误而无法排查。 SimpleMappingExceptionResolver这种异常处理器需要提前配置异常类和对应的view视图。一般用于使用JSP的项目中，出现异常则通过这个异常处理器跳转到指定的页面。 怎么配置？首先搭建JSP项目我就不浪费篇幅介绍了。首先要加载一个XML文件。 12345678@SpringBootApplication//在启动类，加载配置文件@ImportResource(&quot;classpath:spring-config.xml&quot;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 然后在resources目录下，创建一个spring-config.xml文件，内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!-- 定义默认的异常处理页面 --&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;err&quot;/&gt; &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt; &lt;!-- 定义需要特殊处理的异常，用类名或完全路径名作为key，异常也页名作为值 --&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- 数组越界异常 --&gt; &lt;prop key=&quot;java.lang.ArrayIndexOutOfBoundsException&quot;&gt;err/arrayIndexOutOfBounds&lt;/prop&gt; &lt;!-- 空指针异常 --&gt; &lt;prop key=&quot;java.lang.NullPointerException&quot;&gt;err/nullPointer&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 然后在webapp也就是存放JSP页面的目录下，创建两个JSP页面。 arrayIndexOutOfBounds.jsp如下： 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;数组越界异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;数组越界异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%= ex.getMessage() %&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt; nullPointer.jsp如下： 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;空指针异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;空指针异常&lt;/h1&gt;&lt;br&gt;&lt;%-- 打印异常到页面上 --%&gt;&lt;% Exception ex = (Exception)request.getAttribute(&quot;ex&quot;); %&gt;&lt;br&gt;&lt;div&gt;&lt;%=ex.getMessage()%&gt;&lt;/div&gt;&lt;% ex.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt; 接着创建两个Controller，分别抛出空指针异常和数组越界异常。 123456789101112131415161718192021222324@Controller@RequestMapping(&quot;/error&quot;)public class ErrController &#123; @RequestMapping(&quot;/null&quot;) public String err() throws Exception&#123; String str = null; //抛出空指针异常 int length = str.length(); System.out.println(length); return &quot;index&quot;; &#125; @RequestMapping(&quot;/indexOut&quot;) public String indexOut() throws Exception&#123; int[] nums = new int[2]; for (int i = 0; i &lt; 3; i++) &#123; //抛出数组越界异常 nums[i] = i; System.out.println(nums[i]); &#125; return &quot;index&quot;; &#125;&#125; 启动项目后，我们发送两个请求，就可以看到： 通过上述例子可以看出，其实对于现在前后端分离的项目来说，这种异常处理器已经不是很常用了。 ResponseStatusExceptionResolver这种异常处理器主要用于处理带有@ResponseStatus注释的异常。下面演示一下使用方式。 首先自定义异常类继承Exception，并且使用@ResponseStatus注解修饰。如下： 1234//value需要使用HttpStatus枚举类型，HttpStatus.FORBIDDEN=403。@ResponseStatus(value = HttpStatus.FORBIDDEN,reason = &quot;My defined Exception&quot;)public class DefinedException extends Exception&#123;&#125; 然后再在Controller层抛出此异常。如下： 123456789101112@Controller@RequestMapping(&quot;/error&quot;)public class ErrController &#123; @RequestMapping(&quot;/myException&quot;) public String ex(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception &#123; if (num == 1) &#123; //抛出自定义异常 throw new DefinedException(); &#125; return &quot;index&quot;; &#125;&#125; 然后启动项目，请求接口，可以看到如下信息： 使用这种异常处理器，需要自定义一个异常，一定要一直往上层抛出异常，如果不往上层抛出，在service或者dao层就try-catch处理掉的话，是不会触发的。 ExceptionHandlerExceptionResolver这个异常处理器才是最重要的，也是最常用，最灵活的，因为是使用注解。首先我们还是简单地演示一下怎么使用： 首先需要定义一个全局的异常处理器。 1234567891011121314//这里使用了RestControllerAdvice，是@ResponseBody和@ControllerAdvice的结合//会把实体类转成JSON格式的提示返回，符合前后端分离的架构@RestControllerAdvicepublic class GlobalExceptionHandler &#123; //这里自定义了一个BaseException，当抛出BaseException异常就会被此方法处理 @ExceptionHandler(BaseException.class) public ErrorInfo errorHandler(HttpServletRequest req, BaseException e) throws Exception &#123; ErrorInfo r = new ErrorInfo(); r.setMessage(e.getMessage()); r.setCode(ErrorInfo.ERROR); r.setUrl(req.getRequestURL().toString()); return r; &#125;&#125; 然后我们自定义一个自定义异常类BaseException： 12345public class BaseException extends Exception &#123; public BaseException(String message) &#123; super(message); &#125;&#125; 然后在Controller层定义一个方法测试： 12345678@Controller@RequestMapping(&quot;/error&quot;)public class ErrController &#123; @RequestMapping(&quot;/base&quot;) public String base() throws BaseException &#123; throw new BaseException(&quot;系统异常，请稍后重试。&quot;); &#125;&#125; 老规矩，启动项目，请求接口可以看到结果： 你也可以不自定义异常BaseException，而直接拦截常见的各种异常都可以。所以这是一个非常灵活的异常处理器。你也可以做跳转页面，返回ModelAndView即可（以免篇幅过长就不演示了，哈哈）。 小结经过以上的演示后我们学习了SpringMVC四种异常处理器的工作机制，最后这种作为程序员我觉得是必须掌握的，前面的简单映射异常处理器和状态映射处理器可以选择性掌握，默认的异常处理器了解即可。 那这么多异常处理器，究竟是如何工作的呢？为什么是设计一个接口，下面有一个抽象类加上四个实现子类呢？接下来我们通过源码分析来揭开谜底！ 源码分析源码分析从哪里入手呢？在SpringMVC中，其实你想都不用想，肯定在DispatcherServlet类里。经过我顺藤摸瓜，我定位在了processHandlerException()方法。怎么定位的呢？其实很简单，看源码： 1234567891011121314151617181920private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; //异常不为空 if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); //关键点：执行异常处理 mv = processHandlerException(request, response, handler, exception); //省略... &#125; &#125; //省略...&#125; processHandlerException()就是这个直接的一个if-else判断，那个processHandlerException()方法又是怎么处理的呢？ 12345678910111213141516171819202122232425262728293031323334353637@Nullableprotected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception &#123; ModelAndView exMv = null; //判断异常处理器的集合是否为空 if (this.handlerExceptionResolvers != null) &#123; //不为空则遍历异常处理器 for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) &#123; //调用异常处理器的resolveException()方法进行处理异常 exMv = handlerExceptionResolver.resolveException(request, response, handler, ex); //判断返回的ModelAndView是否为null，不为null则跳出循环，为null则继续下一个异常处理器 if (exMv != null) &#123; break; &#125; &#125; &#125; //如果ModelAndView不为空 if (exMv != null) &#123; if (exMv.isEmpty()) &#123; //设置异常信息提示 request.setAttribute(EXCEPTION_ATTRIBUTE, ex); return null; &#125; //如果返回的ModelAndView不包含view if (!exMv.hasView()) &#123; //设置一个默认的视图 String defaultViewName = getDefaultViewName(request); if (defaultViewName != null) &#123; exMv.setViewName(defaultViewName); &#125; &#125; //省略... //返回异常的ModelAndView return exMv; &#125; throw ex;&#125; 这不就是责任链模式吗！提前加载异常处理器到handlerExceptionResolvers集合中，然后遍历去执行，能处理就处理，不能处理就跳到下一个异常处理器处理。 那接下来我们就有一个问题了，handlerExceptionResolvers集合是怎么加载异常处理器的？这个问题很简单，就是使用DispatcherServlet.properties配置文件。这个文件真的很重要！！！ 123org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver 默认是加载以上三种异常处理器到集合中，所以只要带有@ControllerAdvice、@ExceptionHandler、@ResponseStatus注解的都会被扫描。SimpleMappingExceptionResolver则是通过xml文件(当然也可以使用@Configuration)去配置。 resolveException()其实在resolveException()处理异常的方法中，还使用了模板模式。 1234567891011@Override@Nullablepublic ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) &#123; //省略... //预处理 prepareResponse(ex, response); //调用了一个抽象方法，抽象方法由子类去实现 ModelAndView result = doResolveException(request, response, handler, ex); //省略...&#125; 抽象方法doResolveException()，由子类实现。 123@Nullableprotected abstract ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex); 怎么识别模板方法，其实很简单，只要看到抽象类，有个具体方法里面调用了抽象方法，那很大可能就是模板模式。抽象方法就是模板方法，由子类实现。 子类我们都知道就是那四个异常处理器实现类了。 总结用流程图概括一下： 经过以上的学习后，我们知道只需要把异常处理器加到集合中，就可以执行。所以我们可以使用直接实现HandlerExceptionResolver接口的方式来实现异常处理器。 实现HandlerExceptionResolver接口实现全局异常处理首先自定一个异常类MyException。 12345public class MyException extends Exception &#123; public MyException(String message) &#123; super(message); &#125;&#125; 然后实现HandlerExceptionResolver接口定义一个异常处理器。 12345678910111213141516171819//注册异常处理器到Spring容器中@Componentpublic class MyExceptionHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; try &#123; //如果属于MyException异常，则输出异常提示到页面 if (ex instanceof MyException) &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(ex.getMessage()); //这里返回null，不做处理。也可以返回ModelAndView跳转页面 return null; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 然后在Controller层定义一个方法测试： 123456789@Controller@RequestMapping(&quot;/error&quot;)public class ErrController &#123; @RequestMapping(&quot;/myEx&quot;) public String myEx() throws MyException &#123; System.out.println(&quot;执行myEx()&quot;); throw new MyException(&quot;自定义异常提示信息&quot;); &#125;&#125; 启动项目，请求接口，我们可以看到： 最后说几句以上就是我对于SpringMVC全局异常处理机制的理解。更多的java技术分享，可以关注我的公众号“java技术爱好者”，后续会不断更新。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://alloceee.github.io/tags/SpringMVC/"},{"name":"源码分析","slug":"源码分析","permalink":"https://alloceee.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"面试题总结-基础篇","slug":"面经分享/面试题总结-基础篇","date":"2020-06-11T14:47:02.000Z","updated":"2021-08-04T03:17:18.660Z","comments":true,"path":"2020/06/11/面经分享/面试题总结-基础篇/","link":"","permalink":"https://alloceee.github.io/2020/06/11/%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"基础知识JVM、JRE、JDK有什么联系与区别？JVM是java虚拟机，能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。JRE是java运行时环境，它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。换句话说，JRE包含JVM。JDK是java开发工具包，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。JDK包含JRE。所以总得来说，JDK&gt;JRE&gt;JVM。 面向对象的特征有哪些？有三大特征，继承，封装，多态。 为什么java可以实现跨平台？因为java是编译成.class文件运行在JVM上的。针对不同的系统有不同的JVM实现，在不同的JVM实现上会映射到不同系统的 API 调用，从而实现代码的跨平台运行。 类的加载顺序？静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。 接口和抽象类有什么共同点和不同点？共同点：1.都可以定义抽象方法，子类都要实现定义的抽象方法。2.都不能被实例化，但是可以定义抽象类和接口类型的引用。不同点：1.接口没有构造器，抽象类可以定义构造器。2.接口定义具体方法只能定义default修饰，抽象类可以直接定义具体方法。3.接口的子类是实现接口，关键字是implements，抽象类的子类是继承，关键字是extends。4.接口不能定义成员变量，只能定义常量。抽象类可以定义成员变量。 static关键字有哪些用法？①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。 Switch能用什么数据类型作为参数？JDK1.5前：byte、short、char、intJDK1.5：枚举JDK1.7：String 枚举有哪些特点？在项目中如何使用？特点：1.枚举的构造器是私有的。2.枚举不能被继承。3.枚举是绝对的单例，即使是反序列化也无法创建多个实例。使用场景：当变量只能从一堆固定的值中取出一个时，那么就应该使用枚举。比如时间的单位，季度等等。 什么是方法重载？什么是方法重写？方法重载，一个类中允许同时存在一个以上的同名方法，主要体现在方法参数的类型和数量不同，方法名相同，与访问修饰符和返回值类型都是无关的。口诀是”一同两不同“。方法重写一般在继承中，子类重写父类的方法，既然是重写一遍，那么方法名和参数部分一定是相同的。只是实现的功能不同。声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，声明为 private 的方法不能被重写。 静态变量和实例变量有什么不同？分别位于内存的什么区域？1.静态变量使用static修饰，实例变量不需要。2.静态变量在类被加载时就会分配内存空间，就可以使用。实例变量需要实例对象才会分配内存空间，才可以被引用，是属于实例的。3.静态变量是存在于静态区(全局区)的，实例变量位于堆内存中。 java的内部类的分类有哪些？实例内部类、静态内部类、局部内部类、匿名内部类。 break、continue、return 的作用是什么？ break：结束循环。不仅可以结束其所在的循环，还可结束其外层循环。 continue：跳过本次循环，开始下一次循环。 return：不是专用于结束循环，而是用于结束方法。如果在循环中使用return，就会结束整个方法，循环当然也会结束。Object类有哪些常用的方法？ toString()、equals()、hashCode()。 toString()默认输出对象的内存地址，一般不希望输出内存地址可以重写toString()方法。 equals()方法用于比较对象是否相等，默认比较是内存地址，所以要正确比较两个对象是否值相等，此方法必须被重写。 hashCode()方法用来返回其所在对象的物理地址（哈希码值），常会和equals()方法同时重写，确保相等的两个对象拥有相等的hashCode。==与equals()的区别？equals()方法属于Object对象的，所以比较基础数据类型是不能使用equals()。必须使用==。 在默认情况下，equals()与==是一样的，都是比较内存地址。所以在业务逻辑中，我们一般会重写equals()方法。 equals()与hashCode()有什么联系？1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。2.hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。在使用HashSet或者HashMap集合中，比较两个对象是否相等时，会先调用hashCode()比较，如果hashCode()相等，则会继续调用equals()比较，equals()也相等才会认为是同一个对象。如果hashCode()返回不相等，则认为是不相等的对象。所以一般我们会同时重写hashCode()和equals()方法。 &amp; 和 &amp;&amp;有什么区别？&amp;&amp;具有短路的功能，也就是如果&amp;&amp;左边的条件为fasle就不再执行后面的条件判断。&amp;则会执行完左右两边的条件判断。 final、finalize()、finally{}分别有什么作用？final修饰类，表明这个类不可被其他类继承。final修饰成员变量，表示此变量为常量，只能在初始化时被赋值一次，赋值后不能修改。final修饰方法。把方法锁定，不能被子类重写，以防止子类对其进行更改。finalize()是Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。一个对象的finalize()方法只会被调用一次。finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块。 Cloneable接口有什么作用？Cloneable接口是一个标记接口，实现了此接口，表示可以使用clone()方法，没有实现此接口使用clone()会抛出CloneNotSupportedException异常。 什么是浅克隆，什么是深克隆？浅克隆是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。 深克隆不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。 什么是序列化？什么是反序列化？序列化：把对象转换为字节序列的过程称为对象的序列化。反序列化：把字节序列恢复为对象的过程称为对象的反序列化。 Serializable接口有什么作用？Serializable接口是一个标记接口，一个类只有实现了Serializable接口，它的对象才是可序列化的。否则序列化时会报NotSerializableException异常。如果不显性声明serialVersionUID，则会默认生成一个。为了serialVersionUID的确定性，最好是显性声明。 String、StringBuffer、StringBuilder有什么区别? String被声明为final class，是由定义final的字符数组实现的，因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。 StringBuffer是由定义了临时数据transient的字符数组实现的，提供append()和add()方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列，所有修改数据的方法都加上synchronized。性能相对StringBuilder会差一点。 StringBuilder和StringBuffer本质上没什么区别，区别是去掉了保证线程安全的synchronized，减少了开销，性能有所提高。什么是泛型?什么是泛型的上界和下界?Java 泛型是 JDK1.5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。上界用extends关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。下界用super进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object。什么是反射机制？ Java反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为Java的反射机制。 获取Class对象的方式有哪些？ 通过Object类中的getClass()方法，想要用这种方法必须要明确具体的类并且创建该类的对象。 所有数据类型都具备一个静态的属性.class来获取对应的Class对象。但是还是要明确到类，然后才能调用类中的静态成员。 通过Class.forName()方法完成，必须要指定类的全限定名，由于前两种方法都是在知道该类的情况下获取该类的字节码对象，因此不会有异常，但是Class.forName()方法如果写错类的路径会报ClassNotFoundException的异常。java中的异常有哪几种异常？Throwable类是Java异常类型的顶层父类，Throwable包含了Error和Excetion。Excetion分为两种，一种是**非运行时异常(又称为检查异常)，另一种是运行时异常(RuntimeException)**。java是如何处理异常的？ Error是程序无法处理的, 比如OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, JVM一般会终止线程。 运行时异常(RuntimeException)，如 NullPointerException、IndexOutOfBoundsException等，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉。这些错误一般是由程序的逻辑错误引起的，程序应该从逻辑角度去尽量避免。 非运行时异常是RuntimeException以外的异常，是Exception及其子类，这些异常从程序的角度来说是必须经过捕捉检查处理的，否则不能通过编译。如IOException、SQLException等。java集合、IO流、日期处理等常用的集合有哪些？常用集合有Map、List、Set。HashMap是线程安全的吗？不是线程安全的。如何使HashMap线程安全？使用Collections类的synchronizedMap()方法包装。1Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); 使用java.util.concurrent包下的ConcurrentHashMap类也可以获得线程安全的Map。1ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap(); 使用Hashtable类，也可以获得线程安全的Map1Map&lt;String,Object&gt; hashtable = new Hashtable&lt;&gt;(); HashMap和Hashtable的区别是什么？ Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。 Hashtable是线程安全的，HashMap是线程不安全的。 Hashtable中，key和value都不允许出现null值。 HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。HashMap是如何解决哈希冲突的？ 在JDK1.8前，HashMap是采用链表法解决哈希冲突的。当put()一个值到Map时，会通过Key拿到一个哈希值，通过哈希值获取数组下标，先查询是否存在该hash值。若不存在，则直接以Entry&lt;V,V&gt;的方式存放在数组中。若存在，则再调用equals()方法对比key是否相同，若hashcode()值和key都相同，则替换value，若hashcode()值相同，key不相同，则形成一个单链表，将hashcode()值相同，key不同的元素以Entry&lt;V,V&gt;的方式存放在链表中，这样就解决了哈希冲突。 JDK1.8以后，当链表的长度达到某个限制值(默认是8)，就会转换成红黑树，提高性能。HashMap初始大小是多少？负载因子是多少？默认的数组初始大小是16。负载因子是0.75。 （为什么初始值是2的n次方，为什么负载因子取0.75，这两个问题可以网上找资料看看，这里就不详述了） 简述一下HashMap的扩容机制？HashMap是懒加载的，当调用put()方法时，会先初始化Map的大小，默认数组长度是16，负载因子是0.75，所以阈值是12。当HashMap元素的个数超过阈值时，就会把数组的大小扩展到原来的2倍，然后重新计算每个元素在数组中的位置。 List有哪些常用的子类？ArrayList和LinkedList。 ArrayList和LinkedList有什么区别？ 底层数据结构不同。ArrayList基于数组+动态扩容实现的，LinkedList基于双向链表实现。从储存结构上分析，LinkedList更加占内存，因为每个节点除了存储数据外还要存储指向前节点的引用和指向后节点的引用。 效率不同。当随机访问时，ArrayList是基于数组下标访问，查询效率较高，但是由于数组的长度是固定的，所以当添加的元素到一定的阈值时会扩容数组，消耗性能，增删效率偏低。LinkedList在查询时，需要从前到后依次遍历，所以查询效率不高，但是在增删时只需要更改节点的引用，开销较少，所以增删效率较高。List集合排序的方式有哪些？使用List接口定义的sort()方法。1list.sort(Comparator.comparingInt(User::getAge)); 使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。12345678//实现Comparable接口public class User implements Comparable&lt;User&gt; &#123; //重写compareTo方法 @Override public int compareTo(User user) &#123; return Integer.compare(this.getAge(), user.getAge()); &#125;&#125; 使用Collections的sort()方法123Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge)); 使用Stream流操作的sort()方法，传入一个Comparator接口。1list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList()); 栈和队列的特点分别是什么？在java中有哪些实现的类？栈是先进后出，队列是先进先出。Stack类是栈在java中的实现，继承Vector类，底层是基于数组存储数据。Queue接口是队列在java中的代表，Queue接口有几个常用的子类ArrayDeque、LinkedList。IO、NIO有什么区别？IO包括：File、OutputStream、InputStream、Writer，Reader。NIO三大核心：selector（选择器），channel（通道），buffer（缓冲区）NIO与IO区别在于，IO面向流，NIO面向缓冲区。IO是阻塞，NIO是非阻塞。如何进行日期的转换？使用SimpleDateFormat类进行String和Date之间的转换。如何获取上一年的今天的日期？使用Calendar对象。如下所示：12345678//创建Calendar对象Calendar calendar = Calendar.getInstance();//设置年份，当前年份减去一年calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR) - 1);//以下是打印结果Date time = calendar.getTime();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.format(time));//2019-06-08 23:43:14 正确 BigDecimal类型一定不会失真吗？不一定。参数类型为double的构造方法的结果有一定的不可预知性，是有可能产生失真的。123BigDecimal bigDecimal = new BigDecimal(0.99);System.out.println(bigDecimal);//结果如下//0.9899999999999999911182158029987476766109466552734375 使用参数类型String构造方法是完全可预知的，不会产生失真。所以在开发中推荐使用参数类型String构造方法。java并发编程为什么要使用多线程？ 避免主线程阻塞，可以使用多线程做成异步调用。 提升性能，充分利用CPU资源。创建线程有哪几种方法？ 通过继承Thread类创建线程类。 通过实现Runnable接口创建线程类。 通过实现Callable接口创建线程类。如何获取多线程的返回值？使用Callable和FutureTask 接口，获取返回值。123456789101112131415public static void main(String[] args) throws Exception &#123; try &#123; //使用匿名内部类创建Callable Callable callable = () -&gt; &quot;hello call&quot;; FutureTask futureTask = new FutureTask(callable); //执行线程 new Thread(futureTask).start(); if (!futureTask.isDone()) &#123; //获取返回值 System.out.println(futureTask.get()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 多线程的生命周期？新建状态、就绪状态、运行状态、阻塞状态、死亡状态如何进行线程之间的通信？ 使用synchronized、wait()、notify() 使用JUC工具类CountDownLatch 使用ReentrantLock 结合Condition 基本LockSupport实现线程间的阻塞和唤醒 以上几种方式的具体实现代码，可以网上找一下资料，这里不演示了。 说说 sleep() 方法和 wait() 方法区别和共同点?相同点： sleep()方法和wait()方法都用来改变线程的状态，能够让线程从运行状态，转变为休眠状态。 不同点： sleep()方法是Thread类中的静态方法，而wait()方法是Object类中的方法。 sleep()方法可以在任何地方调用，而wait()方法只能在同步代码块或同步方法中使用(即使用synchronized关键字修饰的)。 这两个方法都在同步代码块或同步方法中使用时，sleep()方法不会释放对象锁。而wait()方法则会释放对象锁。如何停止线程？ 使用退出标志，使线程正常退出，也就是当run()方法完成后线程终止。 使用stop()方法强行终止(不推荐)，可能会出现数据不同步，或者资源未释放等问题。 使用interrupt()方法中断线程。什么是线程的死锁？如何避免线程死锁？多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进，这种现象称为死锁。 避免死锁的三种方式： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）线程池的作用？ 利用线程池管理并复用线程，减少创建线程和销毁线程的资源消耗。 实现任务线程队列缓存策略和拒绝机制。 可以对线程进行统一的分配，监控和调优。 提供定时执行、最大线程数、并发数控制等功能。创建线程池的重要参数分别代表什么意思？ corePoolSize线程池核心线程大小。在没有设置 allowCoreThreadTimeOut为true的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize。 maximumPoolSize线程池最大线程数量。线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。对于无界队列可以忽略此参数。 keepAliveTime线程存活保持时间。当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。 unit 空间线程存活时间单位。 workQueue任务队列：用于传输和保存等待执行任务的阻塞队列。①ArrayBlockingQueue，基于数组的有界阻塞队列，按FIFO排序。②LinkedBlockingQuene，基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。当使用该队列时，maximumPoolSize参数可以忽略。③SynchronousQuene，一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。④PriorityBlockingQueue，具有优先级的无界阻塞队列，优先级通过参数Comparator实现。 threadFactory线程工厂，用于创建新线程。 handler线程饱和策略，当线程池和队列都满了，再加入线程会执行此策略。线程池中submit() 和 execute()方法有什么区别？ 参数不同 submit()方法有三个重载方法。 123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); execute()方法只有一个 1void execute(Runnable command); execute()没有返回值；而submit()有返回值 submit()的返回值Future调用get()方法时，可以捕获处理异常。而execute()没有返回值不能捕获异常。有哪些常用的线程池？Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有已建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。Executors.newFixedThreadPool()：可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。Executors.newScheduledThreadPool(int n)：定长线程池，支持定时及周期性任务执行。Executors.newSingleThreadExecutor()：单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。什么是线程安全问题？如何保证线程安全？当多个线程同时共享，同一个全局变量或者静态变量，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。java的内存模型？java的内存模型规定了所有的变量都存储在主内存中，每个线程拥有自己的工作内存，工作内存保存了该线程使用到的变量的主内存拷贝，线程对变量所有操作，读取，赋值，都必须在工作内存中进行，不能直接写主内存变量，线程间变量值的传递均需要主内存来完成。volatile关键字有什么作用？volatile一定能保证原子性吗？volatile关键字有什么作用： 内存可见性（Memory Visibility)：所有线程都能看到共享内存的最新状态。 禁止指令重排。 volatile是Java提供的一种轻量级的同步机制，并不能保证原子性。 什么是指令重排？指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。 synchronized的使用方式？ 修饰实例(非静态方法。被锁对象是类的实例(this)。 修饰静态方法。被锁对象是类对象。 同步代码块。有三种形式。①synchronized(this)&#123;&#125;，被锁对象是类的实例。②synchronized(XXX.Class)，被锁对象是类对象。③synchronized(new Object())，被锁对象是实例对象object。Lock锁的使用方式？ 1.获取锁。2.上锁。3.释放锁。注意点：释放锁最好放在finally&#123;&#125;代码块中，保证能执行释放锁。 什么是乐观锁、什么是悲观锁？ 悲观锁：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。具有强烈的独占和排他特性。 乐观锁：乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试。相对于悲观锁，在高并发的场景下有更好的性能表现，通常用”版本号”实现。synchronized与Lock锁的区别？ synchronized是java内置关键字，在jvm层面。Lock是个java类。 synchronized无法判断是否获取锁的状态。Lock可以判断是否获取到锁。 synchronized会自动释放锁。Lock锁需要在finally&#123;&#125;代码块中手工释放锁。 synchronized的锁可重入、不可中断、非公平。而Lock锁可重入、可判断、可公平（两者皆可）。有哪些常用的线程安全的集合？ConcurrentHashMap、Vector、Hashtable、Stack。还可以使用Collections包装方法获得线程安全的集合。CAS是什么，有什么问题，如何解决？CAS是compare and swap的缩写，意思是比较与交换。CAS是乐观锁的一种实现。CAS操作包含三个操作数—内存位置的值（V）、预期原值（A）和新值（B）。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。 CAS有以下缺点： ABA问题： 线程C、D。线程D将A修改为B后又修改为A，此时C线程以为A没有改变过。这个问题通常可以使用版本号来解决。 CPU开销过大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。什么是ThreadLocal？这个类提供了线程局部变量也称为线程本地变量，它为变量在每个线程中创建了一个副本，通过这样的方式做到变量在线程间隔离且在方法间共享的场景。ThreadLocal是如何保证线程安全的？ThreadLocal存储的值不是线程共享的，而是属于线程的。内部会维护一个ThreadLocalMap，key是当前线程的ThreadLocal，value是存储的值。换句话说，每个线程都有自己的值，当然不会出现线程安全问题了。 源码如下： 123456789101112public void set(T value) &#123; //获取当前线程 Thread t = Thread.currentThread(); //通过当前线程获取到ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) //key是this，value是需要存储的值 map.set(this, value); else //创建一个map createMap(t, value); &#125; JVM相关什么是JVM内存模型？Java内存模型（Java Memory Model，简称为JMM)，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 根据java虚拟机规范，JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。 栈内存溢出(StackOverflowError)的常见原因有哪些？栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是方法递归调用产生这种结果。 堆内存溢出(OOM)的常见原因有哪些？ OutOfMemoryError: Java heap space。在创建新的对象时, 堆内存中的空间不足以存放新创建的对象时发生。产生原因：程序中出现了死循环，不断创建对象；程序占用内存太多，超过了JVM堆设置的最大值。 OutOfMemoryError: unable to create new native thread。产生原因：系统内存耗尽，无法为新线程分配内存；创建线程数超过了操作系统的限制。 OutOfMemoryError: PermGen space。永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。 OutOfMemoryError：GC overhead limit exceeded。超过98%的时间都在用来做GC并且回收了不到2%的堆内存。连续多次的GC，都回收了不到2%的极端情况下才会抛出。 JVM参数调优有哪些重要的参数？分别有什么作用？ -Xms 初始堆内存大小。 -Xmx 最大堆内存大小。 -Xss 每个线程的栈大小。 -XX:+PrintGC 每次GC时打印相关信息。 -XX:Newratio 设置年轻代和老年代的比例，比如值为2，则老年代是年轻代的2倍。 -XX:Newsize 设置年轻代的初始值大小。 -XX:Maxnewsize 设置年轻代的最大值大小。 GC垃圾回收机制，有哪些垃圾回收算法？标记-清除算法、复制算法、标记整理算法、分代收集算法。 JVM如何判断对象是否可以回收？会使用可达性分析算法进行判断，原理是从一系列被称为GC ROOT的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT之间没有引用链，说明这个对象不可用，那么就会被GC回收。 什么是强引用、软引用、弱引用、虚引用？强引用。一般new出来的对象都是强引用。如果一个对象具有强引用，GC绝不会回收它；当内存空间不足，JVM宁愿抛出OutOfMemoryError错误。 12//强引用Object obj = new Object(); 软引用。如果一个对象只具有软引用。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。 12//软引用SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object()); 弱引用。如果一个对象具有弱引用，在GC线程扫描内存区域的过程中，不管当前内存空间足够与否，都会回收内存。 12//弱引用WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object()); 虚引用。如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收。 12//虚引用PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;()); 什么是类加载器？Java类加载器是Java运行时环境的一部分，负责动态加载Java类到JVM的内存空间中。 什么是双亲委派机制？双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。 类的生命周期？加载、验证、准备、解析、初始化、使用、卸载。 有些资料会把(验证、准备、解析)归纳为连接，于是就变成：加载、连接、初始化、使用、卸载。 设计模式相关如何实现单例模式？ 饿汉式单例模式。定义一个静态成员变量，把构造器私有化，只对外暴露一个获取实例的方法。12345678910public class SingLeton &#123; //立即加载 private static SingLeton singLeton = new SingLeton(); //私有化构造器 private SingLeton()&#123;&#125; //对外暴露获取实例的方法 public static SingLeton getSingLeton()&#123; return singLeton; &#125;&#125; 懒汉式单例模式。非线程安全。基本和上面饿汉式实现方式类似，只是在获取时再判断是否创建实例，但是会有线程安全问题。1234567891011121314public class SingLeton &#123; //立即加载 private static SingLeton singLeton; //私有化构造器 private SingLeton() &#123; &#125; //对外暴露获取实例的方法 public static SingLeton getSingLeton() &#123; if (singLeton == null) &#123; singLeton = new SingLeton(); &#125; return singLeton; &#125;&#125; 使用静态内部类实现123456789101112public class SingLeton &#123; //私有化构造器 private SingLeton() &#123;&#125; //对外暴露获取实例的方法 public static SingLeton getSingLeton() &#123; return SingLetonHolder.SINGLETON; &#125; //私有静态内部类 private static class SingLetonHolder &#123; private static final SingLeton SINGLETON = new SingLeton(); &#125;&#125; 使用枚举实现123public enum SingLeton &#123; SINGLETON;&#125; 如何实现线程安全的单例模式？饿汉式实现、枚举、静态内部类都是线程安全的实现方式。还可以使用双检锁的懒汉式方式实现： 12345678910111213141516public class SingLeton &#123; private static volatile SingLeton singLeton; //私有化构造器 private SingLeton() &#123;&#125; //对外暴露获取实例的方法 public static SingLeton getSingLeton() &#123; if (singLeton == null) &#123; synchronized (SingLeton.class) &#123; if (singLeton == null) &#123; singLeton = new SingLeton(); &#125; &#125; &#125; return singLeton; &#125;&#125; 为什么要使用工厂模式创建对象？ 解耦。把对象的创建和使用的过程分开。 可以降低代码重复。如果创建B过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。 减少了使用者因为创建逻辑导致的错误。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可。 提高了代码的可维护性。如果发生业务逻辑变化，不需要找到所有需要创建对象的地方去逐个修正，只需要在工厂里修改即可。 在java中，实现代理模式有哪几种方式？ 静态代理。 JDK动态代理。 CGlib动态代理。 JDK动态代理和CGlib动态代理的区别？ （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类。 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 因为是继承，所以该类或方法不能声明成final。 策略模式的使用场景？ 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 装饰器模式解决了什么问题？在java中有哪些应用了装饰器模式？使用场景： 扩展一个类的功能。 动态增加功能，动态撤销。 java中经典的例子就是I/O流。具体分析过程可以参考我写的这篇文章：装饰者模式与IO流的应用。 经典算法有哪些经典的排序算法？插入排序、冒泡排序、归并排序、快速排序、堆排序、桶排序、基数排序等等。 冒泡排序的时间复杂度和空间复杂度？平均的时间复杂度是O(n^2)，最好的情况是O(n)，最坏的情况是O(n^2)。空间复杂度是O(1)。 哪一种排序算法的时间复杂度比较稳定？归并排序。最好和最坏的情况下，时间复杂度都是O(n*log n)。 如何实现二分查找？二分查找的时间复杂度？(笔试常见)有两种方式，迭代法和递归法。具体实现代码，可以参考我写的这篇《手把手教你实现二分查找》。时间复杂度是O(log n)。 跳楼梯的问题。(笔试常见)这是一个经典的斐波那契数列问题。力扣题库第70题。可以看看大佬们的题解。这是我的题解，使用了Map作为缓存，减少一些不必要的递归，效率还不错。执行时间：1 ms。当然你去掉那个Map也是完全没错的，只是运行时间会久一些，可能会超出leetcode的时间限制，没法通过。我的题解链接 1234567891011121314151617181920212223242526/** * 题目描述： * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/class Solution &#123; private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public int climbStairs(int n) &#123; if (n == 1) &#123; map.put(n, 1); return 1; &#125; if (n == 2) &#123; map.put(n, 2); return 2; &#125; if (map.get(n) != null) &#123; return map.get(n); &#125; else &#123; int num = climbStairs(n - 1) + climbStairs(n - 2); map.put(n, num); return num; &#125; &#125;&#125; 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://alloceee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"总结","slug":"总结","permalink":"https://alloceee.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"责任链模式","slug":"常用的设计模式/责任链模式","date":"2020-06-06T14:08:31.000Z","updated":"2021-08-04T03:17:18.565Z","comments":true,"path":"2020/06/06/常用的设计模式/责任链模式/","link":"","permalink":"https://alloceee.github.io/2020/06/06/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"各位java技术爱好者，我们又见面了！之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~不过今日不同往日了，现在我已经搞懂了，其实并不是很难。","text":"各位java技术爱好者，我们又见面了！之前我在面试的时候遇到这个问题，当时答不上来。这件事就一直在我心里耿耿于怀。相信很多人面试完都有这种体验，哈哈~不过今日不同往日了，现在我已经搞懂了，其实并不是很难。 开始搞事情要学习一种技术，当然要搞清楚能解决什么问题，这是最关键的，否则就像买了一个开瓶器，还是用嘴咬开啤酒瓶盖一样(比喻很巧妙)。 例子首先我们用Request对象，表示一个请求。 123456789101112public class Request &#123; //请求数据 private String data; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 假设data中有很多数据，我们要过滤掉一些关键字，比如水果、蔬菜。如果不用设计模式，直接用if解决，就是这样写： 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) throws Exception &#123; //创建请求体 String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;; Request request = new Request(); request.setData(data); String requestData = request.getData(); //如果包含水果关键字 if (requestData.contains(&quot;水果&quot;)) &#123; //过滤水果关键字 requestData = filterByWord(requestData, &quot;水果&quot;); &#125; //如果包含蔬菜关键字 if (requestData.contains(&quot;蔬菜&quot;)) &#123; //过滤蔬菜关键字 requestData = filterByWord(requestData, &quot;蔬菜&quot;); &#125; request.setData(requestData); System.out.println(requestData);//肉蛋葱鸡千层饼雅俗共赏第五层的马老师 &#125; //过滤关键字的方法 private static String filterByWord(String data, String word) &#123; StringBuilder sb = new StringBuilder(data); while (true) &#123; int index = sb.indexOf(word); //如果不等于-1，搜索到关键字 if (index != -1) &#123; for (int i = 0; i &lt; word.length(); i++) &#123; //关键字有多长就删多少次，比如水果，在index位置上删两次 sb.deleteCharAt(index); &#125; &#125; else &#123; //等于-1，没有关键字，跳出循环 break; &#125; &#125; return sb.toString(); &#125;&#125; 这样的代码在项目中不要太多，遇事不决来个if，不行就再来一个。一般这种程序员就只看到了第一层。问题：1.如果这时候要增加多一些关键字呢，怎么处理？在原来的代码里继续加if的话，那这个方法就越写越长。而且破坏了开闭原则。2.如果要调换顺序呢。难道要剪切复制代码？所以一个好的程序员，实现功能只是基本要求，重要是代码要有好的维护性和扩展性。 怎么优化呢？我们可以这样想，把每个过滤关键字的方法抽成一个类，然后定义一个过滤关键字的方法，因为有很多个类似职责的类，所以定义一个接口，公共的方法可以定义在接口。第一步：定义过滤器接口 12345678910111213141516171819202122public interface Filter &#123; //接口方法 String doFilter(String data, FilterChain filterChain); //过滤关键字的方法 default String filterByWord(String data, String word) &#123; StringBuilder sb = new StringBuilder(data); while (true) &#123; int index = sb.indexOf(word); if (index != -1) &#123; for (int i = 0; i &lt; word.length(); i++) &#123; //关键字有几个字，就删几次。比如水果就在index删两次即可 sb.deleteCharAt(index); &#125; &#125; else &#123; //如果找不到关键字，就跳出循环 break; &#125; &#125; return sb.toString(); &#125;&#125; 第二步：定义水果关键字过滤器 123456789public class FruitsFilter implements Filter &#123; @Override public String doFilter(String data, FilterChain filterChain) &#123; //过滤水果关键字 data = filterByWord(data, &quot;水果&quot;); //拿到控制器，继续调用下一个过滤器 return filterChain.preHandleRequest(data); &#125;&#125; 第三部：定义蔬菜关键字过滤器 123456789public class VegetablesFilter implements Filter &#123; @Override public String doFilter(String data, FilterChain filterChain) &#123; //过滤蔬菜关键字 data = filterByWord(data, &quot;蔬菜&quot;); //拿到控制器，继续调用下一个过滤器 return filterChain.preHandleRequest(data); &#125;&#125; 第四步：定义一个过滤器的控制器 123456789101112131415161718192021222324public class FilterChain &#123; //使用List装过滤器，List是有序的 private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); //过滤器的下标，从0开始，每次调用preHandleRequest方法就+1 private int index = 0; //添加过滤器 public void addFilter(Filter filter) &#123; filters.add(filter); &#125; //调用过滤器的doFilter()方法，并把指针+1指向下一个过滤器 public String preHandleRequest(String data) &#123; //如果指针大于集合的size，则return，不再往下调用，相当于递归的终结条件 if (index == filters.size()) &#123; return data; &#125; Filter filter = filters.get(index); //下标指针+1 index++; //精髓在这个this，把自己再当做参数传进去，实现了递归 return filter.doFilter(data, this); &#125;&#125; 这样就大功告成了，最后我们创建一个Main方法试试吧~ 12345678910111213141516171819public class Main &#123; public static void main(String[] args) throws Exception &#123; //创建请求体 String data = &quot;肉蛋葱鸡水果蔬菜千层饼雅俗共赏第五层的马老师&quot;; Request request = new Request(); request.setData(data); //创建FilterChain执行链 FilterChain filterChain = new FilterChain(); //添加过滤器 filterChain.addFilter(new FruitsFilter()); filterChain.addFilter(new VegetablesFilter()); //执行预处理 String s = filterChain.preHandleRequest(request.getData()); request.setData(s); //打印结果，验证 System.out.println(request.getData());//下面是打印结果，结果正确 //肉蛋葱鸡千层饼雅俗共赏第五层的马老师 &#125;&#125; 这就是责任链模式！下面用一张图来看看调用链的执行顺序。其实没有想得那么难吧。你学会了吗？ 责任链模式的优点我们回过头去看，为什么这么绕呢，直接if不香吗？还真不香，在用if的时候，提到的两个问题，破坏开闭原则，还有调用顺序的问题，用责任链模式都得到解决了。1.如果要加一些过滤的关键字，只需要加一个过滤的类，然后再添加到过滤器的集合中，不需要对原来的代码进行侵入式的开发。符合开闭原则。2.执行顺序要变更的话，也不需要侵入式的改代码，只需要改一下添加过滤器的顺序。在Servlet中，过滤器的顺序就是按xml文件定义的顺序。在SpringMVC则是按注册的顺序。这就非常易于扩展。要多为下一个程序员着想，我为人人，人人为我，世界才会变得更美好！哈哈~~ SpringMVC的责任链模式以上就是一个简单的demo，重要的是学习这种思想。那么我们看实战中是怎么应用的，所谓知其然知其所以然，学习忌讳浅尝辄止，趁热打铁，我们看看框架中怎么应用责任链模式。 SpringMVC拦截器的使用很简单，实现HandlerInterceptor 接口，接口有三个方法需要重写。 preHandle()：在业务处理器处理请求之前被调用。预处理。 postHandle()：在业务处理器处理请求执行完成后，生成视图之前执行。后处理。 afterCompletion()：在DispatcherServlet完全处理完请求后被调用，可用于清理资源等。返回处理（已经渲染了页面）； 我们定义一个关键字过滤器WordInterceptor ： 12345678910111213141516171819//定义一个关键字拦截器public class WordInterceptor implements HandlerInterceptor &#123; //在执行controller定义的请求方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;执行WordInterceptor的preHandle()&quot;); return true; &#125; //controller定义的请求方法执行后，但还没渲染页面前，执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;执行WordInterceptor的postHandle()&quot;); &#125; //在渲染页面完毕后执行，或者preHandle()返回fasle时执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;执行WordInterceptor的afterCompletion()&quot;); &#125;&#125; 如法炮制，再定义一个登录拦截器 123456789101112131415161718public class LoginInterceptor implements HandlerInterceptor &#123; //在执行controller定义的请求方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;执行LoginInterceptor的preHandle()&quot;); return true; &#125; //controller定义的请求方法执行后，但还没渲染页面前，执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;执行LoginInterceptor的postHandle()&quot;); &#125; //在渲染页面完毕后执行，或者preHandle()返回fasle时执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;执行LoginInterceptor的afterCompletion()&quot;); &#125;&#125; 然后再注册到拦截器的集合中。 12345678910@Componentpublic class WebInterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //先注册关键字拦截器，拦截所有请求 registry.addInterceptor(new WordInterceptor()).addPathPatterns(&quot;/**&quot;); //再注册登录拦截器，拦截所有请求 registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125; 然后启动项目，发起一个请求，我们就可以在控制台看到调用的顺序了。注意观察： 123456789//按注册顺序执行preHandle()方法执行WordInterceptor的preHandle()执行LoginInterceptor的preHandle()//按注册顺序，逆序执行postHandle()方法执行LoginInterceptor的postHandle()执行WordInterceptor的postHandle()//从最后一个preHandle()执行的类，逆序执行afterCompletion()执行LoginInterceptor的afterCompletion()执行WordInterceptor的afterCompletion() 执行的流程图就是这样：原理是什么呢？我们不妨走进源码去分析。 SpringMVC拦截器源码分析还是要看DispatcherServlet的doDispatch()方法 doDispatch()调用顺序12345678910111213141516171819202122232425262728293031323334353637383940414243protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //请求对象 HttpServletRequest processedRequest = request; //定义一个调用链 HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //省略 // 获取调用链 mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //获取对应的适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); //调用拦截器的preHandle()前处理方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; //如果上面返回fasle,取反就是true，进来这里就return，结束了 return; &#125; //调用Controller的RequestMapping对应的方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); //调用拦截器的postHandle()后处理方法 mappedHandler.applyPostHandle(processedRequest, response, mv); //省略 &#125;catch (Exception ex) &#123; //如果出现异常还是会执行triggerAfterCompletion()方法 triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; //如果出现异常还是会执行triggerAfterCompletion()方法 triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; //省略 &#125; &#125; 从上面源码中明显可以知道，拦截器接口的执行顺序:applyPreHandle()→handle()→applyPostHandle()→triggerAfterCompletion()或者applyPreHandle()→triggerAfterCompletion() 关键在于HandlerExecutionChain接口其实上面这些方法除了handle()定义在适配器中，其他都是这个接口的。handle()方法我已经在上一篇《适配器模式与SpringMV》讲过了。下面我们看HandlerExecutionChain接口。 12345678910public class HandlerExecutionChain &#123; //省略 @Nullable private HandlerInterceptor[] interceptors; @Nullable//拦截器集合 private List&lt;HandlerInterceptor&gt; interceptorList; //指针,用来记录applyPreHandle()方法执行到哪一个拦截器 private int interceptorIndex = -1;&#125; 这不就跟我们的demo类似吗？定义了一个集合封装拦截器，定义一个指针遍历集合。 applyPreHandle()方法那么前置方法applyPreHandle()是怎么样执行的呢？ 1234567891011121314151617181920212223boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //获取拦截器 HandlerInterceptor[] interceptors = getInterceptors(); //判断不为空 if (!ObjectUtils.isEmpty(interceptors)) &#123; //按顺序遍历，所以拦截器接口定义的preHandle()是按顺序执行的 for (int i = 0; i &lt; interceptors.length; i++) &#123; //按顺序获取注册的拦截器 HandlerInterceptor interceptor = interceptors[i]; //执行拦截器的preHandle()方法 if (!interceptor.preHandle(request, response, this.handler)) &#123; //如果preHandle()返回false,那就调用triggerAfterCompletion()方法 triggerAfterCompletion(request, response, null); //返回false，结束调用 return false; &#125; //如果preHandle()返回true，继续执行 //把下标索引记录到成员变量的指针中，用于后面执行triggerAfterCompletion()方法 this.interceptorIndex = i; &#125; &#125; return true; &#125; applyPostHandle()方法然后下一步执行的applyPostHandle()方法，又是怎么执行的呢？ 123456789101112void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; //倒序遍历，所以postHandle()方法是从最后一个拦截器开始执行的 for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; //postHandle()能获取到ModelAndView对象，拦截器可以对mv对象进行后处理 interceptor.postHandle(request, response, this.handler, mv); &#125; &#125; &#125; triggerAfterCompletion()方法12345678910111213141516void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; //从成员变量interceptorIndex记录的指针值，开始倒序遍历 for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; try &#123; interceptor.afterCompletion(request, response, this.handler, ex); &#125; catch (Throwable ex2) &#123; logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2); &#125; &#125; &#125; &#125; 拦截器集合 interceptorList如何组装我们都看到上面三个方法都有一个公用的方法getInterceptors()。 1234567@Nullablepublic HandlerInterceptor[] getInterceptors() &#123; if (this.interceptors == null &amp;&amp; this.interceptorList != null) &#123; this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[0]); &#125; return this.interceptors;&#125; 关键是这个interceptorList是在哪里把拦截器add()进去的呢？其实很简单，经过一路顺藤摸瓜，我们看到AbstractHandlerMapping的getHandlerExecutionChain()方法： 12345678910111213141516171819202122protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123; HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler)); String lookupPath = this.urlPathHelper.getLookupPathForRequest(request); for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123; //判断是否继承拦截器父类 if (interceptor instanceof MappedInterceptor) &#123; MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor; if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123; //添加拦截器 chain.addInterceptor(mappedInterceptor.getInterceptor()); &#125; &#125; else &#123; //添加拦截器 chain.addInterceptor(interceptor); &#125; &#125; //返回调用链 return chain;&#125; 那么上面这个方法又在什么时候被调用呢？我们一直往上找调用方。首先是AbstractHandlerMapping的getHandler()方法 12345678@Override@Nullablepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //获取调用链 HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); //省略 return executionChain;&#125; 然后到了DispatcherServlet的getHandler()方法 123456789101112131415@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; if (this.handlerMappings != null) &#123; for (HandlerMapping hm : this.handlerMappings) &#123; //省略 //获取调用链 HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; //不为null则返回 return handler; &#125; &#125; &#125; return null;&#125; 最后回到了DispatcherServlet的doDispatch()方法 1234567891011121314protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 获取调用链方法！！！ mappedHandler = getHandler(processedRequest); //省略 &#125; &#125; &#125;&#125; 哈哈~~真相大白了！是在doDispatch()方法里，获取调用链getHandler()方法中组装好interceptorList拦截器集合的！ SpringMVC拦截器执行流程图解用张图总结一下，就是这样，我用不同的颜色分步骤从浅到深标记了(求点赞)： 最后说多几句除了SpringMVC外，其实还有很多框架都使用了责任链模式，比如Servlet的Filter，还有Struts2的Interceptor等等。有兴趣的同学可以去看看源码，其实都大同小异，思想懂了之后，源码看起来就没那么费劲了。 想第一时间看到我更新的文章，可以微信搜索公众号「java技术爱好者」，拒绝做一条咸鱼，我是一个在互联网荒野求生的程序员。我们下期再见！！！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！ 学之，则难者亦易矣。不学，则易者亦难矣。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式与SpringMVC","slug":"常用的设计模式/适配器模式与SpringMVC","date":"2020-05-31T05:41:20.000Z","updated":"2021-08-04T03:17:18.566Z","comments":true,"path":"2020/05/31/常用的设计模式/适配器模式与SpringMVC/","link":"","permalink":"https://alloceee.github.io/2020/05/31/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8ESpringMVC/","excerpt":"适配器模式定义适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。","text":"适配器模式定义适配器模式是将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 通俗解释用生活中的例子就是充电器的转接头或者数据线转接头，也就是两个类不兼容的情况下，通过适配器类来做到兼容。 举个例子我看了网上很多人的博客，关于适配器模式的一些例子，主要有两种，一种叫类适配器，一种叫对象适配器。写完这两个例子后，我有种恍然大悟的感觉！ 类适配器首先有一个接口是目标接口PayService，目标方法pay()。 1234public interface PayService &#123; String pay(String channel, String amount) throws Exception;&#125; 然后有一个被适配的类CheckHelper，适配方法checkedPay() 1234567891011121314151617public class CheckHelper &#123; //检查支付渠道和支付金额 public boolean checkedPay(String channel, String amount) &#123; try &#123; //字符串转成数字，如果出现转换异常返回fasle int mount = Integer.parseInt(amount); //PayEnum定义了一些支付渠道，比如支付宝、微信、银联等等 List&lt;String&gt; channelList = Arrays.stream(PayEnum.values()) .map(PayEnum::getChannel) .collect(Collectors.toList()); //包含在支付渠道中，并且金额大于0，返回true，否则返回false return channelList.contains(channel) &amp;&amp; mount &gt; 0; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 需求是要使得在接口PayService调用CheckHelper的checkedPay()方法，现在使用类适配器的方式演示： 1234567891011public class PayAdapter extends CheckHelper implements PayService &#123; @Override public String pay(String channel, String amount) throws Exception &#123; boolean checked = super.checkedPay(channel, amount); if (!checked) &#123; return &quot;支付失败，支付参数有误&quot;; &#125; return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount; &#125;&#125; 其实就是使用继承的方式来完成，适配器类继承CheckHelper类，然后使用super来调用被适配类 CheckHelper的checkedPay()方法，一目了然了。 对象适配器明显使用类适配器的方式不太灵活，因为java是单继承，所以我们可以改成成员变量的方式，也就是对象适配器。代码如下： 1234567891011121314public class PayAdapter implements PayService &#123; //使用成员变量 private CheckHelper checkHelper = new CheckHelper(); @Override public String pay(String channel, String amount) throws Exception &#123; //调用CheckHelper的checkedPay()方法 boolean checked = checkHelper.checkedPay(channel, amount); if (!checked) &#123; return &quot;支付失败，支付参数有误&quot;; &#125; return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount; &#125;&#125; 那么肯定有人会说，你这样直接new一个对象不好，可以使用SpringIOC注入，于是又可以写成这样： 12345//注册到Spring容器中@Component(&quot;checkHelper&quot;)public class CheckHelper &#123; &#125; 1234567891011121314public class PayAdapter implements PayService &#123; @Resource(name = &quot;checkHelper&quot;) private CheckHelper checkHelper; @Override public String pay(String channel, String amount) throws Exception &#123; boolean checked = checkHelper.checkedPay(channel, amount); if (!checked) &#123; return &quot;支付失败，支付参数有误&quot;; &#125; return &quot;支付成功，渠道为：&quot; + channel + &quot;,金额：&quot; + amount; &#125;&#125; 然后有人可能已经开始察觉了，这不就是平时我们使用的依赖注入吗？没错！所以我开始就说了，写完这两个例子后，我恍然大悟了。原来适配器模式我们一直都在用，只是没认出来罢了。 总结一下那么我们用适配器模式有什么优点呢？为什么要这样写： 1.解耦，降低了对象与对象之间的耦合性。 2.增加了类的复用，这点是比较重要的。 3.灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。这点我待会在下面SpringMVC的应用中详细说明。 在SpringMVC中的应用我们都知道SpringMVC定义一个映射的方式很简单，使用@RequestMapping注解，如下所示： 1234567@RestControllerpublic class PayController &#123; @RequestMapping(&quot;/pay&quot;) public String pay(String channel,String amount)throws Exception&#123; return &quot;&quot;; &#125;&#125; 实际上除了上面这种常用的方式外，还有其他的方式定义： 实现Controller接口 1234567@org.springframework.stereotype.Controller(&quot;/path&quot;)public class TestController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; return null; &#125;&#125; 实现HttpRequestHandler 接口 12345678910@Controller(&quot;/httpPath&quot;)public class HttpController implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response ) throws ServletException, IOException &#123; //业务处理，页面跳转，返回响应结果等等 &#125;&#125; 实现Servlet接口 1234567891011121314@Controller(&quot;/servletPath&quot;)public class ServletController implements Servlet &#123; //Servlet生命周期函数 //重写init()方法 //重写getServletConfig()方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //业务处理 &#125; //重写getServletInfo()方法 //重写destroy()方法&#125; 还要配置一个SimpleServletHandlerAdapter适配器的bean，因为默认只加载前面三种适配器，所以这种适配器需要自己手动添加。从这里也可以看出SpringMVC已经不推荐这种创建方式。 12345678@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Bean public SimpleServletHandlerAdapter simpleServletHandlerAdapter() &#123; return new SimpleServletHandlerAdapter(); &#125;&#125; HandlerFunction接口，关于响应式接口的开发 最后一种是使用HandlerFunction函数式接口，这是Spring5.0后引入的方式，主要用于做响应式接口的开发，这里就不举例子了。后面我会写一篇文章再详述。 问题：以上就有五种方式定义Mapping映射，那么SpringMVC是如何去适配的呢？并且具有良好的扩展性和维护性呢？ 源码分析首先我们把目光放在DispatcherServlet类的doDispatch()方法 12345678910111213141516171819202122232425262728293031323334353637protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //重点： 获取到对应的适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); //省略... //重点： 调用HandlerAdapter接口的handle()方法，得到ModelAndView结果 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); //省略... &#125; catch (Exception ex) &#123; //省略... &#125; catch (Throwable err) &#123; //省略.. &#125; &#125; &#125; 先不要慌张，其实学过策略模式你一眼就可以看出来，实际上这里就是运用了类似于策略模式的方式，根据不同的对象获取到对应的适配器，然后执行HandlerAdapter接口的handle()方法得到结果。 关键是这个getHandlerAdapter()方法，是怎么获取到对应的HandlerAdapter。 1234567891011121314protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; if (this.handlerAdapters != null) &#123; //这个handlerAdapters有全部的适配器，遍历handlerAdapters集合 for (HandlerAdapter adapter : this.handlerAdapters) &#123; //如果匹配 if (adapter.supports(handler)) &#123; //就返回这个适配器 return adapter; &#125; &#125; &#125; throw new ServletException(&quot;No adapter for handler [&quot; + handler + &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;); &#125; 那么你看到上面这个this.handlerAdapters肯定会有疑问，handlerAdapters集合里面的适配器是什么时候初始化的？哪里初始化？继续看。 在DispatcherServlet的initStrategies()方法中有一堆初始化方法。 123456789101112protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); //这个就是初始化适配器的方法，handlerAdapters就是在这里初始化的 initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); &#125; 接着我们看initHandlerAdapters()方法 123456789101112private void initHandlerAdapters(ApplicationContext context) &#123; this.handlerAdapters = null; //省略... //如果为null，刚开始当然为null，所以加载handlerAdapters集合 if (this.handlerAdapters == null) &#123; //关键又在于getDefaultStrategies方法 this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;No HandlerAdapters found in servlet &#x27;&quot; + getServletName() + &quot;&#x27;: using default&quot;); &#125; &#125; &#125; 然后我们又去getDefaultStrategies()方法中看你会发现： 123456 protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123; String key = strategyInterface.getName(); //defaultStrategies中获取值，key就是HandlerAdapter.class对象 String value = defaultStrategies.getProperty(key); //省略...&#125; 然后重点就在于这个defaultStrategies对象。我们继续看，很快看到了。 123456789101112131415//DispatcherServlet.properties文件名private static final String DEFAULT_STRATEGIES_PATH = &quot;DispatcherServlet.properties&quot;;//Properties对象，全局变量private static final Properties defaultStrategies;static &#123; try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); //加载DispatcherServlet.properties文件 defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(&quot;Could not load &#x27;&quot; + DEFAULT_STRATEGIES_PATH + &quot;&#x27;: &quot; + ex.getMessage()); &#125;&#125; 所以明显可以看到所有的适配器类都是写在DispatcherServlet.properties文件里了！默认加载这三种适配器。 123org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 得到结论：适配器实现类是从DispatcherServlet.properties文件加载到内存中的。 HandlerAdapter接口所以关键在于HandlerAdapter接口，接口信息如下： 12345678910111213public interface HandlerAdapter &#123; //子类去实现，用于判断上级接口 boolean supports(Object handler); //子类实现这个方法，返回响应的结果 @Nullable ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存 long getLastModified(HttpServletRequest request, Object handler);&#125; 学过策略模式的应该很清楚了，上面讲过有5种方式定义Mapping。 所以应该可以猜测HandlerAdapter接口有五个子类。打开类图： 果然是有五个实现的子类分别对应五种方式！ 那么我们找其中一个实现类，比如最简单的SimpleControllerHandlerAdapter，来分析一下： 123456789101112131415161718192021222324252627public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123; @Override //getHandlerAdapter()方法就会调用这个方法判断，然后返回对应的适配器实现类 //这里返回的就是SimpleControllerHandlerAdapter适配器 public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; @Override @Nullable public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //执行Controller接口的handleRequest，也就是mapping映射的方法 return ((Controller) handler).handleRequest(request, response); &#125; //判断是否使用浏览器缓存，返回-1表示不使用浏览器缓存 @Override public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; 下面画一张图来总结一下以上的分析过程： 这不就像策略模式吗…只能解释为设计模式有很多都比较类似。假设SpringMVC要增加一种定义Mapping的方式，那就很容易了，增加对应的适配器实现类，对原有的代码没有任何的侵入，这就非常符合开闭原则。接下来我们就对适配器进行扩展，自定义一个适配器。 自定义SpringMVC适配器首先要定义一个适配器MyHandlerAdapter，实现HandlerAdapter接口。 123456789101112131415161718public class MyHandlerAdapter implements HandlerAdapter &#123; @Override public boolean supports(Object handler) &#123; return handler instanceof MyController; &#125; @Override public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((MyController) handler).handleRequest(request, response); &#125; @Override public long getLastModified(HttpServletRequest request, Object handler) &#123; //不使用浏览器缓存，返回-1 return -1; &#125;&#125; 接着定义一个MyController接口。 1234567public interface MyController &#123; /** * 处理请求 */ @Nullable ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; 注册适配器到Spring容器中。 123456789@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; //注册自定义的适配器 @Bean public MyHandlerAdapter myHandlerAdapter() &#123; return new MyHandlerAdapter(); &#125;&#125; 最后创建一个MyTestController实现MyController进行测试。 123456789@Controller(&quot;/myTest&quot;)public class MyTestController implements MyController &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.getWriter().println(&quot;MyTestController Test success!!!&quot;); return null; &#125;&#125; 启动项目，然后在浏览器输入访问地址，即可看到。 当你理解透彻之后，你就可以这样自定义一个适配器，来加深一下理解，验证之前的分析的正确性。 沉下心学习，才能跑得更快！ 以上就是适配器模式的学习，更多的java技术分享，就关注java技术爱好者吧！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"记一次高级java面试","slug":"面经分享/记一次高级java面试","date":"2020-05-24T12:20:49.000Z","updated":"2021-08-04T03:17:18.655Z","comments":true,"path":"2020/05/24/面经分享/记一次高级java面试/","link":"","permalink":"https://alloceee.github.io/2020/05/24/%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%AB%98%E7%BA%A7java%E9%9D%A2%E8%AF%95/","excerpt":"记录一次高级JAVA开发面试题目面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。","text":"记录一次高级JAVA开发面试题目面试时间大概40多分钟，问了有十几个问题，回忆一下记录下来，总结经验，以供参考。 1、 static关键字的作用，平时开发用在什么地方？答：主要有三种用法。①修饰成员变量，用static修饰的成员变量就成为静态变量，静态变量只会存在一份，在类被加载时会初始化，且只会加载一次，通过类名访问。一般可以用static和final定义一些String类型，boolean类型，int类型的变量作为常量，可以减少资源的消耗。②static修饰方法，该方法就被定义为静态方法，静态方法是不能被方法重写的，通过类名调用。一般用static定义一些工具类的方法。③用static修饰代码块，该代码块就被定义为静态代码块，静态代码块在类初始化时被执行，且执行一次。一般用于初始化一些静态的成员变量的值。 2、static修饰的成员变量和非static修饰的成员变量有什么区别？分别存在什么区域？答：静态成员变量在内存中只会存在一份，是通过类名访问，存在于静态区中。非静态成员变量是随着对象的创建而存在的，可以有多份，通过创建的对象访问，存在于堆内存中。 3、说一下类初始化的顺序。答：静态成员变量、静态代码块、实例成员变量，实例代码块，构造器，实例方法。 4、常用的集合类型有哪些？答：有Map、Set、List是比较常用的。 5、List常用的实现类有哪些？ArrayList和LinkedList底层实现原理是什么？答：List常用的实现类有ArrayList和LinkedList。ArrayList底层原理是数组+动态扩容机制实现的，LinkedList底层原理是用Node结点形成的链表实现的。 6、在开发中如何选择使用ArrayList和LinkedList？答：ArrayList是数组实现，所以通过下标访问效率最快，但是缺点是如果增删比较频繁的情况下，需要经常扩容，性能不是很好。LinkedList在增删的情况下，效率较高，但是访问集合中的元素时都需要从第一个元素开始遍历，效率较低。所以如果增删的情况较多的时候，可以使用LinkedList。查询较多时使用ArrayList。 7、List集合如果要排序有哪些实现方式？①使用List接口定义的sort()方法。 1list.sort(Comparator.comparingInt(User::getAge)); ②使用Collections的sort()方法，排序的对象需要实现Comparable接口，重写compareTo()方法。 12345678//实现Comparable接口public class User implements Comparable&lt;User&gt; &#123; //重写compareTo方法 @Override public int compareTo(User user) &#123; return Integer.compare(this.getAge(), user.getAge()); &#125;&#125; 使用Collections的sort()方法 123Collections.sort(list);//如果不想实现Comparable接口，也可以使用这个方法Collections.sort(list,Comparator.comparingInt(User::getAge)); ③使用Stream流操作的sort()方法，传入一个Comparator接口。 1list.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList()); 8、ArrayList是线程安全的吗？有什么方式可以让ArrayList变成线程安全的？答：不是线程安全的。使用Collections的synchronizedList()方法包装可获得线程安全的ArrayList。 1List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 9、你是怎么在项目中使用redis的？答：这其实是考了“redis常用的应用场景”这个问题。①利用redis读写速度快的特点，可以做热点数据的储存，降低数据库查询的压力。②利用redis键值设置有效期的特性，做一些限时的业务。比如手机验证码。③利用setnx命令的特性，可以实现分布式锁。 10、使用Redis实现分布式锁的原理是什么？答： 利用setnx命令的特性。使用setnx一个lockKey字符串作为键，当前的时间+上锁时间作为value。如果返回是0，表示已经被上锁了，需要等待锁持有者释放锁；如果返回1，则表示获得了锁。客户端释放锁的话执行del命令删除lockKey对应的键值。 11、如果使用分布式锁加锁后，由于一些异常的原因没有执行解锁的操作，怎么办？答：一般解锁操作会放在finally代码块中执行。如果有极端情况下没有执行到解锁的操作，可以通过key对应的时间戳判断是否超时，然后使用GETSET命令去进行解锁，通过判断返回的时间戳是否是超时的key对应的时间戳，确认是否成功上锁。 12、如果加分布式锁的时候，业务操作时间比较长，造成长时间的阻塞，有什么解决方案？答：可以在加锁时启动一个watch dog(看门狗)线程，每隔10秒检查一下，如果客户端还持有锁则加长lockKey的生存时间。或者可以考虑用zookeeper实现的分布式锁，因为zk实现原理是基于事件监听的方式来实现。 13、MySQL性能优化的策略有哪些？①复杂的多表查询可以拆成多句简单查询。②返回尽量少的列，按需返回，严禁使用select *。③尽量使用索引列做查询条件和排序条件。④使用复合索引要遵循最左匹配原则。 14、MySQL索引创建的原则是什么？①对于查询频率高的字段，创建索引。②对排序、分组、联合查询频率高的字段创建索引。③如果多个列都需要设置索引，可以考虑创建复合索引。④尽量选择数据量较少的列作为索引。⑤一个表的索引数量不宜过多，会降低查询的效率。 15、雪花算法是什么原理？答：使用一个 64 bit 的 long 型的数字作为全局唯一 id。是由时间戳、机房id、机器id、序号组成的。结合了UUID的全局唯一的特点，又具有自增有顺序的特点。 16、为什么雪花算法生成的主键有字符串类型和long类型两种类型？答：因为后端返回给前端一个long类型时，会有可能产生丢失精度的问题，所以会有字符串的类型，弥补这个问题。 17、谈一谈MySQL锁机制。主要有以下几种锁：表锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。行锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。在MySQL中只有InnoDB存储引擎可以使用行锁。行锁又分为以下两种形式：读锁(共享锁)：当读取一条数据时，会加上读锁，其他事务如果要读取是可以的，如果要修改则要等事务释放才可以。写锁(排他锁)：这个比较简单，当有一个事务要修改数据时，就会给这些行加上写锁。在加锁期间，不允许其他事务加上任何的锁，只有当这个事务释放了，才可以加锁操作。 在这次面试中，其实也不是特别难，大部分都回答得不错，但是有两个问题不是很好。雪花算法为什么主键生成有两种类型这个问题没有答出来，还有分布式锁长时间阻塞的解决方案没有详细展开讲。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://alloceee.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"原型模式在实战中的应用","slug":"常用的设计模式/原型模式在实战中的应用","date":"2020-05-17T05:41:09.000Z","updated":"2021-08-04T03:17:18.550Z","comments":true,"path":"2020/05/17/常用的设计模式/原型模式在实战中的应用/","link":"","permalink":"https://alloceee.github.io/2020/05/17/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"原型模式定义原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。","text":"原型模式定义原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 通俗解释比如有些人喜欢写文章，但是如果从头到尾原创的话太麻烦了，那么他可以上网去搜索，找一篇写得不错的文章，然后复制下来，做一些修改，最后发布就是自己的文章了。这其实就使用了原型模式的设计模式，创建一个对象过于麻烦的时候，我们只需要创建一次，后面再创建的话只需要对原对象进行克隆即可。 不使用原型模式的问题假设我们有一个用户User的类，类里面有很多字段，当我们创建对象时，就会像这样子： 123456789101112131415161718192021222324252627282930public class Main &#123; public static void main(String[] args) throws Exception &#123; //第一个用户 User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(18); user.setJob(&quot;程序员&quot;); user.setSchool(&quot;家里蹲大学&quot;); user.setNation(&quot;汉族&quot;); //0-男 1-女 user.setGender((byte)0); user.setPhone(&quot;110&quot;); user.setPoliticalFeatures(&quot;群众&quot;); user.setEducation(&quot;大学本科&quot;); //第二个用户，跟第一个用户只有id，name，phone这三个字段不同 User user1 = new User(); user1.setId(2); user1.setName(&quot;李四&quot;); user1.setAge(18); user1.setJob(&quot;程序员&quot;); user1.setSchool(&quot;家里蹲大学&quot;); user1.setNation(&quot;汉族&quot;); //0-男 1-女 user1.setGender((byte)0); user1.setPhone(&quot;111&quot;); user1.setPoliticalFeatures(&quot;群众&quot;); user1.setEducation(&quot;大学本科&quot;); &#125;&#125; 不难看出上面的代码有以下问题： 1.user对象有10个字段，明显在创建第二个user对象的时候有很多重复的设值的操作。在实际项目中，肯定还不止设置10个字段，那么就会显得很难看。 2.创建对象如果消耗资源很多的话，这样多次去创建设值肯定会造成资源浪费。 对于以上的问题，我们可以使用原型模式进行优化。 使用Cloneable接口优化java提供了一个Cloneable接口，可以实现克隆对象的用途，怎么实现，请看以下代码： 1234567891011//实现Cloneable接口public class User implements Cloneable &#123; //省略了字段 //省略了字段的Get、Set方法 //重写clone()方法 @Override public User clone() throws CloneNotSupportedException &#123; return (User) super.clone(); &#125;&#125; 然后就可以把main()方法的代码改成以下这样： 1234567891011121314151617181920212223public static void main(String[] args) throws Exception &#123; //第一个用户 User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(18); user.setJob(&quot;程序员&quot;); user.setSchool(&quot;家里蹲大学&quot;); user.setNation(&quot;汉族&quot;); //0-男 1-女 user.setGender((byte)0); user.setPhone(&quot;110&quot;); user.setPoliticalFeatures(&quot;群众&quot;); user.setEducation(&quot;大学本科&quot;); //调用克隆方法，复制第一个user对象 User user1 = user.clone(); user1.setId(2); user1.setName(&quot;李四&quot;); user1.setPhone(&quot;111&quot;); System.out.println(user1); //控制台打印结果 //User&#123;id=2, name=&#x27;李四&#x27;, phone=&#x27;111&#x27;, nation=&#x27;汉族&#x27;...&#125;&#125; 你是不是有疑问，这两个user对象内存地址是否一致呢？我们可以打印出来看看： 12com.yehongzhi.httpclient.model.User@4c873330com.yehongzhi.httpclient.model.User@119d7047 内存地址是不一样的，所以我们可以得出一个结论：克隆出来的对象是一个新的对象。 问题：克隆方法的底层是不是调用了构造器创建了一个对象的呢？ 我们可以在构造器上面加一些打印语句来验证一下： 123456789101112131415public class User implements Cloneable &#123; //其他非重点代码省略 //构造器，如果以下语句打印了两次，则证明clone调用了构造器创建对象 public User() &#123; System.out.println(&quot;调用了无参构造器&quot;); &#125; //克隆方法 @Override public User clone() throws CloneNotSupportedException &#123; System.out.println(&quot;调用了clone()方法&quot;); return (User) super.clone(); &#125;&#125; 我们运行main()方法后，可以看到控制台打印信息如下： 12// 调用了无参构造器// 调用了clone()方法 只调用了一次构造器，我们可以得出结论： clone()方法不是调用了构造器创建对象的。 如果你刨根究底，究竟clone()方法是怎么创建对象的，其实也很简单，打开源码： 12345678910public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; //最终会调用Object的克隆方法，是一个native修饰的方法 protected native Object clone() throws CloneNotSupportedException;&#125; native修饰的方法是什么意思呢？意思就是这个方法的实现不是用java，而是C/C++实现。这个native关键字我们可以单独写一篇文章细讲，这里就不深入展开。底层的实现逻辑就是拷贝一份数据，开辟一块新的内存。所以拷贝出来的对象，打印的内存地址和原来的对象不一样。 使用Cloneable接口的问题使用Cloneable接口是不是就完美的呢，其实并不是，因为如果一个对象的字段也是一个对象，是一个引用数据类型时，那就会有问题。请看以下代码： 我们增加一个对象IdCard类 12345678910public class IdCard &#123; private String cardNo; private Integer validityPeriod; private Date createDate; //省略getter、setter方法&#125; 12345678public class User implements Cloneable &#123; //其他字段省略 //身份证对象 private IdCard idCard; //省略getter、setter方法&#125; 然后我们在main()方法赋值： 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) throws Exception &#123; //第一个用户 User user = new User(); //省略其他字段的赋值 //创建一个IdCard对象 IdCard idCard = new IdCard(); //身份证号码 idCard.setCardNo(&quot;111111&quot;); //创建日期 idCard.setCreateDate(new Date()); //身份证有效期 idCard.setValidityPeriod(10); //user对象设置身份证对象 user.setIdCard(idCard); //user克隆，得到user1 User user1 = user.clone(); //打印user、user1的IdCard对象的内存地址，内存地址一样！ System.out.println(user.getIdCard());//IdCard@4c873330 System.out.println(user1.getIdCard());//IdCard@4c873330 //当改变克隆体user1的IdCard里面的字段值 user1.getIdCard().setCardNo(&quot;222222&quot;); //源对象user的IdCard里面的字段值也跟着一起改变了 System.out.println(user.getIdCard().getCardNo());//222222 &#125;&#125; 明显这样的克隆是有巨大的问题的，因为项目中不可能只有基本数据类型。那怎么解决呢？ 12345678//IdCard对象也要实现Cloneable接口public class IdCard implements Cloneable&#123; //也需要重写clone()方法 @Override protected IdCard clone() throws CloneNotSupportedException &#123; return (IdCard)super.clone(); &#125;&#125; 123456789101112public class User implements Cloneable &#123; @Override public User clone() throws CloneNotSupportedException &#123; User user = (User) super.clone(); //获取idCard源对象 IdCard idCard = user.getIdCard(); //克隆一个idCard对象。然后set值到user对象中 user.setIdCard(idCard.clone()); return user; &#125;&#125; 最后我们再调用main()方法： 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws Exception &#123; //第一个用户 User user = new User(); //创建一个IdCard对象 IdCard idCard = new IdCard(); //身份证号码 idCard.setCardNo(&quot;111111&quot;); //user对象设置身份证对象 user.setIdCard(idCard); //克隆user对象，得到user1对象 User user1 = user.clone(); //打印user、user1的IdCard对象的内存地址，内存地址不一样了！ System.out.println(user.getIdCard());//IdCard@4c873330 System.out.println(user1.getIdCard());//IdCard@119d7047 //当改变克隆体user1的IdCard里面的字段值 user1.getIdCard().setCardNo(&quot;222222&quot;); //源对象user的IdCard里面的字段还是原来的值 System.out.println(user.getIdCard().getCardNo());//111111 &#125;&#125; 使用序列化实现深克隆上面使用Cloneable接口的方式，被称为浅克隆，如果你想要克隆的源对象里面又有对象时，里面的对象也要实现Cloneable接口，然后修改源对象的clone()方法，这样就非常麻烦，而且当扩展时会破坏开闭原则。 解决方法，我们可以采用序列化对象的方式，实现深克隆呢？请看以下代码： User对象实现Serializable接口: 123public class User implements Serializable &#123; private static final long serialVersionUID = 8656071024384993135L;&#125; IdCard对象实现Serializable接口： 123public class IdCard implements Serializable &#123; private static final long serialVersionUID = -422430076410272813L;&#125; 创建一个工具类CloneUtil实现深克隆： 123456789101112131415161718192021222324252627public class CloneUtil &#123; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T depthClone(T t, Class&lt;T&gt; clazz) throws Exception &#123; ByteArrayOutputStream baos = null; ObjectOutputStream ous = null; ByteArrayInputStream bais = null; ObjectInputStream ois = null; try &#123; //将源对象序列化，写入流中，写入流的对象是一个拷贝的对象，原对象还在JVM中 baos = new ByteArrayOutputStream(); ous = new ObjectOutputStream(baos); ous.writeObject(t); //把流中的对象再读取到内存中，就获得了克隆后的对象 bais = new ByteArrayInputStream(baos.toByteArray()); ois = new ObjectInputStream(bais); return (T) ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;深克隆出现异常&quot;); &#125; finally &#123; if (ous != null) &#123;ous.close();&#125; if (baos != null) &#123;baos.close();&#125; if (bais != null) &#123;bais.close();&#125; if (ois != null) &#123;ois.close();&#125; &#125; &#125;&#125; 验证是否深克隆，在main()方法中打印内存地址查看即可： 12345678910111213public class Main &#123; public static void main(String[] args) throws Exception &#123; User user = new User(); user.setIdCard(new IdCard()); User user1 = CloneUtil.depthClone(user, User.class); //内存地址都不相同，达到了深克隆的效果 System.out.println(user);//User@3d075dc0 System.out.println(user1);//User@2ef1e4fa System.out.println(user.getIdCard());//IdCard@214c265e System.out.println(user1.getIdCard());//IdCard@306a30c7 &#125;&#125; 用序列化实现深克隆的优点就是，对源代码侵入性很低，只需要实现Serializable接口，不需要一层一层去实现Cloneable接口，还有重写clone()方法。 问题：如果这个实体类是在jar包中的呢，我们没法去修改实体类的代码，那怎么实现克隆呢？ 使用反射实现克隆利用反射，实际上我们可以拿到源对象的任何值，所以就可以实现克隆，请看以下代码： 我们创建一个copyProperties()方法，具体实现看以下代码： 1234567891011121314151617181920212223242526272829303132333435public class CloneUtil &#123; public static void copyProperties(Object source, Object target) throws Exception &#123; //获取源对象的属性描述器 PropertyDescriptor[] sourceDescriptors = Introspector .getBeanInfo(source.getClass()) .getPropertyDescriptors(); //获取目标对象的字段名称集合 List&lt;String&gt; targetFieldNames = Arrays .stream(target.getClass().getDeclaredFields()) .map(Field::getName) .collect(Collectors.toList()); for (PropertyDescriptor sourceProperty : sourceDescriptors) &#123; //获取源对象的属性名称 String name = sourceProperty.getName(); //源对象的getter方法 Method readMethod = sourceProperty.getReadMethod(); if (!readMethod.isAccessible()) &#123; //设置方法的可访问权限 readMethod.setAccessible(true); &#125; //调用源对象的getter方法，获取到里面的每一个值 Object value = readMethod.invoke(source); //如果源对象的属性名称包含在目标对象的字段名称集合中 if (targetFieldNames.contains(name)) &#123; //则通过源对象的属性名称获取目标对象属性的属性描述器 PropertyDescriptor propertyDescriptor = new PropertyDescriptor(name, target.getClass()); //获取目标对象的setter方法 Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.setAccessible(true); //执行setter方法，参数是从源对象getter方法获取到的值 writeMethod.invoke(target, value); &#125; &#125; &#125;&#125; 测试： 123456789101112public static void main(String[] args) throws Exception &#123; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setIdCard(new IdCard()); User user1 = new User(); CloneUtil.copyProperties(user, user1); System.out.println(user.getName());//张三 System.out.println(user1.getName());//张三 System.out.println(user.getIdCard());//IdCard@b81eda8 System.out.println(user1.getIdCard());//IdCard@b81eda8 &#125; 这样实现的不是深克隆的效果，所以IdCard对象的内存地址还是一样的。为了避免这样的结果，我们可以在使用时注意一下： 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); IdCard idCard = new IdCard(); user.setIdCard(idCard); User user1 = new User(); //创建一个新的IdCard对象 IdCard idCard1 = new IdCard(); CloneUtil.copyProperties(user, user1); //复制idCard的值到idCard1里 CloneUtil.copyProperties(idCard,idCard1); //再设置idCard1到user1中 user1.setIdCard(idCard1); System.out.println(user.getName());//张三 System.out.println(user1.getName());//张三 System.out.println(user.getIdCard());//IdCard@68de145 //内存地址不同 System.out.println(user1.getIdCard());//IdCard@27fa135a &#125; 这样就避免产生内存地址一样的情况了。 Spring的copyProperties()实际上在Spring框架中，已经提供了copyProperties()方法： 123456789public static void main(String[] args) throws Exception &#123; User user = new User(); user.setName(&quot;张三&quot;); User user1 = new User(); //Spring的copyProperties()方法 BeanUtils.copyProperties(user,user1); System.out.println(user.getName());//张三 System.out.println(user1.getName());//张三 &#125; 一般在实际项目中，我们采用copyProperties()方法实现原型模式会更好，因为这样不会破坏开闭原则，即使是jar包中定义的实体类，也可以使用。缺点就是如果对象层级比较多的话，会比较麻烦。 总结实现原型模式的三种方式：实现Cloneable接口、序列化对象、反射机制。 原型模式的优点： 提高了创建对象的性能，避免了调用构造器创建对象。 对于创建一个对象需要很多资源的情况，可以减少资源的浪费。 原型模式的缺点： 如果使用Cloneable接口的方式，需要实现Cloneable接口，对代码有一定的侵入性。 如果使用序列化方式，则需要实现Serializable接口，对代码也有一定的侵入性。 如果使用反射机制，层级较多时会比较难维护。 以上就是原型模式的学习，更多的java技术分享，就关注java技术爱好者吧！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式与IO流","slug":"常用的设计模式/装饰者模式与IO流","date":"2020-05-04T14:10:01.000Z","updated":"2021-08-04T03:17:18.560Z","comments":true,"path":"2020/05/04/常用的设计模式/装饰者模式与IO流/","link":"","permalink":"https://alloceee.github.io/2020/05/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8EIO%E6%B5%81/","excerpt":"装饰者模式定义装饰者模式是一种对象结构型模式。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成子类更为灵活。","text":"装饰者模式定义装饰者模式是一种对象结构型模式。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成子类更为灵活。 通俗解释上面的定义在网上是随处可见的描述，怎么解释呢。比如：我前几天和女朋友去买戒指，珠宝店的销售给我推荐了一种自由搭配的原创戒指。他跟我介绍戒指的元素需要选择材质(黄金，铂金，彩金)、表面工艺(拉丝，磨砂，光滑，铸造)、镶钻(内嵌，外嵌)、指环大小等等，然后组成一个戒指。这种就是装饰者模式的应用，原型是一个戒指，不断地给对象添加额外的职责，然后得到最终想要的产品。这样就可以通过不同的搭配产生很多不同类型的戒指。 后面那句装饰者模式比生成子类更为灵活怎么理解。如果用子类去描述的话，要把每一种搭配的结果都变成一个子类，也就是要穷举，就会产生很多子类，也就是造成“类爆炸”。所以就会说装饰者模式更加灵活。 来个例子现在有一个需求，要求做一个加密的工具类，对传入的字符串加密。加密的算法有很多，有MD5、AES、DES等等，一般加密都不是单独使用一种加密算法，而是多种混合一起使用，这样可以提高安全性。 现在有三种算法：MD5、AES、DES。做一个工具类，给系统提供加密的服务，要求可以自由搭配使用。 使用继承的方式实现我们就创建一个抽象类EncryptionBase，每一种组合方式就创建一个子类继承EncryptionBase，现在有三种加密方式，很容易我们可以穷举完，总共有6种组合。请看以下代码： 首先创建一个抽象类EncryptionBase： 123public abstract class EncryptionBase &#123; public abstract String encrypt(String string,String password);&#125; 接着创建子类继承抽象类，并且实现其方法。以其中一个为例，其他实现类都类似： 123456789101112public class AESandDESandMD5Encryption extends EncryptionBase &#123; @Override public String encrypt(String string, String password) &#123; //网上可以找具体加密的代码，我这里篇幅受限就不展示了 //AES加密 byte[] encryptByAES = AESUtil.encrypt(string, password); //DES加密 byte[] encryptByDES = DESUtil.encrypt(encryptByAES, password); //MD5加密 return MD5Util.encryptByMD5(new String(encryptByDES) + password); &#125;&#125; 我们就可以实现以下效果，有6个实现类分别实现了3种加密算法的不同顺序。 123456789101112131415161718public static void main(String[] args) &#123; String string = &quot;需要加密的字符串&quot;; //秘钥 String password = &quot;12345678&quot;; //第一种加密顺序：AES-&gt;DES-&gt;MD5 EncryptionBase AESandDESandMD5 = new AESandDESandMD5Encryption(); //第二种加密顺序：AES-&gt;MD5-&gt;DES EncryptionBase AESandMD5andDES = new AESandMD5andDESEncryption(); //第三种加密顺序：DES-&gt;AES-&gt;MD5 EncryptionBase DESandAESandMD5 = new DESandAESandMD5Encryption(); //第四种加密顺序：DES-&gt;MD5-&gt;AES EncryptionBase DESandMD5andAES = new DESandMD5andAESEncryption(); //第五种加密顺序：MD5-&gt;DES-&gt;AES EncryptionBase MD5andDESandAES = new MD5andDESandAESEncryption(); //第六种加密顺序：MD5-&gt;AES-&gt;DES EncryptionBase MD5andAESandDES = new MD5andAESandDESEncryption(); &#125; 以上就是使用继承的方式来完成这个需求。看起来没什么问题，但是仔细思考你会发现几个问题。 会创建很多子类。为什么3种算法是6个类呢？这是根据数学的排列组合3*2*1=6，假设再多两种算法呢？那就是5*4*3*2*1=120，那就是120个类了！这就是“类爆炸”。 不符合开闭原则。假设增加了新的算法，那就要修改原来的类，不利于代码的维护。 假如其中一种加密算法要用两次，比如双重MD5加密，那也是很难扩展的。 如果你不会装饰者模式，那估计要加班加点去写代码，创建很多类。如果你会装饰者模式，那问题就很简单了，那怎么做呢？请继续看下去。 使用装饰者模式实现首先创建三种算法的基础类，继承EncryptionBase，实现三种加密算法。 MD5加密 1234567public class MD5Encryption extends EncryptionBase &#123; @Override public String encrypt(String string, String password) &#123; System.out.println(&quot;使用MD5加密，得到基础密文&quot;); return MD5Util.encryptByMD5(string + password); &#125;&#125; AES加密 1234567public class AESEncryption extends EncryptionBase &#123; @Override public String encrypt(String string, String password) &#123; System.out.println(&quot;使用AES加密，得到基础密文&quot;); return new String(AESUtil.encrypt(string, password)); &#125;&#125; DES加密 1234567public class DESEncryption extends EncryptionBase &#123; @Override public String encrypt(String string, String password) &#123; System.out.println(&quot;使用DES加密，得到基础密文&quot;); return new String(DESUtil.encrypt(string.getBytes(), password)); &#125;&#125; 接着创建一个装饰抽象类EncryptionDecorator，需要继承EncryptionBase 1234567891011121314public abstract class EncryptionDecorator extends EncryptionBase &#123; //定义一个父类的成员变量，用来存储其他装饰类，或者基础加密类 private EncryptionBase encryption; public EncryptionDecorator(EncryptionBase encryption) &#123; this.encryption = encryption; &#125; @Override public String encrypt(String string, String password) throws Exception&#123; return encryption.encrypt(string, password); &#125;&#125; 然后实现三种加密的装饰者实现类，需要继承抽象装饰者类EncryptionDecorator。 MD5加密装饰者实现类MD5EncryptionDecorator 1234567891011121314151617public class MD5EncryptionDecorator extends EncryptionDecorator &#123; public MD5EncryptionDecorator(EncryptionBase encryption) &#123; //有参构造器获取到参数，调用父类的有参构造器， //当下面encrypt()方法里调用父类的加密算法就会调用传入的算法实现类的加密算法 super(encryption); &#125; @Override public String encrypt(String string, String password) throws Exception&#123; //首先调用父类的加密方法，得到父类的算法加密后的结果 String encrypt = super.encrypt(string, password); System.out.println(&quot;使用MD5加密&quot;); //得到的密文，再用MD5算法加密，返回 return MD5Util.encryptByMD5(encrypt + password); &#125;&#125; AES加密装饰者实现类AESEncryptionDecorator 123456789101112131415public class AESEncryptionDecorator extends EncryptionDecorator &#123; public AESEncryptionDecorator(EncryptionBase encryption) &#123; super(encryption); &#125; @Override public String encrypt(String string, String password) throws Exception&#123; //首先调用父类的加密方法，得到父类的算法加密后的结果 String encrypt = super.encrypt(string, password); System.out.println(&quot;使用AES加密&quot;); //得到的密文，再用AES算法加密，返回 return new String(AESUtil.encrypt(encrypt, password),&quot;UTF-8&quot;); &#125;&#125; DES加密装饰者实现类DESEncryptionDecorator 1234567891011121314public class DESEncryptionDecorator extends EncryptionDecorator &#123; public DESEncryptionDecorator(EncryptionBase encryption) &#123; super(encryption); &#125; @Override public String encrypt(String string, String password) throws Exception&#123; //首先调用父类的加密方法，得到父类的算法加密后的结果 String encrypt = super.encrypt(string, password); System.out.println(&quot;使用DES加密&quot;); //得到的密文，再用DES算法加密，返回 return new String(DESUtil.encrypt(encrypt.getBytes(), password),&quot;UTF-8&quot;); &#125;&#125; 大功告成！我们用main()方法测试一下： 123456789public class Main &#123; public static void main(String[] args) throws Exception&#123; String string = &quot;需要加密的字符串&quot;; String password = &quot;12345678&quot;; //第一种加密顺序：AES-&gt;DES-&gt;MD5 EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption())); encryptionBase.encrypt(string, password); &#125;&#125; 控制台打印结果： 12345/**使用AES加密，得到基础密文使用DES加密使用MD5加密*/ 我们可以看到结果是很完美地实现了，你可以任意搭配加密算法，即使加多N种算法，我们也不会呈指数增加类的数量，只需要增加M*N个类即可，M是基础构件数量，N是具体装饰类数量。 原理是什么呢？我们不能说只学到形式，而不明白原理。接下来看类图。 在IDEA可以选中类名，然后右键，选中“Diagrams”，再选中“show Diagrams…”，就可以打开类图。 123//MD5(DES(AES))，最顶层的父类是AES，所以先执行，第二层是DES，第二执行，最外层是MD5第三执行EncryptionBase encryptionBase = new MD5EncryptionDecorator(new DESEncryptionDecorator(new AESEncryption()));encryptionBase.encrypt(string, password); 以上面这句代码为例，那么调用顺序就是：AES-&gt;DES-&gt;MD5 这就是装饰者模式的原理，其实很简单的，很容易就可以看清楚。 装饰者模式与I/O流看了上面的代码，很容易我们能联想到IO流也有类似的创建方式，比如我们要用文件缓冲输入流，那就要这样创建： 12InputStream inputStream = new BufferedInputStream(new FileInputStream(new File(&quot;/D:abc.text&quot;))); 可以看出IO流使用了装饰者模式。 如果我们打开源码，查看BufferedInputStream，我们可以看到： 123456789101112public class BufferedInputStream extends FilterInputStream &#123; //有参构造器 public BufferedInputStream(InputStream in, int size) &#123; //调用父类构造器，这是关键 //通过上面我们学过的例子，可以知道BufferedInputStream是装饰实现类 super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size]; &#125;&#125; 关键在FilterInputStream这个类，这是装饰者模式的基类。查看源码： 1234567891011121314public class FilterInputStream extends InputStream &#123; /** * The input stream to be filtered. */ protected volatile InputStream in; protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; public int read() throws IOException &#123; return in.read(); &#125;&#125; FilterInputStream类似于加密算法例子的EncryptionDecorator类。我们可以通过加密算法的例子和这个作对比，就可以很容易地看出他们的关系。类图如下： FileInputStream就是基础构件类，可以通过FilterInputStream的子类去做扩展，增加额外的功能，比如可以使用BufferedInputStream增加缓冲的作用。 接着我们真正理解了IO流的装饰者模式的应用后，我们可以写一个扩展类，实现一个功能：读取磁盘的文件，把所有字母变成大写的字母。代码如下： 123456789101112131415161718public class CapitalizaInputStream extends FilterInputStream &#123; public CapitalizaInputStream(InputStream in) &#123; super(in); &#125; @Override public int read(byte[] b, int off, int len) throws IOException &#123; int result = super.read(b, off, len); for (int i = off; i &lt; off + result; i++)&#123; //如果是小写字母，转成大写，其他不是小写字母的不变 if(Character.isLetter((char)b[i]))&#123; b[i] = (byte) Character.toUpperCase((char) b[i]); &#125; &#125; return result; &#125;&#125; abc.txt文件内容： 1abcdefghijklmnopqrstuvwxyz Main方法测试代码： 12345678910public static void main(String[] args) throws Exception &#123; InputStream inputStream = new CapitalizaInputStream(new FileInputStream(new File(&quot;D://abc.txt&quot;))); byte[] bytes = new byte[1024 * 2]; int c; while ((c = inputStream.read(bytes, 0, bytes.length)) != -1) &#123; System.out.println(new String(bytes, 0, c)); &#125; inputStream.close(); &#125; 控制台打印结果： 1ABCDEFGHIJKLMNOPQRSTUVWXYZ 以上就是IO流关于装饰者模式的扩展，能够加深我们对装饰者模式的理解。很多博客写不清楚，讲得很复杂，或者讲得很简单，很大原因是我们只看，而没有动手去做，动手去自己写，自己琢磨，就很容易能理解。这是学习方法，不是关注了公众号，看几篇文章就能轻松学会的，学习总是要自己动手才会理解深刻。看我的文章可以提供一些思路，更容易去上手。 总结装饰者模式的优点： 可以动态地扩展类的功能，不会相互耦合。 符合开闭原则，利于代码维护。 比继承扩展的方式要更加灵活。 缺点：多层装饰，代码结构变得复杂。 更多的java技术分享，就关注java技术爱好者吧！ 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式以及实际项目应用","slug":"常用的设计模式/观察者模式以及实际项目应用","date":"2020-05-02T12:44:32.000Z","updated":"2021-08-04T03:17:18.563Z","comments":true,"path":"2020/05/02/常用的设计模式/观察者模式以及实际项目应用/","link":"","permalink":"https://alloceee.github.io/2020/05/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8/","excerpt":"","text":"观察者模式定义观察者模式（Observer），又叫发布-订阅模式（Publish/Subscribe），定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。 通俗解释比如我们在宿舍打斗地主，我们要找个人来“放风”，这个人在门口观察，如果有宿管过了检查，那么就通知宿舍其他的小伙伴停止斗地主回床上睡觉。这种模式就被称为观察者模式。 从这个例子看，“宿管是否过来宿舍”是订阅的主题，观察者是放风的人，订阅者是打斗地主的小伙伴，被观察者就是宿管。 不使用观察者模式的问题假设我们基于之前在策略模式讲的电子支付的例子，支付完成后要发送消息，发送的消息有：短信，公众号消息，APP站内消息，邮箱。如果不使用观察者模式，怎么做呢？看代码： 1234567891011121314151617@Override public String pay(String channel, String amount) throws Exception &#123; PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel); if(payStrategy == null)&#123; return &quot;输入渠道码有误&quot;; &#125; String msg = payStrategy.pay(channel, amount); //发送短信 System.out.println(&quot;发送短信：&quot;+msg); //发送微信公众号消息 System.out.println(&quot;发送微信公众号消息：&quot;+msg); //发送邮件 System.out.println(&quot;发送邮件：&quot;+msg); //发送APP系统信息 System.out.println(&quot;发送APP系统信息：&quot;+msg); return msg; &#125; 启动项目是没有问题的，我们调用接口后可以看到控制台打印以下信息： 123456/**发送短信：使用 支付宝支付 ,消费了 100 元发送微信公众号消息：使用 支付宝支付 ,消费了 100 元发送邮件：使用 支付宝支付 ,消费了 100 元发送APP系统信息：使用 支付宝支付 ,消费了 100 元*/ 但是我们很明显可以看出有以下的问题： 每次支付如果需要新增一种消息通知方式，则要修改原来的类，不利于维护。 违反了开闭原则，对拓展开放，对修改关闭。 违反了单一职责原则，支付不应该糅杂消息通知的功能。 上面就从代码演示了为什么要使用观察者模式，很多文章说不清楚，单纯地抛出一个概念和一些简单的例子，实际项目中肯定是没有那么简单。 使用观察者模式优化这里的话，我不使用java自带的Observer和Observable来做，因为实际项目中一般都会使用Spring框架，Spring框架有一个事件机制，也是使用观察者模式的这种设计模式，而且在实际项目中我们往往会采用这种成熟度更高的框架，就像代理模式我们也很少会直接使用原生的JDK动态代理，而是采用SpringAOP来实现。 创建支付的事件123456789101112131415161718192021222324252627//继承ApplicationEvent类public class PayEvent extends ApplicationEvent &#123; //消息体 private Map&lt;String,String&gt; map; //订阅主题 private String topic; public PayEvent(Object source, Map&lt;String, String&gt; map, String topic) &#123; //调用父类的构造器 super(source); this.map = map; this.topic = topic; &#125; public Map&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public String getTopic() &#123; return topic; &#125; public void setTopic(String topic) &#123; this.topic = topic; &#125;&#125; 创建事件监听类1234567891011121314//短信监听，实现ApplicationListener接口，重写onApplicationEvent()方法@Componentpublic class SmsListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; //订阅主题 String topic = payEvent.getTopic(); //消息体 Map&lt;String, String&gt; map = payEvent.getMap(); //发送短信 System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送短信:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 1234567891011//公众号监听@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; String topic = payEvent.getTopic(); Map&lt;String, String&gt; map = payEvent.getMap(); System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 1234567891011//邮箱监听@Componentpublic class MailListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; String topic = payEvent.getTopic(); Map&lt;String, String&gt; map = payEvent.getMap(); System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送邮件:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 1234567891011//App站内消息监听@Componentpublic class AppListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; String topic = payEvent.getTopic(); Map&lt;String, String&gt; map = payEvent.getMap(); System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送App站内消息:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 重构PayServiceImpl类123456789101112131415@Override public String pay(String channel, String amount) throws Exception &#123; PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel); if(payStrategy == null)&#123; return &quot;输入渠道码有误&quot;; &#125; String msg = payStrategy.pay(channel, amount); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,msg); //创建一个支付事件 PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;); //获取Spring的ApplicationContext容器，发布事件，监听类监听到事件后就会发送消息 SpringContextUtil.getApplicationContext().publishEvent(payEvent); return msg; &#125; 然后我们启动项目，调用接口，控制台就可以打印的信息： 123456/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送公众号消息:使用 支付宝支付 ,消费了 100 元*/ 异步监听事件，实现解耦改造之后是否就一劳永逸了呢，实际上并非如此。因为上面的消息发送的监听类是同步的，也就是如果发送消息出现异常，那就会导致支付的接口无法正常返回。请看以下代码： 123456789101112@Componentpublic class WechatListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; String topic = payEvent.getTopic(); Map&lt;String, String&gt; map = payEvent.getMap(); //在发送微信公众号消息的逻辑中制造异常 System.out.println(10 / 0); System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 1234567891011121314151617@Override public String pay(String channel, String amount) throws Exception &#123; PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel); if(payStrategy == null)&#123; return &quot;输入渠道码有误&quot;; &#125; String msg = payStrategy.pay(channel, amount); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;msg&quot;,msg); //创建一个支付事件 PayEvent payEvent = new PayEvent(this, map, &quot;支付&quot;); //获取Spring的ApplicationContext容器，发布事件 SpringContextUtil.getApplicationContext().publishEvent(payEvent); //发送消息后的逻辑，打印日志到控制台 System.out.println(&quot;发送消息后的逻辑代码...&quot;); return msg; &#125; 我们在发送公众号消息的逻辑里制造了一个异常，然后在pay()方法中加了一个打印日志在发布支付的事件后面，接下来调用接口，结果是： 1234567/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/ 发送消息后的逻辑是没有被执行。这样显然是不符合业务要求的，因为在很多时候，发送消息失败是不能影响支付流程的，应该异步进行。怎么异步进行发送消息呢？ 很简单，只需要两个步骤。 第一步:在监听类或者方法上添加@Async注解，例如： 123456789101112@Component@Async//加上异步执行的注解public class WechatListener implements ApplicationListener&lt;PayEvent&gt; &#123; @Override public void onApplicationEvent(PayEvent payEvent) &#123; String topic = payEvent.getTopic(); Map&lt;String, String&gt; map = payEvent.getMap(); System.out.println(10 / 0); System.out.println(&quot;订阅主题是:&quot; + topic + &quot;;发送公众号消息:&quot; + map.get(&quot;msg&quot;)); &#125;&#125; 第二步：在SpringBoot启动类上添加@EnableAsync注解，例如： 1234567@SpringBootApplication@EnableAsync//添加启用异步的注解public class StrategyApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StrategyApplication.class, args); &#125;&#125; 然后就可以实现异步监听了，调用接口，我们可以看到控制台打印的日志如下： 123456789/**订阅主题是:支付;发送App站内消息:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送邮件:使用 支付宝支付 ,消费了 100 元订阅主题是:支付;发送短信:使用 支付宝支付 ,消费了 100 元发送消息后的逻辑代码...使用 支付宝支付 ,消费了 100 元java.lang.ArithmeticException: / by zero......*/ 明显可以看到支付后的逻辑也能正常执行下去，证明实现了异步监听！ 扩展在Spring里提供了许多的监听器，这里只是介绍了其中一种。 还有一种叫SpringApplicationRunListener也是很常用的监听器，可以监听SpringBoot项目启动的事件，用于在启动项目时加载一些配置。 还有一种叫SmartApplicationListener，这种监听器可以设置优先级。假设发送消息需要按顺序先发送短信，再发送公众号，再发送邮箱…，那就可以使用这种监听器实现，这里就不多做介绍了，小伙伴有兴趣的话，我可以再写一篇文章详细介绍。 总结经过重构之后，我们可以明显看到，如果以后要增加一种新的消息通知方式，是不需要修改PayServiceImpl的，我们只需要再增加一个监听类即可，这就符合了开闭原则。有利于代码的维护。而且最重要是解耦，支付的业务逻辑和发送消息的业务逻辑不会再糅合在一起了，符合职责单一原则。 在很多框架中，观察者模式都有应用，对于学习很多例如zookeeper、消息中间件、微服务注册中心等知识是有很大帮助的。在实际项目中，观察者模式也是一种很常用的设计模式。比如有一种业务场景，通讯录的部门里有员工离职，需要通知其他依赖于通讯录的应用都要同步部门的员工，那就可以使用这种方式来实现。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"教你用构建者(生成器)模式优雅地创建对象","slug":"常用的设计模式/教你用构建者-生成器-模式优雅地创建对象","date":"2020-04-27T15:13:53.000Z","updated":"2021-08-04T03:17:18.551Z","comments":true,"path":"2020/04/27/常用的设计模式/教你用构建者-生成器-模式优雅地创建对象/","link":"","permalink":"https://alloceee.github.io/2020/04/27/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%99%E4%BD%A0%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85-%E7%94%9F%E6%88%90%E5%99%A8-%E6%A8%A1%E5%BC%8F%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"为什么要用构建者模式很多博客文章上来就先抛出一个定义，我们不妨反过来问一句为什么要用构建者模式。首先我们创建一个User类，然后采用有参构造器的方式创建对象。 12345678910111213141516public class User &#123; private String id; private String name; private String gender; private String address; private Integer age; private String phone; //省略无参构造器，有参构造器，getter，setter方法...&#125; 1234public static void main(String[] args) throws Exception &#123; String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); User user = new User(id, &quot;张三&quot;, &quot;男&quot;, &quot;广州天河&quot;, 20, &quot;135461852xx&quot;);&#125; 我们通过有参构造器创建对象，并且赋值，看起来没什么问题，因为我们经常看到有人是这样写的。事实上，如果User对象里面有更多的字段，通过有参构造器去创建对象是很难一眼看出字段具体是什么意思，我们经常要看着User构造器的代码，然后对照顺序才能看出字段的代表什么意思。 12345678public User(String id, String name, String gender, String address, Integer age, String phone) &#123; this.id = id; this.name = name; this.gender = gender; this.address = address; this.age = age; this.phone = phone;&#125; 比如通过上面这个，我们可以知道第一个参数是id，第二个参数是名字，第三个是性别… 使用有参构造器的缺点：这显然不利于代码的维护性，对于不熟悉业务的新入职的员工，如果看到这种方式构建一个对象，估计要看上一会，有些项目我遇过一个构造器十几个参数的，更加离谱。而且一般老代码还不敢乱动他的这个构造器，一不小心你动了构造器里面的一个参数的顺序，直接GG；或者你在他原有的构造器后面加多一个参数，你会发现他很多地方都引用了这个有参构造器，你很多地方都要去修改，是真的恶心。 解决方法一 使用无参构造器，通过setter方法设置属性值12345678910public static void main(String[] args) throws Exception &#123; User user = new User(); user.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;)); user.setName(&quot;张三&quot;); user.setAge(20); user.setGender(&quot;男&quot;); user.setPhone(&quot;135461852xx&quot;); user.setAddress(&quot;广州天河&quot;); out.println(user);&#125; 上面这样，显然比直接用有参构造器要好很多，因为这样就可以创建对象和赋值分开进行，一眼就可以看出对什么属性值赋值，而且如果加一个字段，我们不需要再每一处都去修改，因为用的是无参构造器，是不是这样写就是万全之计呢？也不是，因为这样创建对象和赋值是分开的，各个参数的初始化被放到了不同的方法中调用，这会导致严重的线程不安全问题(使用构造器则不会有这个问题)，对象在一连串的set方法中，可能会出现状态不一致的情况，这是应该尽量避免的。 解决方法二 通过构建者模式，链式调用构建方法设置属性值什么是链式编程，就是调用一个方法，返回值是他本身，可以继续调用下一个方法，返回又是他本身，如此调用下去，看上去就像一条链子一样。典型的例子可以看java8新特性的Stream流操作。我们可以使用构建者模式，也能达到这种效果，并且线程安全，而且能直观地看到属性值的意思。总得来说，既保证线程安全，也很具有代码的可读性。先看结果代码： 123456789101112public static void main(String[] args) throws Exception &#123; String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); User user = UserBuilder.getInstance() .newPojo() .addId(id) .addName(&quot;张三&quot;) .addGender(&quot;男&quot;) .addAge(20) .addPhone(&quot;135461852xx&quot;) .addAddress(&quot;广州天河&quot;) .build();&#125; 怎么实现呢？其实很简单，我们只需要创建一个UserBuilder类即可。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class UserBuilder &#123; private User user; private UserBuilder() &#123; &#125; public static UserBuilder getInstance() &#123; return new UserBuilder(); &#125; public UserBuilder newPojo() &#123; this.user = new User(); //返回本身 return this; &#125; public UserBuilder addId(String id) &#123; this.user.setId(id); //返回本身 return this; &#125; public UserBuilder addName(String name) &#123; this.user.setName(name); return this; &#125; public UserBuilder addGender(String gender) &#123; this.user.setGender(gender); return this; &#125; public UserBuilder addAge(Integer age) &#123; this.user.setAge(age); return this; &#125; public UserBuilder addAddress(String address) &#123; this.user.setAddress(address); return this; &#125; public UserBuilder addPhone(String phone) &#123; this.user.setPhone(phone); return this; &#125; public User build() &#123; return this.user; &#125;&#125; 那么是不是这种方式就是万全之计呢，就一定没有缺点吗？ 构造者模式的缺点还是有的1.代码冗长。如果一个对象的属性很多，那我们在创建一个对象时，链式就会变得很长，但是这也没有办法，无论采用构造器还是builder模式都会很长。如果非要变得简洁一点，那就只有采用原型模式(克隆)等其他方式了。2.会产生很多Builder类。我们可以放在一个包下统一管理应该问题不大。第二个缺点实际上可以使用Lombok插件，然后在实体类上使用@Builder注解，就不会产生过多的Builder类了。但是有些公司的技术总监不太建议使用Lombok，那就莫得办法了… 注意点有很多博客的示范代码，Builder类的addXXX方法会写成setXXX方法，这是一个隐患。因为很多框架，对Setter方法比较敏感，往往会对Setter方法做一些处理，所以Builder类里的设置属性值方法尽量不要用setXXX命名，防止出现一些不明原因的错误。 结束语一般我们在项目中创建复杂的对象时，建议采用这种构建者模式创建对象。这样可以使代码可读性更好。在java源码中，我们也可以看到构建者模式的应用。比如在StringBuilder类中： 1234567891011121314151617181920@Overridepublic StringBuilder append(CharSequence s) &#123; super.append(s); return this;&#125;/** * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */@Overridepublic StringBuilder append(CharSequence s, int start, int end) &#123; super.append(s, start, end); return this;&#125;@Overridepublic StringBuilder append(char[] str) &#123; super.append(str); return this;&#125; StringBuilder的append()方法也是通过返回this对象实现链式构建对象，人们经常说这个StringBuilder类线程不安全是因为append()方法没有用synchronized修饰。StringBuffer则用了synchronized修饰，所以就是线程安全的。还有Mybatis框架中，构建SqlSessionFactory对象是使用SqlSessionFactoryBuilder 类进行构建，构建者模式运用非常广泛，非常值得学习。更多的设计模式实战经验的分享，就关注java技术小牛吧。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理模式以及应用","slug":"常用的设计模式/代理模式以及应用","date":"2020-04-19T06:56:04.000Z","updated":"2021-08-04T03:17:18.547Z","comments":true,"path":"2020/04/19/常用的设计模式/代理模式以及应用/","link":"","permalink":"https://alloceee.github.io/2020/04/19/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"代理模式代理模式的定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。","text":"代理模式代理模式的定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 通俗点说，就是一个中介，比如有一个广州人，是个本地人，有两套房，他要租出去收租，但是除了收租，他还要去找租客，带租客看房，还要准备租房合同，核算水电费等等，很麻烦。这个本地人他也不想这么折腾，他只想完成他的核心业务(收钱),其他杂七杂八的事情就不想管，但是总要有人去做，那就找租房中介，也就是二手房东。二手房东就代理这个广州本地人把房子租给租客。这个道理就是这么简单。 他们这些在广州有房子的本地人都可以找中介公司去代理租房是一样的。因为很多广州本地人都有这个需求，干脆就搞一个中介公司来专门去做租房子的事情。 代理模式，运用在编程里，也是这个道理，有一些非核心业务的代码，在很多地方都需要用到的逻辑，可以交给代理对象完成，程序员只需要关心核心业务的逻辑即可。 实现代理模式的三种方式项目就基于上一篇模板模式的文章的项目进行试验。 静态代理假设原来有一个接口UserService，controller层调用userService的getAllUser()方法。如下所示： 12345678910public interface UserService &#123; /** * 获取所有用户信息 * * @return List * @author Ye hongzhi * @date 2020/4/12 */ List&lt;User&gt; getAllUser() throws Exception;&#125; 123456789101112@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;User&gt; getAllUser()throws Exception&#123; return userService.getAllUser(); &#125;&#125; 如果用静态代理实现记录日志信息，怎么记录呢？ 首先创建一个代理类UserServiceProxy，实现UserService接口，然后在UserServiceProxy里面创建一个成员变量userService，再写一个有参构造器来初始化userService。代码如下： 1234567891011121314151617public class UserServiceProxy implements UserService &#123; private UserService userService; public UserServiceProxy(UserService userService) &#123; this.userService = userService; &#125; @Override public List&lt;User&gt; getAllUser() throws Exception &#123; System.out.println(&quot;记录日志：执行getAllUser()方法前&quot;); List&lt;User&gt; userList = userService.getAllUser(); System.out.println(userList); System.out.println(&quot;记录日志：执行getAllUser()方法后&quot;); return userList; &#125;&#125; 所以在controller层调用的方式就要改一下，是用代理类UserServiceProxy调用getAllUser()方法。如下： 123456789101112@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController &#123; @Resource(name = &quot;userService&quot;) private UserService userService; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;User&gt; getAllUser()throws Exception&#123; return new UserServiceProxy(userService).getAllUser(); &#125;&#125; 然后启动项目，调用一下接口，就可以看到控制台打印如下日志： 12345/*记录日志：执行getAllUser()方法前[User&#123;id=1, name=&#x27;大司马&#x27;, age=36, job=&#x27;厨师&#x27;&#125;, User&#123;id=2, name=&#x27;朴老师&#x27;, age=36, job=&#x27;主播&#x27;&#125;, User&#123;id=3, name=&#x27;王刚&#x27;, age=30, job=&#x27;厨师&#x27;&#125;, User&#123;id=4, name=&#x27;大sao&#x27;, age=32, job=&#x27;美食up主&#x27;&#125;, User&#123;id=5, name=&#x27;姚大秋&#x27;, age=35, job=&#x27;主持人&#x27;&#125;]记录日志：执行getAllUser()方法后*/ 这就是静态代理的实现思路，很简单。但是一般我们肯定是不用这种方式。因为这种方式太笨了，很容易就可以看出几个缺点。 1.要实现接口，也就是目标的方法要定义一个接口方法，实际上是运用了java多态的特性 2.第一点还不是致命的，因为JDK动态代理也是必须要定义接口；致命的是每一个你想代理的接口你都要去创建一个代理类去实现，假设有很多要代理的接口，那就创建很多代理类，这样显得很臃肿 假设还是不理解为什么要动态代理，不妨我们再多加一个支付接口PayService，这个支付接口我们也要加上日志记录。 用静态代理怎么做？很简单呀，再创建一个PayServiceProxy类不就完了吗，如果还有OrderService(订单), WarehouseService(仓库)等等。那就要创建很多XXXServiceProxy类。如果使用动态代理，就没必要创建这么多代理类，创建一个代理类就够了！ 动态代理就是为了解决静态代理的这个缺点产生的。 JDK动态代理JDK本身就带有动态代理，必须要满足一个条件，就是要有接口。原理其实和静态代理是一样的，也是用代理类去实现接口，但是代理类不是一开始就写好的，而是在程序运行时通过反射创建字节码文件然后加载到JVM。也就是动态生成的代理类对象。 下面就是用JDK动态代理实现代理模式。 12345678910111213141516171819202122232425public class LogRecordProxy&lt;T&gt; implements InvocationHandler &#123; private T target; public LogRecordProxy(T t) &#123; this.target = t; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前&quot;); Object result = method.invoke(target, args); System.out.println(result); System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后&quot;); return result; &#125; /** * 获取代理对象的方法 * */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy() throws Exception &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125;&#125; 在controller层，就要改成这样。 1234567891011121314@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;User&gt; getAllUser() throws Exception &#123; //获取代理对象 UserService userServiceProxy = new LogRecordProxy&lt;&gt;(userService).getProxy(); return userServiceProxy.getAllUser(); &#125;&#125; 假设有一个PayService也要做日志记录，就可以直接使用。 1234567891011@Resource(name = &quot;payService&quot;) private PayService payService; @RequestMapping(&quot;/pay&quot;) public String pay(@RequestParam(name = &quot;channel&quot;) String channel, @RequestParam(name = &quot;amount&quot;) String amount )throws Exception&#123; //获取代理对象，实际上就在构造器上改一下传入的参数即可 PayService payServiceProxy = new LogRecordProxy&lt;&gt;(payService).getProxy(); return payServiceProxy.pay(channel,amount); &#125; 很多文章给的例子都不带泛型，也可以，就是获取的代理对象需要强转一下，强转成对应的接口类。 注意：这里一定要用接口接收代理对象，不能用实现类！ 因为返回的对象已经不是实现类的对象，而是和实现类有共同的接口类的代理类对象，所以当然只能用接口类去接收。 这也是为什么一再强调要面向接口编程的原因，因为面向接口编程可以做更多的扩展。假设是面向实现类去编程，那就不能用JDK动态代理去扩展了！ CGLB动态代理那如果有些场景真的没有接口呢，我们怎么运用代理模式？ 首先引入maven配置 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 然后创建一个方法拦截器LogRecordInterceptor，要实现MethodInterceptor类，如下： 1234567891011121314151617public class LogRecordInterceptor implements MethodInterceptor &#123; private Object target; public LogRecordInterceptor(Object target) &#123; this.target = target; &#125; @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法前,参数：&quot; + Arrays.toString(args)); Object result = method.invoke(target, args); System.out.println(result); System.out.println(&quot;记录日志：执行&quot; + method.getName() + &quot;方法后,参数：&quot; + Arrays.toString(args)); return result; &#125;&#125; 然后再创建一个工厂类InterceptorFactory，用于创建代理对象。 12345678910public class InterceptorFactory &#123; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getInterceptor(Class&lt;T&gt; clazz, MethodInterceptor methodInterceptor) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clazz); enhancer.setCallback(methodInterceptor); return (T) enhancer.create(); &#125;&#125; 接着我们就可以创建一个没有接口的类，我这里就创建一个数学工具类进行测试 12345678public class MathUtil &#123; /** * 获取一个数的平方 * */ public String getSquare(int num) &#123; return String.valueOf(num * num); &#125;&#125; 然后在controller层定义一个接口来测试 12345@RequestMapping(&quot;/getSquare&quot;) public String getSquare(@RequestParam(name = &quot;num&quot;) Integer num) throws Exception &#123; MathUtil mathUtil = InterceptorFactory.getInterceptor(MathUtil.class, new LogRecordInterceptor(new MathUtil())); return mathUtil.getSquare(num); &#125; 用浏览器或者POSTMAN工具调用接口，就可以在控制台看到以下输出： 12345/*记录日志：执行getSquare方法前,参数：[2]4记录日志：执行getSquare方法后,参数：[2]*/ 这样就实现没有定义接口也可以实现动态代理！ 实际上，定义接口的也可以用这种方法来进行扩展，比如上面的userService接口 123456789101112131415@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;User&gt; getAllUser() throws Exception &#123; UserServiceImpl userServiceProxy = InterceptorFactory .getInterceptor(UserServiceImpl.class, new LogRecordInterceptor(userService)); return userServiceProxy.getAllUser(); &#125;&#125; 调用接口我们在控制台也是可以看到以下输出日志： 12345/*记录日志：执行getAllUser方法前,参数：[][User&#123;id=1, name=&#x27;大司马&#x27;, age=36, job=&#x27;厨师&#x27;&#125;, User&#123;id=2, name=&#x27;朴老师&#x27;, age=36, job=&#x27;主播&#x27;&#125;, User&#123;id=3, name=&#x27;王刚&#x27;, age=30, job=&#x27;厨师&#x27;&#125;, User&#123;id=4, name=&#x27;大sao&#x27;, age=32, job=&#x27;美食up主&#x27;&#125;, User&#123;id=5, name=&#x27;姚大秋&#x27;, age=35, job=&#x27;主持人&#x27;&#125;]记录日志：执行getAllUser方法后,参数：[]*/ 总结以上就是代理模式的一些通俗的解释，还有三种实现的方式的学习 多说几句，我们都知道Spring框架有两个核心技术，一个叫控制反转IOC，另一个叫切面编程AOP。切面编程大家都很熟悉，用的就是代理模式，那么AOP实现的代理模式用的是JDK动态代理还是CLB动态代理？ 答曰：两个都用！ 最简单的，我们看Spring的事务管理，就是用代理模式实现的，如果有兴趣，其实我们自己也可以通过JDK动态代理手写实现事务管理，其实不是很难。篇幅有限，以后可以单独写一篇文章详细说明Spring的事务管理，敬请期待。更多的设计模式实战经验的分享，就关注java技术小牛吧。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"模板模式以及实战应用","slug":"常用的设计模式/模板模式以及实战应用","date":"2020-04-12T08:28:29.000Z","updated":"2021-08-04T03:17:18.557Z","comments":true,"path":"2020/04/12/常用的设计模式/模板模式以及实战应用/","link":"","permalink":"https://alloceee.github.io/2020/04/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/","excerpt":"写在前面上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。","text":"写在前面上一篇讲了策略模式，知道了可以使用策略模式对多重if-else进行优化，而且符合开闭原则。那么除了策略模式，还有什么设计模式比较好用而且常用的呢。这就是今天要讲的模板模式。 模板模式解决什么问题呢？ 正片开始首先我们使用SpringBoot来搭建一个工程。 123456789101112131415&lt;!-- maven配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; application.yml配置如下： 12345678server: port: 8888spring: datasource: url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: 账号 password: 密码 driver-class-name: com.mysql.jdbc.Driver 创建一个全局配置类GlobalProperties，我们通过这个类可以获取yml的配置信息 12345678910111213141516@Component(&quot;globalProperties&quot;)public class GlobalProperties &#123; @Value(&quot;$&#123;spring.datasource.driver-class-name&#125;&quot;) private String driverClass; @Value(&quot;$&#123;spring.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.datasource.password&#125;&quot;) private String password; //字段对应的getter、setter方法... 创建一个连接工厂类ConnectFactory，获取数据库连接 12345678910111213public class ConnectFactory &#123; public static Connection getConnection() throws Exception&#123; //获取yml文件的配置，SpringContextUtil工具类在上一篇文章有介绍，可以参考上一篇文章的代码 GlobalProperties properties = SpringContextUtil .getBean(&quot;globalProperties&quot;, GlobalProperties.class); //加载数据驱动 Class.forName(properties.getDriverClass()); //获取数据库连接，返回数据库连接对象 return DriverManager.getConnection(properties.getUrl(), properties.getUsername(), properties.getPassword()); &#125;&#125; 创建实体类User 1234567891011public class User &#123; private Integer id; private String name; private Integer age; private String job; //字段对应的getter、setter方法... 接着在mysql对应的数据库创建数据表tb_user，sql语句如下： 1234567CREATE TABLE `tb_user` ( `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(255) NOT NULL COMMENT &#x27;名称&#x27;, `age` tinyint(4) NOT NULL COMMENT &#x27;年龄&#x27;, `job` varchar(255) DEFAULT NULL COMMENT &#x27;工作&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 插入一些测试数据 12345INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#x27;大司马&#x27;,36,&#x27;厨师&#x27;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#x27;朴老师&#x27;,36,&#x27;主播&#x27;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#x27;王刚&#x27;,30,&#x27;厨师&#x27;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#x27;大sao&#x27;,32,&#x27;美食up主&#x27;);INSERT INTO tb_user(`name`,`age`,`job`) VALUES(&#x27;姚大秋&#x27;,35,&#x27;主持人&#x27;); 假设我们有一张user表，我们通过原生的JDBC来进行数据库操作，那么需要在dao层完成以下几步。 1.装载相应的数据库的JDBC驱动并进行初始化 2.建立JDBC和数据库之间的Connection连接 3.创建Statement或者PreparedStatement接口，执行SQL语句 4.处理和显示结果 5.释放资源 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#x27;%s&#x27;&quot;;@Override public User getUserByName(String name) throws Exception &#123; User user = new User(); //获取数据连接 try (Connection connection = ConnectFactory.getConnection(); Statement statement = connection.createStatement(); ResultSet resultSet = statement .executeQuery(String.format(GET_USER_BY_NAME_SQL, name)) ) &#123; while (resultSet.next()) &#123; //获取id user.setId(resultSet.getInt(&quot;id&quot;)); //获取名称 user.setName(resultSet.getString(&quot;name&quot;)); //获取年龄 user.setAge(resultSet.getInt(&quot;age&quot;)); //获取工作 user.setJob(resultSet.getString(&quot;job&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return user; &#125;private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#x27;%s&#x27;&quot;; @Override public User getUserById(Integer id) throws Exception &#123; User user = new User(); //获取数据库连接 try (Connection connection = ConnectFactory.getConnection(); Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(String.format(GET_USER_BY_ID_SQL, id)) ) &#123; while (resultSet.next()) &#123; //获取id user.setId(resultSet.getInt(&quot;id&quot;)); //获取名称 user.setName(resultSet.getString(&quot;name&quot;)); //获取年龄 user.setAge(resultSet.getInt(&quot;age&quot;)); //获取工作 user.setJob(resultSet.getString(&quot;job&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return user; &#125; PS:这里为了简单一点就直接把参数拼接sql语句，不采用预编译来处理sql的参数。 问题分析通过上面的代码，我们很明显可以看到是有很大的问题的。 1.每次在进行数据库操作都需要获取Connection对象，创建Statement对象。 2.每次获取结果后，都要进行结果处理，而且如果是同一张表的查询，会很重复。每次都需要把结果值set回到对象的字段中。 模板模式就可以解决这个问题！ 使用模板模式重构代码第一步创建一个模板类DaoTemplate，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author Ye Hongzhi * @program DaoTemplate * @description * @date 2020-04-12 17:04 **/@Componentpublic class DaoTemplate &#123; public &lt;T&gt; T query(String sql, Class&lt;T&gt; clazz) throws Exception &#123; //通过clazz创建返回值对象 T t = clazz.newInstance(); //获取数据库连接 try (Connection connection = ConnectFactory.getConnection(); Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql) ) &#123; while (resultSet.next()) &#123; //获取所有字段 Field[] fields = clazz.getDeclaredFields(); //获取所有方法 Method[] methods = clazz.getDeclaredMethods(); Map&lt;String, Method&gt; methodNameMap = Arrays.stream(methods) .collect(Collectors.toMap(Method::getName, Function.identity())); //把数据库对应的列的值赋值给 泛型T对象的 对应的字段 for (Field field : fields) &#123; //获取字段名 String fieldName = field.getName(); //获取set方法 Method method = methodNameMap.get(&quot;set&quot; + change(fieldName)); //获取数据库的列的值 Object fieldValue = null; if (field.getType() == String.class) &#123; fieldValue = resultSet.getString(fieldName); &#125; if (field.getType() == Integer.class) &#123; fieldValue = resultSet.getInt(fieldName); &#125; if (field.getType() == Boolean.class) &#123; fieldValue = resultSet.getBoolean(fieldName); &#125; if (field.getType() == Long.class) &#123; fieldValue = resultSet.getLong(fieldName); &#125; if(field.getType() == Double.class)&#123; fieldValue = resultSet.getDouble(fieldName); &#125; if(field.getType() == BigDecimal.class)&#123; fieldValue = resultSet.getBigDecimal(fieldName); &#125; if (field.getType() == Date.class) &#123; fieldValue = resultSet.getDate(fieldName); &#125; //设置更多的字段类型... //利用反射执行对象的set方法，把数据库的值设置到对象的字段中 method.invoke(t, fieldValue); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * 将一个字符串首字母大写，其它字母小写 * * @param str 字符串 * @return */ private static String change(String str) &#123; return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase(); &#125;&#125; 第二步创建模板后，可以在DAO层引入模板，然后使用。如下： 12345678910111213141516171819//引入模板 @Resource private DaoTemplate daoTemplate;private static final String GET_USER_BY_ID_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `id` = &#x27;%s&#x27;&quot;; @Override public User getUserById(Integer id) throws Exception &#123; //使用模板的方法，查询 return daoTemplate.query(String.format(GET_USER_BY_ID_SQL, id), User.class); &#125;private static final String GET_USER_BY_NAME_SQL = &quot;SELECT `id`,`name`,`age`,`job` FROM `tb_user` WHERE `name` = &#x27;%s&#x27;&quot;; @Override public User getUserByName(String name) throws Exception &#123; //使用模板的方法，查询 return daoTemplate.query(String.format(GET_USER_BY_NAME_SQL, name), User.class); &#125; 哇喔！突然间代码就显得清爽很多了！ 小伙伴们看到这里，get到新的技能了吗？ 扩展知识实际上在Spring框架就有提供JDBC模板 我们可以在MAVEN中引入以下配置： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 创建一个映射类UserRowMapper 1234567891011public class UserRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet resultSet, int i) throws SQLException &#123; User user = new User(); user.setId(resultSet.getInt(&quot;id&quot;)); user.setName(resultSet.getString(&quot;name&quot;)); user.setAge(resultSet.getInt(&quot;age&quot;)); user.setJob(resultSet.getString(&quot;job&quot;)); return user; &#125;&#125; 然后在DAO层的UserDaoImpl，我们就可以引入JdbcTemplate 12345678@Resource private JdbcTemplate jdbcTemplate;//使用jdbcTemplate查询@Override public User getUserByName(String name) throws Exception &#123; return jdbcTemplate.queryForObject(String.format(GET_USER_BY_NAME_SQL, name), new UserRowMapper()); &#125; 从这里可以看出实际上Spring框架就是采用这种思想来实现JdbcTemplate模板。 结束语所以在实际项目的开发中，我们有时候遇到某些代码块的前后都有重复操作时，可以采用模板模式去重构代码，使代码更加简洁，容易维护。 更多的设计模式实战经验的分享，就关注java技术小牛吧。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"教你用策略模式解决多重if-else","slug":"常用的设计模式/教你用策略模式解决多重if-else","date":"2020-04-05T06:12:40.000Z","updated":"2021-08-04T03:17:18.553Z","comments":true,"path":"2020/04/05/常用的设计模式/教你用策略模式解决多重if-else/","link":"","permalink":"https://alloceee.github.io/2020/04/05/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%99%E4%BD%A0%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%A4%9A%E9%87%8Dif-else/","excerpt":"","text":"写在前面很多人可能在公司就是做普通的CRUD的业务，对于设计模式，即使学了好像也用处不大，顶多就在面试的时候能说上几种常见的单例模式，工厂模式。而在实际开发中，设计模式似乎很难用起来。 在现在的环境下，程序员的竞争已经非常激烈了，要体现出自身的价值，最直接的体现当然是差异化。这无需多说，我认为在实际开发中能运用设计模式，是很能体现差异化的。设计模式是一些前人总结的较好的方法，使程序能有更好的扩展性，可读性，维护性。 下面举个例子，使用策略模式解决多重if-else的代码结构。想学习更多的设计模式的实战经验，那就点个关注吧，谢谢大佬。 使用if-else假设我们要开发一个支付接口，要对接多种支付方式，通过渠道码区分各种的支付方式。于是定义一个枚举PayEnum，如下： 1234567891011121314public enum PayEnum &#123; ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;), WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;), UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;), XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;); /**渠道*/ private String channel; /**描述*/ private String description; PayEnum(String channel, String description) &#123; this.channel = channel; this.description = description; &#125; /**以下省略字段的get、set方法*/ 创建一个PayController类，代码如下： 1234567891011121314151617181920@RestController@RequestMapping(&quot;/xiaoniu&quot;)public class PayController &#123; @Resource(name = &quot;payService&quot;) private PayService payService; /** * 支付接口 * @param channel 渠道 * @param amount 消费金额 * @return String 返回消费结果 * @author Ye hongzhi * @date 2020/4/5 */ @RequestMapping(&quot;/pay&quot;) public String pay(@RequestParam(name = &quot;channel&quot;) String channel, @RequestParam(name = &quot;amount&quot;) String amount )throws Exception&#123; return payService.pay(channel,amount); &#125;&#125; 再创建一个PayService接口以及实现类PayServiceImpl 1234567891011public interface PayService &#123; /** * 支付接口 * @param channel 渠道 * @param amount 金额 * @return String * @author Ye hongzhi * @date 2020/4/5 */ String pay(String channel,String amount)throws Exception;&#125; 1234567891011121314151617181920212223242526@Service(&quot;payService&quot;)public class PayServiceImpl implements PayService &#123; private static String MSG = &quot;使用 %s ,消费了 %s 元&quot;; @Override public String pay(String channel, String amount) throws Exception &#123; if (PayEnum.ALI_PAY.getChannel().equals(channel)) &#123; //支付宝 //业务代码... return String.format(MSG,PayEnum.ALI_PAY.getDescription(),amount); &#125;else if(PayEnum.WECHAT_PAY.getChannel().equals(channel))&#123; //微信支付 //业务代码... return String.format(MSG,PayEnum.WECHAT_PAY.getDescription(),amount); &#125;else if(PayEnum.UNION_PAY.getChannel().equals(channel))&#123; //银联支付 //业务代码... return String.format(MSG,PayEnum.UNION_PAY.getDescription(),amount); &#125;else if(PayEnum.XIAO_MI_PAY.getChannel().equals(channel))&#123; //小米支付 //业务代码... return String.format(MSG,PayEnum.XIAO_MI_PAY.getDescription(),amount); &#125;else&#123; return &quot;输入渠道码有误&quot;; &#125; &#125;&#125; 然后通过浏览器，我们可以看到效果 这样看，以上代码的确可以实现需求，通过渠道码区分支付方式，可是看到上面那么多达4个的if-else的代码结构，已经开始显示出问题了。假设有更多的支付方式，那么这段代码就要写更多的else if去判断，这显然会不利于代码的扩展，这样会导致这个支付的方法越写越长。 在设计模式六大原则中，其中一个原则叫做开闭原则，对扩展开放，对修改关闭，应尽量在不修改原有代码的情况下进行扩展。 基于上面提到的开闭原则，我们可以使用策略模式进行重构。 使用策略模式重构代码定义一个策略接口类PayStrategy 1234public interface PayStrategy &#123; String MSG = &quot;使用 %s ,消费了 %s 元&quot;; String pay(String channel,String amount)throws Exception;&#125; 然后再创建四种策略实现类实现接口 1234567@Component(&quot;aliPayStrategy&quot;)public class AliPayStrategyImpl implements PayStrategy&#123; @Override public String pay(String channel, String amount) throws Exception &#123; return String.format(MSG, PayEnum.ALI_PAY.getDescription(),amount); &#125;&#125; 1234567@Component(&quot;wechatPayStrategy&quot;)public class WechatPayStrategyImpl implements PayStrategy&#123; @Override public String pay(String channel, String amount) throws Exception &#123; return String.format(MSG, PayEnum.WECHAT_PAY.getDescription(),amount); &#125;&#125; 1234567@Component(&quot;unionPayStrategy&quot;)public class UnionPayStrategyImpl implements PayStrategy&#123; @Override public String pay(String channel, String amount) throws Exception &#123; return String.format(MSG, PayEnum.UNION_PAY.getDescription(),amount); &#125;&#125; 1234567@Component(&quot;xiaomiPayStrategy&quot;)public class XiaomiPayStrategyImpl implements PayStrategy&#123; @Override public String pay(String channel, String amount) throws Exception &#123; return String.format(MSG, PayEnum.XIAO_MI_PAY.getDescription(),amount); &#125;&#125; 看到这里实际上已经很清晰了，思路就是通过渠道码，动态获取到具体的实现类，这样就可以实现不需要if else判断。怎么通过渠道码获取实现类呢？ 在PayEnum枚举加上BeanName字段，然后增加一个通过渠道码获取BeanName的方法 123456789101112131415161718192021222324ALI_PAY(&quot;ali&quot;,&quot;支付宝支付&quot;,&quot;aliPayStrategy&quot;), WECHAT_PAY(&quot;wechat&quot;,&quot;微信支付&quot;,&quot;wechatPayStrategy&quot;), UNION_PAY(&quot;union&quot;,&quot;银联支付&quot;,&quot;unionPayStrategy&quot;), XIAO_MI_PAY(&quot;xiaomi&quot;,&quot;小米支付&quot;,&quot;xiaomiPayStrategy&quot;);/**策略实现类对应的 beanName*/ private String beanName;/** * 通过渠道码获取枚举 * */ public static PayEnum findPayEnumBychannel(String channel)&#123; PayEnum[] enums = PayEnum.values(); for (PayEnum payEnum : enums)&#123; if(payEnum.getChannel().equals(channel))&#123; return payEnum; &#125; &#125; return null; &#125;//构造器 PayEnum(String channel, String description, String beanName) &#123; this.channel = channel; this.description = description; this.beanName = beanName; &#125; 这时候还差一个获取Spring上下文对象的工具类，于是我们创建一个SpringContextUtil类 1234567891011121314151617181920212223242526272829@Componentpublic class SpringContextUtil implements ApplicationContextAware &#123; /** * 上下文对象实例 */ private static ApplicationContext applicationContext; /** * 获取applicationContext */ private static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 通过name获取Bean * */ public static Object getBean(String name)&#123; return getApplicationContext().getBean(name); &#125; /** * 通过name,以及Clazz返回指定的Bean * */ public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123; return getApplicationContext().getBean(name,clazz); &#125; @Override @Autowired public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringContextUtil.applicationContext = applicationContext; &#125; 接着定义一个工厂类，通过渠道码获取对应的策略实现类 123456789101112public class PayStrategyFactory &#123; /** * 通过渠道码获取支付策略具体实现类 * */ public static PayStrategy getPayStrategy(String channel)&#123; PayEnum payEnum = PayEnum.findPayEnumBychannel(channel); if(payEnum == null)&#123; return null; &#125; return SpringContextUtil.getBean(payEnum.getBeanName(),PayStrategy.class); &#125;&#125; 最后我们再改造一下原来的PayServiceImpl的pay方法 12345678@Overridepublic String pay(String channel, String amount) throws Exception &#123; PayStrategy payStrategy = PayStrategyFactory.getPayStrategy(channel); if(payStrategy == null)&#123; return &quot;输入渠道码有误&quot;; &#125; return payStrategy.pay(channel,amount);&#125; 哇喔！突然间代码就显得清爽很多了！ 小伙伴们看到这里，get到新的技能了吗？ 假设需要增加新的支付方式，就不需要再使用else if 去判断，而是在枚举中定义一个新的枚举对象，然后再增加一个策略实现类，实现对应的方法，那就可以很轻松地扩展。也实现了开闭原则。 写在最后设计模式运用得熟练的话，很多代码可以写得很优雅。更多的设计模式实战经验的分享，就关注java技术小牛吧。 能力有限，如果有什么错误或者不当之处，请大家批评指正，一起学习交流！","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis常见面试题","slug":"数据库/Redis/Redis-面试题","date":"2020-02-29T16:00:00.000Z","updated":"2021-08-04T03:05:13.688Z","comments":true,"path":"2020/03/01/数据库/Redis/Redis-面试题/","link":"","permalink":"https://alloceee.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用做数据库、缓存、消息中间件等。 它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。","text":"Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用做数据库、缓存、消息中间件等。 它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。 Redis是什么Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用做数据库、缓存、消息中间件等。 它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。 Redis作为一个内存数据库： 性能优秀，数据在内存中，读写速度非常快，支持并发10w QPS 单进程单线程，是线程安全的，采用IO多路复合机制 丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等 支持数据持久化，可以将内存中数据保存在磁盘中，重启时加载 主从复制，哨兵，高可用 可以用作分布式锁 可以作为消息中间件使用，支持发布订阅 Redis为何这么快，还是单线程Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。 既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。 为什么单线程这么快： Redis是完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O（1）。 数据结构简单，对数据操作也简单 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。 使用多路复用IO模型，非阻塞IO Redis和Memcached的区别 存储方式上：Memcached会把数据全部存储在内存之中，断电之后会挂掉，数据不能超过内存大小。Redis有部分数据存在硬盘上，这样能保证数据的持久性。 数据支持类型上：Memcached对数据类型的支持简单，只支持简单的key-value，而Redis支持五种数据类型。 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 Value的大小：Redis可以达到1GB，而Memached只有1MB。 淘汰策略Redis有六种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的KV集合中有限对最近最好使用（less recently used）的数据淘汰 volatile-ttl 从已设置过期时间的KV集合中优先对剩余时间短（time to live）的数据淘汰 volatile-random 从已设置过期时间的KV集合中随机选择数据淘汰 allkeys-lru 从所有KV集合中优先对最近最少使用（less recently used）的数据淘汰 allkeys-random 从所有KV集合中随机选择数据淘汰 noeviction 不淘汰策略，若超过最大内存，返回错误信息 Redis 4.0加入了LFU（least frequently use）淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰 持久化机制Redis为了保证效率，数据缓存在内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。 Redis的持久化策略有两种： RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存策略 AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令集合。 Redis默认是快照RDB的持久化方式。 当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整，你甚至可以关闭持久化功能，让数据只在服务器运行时存。 主从复制","categories":[{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://alloceee.github.io/tags/Redis/"}],"author":"Alloceee"},{"title":"一致性哈希算法的理解与实践","slug":"Algorithm/一致性哈希算法的理解与实践","date":"2016-06-09T02:43:54.000Z","updated":"2020-02-18T09:23:42.000Z","comments":true,"path":"2016/06/09/Algorithm/一致性哈希算法的理解与实践/","link":"","permalink":"https://alloceee.github.io/2016/06/09/Algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/","excerpt":"0. 概述在维基百科中，是这么定义的 一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。 1. 引出我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？那么我们引出一个问题： 假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。 看一看普通Hash算法的原理：","text":"0. 概述在维基百科中，是这么定义的 一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。 1. 引出我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？那么我们引出一个问题： 假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。 看一看普通Hash算法的原理： 算法的核心计算如下 123456for item in range(ITEMS): k = md5(str(item)).digest() h = unpack_from(&quot;&gt;I&quot;, k)[0] # 通过取余的方式进行映射 n = h % NODES node_stat[n] += 1 具体的完整实现请参考normal_hash.py，输出是这样的： Ave: 100000Max: 100695 (0.69%)Min: 99073 (0.93%) 从上述结果可以发现，普通的Hash算法均匀地将这些数据项打散到了这些节点上，并且分布最少和最多的存储节点数据项数目小于1%。之所以分布均匀，主要是依赖Hash算法（实现使用的MD5算法）能够比较随机的分布。 然而，我们看看存在一个问题，由于该算法使用节点数取余的方法，强依赖node的数目，因此，当是node数发生变化的时候，item所对应的node发生剧烈变化，而发生变化的成本就是我们需要在node数发生变化的时候，数据需要迁移，这对存储产品来说显然是不能忍的，我们观察一下增加node后，数据项移动的情况： 123456789for item in range(ITEMS): k = md5(str(item)).digest() h = unpack_from(&quot;&gt;I&quot;, k)[0] # 原映射结果 n = h % NODES # 现映射结果 n_new = h % NEW_NODES if n_new != n: change += 1 详细实现代码在normal_hash_add.py输出是这样的： Change: 9900989 (99.01%) 翻译一下就是，如果有100个item，当增加一个node，之前99%的数据都需要重新移动。 这显然是不能忍的，普通哈希算法的问题我们已经发现了，如何对其进行改进呢？没错，我们的一致性哈希算法闪亮登场。 2. 登场我们上节介绍了普通Hash算法的劣势，即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。 那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量的降到最低。 一致性Hash算法的原理是这样的： 12345678910for n in range(NODES): h = _hash(n) ring.append(h) ring.sort() hash2node[h] = nfor item in range(ITEMS): h = _hash(item) n = bisect_left(ring, h) % NODES node_stat[hash2node[ring[n]]] += 1 我们依然对其进行了实现consist_hash_add.py，并且观察了数据迁移的结果： Change: 58897 (0.59%) 虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据项分布的均匀性，进行了一致性Hash算法的实现consist_hash.py： Ave: 100000Max: 596413 (496.41%)Min: 103 (99.90%) 这结果简直是简直了，确实非常结果差，分配的很不均匀。我们思考一下，一致性哈希算法分布不均匀的原因是什么？从最初的1000w个数据项经过一般的哈希算法的模拟来看，这些数据项“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据项本身的哈希值并未发生变化，变化的是判断数据项哈希应该落到哪个节点的算法变了。因此，主要是因为这100个节点Hash后，在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一造成的。 3. 改进-虚节点当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。 详细实现请见virtual_consist_hash.py 1234567891011121314for n in range(NODES): for v in range(VNODES): h = _hash(str(n) + str(v)) # 构造ring ring.append(h) # 记录hash所对应节点 hash2node[h] = nring.sort()for item in range(ITEMS): h = _hash(str(item)) # 搜索ring上最近的hash n = bisect_left(ring, h) % (NODES*VNODES) node_stat[hash2node[ring[n]]] += 1 输出结果是这样的： Ave: 100000Max: 116902 (16.90%)Min: 9492 (90.51%) 因此，通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。同时，观察增加节点后数据变动情况，详细的代码请见virtual_consist_hash_add.py： 123456for item in range(ITEMS): h = _hash(str(item)) n = bisect_left(ring, h) % (NODES*VNODES) n2 = bisect_left(ring2, h) % (NODES2*VNODES) if hash2node[ring[n]] != hash2node2[ring2[n2]]: change += 1 100000101000Change: 104871 (1.05%) 3. 另一种改进然而，虚节点这种靠数量取胜的策略增加了存储这些虚节点信息所需要的空间。在OpenStack的Swift组件中，使用了一种比较特殊的方法来解决分布不均的问题，改进了这些数据分布的算法，将环上的空间均匀的映射到一个线性空间，这样，就保证分布的均匀性。代码实现见part_consist_hash.py 123456789for part in range(2 ** LOG_NODE): ring.append(part) part2node[part] = part % NODESfor item in range(ITEMS): h = _hash(item) &gt;&gt; PARTITION part = bisect_left(ring, h) n = part % NODES node_stat[n] += 1 Ave: 100000Max: 157298 (57.30%)Min: 77405 (22.59%) 可以看到，数据分布是比较理想的。如果节点数刚好和分区数相等，理论上是可以均匀分布的。而观察下增加节点后的数据移动比例，代码实现见part_consist_hash_add.py 123456789101112131415for part in range(2 ** LOG_NODE): ring.append(part) part2node[part] = part % NODES part2node2[part] = part % NODES2change = 0for item in range(ITEMS): h = _hash(item) &gt;&gt; PARTITION p = bisect_left(ring, h) p2 = bisect_left(ring, h) n = part2node[p] % NODES n2 = part2node2[p] % NODES2 if n2 != n: change += 1 结果如下所示： Change: 2190208 (21.90%) 可以看到，移动也是比较理想的。 参考链接：深入云存储系统Swift核心组件：Ring实现原理剖析Basic Hash RingPartition Ring vs. Hash Ring","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"网络知识拾遗","slug":"计算机网络/网络知识拾遗","date":"2015-11-23T13:19:23.000Z","updated":"2020-02-18T09:23:42.000Z","comments":true,"path":"2015/11/23/计算机网络/网络知识拾遗/","link":"","permalink":"https://alloceee.github.io/2015/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/","excerpt":"本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。","text":"本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。 1. 二层交换二层交换指的是传统的二层交换机实现的功能，主要的功能就是将以太网帧从一个端口接收，并从合适的端口发送出去。 1.1 以太网帧 以太网帧如上图所示，如此构造主要是为了表达这个帧：到哪去（目的MAC，6字节）、从哪来（源MAC，6字节）、什么帧（长度/类型，2字节）、有什么（数据，40~1500字节）、错没错（FCS，CRC，4字节）。 用户数据的长度不同，以太网帧的长度也不同，范围为64-1518字节。 1.2 存储转发与地址学习 存储转发：转发时，常用的方式为存储转发方式（store forward），即数据帧先入存储队列再根据转发表进行转发。使用存储转发，一来可以为多种速率端口的数据进行缓冲，二来也可以将残损、CRC错误等异常帧进行丢弃。小科普：除了存储转发外，还有直通转发（cut through，只读到DA后就转发，无法处理冲突帧、CRC错帧）、碎片隔离（fragment free，读一个slot共64字节，无冲突再转发，无法处理CRC帧）。 地址学习：在完成存储转发时，需要查询转发表，从而得知数据帧应该从哪个端口发出，因此，转发表存的就是目的MAC地址与端口的映射，转发表生成的过程就是地址学习。大致过程就是，来一个帧，读他的源MAC，然后把源MAC和接收的端口号存下来。这样，交换机就知道了，从X端口来过MAC地址为Y的数据，当下次Y需要转发时，就可以把他转发到X端口了。从而，完成“从哪来去回哪去”的任务 1.3 广播风暴在几个交换机构成环时，会产生广播风暴，造成广播风暴的根本原因是交换机之间不能感知到互相的存在，导致地址学习时，一个交换将某个MAC的转发端口学习成了另一个交换机的端口。可以通过STP协议进行抑制，从逻辑上“断开”环。 1.4 VLAN VLAN可以将广播域分隔为多个逻辑网段。从帧格式上来看，增加了VLAN相关的域，VLAN相关域包括0x8100标志位，然后3bit的优先级，1bit的丢帧优先级，12bit的VLANID。在做转发学习时，通过SA+VLAN来学习转发端口。值得注意的是：当某个DA+VLAN查不到表时，仅在VLAN域广播。 换一种思想来看，可以认为VLAN是一种网络的虚拟化，将一个端口虚拟化成多个端口。 2. 三层路由路由的主要功能是根据目的IP转发到相应的网络中。和二层中的转发表类似，三层路由也存在一个类似的表，叫做路由表。 也就是说如果一个LAN希望连接另一个LAN，那么需要借助路由完成。另外，在大型的LAN中，由于连接设备多，导致MAC多，导致广播负担大，因此切分子网来避免这一问题，而子网之间所属不同LAN所以也需要借助路由完成通信。 在进行路由的时候，路由首先根据最长匹配原则在路由表中查找下一跳IP地址，之后，根据ARP表，获取下一跳的MAC信息，便进入ARP流程，最后，根据下一跳MAC地址生成以太网数据帧，并将该数据帧从接口转发至网络。 路由与三层交换有类似的地方，L3交换虽具有路由功能，但其核心功能主要在于数据交换上，而路由仅具有路由转发功能。 2.1 NATNetwork Adress Translator，网络地址转换。 对于源地址NAT，主要用于内网访问外网，源地址进行转换；对于目的地址NAT，一般用于外网访问内网，目的地址进行转换。 3. Linux网络由于目前大部分云计算服务器、网络设备都是运行在Linux上的，因此，学习一些和Linux网络底层相关的实现，有助于我们理解。如Linux 上的基础网络设备详解一文中所述： Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，既通用的 Linux 网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。 另外，对于Linux网络中的数据流在kernel flow中有所描述，文中更有一张神图。 3.1 网络驱动 之前，有做过网络驱动，其实回想起来，核心的实现就2个：发送函数和接收函数。 1. 发送函数（回调） 核心功能是将上层网络传来的帧，写入到网卡中； 在网络驱动初始化时，会通过注册的方式对网络驱动进行初始化， 123456static const struct net_device_ops netdev_ops = &#123; .ndo_open = driver_open, .ndo_stop = driver_close, .ndo_start_xmit = driver_xmit, .ndo_get_stats = get_stats,&#125;; 当上层有帧传来时，就会回调driver_xmit函数，因此，在driver_xmit函数中，就应当实现将帧写入到硬件，一般硬件会提供插入帧的接口，完成插入时帧会进入网卡硬件的插入队列中。 2. 接收函数（中断）核心功能是将网卡中的帧，传送到上层协议栈中。 对于接收函数，则需要依靠硬件的中断，数据帧到达网卡，硬件以中断的方式告知系统，然后，接收函数回调，回调时，需通过硬件的接口读取数据帧，然后将其上传值上层接口。一般调用netif_rx()进行传输。 3.2 Linux BridgeLinux Bridge名释其意，像一个桥梁一样把网络设备桥接起来。Linux bridge是802.1D的实现，可以参考链接。 如上图所示是eth0和eth1加入到br0后的实现，可以看出，网桥向上屏蔽了桥下的网卡设备，从上层协议上来看，仅能看到网桥设备br0。 在《Understanding Linux Network Internals》一书中，分析了Linux Bridge的实现： 在br中有个链表来链net_device，每个net_device也反向链着br。在br中有个hash结构叫做fdb_entry，存储着转发表（forward databse），若某个MAC地址在fdb中，那么就直接发到某个net_device，如果没在的话，就广播给链接到该br的所有设备。 3.3 Linux VLAN交换与隔离是VLAN的两大功能，现实世界中的802.1q交换机存在多个VLAN，每个VLAN拥有多个端口，同一VLAN的端口可数据交换，不同VLAN的端口之间隔离。而Linux VLAN实现的是隔离，需要交换的话，需要在Linux Bridge上attach一个VLAN。即Linux Bridge加VLAN device能在功能层面完整模拟现实世界里的802.1.q交换机。 在关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考一文中，举了个例子，觉得很不错，画了个图加深理解： 一个盒子有6个物理interface, eth0,eth1,eth2,eth3,eth4,eth5,eth6.bridge0 { eth0, eth1, eth2 }, vlan id 是2bridge1 { eth3, eth4, eth5 }, vlan id 是3eth0,eth1,eth2,eth3,eth4,eth5都在混杂模式，并且没有ip地址，它们是bridge的port.创建vlan interface, bridge0.2, bridge1.3。在bridge0.2和bridge1.3上配置ip地址。vlan 2的机器，把bridge0.2的地址设置为缺省网关；vlan 3的机器，把bridge1.3设置为缺省网关。当有包要从vlan 2发往vlan 3是，它将送到bridge0.2，然后，通过路由，找到bridge1.3，然后由bridge1.3发出去。这个过程中，packet里面的vlan id会发生改变。这个例子里面，要求从bridge port上收到的包都必须是打tag的，在bridge里面，并不能识别和处理tag，只有到三层的vlan interface才能识别并处理这些tag. 另外，Linux VLAN则是802.1Q的实现，可以参考链接 参考链接《云计算网络珠玑》《 图解网络硬件》kernel flowlinux bridge《Understanding Linux Network Internals》关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考802.1Q VLAN implementation for Linux","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://alloceee.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"如何设计实现一个LRU Cache？","slug":"Algorithm/如何设计实现一个LRU-Cache？","date":"2015-04-03T15:35:02.000Z","updated":"2020-02-18T09:23:42.000Z","comments":true,"path":"2015/04/03/Algorithm/如何设计实现一个LRU-Cache？/","link":"","permalink":"https://alloceee.github.io/2015/04/03/Algorithm/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/","excerpt":"","text":"1. 什么是LRU Cache？之前，在LeetCode上看到一个LRU Cache实现的题目，题目描述是这样的： Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。 那么我们思考一个问题：如何设计实现一个LRU Cache？那么，我们可能需要使用类似这样的数据结构去实现这个LRU Cache：这不就是LinkedHashMap吗！这样做的好处是，get和set在不冲突的情况下可以保证O(1)的复杂度，同时，也可以通过双向链表来保证LRU的删除和更新操作也能保证O(1)的复杂度。 2.实现思路在学习了HashMap(#7 )和LinkedHashMap(#8 )后，是不是觉得这俩数据结构简直太适合做LRU Cache了！那么动手实现一下：基于HashMap和双向链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class LRUCache &#123; class Node &#123; Node pre; Node next; Integer key; Integer val; Node(Integer k, Integer v) &#123; key = k; val = v; &#125; &#125; Map&lt;Integer, Node&gt; map = new HashMap&lt;Integer, Node&gt;(); // The head (eldest) of the doubly linked list. Node head; // The tail (youngest) of the doubly linked list. Node tail; int cap; public LRUCache(int capacity) &#123; cap = capacity; head = new Node(null, null); tail = new Node(null, null); head.next = tail; tail.pre = head; &#125; public int get(int key) &#123; Node n = map.get(key); if(n!=null) &#123; n.pre.next = n.next; n.next.pre = n.pre; appendTail(n); return n.val; &#125; return -1; &#125; public void set(int key, int value) &#123; Node n = map.get(key); // existed if(n!=null) &#123; n.val = value; map.put(key, n); n.pre.next = n.next; n.next.pre = n.pre; appendTail(n); return; &#125; // else &#123; if(map.size() == cap) &#123; Node tmp = head.next; head.next = head.next.next; head.next.pre = head; map.remove(tmp.key); &#125; n = new Node(key, value); // youngest node append taill appendTail(n); map.put(key, n); &#125; private void appendTail(Node n) &#123; n.next = tail; n.pre = tail.pre; tail.pre.next = n; tail.pre = n; &#125;&#125; 基于LinkedHashMap的实现HashMap+双向链表？这不就是LinkedHashMap吗！ 1234567891011121314151617181920212223242526public class LRUCache &#123; private int capacity; private Map&lt;Integer, Integer&gt; cache; public LRUCache(int capacity) &#123; this.capacity = capacity; this.cache = new java.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, 0.75f, true) &#123; // 定义put后的移除规则，大于容量就删除eldest protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; capacity; &#125; &#125;; &#125; public int get(int key) &#123; if (cache.containsKey(key)) &#123; return cache.get(key); &#125; else return -1; &#125; public void set(int key, int value) &#123; cache.put(key, value); &#125;&#125;","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"排序算法总结","slug":"Algorithm/algorithm_sort","date":"2014-11-19T16:00:00.000Z","updated":"2020-02-18T09:23:42.000Z","comments":true,"path":"2014/11/20/Algorithm/algorithm_sort/","link":"","permalink":"https://alloceee.github.io/2014/11/20/Algorithm/algorithm_sort/","excerpt":"","text":"1. 排序算法汇总1. 概述 算法名称 复杂度 实现关键 冒泡排序 O(n^2) （无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。 选择排序 O(n^2) （有序区，无序区）。在无序区里选择一个最小的元素跟在有序区的后面。 插入排序 O(n^2) （有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。 希尔排序 nlog^2(n) 每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1(插入)。 快速排序 nlog(n) （小数，枢纽元，大数）。 堆排序 nlog(n) 桶排序 O(n) 将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 不稳定的排序：稳定性一个形象的比喻，本来有两个并列第三，一排序把原来并列的顺序给变了。比如：选择排序、快速排序、堆排序、希尔排序；参考链接 2. 冒泡排序 每次都把未排序的第一个作为起始点，然后逐渐冒泡上升，之后未排序区越来越少，最终排序完成 123456789101112131415161718// 冒泡排序void bubble_sort(int a[], int n)&#123; int i = 0; int j = 0; for (i=0; i&lt;n-1; i++) &#123; // 比较相邻元素，若a[j]比a[j+1]大，则交换 // a[j]就像一个气泡一样“浮”到合适位置了 for(j=0; j&lt;n-1-i; j++) &#123; if(a[j]&gt;a[j+1]) &#123; swap(&amp;a[j], &amp;a[j+1]); &#125; &#125; &#125;&#125; 3. 选择排序 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 12345678910111213141516171819// 选择排序void select_sort(int a[], int n)&#123; int i=0,j=0,min=0; for (i=0; i &lt; n-1; i++) &#123; min = i; // 找到最小值 for (j=i+1; j &lt;= n-1; j++) &#123; if (a[min] &gt; a[j]) min = j; &#125; if(min != i) &#123; swap(&amp;a[min], &amp;a[i]); &#125; &#125;&#125; 4. 插入排序 每次排序从未排序区取一个“牌”，然后往前插入(包括了两步：大的往后移，把牌放到合适位置)。 12345678910111213141516171819202122232425// 插入排序void insert_sort(int a[], int n)&#123; int i=0; int j=0; int tmp=0; for (i = 1; i &lt; n; i++) &#123; // 取牌 tmp = a[i]; // 往前插的起始位置 j = i - 1; // 大的a[j]都放后面，寻找出j while ((j &gt;= 0) &amp;&amp; a[j] &gt; tmp) &#123; // 往后放一个 a[j+1] = a[j]; j--; &#125; // 放到该放的位置 a[j+1]=tmp; &#125;&#125; 另外还有种思路，把数据后移的过程换成交换的过程 1234567891011121314151617181920// 插入排序，选中的牌冒泡向前插入void insert_sort_2(int a[], int n)&#123; int i=0; int j=0; //通过i选牌 for (i=1; i &lt; n; i++) &#123; // 冒泡向前插入(i-1 --&gt; 0) for (j=i-1; j&gt;=0 &amp;&amp; a[j] &gt; a[j + 1]; j--) &#123; swap(&amp;a[j], &amp;a[j+1]); &#125; &#125; print_a(a, n);&#125;````### 5. 希尔排序对插入排序再加一个步长的循环就是希尔排序了，例如 [ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ] 1按照5步长排序，则相当于按列先进行排序(实际是通过下标实现的) 13 14 94 33 8225 59 94 65 2345 27 73 25 3910 1排序后结果为 10 14 73 25 2313 27 94 33 3925 59 94 65 8245 12345678910111213141516171819202122232425262728多次循环后，只需要**最终步长为1**即可。```C// 希尔排序void shell_sort(int a[], int n)&#123; int i=0; int j=0; int tmp=0; int gap=0; while (gap &lt;= n) &#123; gap = gap*3 + 1; &#125; while (gap &gt; 0) &#123; // 取牌 for (i = gap; i &lt; n; i++) &#123; // 冒泡向前插入(i-gap : gap : 0), 保证每列ok for (j = i - gap; (j &gt;= 0) &amp;&amp; (a[j] &gt; a[j + gap]); j = j - gap) &#123; swap(&amp;a[j], &amp;a[j+gap]); &#125; &#125; gap = (gap-1) / 3; &#125;&#125; 6. 快速排序每次迭代都选出一个基准，左边放小的，右边放大的，最终迭代完成。 12345678910111213141516171819202122232425262728293031323334353637// 快速排序分区static int partition(int a[], int p, int r)&#123; int x=0; int i=0; int j=0; // x为基准 x = a[r]; // i为界限,发现小于x的，就i++，再放到i处 i = p-1; for (j=p; j&lt;= r-1; j++) &#123; if (a[j]&lt;=x) &#123; i++; swap(&amp;a[i], &amp;a[j]); &#125; &#125; // 至此，所有小于x的都到i左边了(a[0]~a[i-1])，a[r]是x，因此交换a[i+1]和a[r] swap(&amp;a[i+1], &amp;a[r]); return i+1;&#125;// 快速排序void quick_sort(int a[], int p, int r)&#123; int q=0; if (p &lt; r) &#123; // 在数据集之中，选择一个元素作为&quot;基准&quot;（pivot） // 所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边 q = partition(a, p, r); // 对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 quick_sort(a, p, q-1); quick_sort(a, q+1, r); &#125;&#125;","categories":[],"tags":[]}],"categories":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://alloceee.github.io/categories/ElasticSearch/"},{"name":"Redis","slug":"数据库/Redis","permalink":"https://alloceee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"},{"name":"web","slug":"web","permalink":"https://alloceee.github.io/categories/web/"},{"name":"css","slug":"web/css","permalink":"https://alloceee.github.io/categories/web/css/"},{"name":"Vue","slug":"Vue","permalink":"https://alloceee.github.io/categories/Vue/"},{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/categories/HTTP/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://alloceee.github.io/categories/WebSocket/"},{"name":"JavaScript","slug":"web/JavaScript","permalink":"https://alloceee.github.io/categories/web/JavaScript/"},{"name":"网络编程","slug":"网络编程","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Netty","slug":"网络编程/Netty","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty/"},{"name":"NIO","slug":"网络编程/NIO","permalink":"https://alloceee.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO/"}],"tags":[{"name":"系统架构师","slug":"系统架构师","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"嵌入式系统设计","slug":"嵌入式系统设计","permalink":"https://alloceee.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"MySQL","slug":"MySQL","permalink":"https://alloceee.github.io/tags/MySQL/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://alloceee.github.io/tags/ElasticSearch/"},{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://alloceee.github.io/tags/ClickHouse/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://alloceee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","permalink":"https://alloceee.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"https://alloceee.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Redis","slug":"Redis","permalink":"https://alloceee.github.io/tags/Redis/"},{"name":"外键","slug":"外键","permalink":"https://alloceee.github.io/tags/%E5%A4%96%E9%94%AE/"},{"name":"JVM","slug":"JVM","permalink":"https://alloceee.github.io/tags/JVM/"},{"name":"CSS","slug":"CSS","permalink":"https://alloceee.github.io/tags/CSS/"},{"name":"Sentinel","slug":"Sentinel","permalink":"https://alloceee.github.io/tags/Sentinel/"},{"name":"Vue","slug":"Vue","permalink":"https://alloceee.github.io/tags/Vue/"},{"name":"移动端","slug":"移动端","permalink":"https://alloceee.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"redis","slug":"redis","permalink":"https://alloceee.github.io/tags/redis/"},{"name":"java","slug":"java","permalink":"https://alloceee.github.io/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"https://alloceee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"配置中心","slug":"配置中心","permalink":"https://alloceee.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"name":"算法","slug":"算法","permalink":"https://alloceee.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"消息队列","slug":"消息队列","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://alloceee.github.io/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"https://alloceee.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"HTTP","slug":"HTTP","permalink":"https://alloceee.github.io/tags/HTTP/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://alloceee.github.io/tags/zookeeper/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://alloceee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"HTTP和HTTPS","slug":"HTTP和HTTPS","permalink":"https://alloceee.github.io/tags/HTTP%E5%92%8CHTTPS/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://alloceee.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://alloceee.github.io/tags/Leetcode/"},{"name":"认证","slug":"认证","permalink":"https://alloceee.github.io/tags/%E8%AE%A4%E8%AF%81/"},{"name":"架构","slug":"架构","permalink":"https://alloceee.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"消息中间件","slug":"消息中间件","permalink":"https://alloceee.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://alloceee.github.io/tags/WebSocket/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://alloceee.github.io/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"https://alloceee.github.io/tags/css/"},{"name":"web","slug":"web","permalink":"https://alloceee.github.io/tags/web/"},{"name":"缓存","slug":"缓存","permalink":"https://alloceee.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"Netty","slug":"Netty","permalink":"https://alloceee.github.io/tags/Netty/"},{"name":"NIO","slug":"NIO","permalink":"https://alloceee.github.io/tags/NIO/"},{"name":"集合","slug":"集合","permalink":"https://alloceee.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"经验总结","slug":"经验总结","permalink":"https://alloceee.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://alloceee.github.io/tags/SpringMVC/"},{"name":"源码分析","slug":"源码分析","permalink":"https://alloceee.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"面试","slug":"面试","permalink":"https://alloceee.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"总结","slug":"总结","permalink":"https://alloceee.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"设计模式","slug":"设计模式","permalink":"https://alloceee.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"系统","slug":"系统","permalink":"https://alloceee.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"网络","slug":"网络","permalink":"https://alloceee.github.io/tags/%E7%BD%91%E7%BB%9C/"}]}